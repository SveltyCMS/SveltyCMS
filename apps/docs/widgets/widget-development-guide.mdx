---
path: 'docs/widgets/widget-development-guide.mdx'
title: 'Widget Development Guide'
description: 'Practical guide for creating, customizing, and managing widgets in SveltyCMS'
order: 3
icon: 'mdi:code-tags'
author: 'admin'
created: '2025-10-17'
updated: '2025-10-17'
tags:
  - 'widgets'
  - 'development'
  - 'guide'
  - 'tutorial'
  - 'custom'
---

# Widget Development Guide

This guide provides practical instructions for creating, customizing, and managing widgets in SveltyCMS.

## 🚀 Quick Start

### Creating Your First Widget

Follow these steps to create a custom widget:

```mermaid
flowchart TD
    START[Start Development] --> PLAN[1. Plan Widget]
    PLAN --> FOLDER[2. Create Folder Structure]
    FOLDER --> DEFINE[3. Define Widget]
    DEFINE --> INPUT[4. Create Input Component]
    INPUT --> DISPLAY[5. Create Display Component]
    DISPLAY --> TEST[6. Test Widget]
    TEST --> DOC[7. Add Documentation]
    DOC --> DEPLOY[8. Enable Widget]

    style START fill:#e8f5e8
    style DEPLOY fill:#c8e6c9
```

### 1. Planning Your Widget

Before coding, consider:

- **Purpose**: What specific functionality does your widget provide?
- **Data Type**: What type of data will it store? (string, object, array, etc.)
- **User Interface**: How will users interact with it?
- **Validation**: What validation rules are needed?
- **Dependencies**: Does it require other widgets or libraries?

### 2. Folder Structure

Create the widget directory structure:

```
src/widgets/custom/myWidget/
├── index.ts           # Definition pillar
├── Input.svelte       # Input pillar
├── Display.svelte     # Display pillar
├── types.ts           # TypeScript definitions
└── myWidget.mdx       # Documentation
```

**⚠️ Critical**: The folder name must match the widget identifier exactly (case-sensitive).

## 📝 Step-by-Step Tutorial

### Step 1: Define the Widget

Create `src/widgets/custom/myWidget/index.ts`:

```typescript
/**
 * @file src/widgets/custom/myWidget/index.ts
 * @description My Custom Widget Definition
 */

import { createWidget } from '@src/widgets/factory';
import { string, minLength, optional, pipe, type InferInput as ValibotInput } from 'valibot';
import Input from '@components/system/inputs/Input.svelte';
import Toggles from '@components/system/inputs/Toggles.svelte';
import type { MyWidgetProps } from './types';
import * as m from '@src/paraglide/messages';

// Validation schema - can be static or dynamic
const createValidationSchema = (field: FieldInstance) => {
	const baseSchema = pipe(string(), minLength(1, 'This field is required'));

	return field.required ? baseSchema : optional(baseSchema, '');
};

// Create the widget using the factory
const MyWidget = createWidget<MyWidgetProps>({
	Name: 'MyWidget',
	Icon: 'mdi:star',
	Description: 'My custom widget description',

	// Three Pillars paths
	inputComponentPath: '/src/widgets/custom/myWidget/Input.svelte',
	displayComponentPath: '/src/widgets/custom/myWidget/Display.svelte',

	// Validation
	validationSchema: createValidationSchema,

	// Default values
	defaults: {
		placeholder: 'Enter value...',
		translated: false
	},

	// Configuration UI for Collection Builder
	GuiSchema: {
		label: { widget: Input, required: true },
		db_fieldName: { widget: Input, required: false },
		required: { widget: Toggles, required: false },
		placeholder: { widget: Input, required: false },
		helper: { widget: Input, required: false }
	}
});

export default MyWidget;

// Type exports for consumers
export type FieldType = ReturnType<typeof MyWidget>;
export type MyWidgetData = ValibotInput<ReturnType<typeof createValidationSchema>>;
```

### Step 2: Create Types

Create `src/widgets/custom/myWidget/types.ts`:

```typescript
/**
 * @file src/widgets/custom/myWidget/types.ts
 * @description Type definitions for MyWidget
 */

export interface MyWidgetProps {
	placeholder?: string;
	maxLength?: number;
	prefix?: string;
	suffix?: string;
	[key: string]: unknown;
}
```

### Step 3: Create Input Component

Create `src/widgets/custom/myWidget/Input.svelte`:

```svelte
<!--
@file src/widgets/custom/myWidget/Input.svelte
@description Interactive input component for MyWidget
-->

<script lang="ts">
	import type { FieldInstance } from '@src/content/types';
	import { contentLanguage } from '@stores/store.svelte';

	// Props
	interface Props {
		field: FieldInstance;
		value: unknown;
		errors?: string[];
		disabled?: boolean;
	}

	let { field, value = $bindable(), errors = [], disabled = false }: Props = $props();

	// Extract widget-specific props
	const placeholder = field.placeholder || 'Enter value...';
	const maxLength = field.maxLength;
	const required = field.required || false;

	// Handle translation
	let currentValue = $state('');

	$effect(() => {
		if (field.translated && value && typeof value === 'object') {
			currentValue = (value as Record<string, string>)[$contentLanguage] || '';
		} else if (typeof value === 'string') {
			currentValue = value;
		}
	});

	function handleInput(event: Event) {
		const target = event.target as HTMLInputElement;
		const inputValue = target.value;

		if (field.translated) {
			const translatedValue = (value as Record<string, string>) || {};
			translatedValue[$contentLanguage] = inputValue;
			value = translatedValue;
		} else {
			value = inputValue;
		}
	}

	// Error state
	const hasErrors = errors && errors.length > 0;
</script>

<div class="widget-input">
	<label class="label">
		<span class="label-text">
			{field.label}
			{#if required}
				<span class="text-error">*</span>
			{/if}
		</span>

		<input
			type="text"
			class="input-bordered input w-full"
			class:input-error={hasErrors}
			{placeholder}
			{maxLength}
			{required}
			{disabled}
			value={currentValue}
			oninput={handleInput}
		/>

		{#if field.helper}
			<div class="label-text-alt text-gray-500">
				{field.helper}
			</div>
		{/if}

		{#if hasErrors}
			<div class="label-text-alt text-error">
				{#each errors as error}
					<div>{error}</div>
				{/each}
			</div>
		{/if}
	</label>
</div>

<style>
	.widget-input {
		@apply space-y-1;
	}
</style>
```

### Step 4: Create Display Component

Create `src/widgets/custom/myWidget/Display.svelte`:

```svelte
<!--
@file src/widgets/custom/myWidget/Display.svelte
@description Read-only display component for MyWidget
-->

<script lang="ts">
  import type { FieldInstance } from '@src/content/types';
  import { contentLanguage } from '@stores/store.svelte';

  // Props
  interface Props {
    field: FieldInstance;
    value: unknown;
    compact?: boolean;
  }

  let { field, value, compact = false }: Props = $props();

  // Get display value based on translation
  const displayValue = $derived(() => {
    if (!value) return '';

    if (field.translated && typeof value === 'object') {
      return (value as Record<string, string>)[$contentLanguage] || '';
    }

    return String(value);
  });

  // Truncate for compact display
  const truncatedValue = $derived(() => {
    if (!compact) return displayValue;
    return displayValue.length > 50
      ? displayValue.substring(0, 50) + '...'
      : displayValue;
  });
</script>

<div class="widget-display" class:compact>
  {#if field.prefix}
    <span class="prefix">{field.prefix}</span>
  {/if}

  <span class="value">
    {truncatedValue || <em>Empty</em>}
  </span>

  {#if field.suffix}
    <span class="suffix">{field.suffix}</span>
  {/if}
</div>

<style>
  .widget-display {
    @apply flex items-center gap-1;
  }

  .widget-display.compact {
    @apply text-sm;
  }

  .prefix, .suffix {
    @apply text-gray-500 text-sm;
  }

  .value {
    @apply flex-1;
  }

  em {
    @apply text-gray-400 italic;
  }
</style>
```

### Step 5: Add Documentation

Create `src/widgets/custom/myWidget/myWidget.mdx`:

````mdx
---
path: 'src/widgets/custom/myWidget/myWidget.mdx'
title: 'My Custom Widget'
description: 'A custom widget example for SveltyCMS'
order: 1
icon: 'mdi:star'
author: 'your-name'
created: '2025-10-17'
updated: '2025-10-17'
tags:
  - 'widget'
  - 'custom'
  - 'example'
---

# My Custom Widget

## Overview

My custom widget provides enhanced text input functionality with custom features.

## Features

- Custom placeholder text
- Prefix/suffix support
- Translation support
- Length validation
- Helper text

## Configuration Options

| Field         | Type    | Description         | Default          |
| ------------- | ------- | ------------------- | ---------------- |
| `label`       | string  | Field label         | Required         |
| `placeholder` | string  | Input placeholder   | "Enter value..." |
| `required`    | boolean | Make field required | false            |
| `maxLength`   | number  | Maximum characters  | none             |
| `helper`      | string  | Helper text         | none             |

## Usage Example

```typescript
import { widgets } from '@src/widgets';

// In a collection schema
export default {
	fields: [
		widgets.MyWidget({
			label: 'Custom Field',
			placeholder: 'Enter custom value...',
			required: true,
			maxLength: 100,
			helper: 'This is a custom widget field'
		})
	]
};
```
````

## Validation

The widget validates input based on configuration:

- **Required**: Ensures non-empty value when `required: true`
- **Length**: Enforces `maxLength` when specified
- **Type**: Ensures string input

## Translation Support

When `translated: true`, the widget stores values as language objects:

```typescript
{
  "en": "English value",
  "de": "German value",
  "fr": "French value"
}
```

````

## 🔧 Advanced Features

### Dynamic Validation

Create validation schemas that adapt to field configuration:

```typescript
const createValidationSchema = (field: FieldInstance) => {
  const rules = [string()];

  // Conditional validation
  if (field.required) {
    rules.push(minLength(1, 'This field is required'));
  }

  if (field.minLength) {
    rules.push(minLength(field.minLength as number, `Minimum ${field.minLength} characters`));
  }

  if (field.maxLength) {
    rules.push(maxLength(field.maxLength as number, `Maximum ${field.maxLength} characters`));
  }

  if (field.pattern) {
    rules.push(regex(new RegExp(field.pattern as string), 'Invalid format'));
  }

  const schema = pipe(...rules);

  // Handle translation
  if (field.translated) {
    return object({ _any: any() });
  }

  return field.required ? schema : optional(schema, '');
};
````

### Database Aggregations

Add database query support for filtering and sorting:

```typescript
const MyWidget = createWidget({
	// ... other config

	aggregations: {
		// Filter support
		filters: async ({ field, filter, contentLanguage }) => {
			const fieldPath = field.translated ? `${field.db_fieldName}.${contentLanguage}` : field.db_fieldName;

			return [
				{
					$match: {
						[fieldPath]: {
							$regex: filter,
							$options: 'i' // Case insensitive
						}
					}
				}
			];
		},

		// Sort support
		sorts: async ({ field, sortDirection, contentLanguage }) => {
			const fieldPath = field.translated ? `${field.db_fieldName}.${contentLanguage}` : field.db_fieldName;

			return {
				[fieldPath]: sortDirection === 'asc' ? 1 : -1
			};
		}
	}
});
```

### Complex GUI Schema

Create advanced configuration interfaces:

```typescript
GuiSchema: {
  // Standard fields
  label: { widget: Input, required: true },
  db_fieldName: { widget: Input, required: false },
  required: { widget: Toggles, required: false },
  translated: { widget: Toggles, required: false },

  // Widget-specific configuration
  inputType: {
    widget: Select,
    required: false,
    options: [
      { label: 'Text', value: 'text' },
      { label: 'Email', value: 'email' },
      { label: 'Phone', value: 'tel' },
      { label: 'URL', value: 'url' }
    ]
  },

  validation: {
    widget: Group,
    label: 'Validation Rules',
    fields: {
      minLength: { widget: Input, type: 'number' },
      maxLength: { widget: Input, type: 'number' },
      pattern: { widget: Input, helper: 'Regular expression pattern' }
    }
  },

  appearance: {
    widget: Group,
    label: 'Appearance',
    fields: {
      placeholder: { widget: Input },
      prefix: { widget: Input },
      suffix: { widget: Input },
      width: { widget: Select, options: ['full', 'half', 'third'] }
    }
  }
}
```

## 🧪 Testing Your Widget

### Unit Testing

Create tests for your widget:

```typescript
// src/widgets/custom/myWidget/myWidget.test.ts
import { describe, test, expect } from 'vitest';
import MyWidget from './index';

describe('MyWidget', () => {
	test('should create widget with default configuration', () => {
		const field = MyWidget({
			label: 'Test Field'
		});

		expect(field.label).toBe('Test Field');
		expect(field.placeholder).toBe('Enter value...');
		expect(field.required).toBe(false);
	});

	test('should apply custom configuration', () => {
		const field = MyWidget({
			label: 'Custom Field',
			placeholder: 'Custom placeholder',
			required: true,
			maxLength: 50
		});

		expect(field.placeholder).toBe('Custom placeholder');
		expect(field.required).toBe(true);
		expect(field.maxLength).toBe(50);
	});

	test('should have proper widget definition', () => {
		expect(MyWidget.Name).toBe('MyWidget');
		expect(MyWidget.Icon).toBe('mdi:star');
		expect(MyWidget.GuiSchema).toBeDefined();
	});
});
```

### Component Testing

Test your Svelte components:

```typescript
// src/widgets/custom/myWidget/Input.test.ts
import { render, fireEvent } from '@testing-library/svelte';
import Input from './Input.svelte';

describe('MyWidget Input Component', () => {
	test('should render input field', () => {
		const field = {
			label: 'Test Field',
			required: true,
			placeholder: 'Test placeholder'
		};

		const { getByLabelText } = render(Input, {
			props: { field, value: '' }
		});

		const input = getByLabelText('Test Field');
		expect(input).toBeInTheDocument();
		expect(input).toHaveAttribute('placeholder', 'Test placeholder');
	});

	test('should handle value changes', async () => {
		const field = { label: 'Test Field' };
		let value = '';

		const { getByLabelText } = render(Input, {
			props: {
				field,
				value,
				onvaluechange: (e) => {
					value = e.detail;
				}
			}
		});

		const input = getByLabelText('Test Field');
		await fireEvent.input(input, { target: { value: 'test value' } });

		expect(value).toBe('test value');
	});
});
```

## 📦 Widget Management

### Enabling Your Widget

After creating your widget:

1. **Restart the application** to trigger widget discovery
2. **Check the admin interface** for your widget in the widget list
3. **Enable the widget** for your tenant
4. **Use in collections** via the Collection Builder

### Widget Discovery Process

```mermaid
sequenceDiagram
    participant App as Application
    participant WD as Widget Discovery
    participant FS as Filesystem
    participant DB as Database
    participant Store as Widget Store

    App->>WD: Startup trigger
    WD->>FS: Scan /src/widgets/
    FS-->>WD: Found widgets list
    WD->>DB: Compare with stored config
    DB-->>WD: Current widget states
    WD->>DB: Register new widgets
    WD->>Store: Load active widgets
    Store-->>App: Widgets ready
```

### Dependency Management

If your widget depends on others:

```typescript
const MyWidget = createWidget({
	// ... other config

	// Specify dependencies
	dependencies: ['Input', 'Select'], // Widget names it depends on

	// Or check in validation
	validationSchema: (field) => {
		// Access other widgets if needed
		const inputWidget = getWidget('Input');
		if (!inputWidget) {
			throw new Error('MyWidget requires Input widget to be enabled');
		}

		return string();
	}
});
```

## 🚀 Deployment and Distribution

### Best Practices

1. **Follow Naming Conventions**: Folder name = widget identifier
2. **Add Comprehensive Documentation**: Include `.mdx` file with examples
3. **Write Tests**: Ensure reliability with unit and component tests
4. **Performance Optimization**: Keep display components lightweight
5. **Accessibility**: Follow WCAG guidelines in components
6. **TypeScript**: Use proper type definitions throughout

### Publishing Custom Widgets

For sharing widgets across projects:

1. **Create NPM Package**: Package your widget as a separate module
2. **Include Installation Instructions**: Document setup process
3. **Provide Examples**: Include working examples and demos
4. **Version Management**: Use semantic versioning for releases

### Migration Guide

When updating existing widgets:

1. **Backup Collections**: Export collections using the widget
2. **Test Changes**: Verify compatibility with existing data
3. **Update Gradually**: Use feature flags for rollout
4. **Monitor Usage**: Track performance and error rates

---

## 🔗 Related Resources

- [Widget System Overview](/docs/widgets/widget-system-overview.mdx) - High-level concepts
- [Widget Architecture](/docs/widgets/widget-architecture.mdx) - Technical details
- [API Documentation](/docs/api/Widget_API.mdx) - API reference
- [Testing Guide](/docs/testing/testing.mdx) - Testing strategies
- [TypeScript Guide](/docs/guides/typescript.mdx) - Type safety best practices
