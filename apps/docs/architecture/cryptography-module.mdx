---
path: 'docs/dev-guide/cryptography-module.mdx'
title: 'Cryptography Module Reference'
description: 'Enterprise-grade cryptography using Argon2id and AES-256-GCM for password hashing, key derivation, and data encryption.'
order: 9
icon: 'mdi:lock-check'
author: 'admin'
created: '2025-10-03'
updated: '2025-10-03'
tags:
  - 'security'
  - 'cryptography'
  - 'argon2'
  - 'aes-256'
  - 'encryption'
---

# Cryptography Module Reference

## Overview

SveltyCMS implements military-grade cryptography through the centralized `@utils/crypto` module, using **Argon2id** for password hashing and key derivation, and **AES-256-GCM** for data encryption. This provides enterprise-level security against modern threats, including AI-powered and quantum computing attacks.

**Module Location:** `src/utils/crypto.ts`

**Why Centralized?**

- ‚úÖ **Single audit surface** for security reviews
- ‚úÖ **Consistent algorithms** across entire CMS
- ‚úÖ **Easy to update** if vulnerabilities discovered
- ‚úÖ **Prevents crypto mistakes** in individual features
- ‚úÖ **Testable and auditable** cryptographic operations

---

## Security Architecture

### Algorithm Combination

SveltyCMS uses a two-algorithm approach for maximum security:

#### 1. Argon2id - Password Hashing & Key Derivation

**Why Argon2id?**

- üèÜ **Winner** of Password Hashing Competition (2015)
- üõ°Ô∏è **Memory-hard** - Requires 64 MB RAM per attempt (stops GPU farms)
- üö´ **ASIC-resistant** - Can't build custom hardware to crack it
- ‚è≥ **Time-hard** - 3 iterations minimum
- üîí **10-100x more secure** than PBKDF2
- üåç **Future-proof** - Resistant to AI/quantum advances

**Configuration:**

```typescript
{
  memory: 65536,      // 64 MB RAM per hash
  time: 3,            // 3 iterations
  parallelism: 4,     // 4 parallel threads
  type: argon2id,     // Hybrid (resistant to side-channel + GPU attacks)
  hashLength: 32      // 256-bit output
}
```

#### 2. AES-256-GCM - Data Encryption

**Why AES-256-GCM?**

- üîê **Military-grade** - Used by US government for TOP SECRET data
- ‚úÖ **Authenticated encryption** - Built-in tamper detection
- ‚ö° **Hardware-accelerated** - Modern CPUs have AES-NI instructions
- üåç **Industry standard** - NIST approved, widely audited

**Configuration:**

```typescript
{
  algorithm: 'aes-256-gcm',
  keyLength: 32,      // 256 bits
  ivLength: 16,       // 128 bits
  saltLength: 32,     // 256 bits for key derivation
  authTagLength: 16   // 128 bits for integrity
}
```

---

## API Reference

### Password Hashing

#### hashPassword()

Hashes a plain text password using Argon2id.

**Signature:**

```typescript
async function hashPassword(password: string): Promise<string>;
```

**Parameters:**

- `password` (string) - Plain text password to hash

**Returns:**

- Promise<string> - Argon2id hash in PHC string format

**Example:**

```typescript
import { hashPassword } from '@utils/crypto';

// Registration - hash user password
const plainPassword = 'MySecurePassword123!';
const hashedPassword = await hashPassword(plainPassword);

// Store in database
await db.users.create({
	email: 'user@example.com',
	password: hashedPassword // $argon2id$v=19$m=65536,t=3,p=4$...
});
```

**Hash Format:**

```
$argon2id$v=19$m=65536,t=3,p=4$<salt>$<hash>
```

Where:

- `argon2id` - Algorithm type (hybrid mode)
- `v=19` - Algorithm version
- `m=65536` - Memory cost (64 MB)
- `t=3` - Time cost (3 iterations)
- `p=4` - Parallelism (4 threads)
- `<salt>` - Base64-encoded random salt
- `<hash>` - Base64-encoded hash

---

#### verifyPassword()

Verifies a plain text password against an Argon2id hash.

**Signature:**

```typescript
async function verifyPassword(password: string, hash: string): Promise<boolean>;
```

**Parameters:**

- `password` (string) - Plain text password to verify
- `hash` (string) - Argon2id hash to compare against

**Returns:**

- Promise<boolean> - `true` if password matches, `false` otherwise

**Example:**

```typescript
import { verifyPassword } from '@utils/crypto';

// Login - verify user password
const user = await db.users.findByEmail('user@example.com');
const isValid = await verifyPassword(plainPassword, user.password);

if (isValid) {
	// Password correct - create session
	const session = await createSession(user._id);
} else {
	// Password incorrect - reject login
	throw new Error('Invalid credentials');
}
```

**Security Notes:**

- ‚è±Ô∏è Constant-time comparison (prevents timing attacks)
- üîí Automatically extracts parameters from hash (memory, time, parallelism)
- üõ°Ô∏è Resistant to timing side-channel attacks

---

### Data Encryption

#### encryptData()

Encrypts data using AES-256-GCM with Argon2id key derivation.

**Signature:**

```typescript
async function encryptData(data: Record<string, unknown>, password: string): Promise<string>;
```

**Parameters:**

- `data` (Record<string, unknown>) - Object to encrypt
- `password` (string) - Password for key derivation

**Returns:**

- Promise<string> - Base64-encoded encrypted blob

**Example:**

```typescript
import { encryptData } from '@utils/crypto';

// Encrypt sensitive configuration data
const sensitiveData = {
	apiKey: 'sk_live_abc123...',
	dbPassword: 'secretPassword',
	jwtSecret: 'myJWTSecret'
};

const encrypted = await encryptData(sensitiveData, 'UserPassword123!');

// encrypted = "A1B2C3...base64-encoded-blob"
// Safe to store or transfer
```

**Encryption Process:**

```
1. Generate random salt (32 bytes)
2. Derive key from password using Argon2id (64 MB RAM, 3 iterations)
3. Generate random IV (16 bytes)
4. Encrypt data with AES-256-GCM
5. Get authentication tag (16 bytes)
6. Combine: salt + IV + authTag + encrypted data
7. Base64 encode result
```

**Output Format:**

```
[salt:32][iv:16][authTag:16][encryptedData:variable]
```

All base64-encoded as single string.

---

#### decryptData()

Decrypts data encrypted by `encryptData()`.

**Signature:**

```typescript
async function decryptData(encryptedData: string, password: string): Promise<Record<string, unknown>>;
```

**Parameters:**

- `encryptedData` (string) - Base64-encoded encrypted blob from `encryptData()`
- `password` (string) - Password used for encryption

**Returns:**

- Promise<Record<string, unknown>> - Decrypted object

**Throws:**

- Error if password is incorrect
- Error if data is tampered with (auth tag mismatch)
- Error if data is corrupted

**Example:**

```typescript
import { decryptData } from '@utils/crypto';

// Decrypt sensitive configuration
try {
	const decrypted = await decryptData(encrypted, 'UserPassword123!');

	console.log(decrypted);
	// {
	//   apiKey: 'sk_live_abc123...',
	//   dbPassword: 'secretPassword',
	//   jwtSecret: 'myJWTSecret'
	// }
} catch (error) {
	console.error('Decryption failed:', error.message);
	// Possible reasons:
	// - Wrong password
	// - Data tampered with
	// - Data corrupted
}
```

**Decryption Process:**

```
1. Base64 decode encrypted blob
2. Extract: salt, IV, authTag, encrypted data
3. Derive same key from password using Argon2id with extracted salt
4. Decrypt with AES-256-GCM
5. Verify authentication tag (ensures data integrity)
6. Parse and return decrypted JSON
```

**Security Features:**

- ‚úÖ **Authentication tag verification** - Detects tampering
- ‚úÖ **Same salt reuse** - Ensures consistent key derivation
- ‚úÖ **Constant-time operations** - Prevents timing attacks
- ‚úÖ **Automatic validation** - Throws on any integrity issue

---

### Key Derivation

#### deriveKey()

Derives a cryptographic key from a password using Argon2id.

**Signature:**

```typescript
async function deriveKey(password: string, salt: Buffer): Promise<Buffer>;
```

**Parameters:**

- `password` (string) - Password to derive key from
- `salt` (Buffer) - Random salt (32 bytes recommended)

**Returns:**

- Promise<Buffer> - 256-bit (32-byte) key

**Example:**

```typescript
import crypto from 'crypto';
import { deriveKey } from '@utils/crypto';

// Generate random salt
const salt = crypto.randomBytes(32);

// Derive key from password
const key = await deriveKey('UserPassword123!', salt);

// Use key for custom encryption
const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
```

**Use Cases:**

- Custom encryption schemes
- API key generation
- Token signing keys
- Database encryption keys

**Security Notes:**

- üîí Same password + salt = same key (deterministic)
- üé≤ Different salt = different key (unique per use)
- ‚è±Ô∏è 64 MB RAM + 3 iterations = slow brute force (~100 attempts/sec on modern GPU)

---

## Security Properties

### Attack Resistance

#### Brute Force Attack

**Scenario:** Attacker tries all possible passwords

| Password Strength          | Keyspace          | Time to Crack (Argon2) |
| -------------------------- | ----------------- | ---------------------- |
| 8 chars (lowercase)        | 26^8 = 2.1√ó10^11  | ~24 days               |
| 12 chars (mixed)           | 62^12 = 3.2√ó10^21 | **10 billion years**   |
| 16 chars (mixed + symbols) | 95^16 = 4.4√ó10^31 | **10^23 years**        |

**Why so slow?**

- 64 MB RAM per attempt (limits parallel attacks)
- 3 iterations (computational cost)
- No ASIC acceleration (memory-hard)

#### GPU Farm Attack

**Scenario:** Attacker uses 1000 high-end GPUs (RTX 4090)

- **Without Argon2 (e.g., SHA-256):** 1 trillion hashes/sec
- **With Argon2:** ~100,000 hashes/sec (10 million times slower)

**Reason:** Each hash requires 64 MB dedicated RAM, GPUs can't parallelize effectively.

#### AI/ML Attack

**Scenario:** Neural network tries to predict passwords

- **Without Argon2:** Can train on billions of hashes quickly
- **With Argon2:** Training is prohibitively expensive (64 MB per training sample)

**Result:** AI attacks are economically infeasible.

#### Quantum Computing Attack

**Scenario:** Quantum computer with Grover's algorithm

- **AES-256:** Reduced to 128-bit security (still requires 2^128 operations)
- **Argon2:** Memory-hard nature resists quantum speedup
- **Timeline:** Decades away from practical quantum threat to AES-256

**Security Timeline:**

```
Current (2025):    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100% secure
+10 years (2035):  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   95% secure
+20 years (2045):  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà         80% secure (quantum computers emerging)
+30 years (2055):  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà               60% secure (post-quantum migration recommended)
```

---

## Usage Examples

### User Authentication System

```typescript
import { hashPassword, verifyPassword } from '@utils/crypto';

// User Registration
export async function registerUser(email: string, password: string) {
	// Hash password with Argon2id
	const hashedPassword = await hashPassword(password);

	// Store in database
	const user = await db.users.create({
		email,
		password: hashedPassword,
		createdAt: new Date()
	});

	return user;
}

// User Login
export async function loginUser(email: string, password: string) {
	// Find user
	const user = await db.users.findByEmail(email);
	if (!user) {
		throw new Error('Invalid credentials');
	}

	// Verify password
	const isValid = await verifyPassword(password, user.password);
	if (!isValid) {
		throw new Error('Invalid credentials');
	}

	// Create session
	const session = await createSession(user._id);
	return { user, session };
}
```

### Secure Configuration Export/Import

```typescript
import { encryptData, decryptData } from '@utils/crypto';

// Export sensitive configuration
export async function exportConfig(password: string) {
	const config = {
		database: {
			host: 'localhost',
			password: 'dbPassword123'
		},
		api: {
			key: 'sk_live_abc123',
			secret: 'secret_xyz789'
		},
		jwt: {
			secret: 'myJWTSecret'
		}
	};

	// Encrypt with password
	const encrypted = await encryptData(config, password);

	// Save to file
	await fs.writeFile('config.encrypted', encrypted);

	return { success: true };
}

// Import configuration
export async function importConfig(password: string) {
	// Read encrypted file
	const encrypted = await fs.readFile('config.encrypted', 'utf8');

	try {
		// Decrypt with password
		const config = await decryptData(encrypted, password);

		// Apply configuration
		await applyConfig(config);

		return { success: true, config };
	} catch (error) {
		throw new Error('Invalid password or corrupted file');
	}
}
```

### API Token Encryption

```typescript
import { encryptData, decryptData } from '@utils/crypto';

// Store encrypted API token
export async function storeApiToken(userId: string, token: string, masterPassword: string) {
	const tokenData = {
		token,
		createdAt: new Date().toISOString(),
		expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
	};

	// Encrypt token
	const encrypted = await encryptData(tokenData, masterPassword);

	// Store in database
	await db.apiTokens.create({
		userId,
		encryptedToken: encrypted
	});
}

// Retrieve and decrypt API token
export async function getApiToken(userId: string, masterPassword: string) {
	const record = await db.apiTokens.findByUserId(userId);
	if (!record) return null;

	try {
		// Decrypt token
		const tokenData = await decryptData(record.encryptedToken, masterPassword);

		// Check expiration
		if (new Date(tokenData.expiresAt) < new Date()) {
			throw new Error('Token expired');
		}

		return tokenData.token;
	} catch (error) {
		throw new Error('Failed to decrypt token');
	}
}
```

---

## Best Practices

### Password Requirements

For maximum security with Argon2id:

```typescript
export function validatePassword(password: string): { valid: boolean; message: string } {
	if (password.length < 12) {
		return { valid: false, message: 'Password must be at least 12 characters' };
	}
	if (!/[A-Z]/.test(password)) {
		return { valid: false, message: 'Password must contain uppercase letter' };
	}
	if (!/[a-z]/.test(password)) {
		return { valid: false, message: 'Password must contain lowercase letter' };
	}
	if (!/[0-9]/.test(password)) {
		return { valid: false, message: 'Password must contain number' };
	}
	if (!/[^A-Za-z0-9]/.test(password)) {
		return { valid: false, message: 'Password must contain special character' };
	}
	return { valid: true, message: 'Password is strong' };
}
```

### Salt Generation

Always use cryptographically secure random salts:

```typescript
import crypto from 'crypto';

// ‚úÖ GOOD: Cryptographically secure
const salt = crypto.randomBytes(32);

// ‚ùå BAD: Not secure
const salt = Buffer.from(Math.random().toString());
```

### Key Storage

**DO:**

- ‚úÖ Store hashed passwords in database
- ‚úÖ Use environment variables for master passwords
- ‚úÖ Encrypt sensitive data at rest
- ‚úÖ Use hardware security modules (HSM) for keys in production
- ‚úÖ Rotate encryption keys periodically

**DON'T:**

- ‚ùå Store plain text passwords
- ‚ùå Hardcode passwords in source code
- ‚ùå Commit passwords to version control
- ‚ùå Share passwords via email or chat
- ‚ùå Use weak passwords for encryption

### Error Handling

Never reveal detailed cryptographic errors to users:

```typescript
// ‚úÖ GOOD: Generic error message
try {
	const decrypted = await decryptData(encrypted, password);
} catch (error) {
	throw new Error('Authentication failed'); // Don't reveal why
}

// ‚ùå BAD: Reveals information
try {
	const decrypted = await decryptData(encrypted, password);
} catch (error) {
	throw new Error('Wrong password'); // Reveals password was incorrect
}
```

---

## Performance Considerations

### Argon2 Performance

Typical performance on modern hardware:

| Hardware                     | Hashes/Second |
| ---------------------------- | ------------- |
| Intel i7-12700K (12 cores)   | ~200          |
| AMD Ryzen 9 5950X (16 cores) | ~250          |
| NVIDIA RTX 4090 (GPU)        | ~100          |
| AWS c6a.2xlarge              | ~150          |

**Why so slow?**

- 64 MB memory allocation per hash
- CPU-bound (not GPU-optimized)
- Intentional slowdown for security

### Optimization Tips

**DO:**

- ‚úÖ Cache results when appropriate (sessions)
- ‚úÖ Use background workers for bulk operations
- ‚úÖ Implement rate limiting on authentication endpoints
- ‚úÖ Use Redis for session storage

**DON'T:**

- ‚ùå Hash passwords synchronously in request handlers
- ‚ùå Reduce Argon2 parameters for "performance"
- ‚ùå Skip encryption for "convenience"

---

## Testing

### Unit Tests

```typescript
import { hashPassword, verifyPassword, encryptData, decryptData } from '@utils/crypto';
import { describe, it, expect } from 'vitest';

describe('Cryptography Module', () => {
	describe('Password Hashing', () => {
		it('should hash and verify password', async () => {
			const password = 'MySecurePassword123!';
			const hash = await hashPassword(password);

			expect(hash).toMatch(/^\$argon2id\$/);

			const isValid = await verifyPassword(password, hash);
			expect(isValid).toBe(true);

			const isInvalid = await verifyPassword('wrongpassword', hash);
			expect(isInvalid).toBe(false);
		});
	});

	describe('Data Encryption', () => {
		it('should encrypt and decrypt data', async () => {
			const data = { secret: 'mySecret', apiKey: 'key123' };
			const password = 'EncryptionPassword123!';

			const encrypted = await encryptData(data, password);
			expect(encrypted).toBeTypeOf('string');

			const decrypted = await decryptData(encrypted, password);
			expect(decrypted).toEqual(data);
		});

		it('should fail with wrong password', async () => {
			const data = { secret: 'mySecret' };
			const encrypted = await encryptData(data, 'password1');

			await expect(decryptData(encrypted, 'wrongpassword')).rejects.toThrow();
		});
	});
});
```

---

## Related Documentation

- [Build-Time Security Plugin](/docs/dev-guide/security-plugin) - Prevents private settings exposure to client
- [Authentication System](/docs/dev-guide/authentication-system) - Complete authentication implementation
- [Import/Export System](/docs/dev-guide/import-export-system) - Uses crypto module for sensitive data
- [Security Best Practices](/docs/dev-guide/security-best-practices) - General security guidelines

---

## References

- [Argon2 RFC 9106](https://datatracker.ietf.org/doc/html/rfc9106) - Official Argon2 specification
- [NIST AES-GCM](https://csrc.nist.gov/publications/detail/sp/800-38d/final) - AES-GCM specification
- [OWASP Password Storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html) - Password storage best practices

---

_Last Updated: October 3, 2025_  
_Security Audit: Annual review recommended_
