<!--
@file src/components/Collections.svelte
@component
**Enhanced Collections component with improved performance, accessibility, and UX.**

@example
<Collections />

#### Props
- `collection` - The collection object to display data from.
- `mode` - The current mode of the component. Can be 'view', 'edit', 'create', 'delete', 'modify', or 'media'.

Features:
- Display collections and categories using TreeView from Skeleton.
- Advanced search with debouncing and filtering.
- Support for nested categories with expand/collapse.
- Responsive sidebar integration.
- Media gallery with folder management.
- Keyboard navigation support.
- Loading states and error handling.
-->

<script lang="ts" module>
	export interface CollectionTreeNode {
		id: string;
		name: string;
		isExpanded: boolean;
		onClick: () => void;
		children?: CollectionTreeNode[];
		icon?: string;
		badge?: {
			count?: number;
			status?: 'archive' | 'draft' | 'publish' | 'schedule' | 'clone' | 'test' | 'delete';
			color?: string;
			visible?: boolean;
			icon?: string; // Warning icon for inactive widgets
			title?: string; // Tooltip text
		};
		nodeType?: 'category' | 'collection' | 'virtual';
		path?: string;
		lastModified?: Date;
		isLoading?: boolean;
		hasError?: boolean;
		depth?: number;
		order?: number; // Add order property for sorting
		parentId?: string;
	}
</script>

<script lang="ts">
	import { goto } from '$app/navigation';
	import { page } from '$app/state';

	// Types
	import type { ContentNode, FieldInstance, Schema, StatusType, Translation } from '@src/content/types';
	import { StatusTypes } from '@src/content/types';
	// Stores
	import { collection, contentStructure, mode, setCollection, setMode } from '@src/stores/collectionStore.svelte';
	import { screenSize } from '@src/stores/screenSizeStore.svelte';
	import { handleUILayoutToggle, toggleUIElement, uiStateManager } from '@src/stores/UIStore.svelte';
	import { contentLanguage, shouldShowNextButton } from '@stores/store.svelte';
	import { get } from 'svelte/store';
	import { untrack } from 'svelte';

	// Utils
	import { debounce } from '@utils/utils';
	import { validateSchemaWidgets } from '@utils/widgetValidation';
	import { activeWidgets } from '@stores/widgetStore.svelte';

	// Components
	import TreeView from '@components/system/TreeView.svelte';

	// ParaglideJS
	import * as m from '@src/paraglide/messages';

	// Extend ContentNode to ensure path property is available
	interface ExtendedContentNode extends Omit<ContentNode, 'children' | 'order'> {
		// All ContentNode properties (_id, name, nodeType, translations, etc.) are inherited
		path?: string;
		children?: ExtendedContentNode[]; // Recursive reference with ExtendedContentNode
		lastModified?: Date;
		fileCount?: number;
		status?: StatusType;
		fields?: FieldInstance[]; // Add fields property for collection nodes (array of FieldInstance)
		order?: number; // Override to make order optional for client-side operations
	}

	// âœ… ADD PROPS DEFINITION
	// Fix: Add explicit type for systemVirtualFolders prop
	const { systemVirtualFolders = [] } = $props<{ systemVirtualFolders: CollectionTreeNode[] }>();

	// State management
	let search = $state('');
	let debouncedSearch = $state('');
	let isLoading = $state(false); // isLoading is now simpler
	let error = $state<string | null>(null);
	let expandedNodes = $state<Set<string>>(new Set());
	let systemVirtualFolderNodes = $state<CollectionTreeNode[]>([]);
	let selectedSystemVirtualFolder = $state<string | null>(null);

	// Use enhanced global debounce for search
	const debouncedSearchUpdate = debounce.create(
		((searchValue: string) => {
			debouncedSearch = searchValue.toLowerCase().trim();
		}) as (...args: unknown[]) => unknown,
		150
	);

	// Derived states with memoization
	let lastContentStructure: any = null;
	let cachedNestedStructure: ExtendedContentNode[] = [];

	let nestedStructure = $derived.by(() => {
		// Only recalculate if content structure actually changed
		if (contentStructure !== lastContentStructure) {
			lastContentStructure = contentStructure;
			// contentStructure is ALREADY nested from getNavigationStructure()
			cachedNestedStructure = contentStructure.value || [];
		}
		return cachedNestedStructure;
	});

	let isMediaMode = $derived(mode.value === 'media');
	let isFullSidebar = $derived(uiStateManager.uiState.value.leftSidebar === 'full');

	// Optimized debounced search effect with Svelte 5 reactive patterns
	$effect(() => {
		// React to search changes and debounce the update
		debouncedSearchUpdate(search);
	});

	// Initialize mode based on current route on component mount
	$effect(() => {
		const pathname = page.url.pathname;
		console.log('[Collections] Initialization effect - pathname:', pathname);

		// Only set mode if we're not on a mediagallery route
		if (!pathname.includes('/mediagallery') && mode.value === 'media') {
			console.log('[Collections] Initializing mode to view for non-mediagallery route');
			setMode('view');
		}
	});

	// Collection counting with persistent caching
	let collectionCountCache = new Map<string, number>();

	function countAllCollections(node: ExtendedContentNode): number {
		const cacheKey = node._id;
		if (collectionCountCache.has(cacheKey)) {
			return collectionCountCache.get(cacheKey)!;
		}

		let count = 0;
		if (!node.children) {
			collectionCountCache.set(cacheKey, 0);
			return 0;
		}

		for (const child of node.children) {
			if (child.nodeType === 'collection') {
				count++;
			} else if (child.nodeType === 'category') {
				count += countAllCollections(child);
			}
		}

		collectionCountCache.set(cacheKey, count);
		return count;
	}

	// Clear cache when content structure changes
	function clearCountCache() {
		collectionCountCache.clear();
	}

	// Optimized node mapping with memoization
	let collectionStructureNodes = $state<CollectionTreeNode[]>([]);

	// Effect to update collectionStructureNodes when dependencies change
	$effect(() => {
		// Track only the inputs we care about
		const structure = nestedStructure;
		const lang = contentLanguage.value;
		const expanded = expandedNodes;

		// Debug logging for collections data
		console.log('[Collections] Data loading debug:', {
			mode: mode.value,
			isMediaMode: mode.value === 'media',
			structureLength: structure?.length || 0,
			contentStructureValue: contentStructure.value?.length || 0,
			structure: structure
		});

		// Use untrack to read the selected collection ID without creating reactivity dependency
		const selectedId = untrack(() => collection.value?._id);

		// Use untrack to prevent reading collectionStructureNodes from triggering this effect
		untrack(() => {
			function mapNode(node: ExtendedContentNode, depth = 0): CollectionTreeNode {
				const isCategory = node.nodeType === 'category';
				// Get translation for current language or fallback to default name
				const translation = node.translations?.find((trans: Translation) => trans.languageTag === lang);
				const label = translation?.translationName || node.name;

				const nodeId = node._id;
				const isExpanded = expanded.has(nodeId) || selectedId === nodeId;

				// Check for inactive widgets if this is a collection
				let hasInactiveWidgets = false;
				if (!isCategory && node.fields) {
					const activeWidgetList = get(activeWidgets);
					const validation = validateSchemaWidgets({ ...node, fields: node.fields } as Schema, activeWidgetList);
					hasInactiveWidgets = !validation.valid;
				}

				let children: CollectionTreeNode[] | undefined;
				if (isCategory && node.children) {
					// Sort children by order before mapping
					const sortedChildren = [...node.children].sort((a, b) => (a.order || 0) - (b.order || 0));
					children = sortedChildren.map((child) => mapNode(child, depth + 1));
				}

				// Add badge only for categories to reduce overhead
				const allowedStatus = ['archive', 'draft', 'publish', 'schedule', 'clone', 'test', 'delete'] as const;
				const badge = isCategory
					? {
							count: countAllCollections(node),
							visible: true,
							status: allowedStatus.includes(node.status as (typeof allowedStatus)[number])
								? (node.status as (typeof allowedStatus)[number])
								: undefined,
							color: isExpanded ? 'bg-surface-400' : getStatusColor(node.status)
						}
					: hasInactiveWidgets
						? {
								visible: true,
								color: 'bg-warning-500',
								icon: 'mdi:alert-circle',
								title: 'This collection uses inactive widgets'
							}
						: undefined;

				return {
					...node,
					name: label,
					id: nodeId,
					isExpanded,
					onClick: () => handleCollectionSelect(node),
					children,
					badge,
					depth,
					order: node.order || 0, // Preserve order property
					lastModified: node.lastModified
				};
			}

			// Clear count cache when structure changes
			clearCountCache();

			// Sort root nodes by order before mapping
			const sortedRootNodes = [...structure].sort((a, b) => (a.order || 0) - (b.order || 0));
			// Update the state
			collectionStructureNodes = sortedRootNodes.map((node) => mapNode(node));
		});
	});

	// Get status color for badges
	function getStatusColor(status?: StatusType): string {
		switch (status) {
			case StatusTypes.publish:
				return 'bg-success-500';
			case StatusTypes.draft:
				return 'bg-warning-500';
			case StatusTypes.archive:
				return 'bg-surface-500';
			default:
				return 'bg-primary-500';
		}
	}

	// Virtual folder selection with state management
	function handleSystemVirtualFolderSelect(folderId: string) {
		selectedSystemVirtualFolder = folderId;

		if (folderId !== 'root') {
			expandedNodes.add(folderId);
		}

		const event = new CustomEvent('systemVirtualFolderSelected', {
			detail: { folderId, path: systemVirtualFolderNodes.find((n) => n.id === folderId)?.path }
		});
		document.dispatchEvent(event);

		console.log('Virtual folder selected:', folderId);
	}

	// Optimized collection selection with debouncing
	let navigationTimeout: ReturnType<typeof setTimeout> | undefined;

	function handleCollectionSelect(selectedCollection: ExtendedContentNode | Schema) {
		// Clear any pending navigation
		if (navigationTimeout) {
			clearTimeout(navigationTimeout);
		}

		// Type guard for ExtendedContentNode
		const isExtendedContentNode = (node: any): node is ExtendedContentNode => node && typeof node === 'object' && '_id' in node && 'nodeType' in node;

		if (isExtendedContentNode(selectedCollection)) {
			if (selectedCollection.nodeType === 'collection') {
				// Check if this collection is already selected to avoid unnecessary navigation
				const currentCollectionId = collection.value?._id;
				const isAlreadySelected = currentCollectionId === selectedCollection._id;

				if (isAlreadySelected) {
					console.log(`[Collections] Collection ${selectedCollection.name} is already selected, skipping navigation`);
					return;
				}

				// Immediately update UI state for responsiveness
				setMode('view');
				setCollection(null);
				shouldShowNextButton.set(true);

				// Clear EntryList cache to prevent stale data
				const cacheEvent = new CustomEvent('clearEntryListCache', {
					detail: { resetState: true, reason: 'collection-switch' }
				});
				document.dispatchEvent(cacheEvent);

				// Debounce the actual navigation slightly to prevent rapid clicks
				navigationTimeout = setTimeout(() => {
					goto(`/${contentLanguage.value}${selectedCollection.path?.toString()}`);
				}, 50);
			} else if (selectedCollection.nodeType === 'category') {
				toggleNodeExpansion(selectedCollection._id);
			}
		} else {
			// Handle Schema type if needed (fallback)
			// Example: if (selectedCollection && 'name' in selectedCollection) { ... }
		}
	}

	// Search clearing
	function clearSearch() {
		search = '';
		debouncedSearch = '';
	}

	// Toggle node expansion
	function toggleNodeExpansion(nodeId: string) {
		if (expandedNodes.has(nodeId)) {
			expandedNodes.delete(nodeId);
		} else {
			expandedNodes.add(nodeId);
		}
	}

	// Function to handle drag & drop reordering
	async function handleDragDropReorder(draggedId: string, targetId: string, position: 'before' | 'after' | 'inside') {
		try {
			console.log('Drag drop reorder:', { draggedId, targetId, position });

			// Prevent dropping a folder into itself or its descendants
			if (draggedId === targetId) {
				console.warn('Cannot drop folder into itself');
				return;
			}

			// Find the dragged node and target node
			const findNodeInTree = (nodes: CollectionTreeNode[], id: string): CollectionTreeNode | null => {
				for (const node of nodes) {
					if (node.id === id) return node;
					if (node.children) {
						const found = findNodeInTree(node.children, id);
						if (found) return found;
					}
				}
				return null;
			};

			// Find parent of a node
			const findParentInTree = (
				nodes: CollectionTreeNode[],
				childId: string,
				parentNode: CollectionTreeNode | null = null
			): CollectionTreeNode | null => {
				for (const node of nodes) {
					if (node.children?.some((child) => child.id === childId)) {
						return node;
					}
					if (node.children) {
						const found = findParentInTree(node.children, childId, node);
						if (found) return found;
					}
				}
				return parentNode;
			};

			// Check if dragged folder is an ancestor of target (prevent circular reference)
			const isAncestor = (ancestorId: string, descendantId: string): boolean => {
				const descendant = findNodeInTree(systemVirtualFolderNodes, descendantId);
				if (!descendant) return false;

				const parent = findParentInTree(systemVirtualFolderNodes, descendantId);
				if (!parent) return false;

				if (parent.id === ancestorId) return true;
				return isAncestor(ancestorId, parent.id);
			};

			if (isAncestor(draggedId, targetId)) {
				console.warn('Cannot move folder into its descendant');
				return;
			}

			const draggedNode = findNodeInTree(systemVirtualFolderNodes, draggedId);
			const targetNode = findNodeInTree(systemVirtualFolderNodes, targetId);

			if (!draggedNode || !targetNode) {
				console.error('Could not find dragged or target node');
				return;
			}

			// Determine the new parent and calculate order updates
			let newParentId: string | null = null;
			let orderUpdates: Array<{ folderId: string; order: number; parentId?: string | null }> = [];

			if (position === 'inside') {
				// Moving inside the target folder - target becomes the parent
				newParentId = targetNode.id === 'root' ? null : targetNode.id;

				// Get existing children to determine the new order
				const targetChildren = targetNode.children || [];
				const newOrder = targetChildren.length; // Add to the end

				orderUpdates.push({
					folderId: draggedId,
					order: newOrder,
					parentId: newParentId
				});
			} else {
				// Moving before or after the target - same parent as target
				const targetParent = findParentInTree(systemVirtualFolderNodes, targetId);
				newParentId = targetParent ? (targetParent.id === 'root' ? null : targetParent.id) : null;

				// Get siblings at the target level
				const siblings = targetParent ? targetParent.children || [] : systemVirtualFolderNodes[0]?.children || [];
				const targetIndex = siblings.findIndex((node) => node.id === targetId);

				if (targetIndex === -1) {
					console.error('Target node not found in siblings');
					return;
				}

				// Calculate new orders for affected items
				let newOrder: number;
				if (position === 'before') {
					newOrder = targetIndex;
					// Shift existing items at or after this position
					siblings.forEach((sibling, index) => {
						if (index >= targetIndex && sibling.id !== draggedId) {
							orderUpdates.push({
								folderId: sibling.id,
								order: index + 1
							});
						}
					});
				} else {
					// after
					newOrder = targetIndex + 1;
					// Shift existing items after this position
					siblings.forEach((sibling, index) => {
						if (index > targetIndex && sibling.id !== draggedId) {
							orderUpdates.push({
								folderId: sibling.id,
								order: index + 1
							});
						}
					});
				}

				orderUpdates.push({
					folderId: draggedId,
					order: newOrder,
					parentId: newParentId
				});
			}

			console.log('Sending reorder request:', { newParentId, orderUpdates });

			// Send reorder request
			const response = await fetch('/api/systemVirtualFolder', {
				method: 'PATCH',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					action: 'reorder',
					parentId: newParentId,
					orderUpdates: orderUpdates
				})
			});

			if (response.ok) {
				console.log('Drag drop reorder successful');
				// Refresh the folder list to show the new structure
				// refreshSystemVirtualFolders();
			} else {
				const errorData = await response.json();
				console.error('Failed to reorder folders via drag & drop:', errorData);
				throw new Error(`Failed to reorder folders: ${errorData.error || 'Unknown error'}`);
			}
		} catch (error) {
			console.error('Error in drag drop reorder:', error);
		}
	}

	// Effects
	$effect(() => {
		if (mode.value === 'media') {
			// Data now comes directly from the prop, no fetching needed.
			// We just need to build the tree structure from the prop data.
			const createRootNode = (): CollectionTreeNode => ({
				id: 'root',
				name: 'Media Root',
				path: 'mediaFiles',
				isExpanded: true,
				onClick: () => handleSystemVirtualFolderSelect('root'),
				icon: 'bi:house-door',
				badge: { visible: false },
				nodeType: 'virtual',
				depth: 0
			});

			const rootNode = createRootNode();

			// The prop `systemVirtualFolders` should already be the flat array of all folders
			if (systemVirtualFolders && systemVirtualFolders.length > 0) {
				const folderMap = new Map<string, CollectionTreeNode>();

				// Create nodes and map them
				systemVirtualFolders.forEach((folder: CollectionTreeNode) => {
					folderMap.set(folder.id, {
						...folder, // Spread existing properties from the prop
						isExpanded: expandedNodes.has(folder.id),
						onClick: () => handleSystemVirtualFolderSelect(folder.id),
						children: [], // Initialize children array
						depth: 0 // Will be set later
					});
				});

				const tree: CollectionTreeNode[] = [];
				// Link children to parents
				systemVirtualFolders.forEach((folder: CollectionTreeNode) => {
					const node = folderMap.get(folder.id)!;
					if (folder.parentId && folderMap.has(folder.parentId)) {
						const parent = folderMap.get(folder.parentId)!;
						parent.children!.push(node);
					} else {
						tree.push(node);
					}
				});

				// Set depth and sort children
				const setDepth = (nodes: CollectionTreeNode[], depth: number) => {
					nodes.sort((a, b) => (a.order || 0) - (b.order || 0));
					nodes.forEach((node) => {
						node.depth = depth;
						if (node.children && node.children.length > 0) {
							setDepth(node.children, depth + 1);
						} else {
							node.children = undefined;
						}
					});
				};
				setDepth(tree, 1);

				rootNode.children = tree;
			}

			systemVirtualFolderNodes = [rootNode];

			// Ensure sidebar is in the correct state
			if (!isFullSidebar) {
				handleUILayoutToggle();
			}
		}
	});

	// Listen for folder creation events
	$effect(() => {
		const handleFolderCreated = (event: CustomEvent) => {
			console.log('Folder created event received:', event.detail);
			if (isMediaMode) {
				console.log('Media mode active, refreshing system virtual folders...');
				// refreshSystemVirtualFolders();
			}
		};

		// Listen for custom events from the media gallery
		document.addEventListener('folderCreated', handleFolderCreated as EventListener);

		return () => {
			document.removeEventListener('folderCreated', handleFolderCreated as EventListener);
		};
	});

	// Effect to handle mode synchronization with route
	$effect(() => {
		const pathname = page.url.pathname;
		console.log('[Collections] Route effect triggered - pathname:', pathname, 'current mode:', mode.value);

		// Directly set mode based on current route
		if (pathname.includes('/mediagallery')) {
			if (mode.value !== 'media') {
				console.log('[Collections] Setting mode to media for mediagallery route');
				setMode('media');
			}
		} else {
			if (mode.value === 'media') {
				console.log('[Collections] Resetting mode to view for non-mediagallery route, pathname:', pathname);
				setMode('view');
			}
		}
	}); // Cleanup on unmount
	$effect(() => {
		return () => {
			if (navigationTimeout) {
				clearTimeout(navigationTimeout);
			}
		};
	});
</script>

<div class="collections-container mt-2" role="navigation" aria-label="Collections navigation">
	{#if !isMediaMode || true}
		<!-- Search Input -->
		<div class="{isFullSidebar ? 'mb-2 w-full' : 'mb-1 max-w-[135px]'} input-group input-group-divider grid grid-cols-[1fr_auto]">
			<div class="relative">
				<input
					type="text"
					placeholder="Search collections..."
					bind:value={search}
					class="input {isFullSidebar ? 'h-12' : 'h-10'} outline-hidden pr-8 transition-all duration-500 ease-in-out"
					aria-label="Search collections"
					autocomplete="off"
				/>
				{#if search}
					<div class="absolute right-2 top-1/2 -translate-y-1/2 transform">
						<div class="h-2 w-2 animate-pulse rounded-full bg-primary-500"></div>
					</div>
				{/if}
			</div>
			<button
				onclick={clearSearch}
				class="variant-filled-surface w-12 transition-colors hover:variant-filled-primary"
				aria-label="Clear search"
				disabled={!search}
			>
				<iconify-icon icon={search ? 'ic:outline-clear' : 'ic:outline-search-off'} width="20"></iconify-icon>
			</button>
		</div>

		<!-- Collections TreeView with Loading State -->
		{#if isLoading}
			<div class="p-4 text-center">
				<div class="flex items-center justify-center space-x-2">
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500"></div>
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500" style="animation-delay: 0.1s"></div>
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500" style="animation-delay: 0.2s"></div>
				</div>
				<p class="mt-2 text-sm text-surface-600">Loading collections...</p>
			</div>
		{:else if error}
			<div class="p-4 text-center text-error-500">
				<iconify-icon icon="ic:outline-error" width="24"></iconify-icon>
				<p class="mt-1 text-sm">{error}</p>
				<button class="variant-filled-error btn btn-sm mt-2" onclick={() => window.location.reload()}> Retry </button>
			</div>
		{:else if collectionStructureNodes.length > 0}
			<!-- Collections Header in Media Mode -->
			{#if isMediaMode && isFullSidebar}
				<div class="mb-2 flex items-center border-b border-surface-300 pb-2">
					<iconify-icon icon="bi:collection" width="20" class="mr-2 text-error-500"></iconify-icon>
					<h3 class="text-sm font-medium text-surface-700 dark:text-surface-300">Collections</h3>
				</div>
			{/if}

			<TreeView
				k={0}
				nodes={collectionStructureNodes}
				selectedId={collection.value?._id ?? null}
				compact={!isFullSidebar}
				search={debouncedSearch}
				iconColorClass="text-error-500"
				showBadges={true}
			></TreeView>
		{:else}
			<div class="p-4 text-center text-surface-500">
				<iconify-icon icon="bi:collection" width="32" class="opacity-50"></iconify-icon>
				<p class="mt-2 text-sm">{m.collection_no_collections_found()}</p>
			</div>
		{/if}

		<!-- Media Gallery Button -->
		<button
			class="btn mt-1 flex w-full rounded-sm {isFullSidebar ? 'flex-row' : 'flex-col'} items-center border border-surface-500 py-{isFullSidebar
				? '3'
				: '1'} group transition-all duration-200 hover:bg-surface-200 dark:bg-surface-500 hover:dark:bg-surface-400"
			onclick={() => {
				setMode('media');
				goto('/mediagallery');
				if (get(screenSize) === 'SM') {
					toggleUIElement('leftSidebar', 'hidden');
				}
				if (!isFullSidebar) handleUILayoutToggle();
			}}
			aria-label="Open media gallery"
		>
			{#if isFullSidebar}
				<iconify-icon icon="bi:images" width="24" class="text-primary-600 transition-transform group-hover:scale-110 rtl:ml-2"></iconify-icon>
				<span class="ml-2 dark:text-white">{m.Collections_MediaGallery()}</span>
			{:else}
				<span class="mb-1 text-xs">{m.Collections_MediaGallery()}</span>
				<iconify-icon icon="bi:images" width="20" class="text-primary-500 transition-transform group-hover:scale-110"></iconify-icon>
			{/if}
		</button>
	{/if}
	{#if isMediaMode}
		<!-- Back to Collections Button -->
		<button
			class="btn my-1 flex w-full rounded-sm {isFullSidebar ? 'flex-row' : 'flex-col'} items-center border border-surface-500 py-{isFullSidebar
				? '3'
				: '1'} group transition-all duration-200 hover:bg-surface-200 dark:bg-surface-500 hover:dark:bg-surface-400"
			onclick={() => {
				setCollection(null);
				setMode('view');
				selectedSystemVirtualFolder = null;
				expandedNodes.clear(); // Clear method triggers reactivity automatically

				if (get(screenSize) === 'SM') {
					toggleUIElement('leftSidebar', 'hidden');
				}
				goto('/');
			}}
			aria-label="Back to collections"
		>
			{#if isFullSidebar}
				<iconify-icon icon="bi:arrow-left" width="20" class="mr-2 text-error-500 transition-transform group-hover:-translate-x-1"></iconify-icon>
				<iconify-icon icon="bi:collection" width="24" class="mr-2 text-error-500"></iconify-icon>
				<span class="text-center">Collections</span>
			{:else}
				<span class="mb-1 text-xs">Collections</span>
				<iconify-icon icon="bi:collection" width="20" class="text-error-500"></iconify-icon>
			{/if}
		</button>

		<!-- Enhanced Virtual Folders Display -->
		{#if isFullSidebar}
			<div class="mb-2 mt-4 flex items-center border-b border-surface-300 pb-2">
				<iconify-icon icon="bi:folder" width="20" class="mr-2 text-primary-500"></iconify-icon>
				<h3 class="text-sm font-medium text-surface-700 dark:text-surface-300">Media Folders</h3>
			</div>
		{/if}
		{#if isLoading}
			<div class="p-4 text-center">
				<div class="flex items-center justify-center space-x-2">
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500"></div>
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500" style="animation-delay: 0.1s"></div>
					<div class="h-4 w-4 animate-bounce rounded-full bg-primary-500" style="animation-delay: 0.2s"></div>
				</div>
				<p class="mt-2 text-sm text-surface-600">Loading media folders...</p>
			</div>
		{:else if error}
			<div class="p-4 text-center text-error-500">
				<iconify-icon icon="ic:outline-error" width="24"></iconify-icon>
				<p class="mt-1 text-sm">{error}</p>
			</div>
		{:else if systemVirtualFolderNodes.length > 0}
			<TreeView
				k={1}
				nodes={systemVirtualFolderNodes}
				selectedId={selectedSystemVirtualFolder}
				compact={!isFullSidebar}
				search={debouncedSearch}
				iconColorClass="text-primary-500"
				showBadges={isFullSidebar}
				allowDragDrop={true}
				onReorder={handleDragDropReorder}
			></TreeView>
		{:else}
			<div class="p-4 text-center text-surface-500">
				<iconify-icon icon="bi:folder" width="32" class="opacity-50"></iconify-icon>
				<p class="mt-2 text-sm">No media folders found</p>
				<button class="variant-filled-primary btn btn-sm mt-2" onclick={() => goto('/mediagallery/create-folder')}> Create Folder </button>
			</div>
		{/if}
	{/if}
</div>

<style>
	/* Smooth animations for expansion states */
	:global(.tree-node) {
		transition: all 0.2s ease-in-out;
	}

	/* Custom scrollbar for sidebar */
	.collections-container {
		scrollbar-width: thin;
		scrollbar-color: rgba(var(--color-primary-500) / 0.3) transparent;
	}

	.collections-container::-webkit-scrollbar {
		width: 4px;
	}

	.collections-container::-webkit-scrollbar-thumb {
		background-color: rgba(var(--color-primary-500) / 0.3);
		border-radius: 2px;
	}
</style>
