{"version":3,"file":"_c0O0354.js","sources":["../../../../../../../../shared/stores/src/system/config.ts","../../../../../../../../shared/stores/src/system/metrics.ts","../../../../../../../../shared/stores/src/system/state.ts"],"sourcesContent":["/**\n * @file src/stores/system/config.ts\n * @description Configuration and initial state for the system state machine.\n */\n\nimport type { ServicePerformanceMetrics, SystemStateStore, AnomalyThresholds } from './types';\n\n// --- Core Constants ---\nexport const DEFAULT_SYSTEM_READY_TIMEOUT = 10000; // 10 seconds\nexport const CALIBRATION_CHECK_INTERVAL = 10; // Calibrate after every 10 health checks\nexport const MAX_STATE_TRANSITIONS_TO_KEEP = 50; // Max history for state transitions\n\n// --- Service Baseline Performance ---\n// Used for intelligent timeout calculations on first run.\nexport const SERVICE_BASELINE_TIMES = {\n\tdatabase: 500, // DB connection is usually fast\n\tauth: 50, // Auth initialization is nearly instant\n\tcache: 200, // Cache/media setup\n\tcontentManager: 300, // Content loading\n\tthemeManager: 200, // Theme loading\n\twidgets: 150 // Widget store initialization\n} as const;\n\n// --- Default Anomaly Thresholds ---\n// These are the initial values before self-calibration kicks in.\nexport const DEFAULT_ANOMALY_THRESHOLDS: AnomalyThresholds = {\n\tmaxStartupTime: 5000, // 5 seconds default\n\tmaxShutdownTime: 2000, // 2 seconds default\n\tmaxConsecutiveFailures: 3,\n\tminUptimePercentage: 95,\n\tcalibrationCount: 0\n};\n\n// --- Initial State Objects ---\n\n// Initial metrics for a new service.\nexport const initialServiceMetrics: ServicePerformanceMetrics = {\n\thealthCheckCount: 0,\n\tfailureCount: 0,\n\trestartCount: 0,\n\tconsecutiveFailures: 0,\n\tuptimePercentage: 100,\n\tstateTimings: {\n\t\tstartup: { count: 0, trend: 'unknown' },\n\t\tshutdown: { count: 0, trend: 'unknown' },\n\t\tidle: { count: 0, totalTime: 0 },\n\t\tactive: { count: 0, totalTime: 0 }\n\t},\n\tanomalyThresholds: { ...DEFAULT_ANOMALY_THRESHOLDS }\n};\n\n// Initial state for the entire system store.\nexport const initialState: SystemStateStore = {\n\toverallState: 'IDLE',\n\tservices: {\n\t\tdatabase: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tauth: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tcache: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tcontentManager: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tthemeManager: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\twidgets: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) }\n\t},\n\tperformanceMetrics: {\n\t\ttotalInitializations: 0,\n\t\tsuccessfulInitializations: 0,\n\t\tfailedInitializations: 0,\n\t\tstateTransitions: []\n\t}\n};\n","/**\n * @file src/stores/system/metrics.ts\n * @description Performance metrics, anomaly detection, and reporting for the system state.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type { Writable } from 'svelte/store';\nimport type { SystemStateStore, ServiceHealth, AnomalyDetection, ServiceName } from './types';\n\n/**\n * Track state timing (startup/shutdown) and update metrics\n */\nexport function trackStateTransition(\n\tserviceName: keyof SystemStateStore['services'],\n\tfromState: ServiceHealth,\n\ttoState: ServiceHealth,\n\tduration: number,\n\tstore: Writable<SystemStateStore>\n): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst stateTimings = { ...service.metrics.stateTimings };\n\n\t\t// Track startup (initializing ‚Üí healthy)\n\t\tif (fromState === 'initializing' && toState === 'healthy') {\n\t\t\tconst startup = { ...stateTimings.startup };\n\t\t\tstartup.count++;\n\t\t\tstartup.lastTime = duration;\n\n\t\t\t// Update statistics\n\t\t\tif (!startup.avgTime) {\n\t\t\t\tstartup.avgTime = duration;\n\t\t\t\tstartup.minTime = duration;\n\t\t\t\tstartup.maxTime = duration;\n\t\t\t} else {\n\t\t\t\tconst prevAvg = startup.avgTime;\n\t\t\t\tstartup.avgTime = (startup.avgTime * (startup.count - 1) + duration) / startup.count;\n\t\t\t\tstartup.minTime = Math.min(startup.minTime ?? duration, duration);\n\t\t\t\tstartup.maxTime = Math.max(startup.maxTime ?? duration, duration);\n\n\t\t\t\t// Determine trend (comparing to previous average)\n\t\t\t\tif (duration < prevAvg * 0.9) {\n\t\t\t\t\tstartup.trend = 'improving';\n\t\t\t\t} else if (duration > prevAvg * 1.1) {\n\t\t\t\t\tstartup.trend = 'degrading';\n\t\t\t\t} else {\n\t\t\t\t\tstartup.trend = 'stable';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstateTimings.startup = startup;\n\t\t}\n\n\t\t// Track shutdown (healthy ‚Üí unhealthy or healthy ‚Üí idle)\n\t\tif (fromState === 'healthy' && (toState === 'unhealthy' || toState === 'initializing')) {\n\t\t\tconst shutdown = { ...stateTimings.shutdown };\n\t\t\tshutdown.count++;\n\t\t\tshutdown.lastTime = duration;\n\n\t\t\tif (!shutdown.avgTime) {\n\t\t\t\tshutdown.avgTime = duration;\n\t\t\t\tshutdown.minTime = duration;\n\t\t\t\tshutdown.maxTime = duration;\n\t\t\t} else {\n\t\t\t\tconst prevAvg = shutdown.avgTime;\n\t\t\t\tshutdown.avgTime = (shutdown.avgTime * (shutdown.count - 1) + duration) / shutdown.count;\n\t\t\t\tshutdown.minTime = Math.min(shutdown.minTime ?? duration, duration);\n\t\t\t\tshutdown.maxTime = Math.max(shutdown.maxTime ?? duration, duration);\n\n\t\t\t\t// Determine trend\n\t\t\t\tif (duration < prevAvg * 0.9) {\n\t\t\t\t\tshutdown.trend = 'improving';\n\t\t\t\t} else if (duration > prevAvg * 1.1) {\n\t\t\t\t\tshutdown.trend = 'degrading';\n\t\t\t\t} else {\n\t\t\t\t\tshutdown.trend = 'stable';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstateTimings.shutdown = shutdown;\n\t\t}\n\n\t\tservice.metrics.stateTimings = stateTimings;\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Self-calibrate anomaly thresholds based on historical performance\n */\nexport function calibrateAnomalyThresholds(serviceName: keyof SystemStateStore['services'], store: Writable<SystemStateStore>): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst metrics = service.metrics;\n\t\tconst thresholds = { ...metrics.anomalyThresholds };\n\n\t\t// Only calibrate if we have enough data (at least 5 startups)\n\t\tif (metrics.stateTimings.startup.count < 5) {\n\t\t\tlogger.debug(`Skipping calibration for ${String(serviceName)} - insufficient data (${metrics.stateTimings.startup.count} startups)`);\n\t\t\treturn current;\n\t\t}\n\n\t\t// Calibrate startup threshold (use 3x average or 1.5x max, whichever is larger)\n\t\tif (metrics.stateTimings.startup.avgTime && metrics.stateTimings.startup.maxTime) {\n\t\t\tconst avgBased = metrics.stateTimings.startup.avgTime * 3;\n\t\t\tconst maxBased = metrics.stateTimings.startup.maxTime * 1.5;\n\t\t\tthresholds.maxStartupTime = Math.max(avgBased, maxBased);\n\t\t}\n\n\t\t// Calibrate shutdown threshold\n\t\tif (metrics.stateTimings.shutdown.avgTime && metrics.stateTimings.shutdown.maxTime) {\n\t\t\tconst avgBased = metrics.stateTimings.shutdown.avgTime * 3;\n\t\t\tconst maxBased = metrics.stateTimings.shutdown.maxTime * 1.5;\n\t\t\tthresholds.maxShutdownTime = Math.max(avgBased, maxBased);\n\t\t}\n\n\t\t// Calibrate failure threshold based on reliability\n\t\tif (metrics.uptimePercentage > 99) {\n\t\t\tthresholds.maxConsecutiveFailures = 2; // Stricter for highly reliable services\n\t\t} else if (metrics.uptimePercentage > 95) {\n\t\t\tthresholds.maxConsecutiveFailures = 3;\n\t\t} else {\n\t\t\tthresholds.maxConsecutiveFailures = 5; // More lenient for less reliable services\n\t\t}\n\n\t\t// Adjust uptime threshold based on historical performance\n\t\tconst actualUptime = metrics.uptimePercentage;\n\t\tif (actualUptime > 99) {\n\t\t\tthresholds.minUptimePercentage = 98; // Expect high reliability to continue\n\t\t} else if (actualUptime > 95) {\n\t\t\tthresholds.minUptimePercentage = 90; // More realistic expectations\n\t\t} else {\n\t\t\tthresholds.minUptimePercentage = 80; // Lower bar for struggling services\n\t\t}\n\n\t\tthresholds.lastCalibrated = Date.now();\n\t\tthresholds.calibrationCount++;\n\n\t\tservice.metrics.anomalyThresholds = thresholds;\n\n\t\tlogger.info(`üéØ Calibrated anomaly thresholds for ${String(serviceName)}`, {\n\t\t\tmaxStartup: `${thresholds.maxStartupTime.toFixed(0)}ms`,\n\t\t\tmaxShutdown: `${thresholds.maxShutdownTime.toFixed(0)}ms`,\n\t\t\tmaxFailures: thresholds.maxConsecutiveFailures,\n\t\t\tminUptime: `${thresholds.minUptimePercentage}%`,\n\t\t\tcalibrationCount: thresholds.calibrationCount\n\t\t});\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Detect anomalies and notify if something is wrong\n */\nexport function detectAnomalies(serviceName: keyof SystemStateStore['services'], state: SystemStateStore): AnomalyDetection[] {\n\tconst service = state.services[serviceName];\n\tconst metrics = service.metrics;\n\tconst thresholds = metrics.anomalyThresholds;\n\tconst anomalies: AnomalyDetection[] = [];\n\n\t// Check startup time\n\tif (metrics.stateTimings.startup.lastTime && metrics.stateTimings.startup.lastTime > thresholds.maxStartupTime) {\n\t\tconst excessPercent = (metrics.stateTimings.startup.lastTime / thresholds.maxStartupTime - 1) * 100;\n\t\tanomalies.push({\n\t\t\ttype: 'slow_startup',\n\t\t\tseverity: excessPercent > 100 ? 'critical' : excessPercent > 50 ? 'high' : 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} startup is slower than expected`,\n\t\t\tdetails: {\n\t\t\t\tactual: `${metrics.stateTimings.startup.lastTime.toFixed(0)}ms`,\n\t\t\t\tthreshold: `${thresholds.maxStartupTime.toFixed(0)}ms`,\n\t\t\t\texcess: `${excessPercent.toFixed(0)}%`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check shutdown time\n\tif (metrics.stateTimings.shutdown.lastTime && metrics.stateTimings.shutdown.lastTime > thresholds.maxShutdownTime) {\n\t\tanomalies.push({\n\t\t\ttype: 'slow_shutdown',\n\t\t\tseverity: 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} shutdown is slower than expected`,\n\t\t\tdetails: {\n\t\t\t\tactual: `${metrics.stateTimings.shutdown.lastTime.toFixed(0)}ms`,\n\t\t\t\tthreshold: `${thresholds.maxShutdownTime.toFixed(0)}ms`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check consecutive failures\n\tif (metrics.consecutiveFailures >= thresholds.maxConsecutiveFailures) {\n\t\tanomalies.push({\n\t\t\ttype: 'consecutive_failures',\n\t\t\tseverity: metrics.consecutiveFailures >= thresholds.maxConsecutiveFailures * 2 ? 'critical' : 'high',\n\t\t\tmessage: `Service ${String(serviceName)} has ${metrics.consecutiveFailures} consecutive failures`,\n\t\t\tdetails: {\n\t\t\t\tfailures: metrics.consecutiveFailures,\n\t\t\t\tthreshold: thresholds.maxConsecutiveFailures.toString()\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check uptime percentage\n\tif (metrics.uptimePercentage < thresholds.minUptimePercentage) {\n\t\tanomalies.push({\n\t\t\ttype: 'low_uptime',\n\t\t\tseverity: metrics.uptimePercentage < thresholds.minUptimePercentage * 0.8 ? 'high' : 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} uptime is below threshold`,\n\t\t\tdetails: {\n\t\t\t\tuptime: `${metrics.uptimePercentage.toFixed(1)}%`,\n\t\t\t\tthreshold: `${thresholds.minUptimePercentage}%`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check performance trend\n\tif (metrics.stateTimings.startup.trend === 'degrading' && metrics.stateTimings.startup.count > 10) {\n\t\tanomalies.push({\n\t\t\ttype: 'degrading_performance',\n\t\t\tseverity: 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} performance is degrading over time`,\n\t\t\tdetails: {\n\t\t\t\ttrend: metrics.stateTimings.startup.trend,\n\t\t\t\tavgTime: `${metrics.stateTimings.startup.avgTime?.toFixed(0)}ms`,\n\t\t\t\tlastTime: `${metrics.stateTimings.startup.lastTime?.toFixed(0)}ms`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Log anomalies\n\tif (anomalies.length > 0) {\n\t\tanomalies.forEach((anomaly) => {\n\t\t\tif (anomaly.severity === 'critical' || anomaly.severity === 'high') {\n\t\t\t\tlogger.error(`üö® ${anomaly.message}`, anomaly.details);\n\t\t\t} else {\n\t\t\t\tlogger.warn(`‚ö†Ô∏è ${anomaly.message}`, anomaly.details);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn anomalies;\n}\n\n/**\n * Update uptime percentage based on health checks\n */\nexport function updateUptimeMetrics(serviceName: ServiceName, store: Writable<SystemStateStore>): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst metrics = service.metrics;\n\n\t\t// Calculate uptime percentage\n\t\tif (metrics.healthCheckCount > 0) {\n\t\t\tconst healthyChecks = metrics.healthCheckCount - metrics.failureCount;\n\t\t\tmetrics.uptimePercentage = (healthyChecks / metrics.healthCheckCount) * 100;\n\t\t}\n\n\t\tservice.metrics = metrics;\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n","/**\n * @file src/stores/system/state.ts\n * @description Core state management for the SveltyCMS system.\n */\n\nimport { writable, derived, get } from 'svelte/store';\nimport type { Writable, Readable } from 'svelte/store';\nimport { logger } from '@shared/utils/logger';\nimport type { SystemStateStore, SystemState, ServiceHealth, ServiceStatus, ServicePerformanceMetrics, ServiceName } from './types';\nimport { initialState } from './config';\nimport { updateUptimeMetrics, trackStateTransition, calibrateAnomalyThresholds, detectAnomalies } from './metrics';\n\n// Create the writable store\nexport const systemStateStore: Writable<SystemStateStore> = writable(initialState);\n\n/**\n * Centralized helper for transitioning a service's state and updating metrics.\n * This reduces code duplication and ensures consistent state transitions.\n */\nfunction transitionServiceState(\n\tstate: SystemStateStore,\n\tserviceName: keyof SystemStateStore['services'],\n\tnewStatus: ServiceHealth,\n\tmessage: string,\n\terror?: string\n): SystemStateStore {\n\tconst now = Date.now();\n\tconst service = state.services[serviceName];\n\tconst metrics: ServicePerformanceMetrics = { ...service.metrics };\n\n\t// Track initialization completion\n\tif (newStatus === 'healthy' && service.status === 'initializing' && metrics.initializationStartedAt) {\n\t\tconst duration = now - metrics.initializationStartedAt;\n\t\tmetrics.initializationCompletedAt = now;\n\t\tmetrics.initializationDuration = duration;\n\n\t\t// Update running statistics with EMA (Exponential Moving Average)\n\t\tconst alpha = 2 / (metrics.healthCheckCount + 1); // Smoothing factor\n\t\tif (!metrics.averageInitTime) {\n\t\t\tmetrics.averageInitTime = duration;\n\t\t\tmetrics.minInitTime = duration;\n\t\t\tmetrics.maxInitTime = duration;\n\t\t} else {\n\t\t\tmetrics.averageInitTime = alpha * duration + (1 - alpha) * metrics.averageInitTime;\n\t\t\tmetrics.minInitTime = Math.min(metrics.minInitTime ?? duration, duration);\n\t\t\tmetrics.maxInitTime = Math.max(metrics.maxInitTime ?? duration, duration);\n\t\t}\n\n\t\tlogger.info(`‚úì Service ${serviceName} initialized in ${duration}ms`, {\n\t\t\taverage: metrics.averageInitTime.toFixed(2),\n\t\t\tmin: metrics.minInitTime,\n\t\t\tmax: metrics.maxInitTime\n\t\t});\n\n\t\tmetrics.consecutiveFailures = 0;\n\t}\n\n\t// Track failures - increment on every unhealthy status\n\tif (newStatus === 'unhealthy') {\n\t\tmetrics.consecutiveFailures++;\n\t\tmetrics.failureCount++;\n\n\t\t// Log only on transition to unhealthy\n\t\tif (service.status !== 'unhealthy') {\n\t\t\tmetrics.lastFailureAt = now;\n\t\t\tlogger.warn(`Service ${serviceName} became unhealthy (failure #${metrics.failureCount}, consecutive: ${metrics.consecutiveFailures})`, {\n\t\t\t\terror\n\t\t\t});\n\t\t}\n\t}\n\n\t// Track recovery\n\tif (newStatus === 'healthy' && service.status === 'unhealthy') {\n\t\tlogger.info(`‚úì Service ${serviceName} recovered from failure`);\n\t\tmetrics.consecutiveFailures = 0;\n\t}\n\n\t// Update health check timestamp\n\tmetrics.healthCheckCount++;\n\tmetrics.lastHealthCheckAt = now;\n\n\tconst updatedState: SystemStateStore = {\n\t\t...state,\n\t\tservices: {\n\t\t\t...state.services,\n\t\t\t[serviceName]: {\n\t\t\t\tstatus: newStatus,\n\t\t\t\tmessage,\n\t\t\t\tlastChecked: now,\n\t\t\t\t...(error && { error }),\n\t\t\t\tmetrics\n\t\t\t}\n\t\t},\n\t\tlastStateChange: now\n\t};\n\n\t// Derive the new overall system state from the updated service statuses\n\tconst derivedState = deriveOverallState(updatedState.services);\n\tupdatedState.overallState = derivedState;\n\n\t// Track successful initialization if state auto-derived to READY from INITIALIZING\n\tif (derivedState === 'READY' && state.overallState === 'INITIALIZING' && state.performanceMetrics.totalInitializations > 0) {\n\t\tconst duration = state.initializationStartedAt ? now - state.initializationStartedAt : 0;\n\t\tupdatedState.performanceMetrics = {\n\t\t\t...state.performanceMetrics,\n\t\t\tsuccessfulInitializations: state.performanceMetrics.successfulInitializations + 1,\n\t\t\tlastInitDuration: duration\n\t\t};\n\t\tlogger.info(`‚úì System auto-transitioned to READY (initialization completed in ${duration}ms)`);\n\t}\n\n\treturn updatedState;\n}\n\n/**\n * Start tracking initialization for a service\n */\nexport function startServiceInitialization(serviceName: keyof SystemStateStore['services']): void {\n\tconst now = Date.now();\n\tsystemStateStore.update((state) => {\n\t\tconst service = state.services[serviceName];\n\t\treturn {\n\t\t\t...state,\n\t\t\tservices: {\n\t\t\t\t...state.services,\n\t\t\t\t[serviceName]: {\n\t\t\t\t\t...service,\n\t\t\t\t\tstatus: 'initializing' as ServiceHealth,\n\t\t\t\t\tmetrics: {\n\t\t\t\t\t\t...service.metrics,\n\t\t\t\t\t\tinitializationStartedAt: now,\n\t\t\t\t\t\trestartCount: service.metrics.restartCount + (service.metrics.initializationStartedAt ? 1 : 0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Update a specific service's health status with performance tracking\n */\nexport function updateServiceHealth(serviceName: keyof SystemStateStore['services'], status: ServiceHealth, message: string, error?: string): void {\n\t// Use the centralized transition helper\n\tsystemStateStore.update((state) => transitionServiceState(state, serviceName, status, message, error));\n\n\t// --- Post-transition side effects ---\n\n\t// Update uptime metrics after state change\n\tupdateUptimeMetrics(serviceName, systemStateStore);\n\n\t// Track state transition timing if status changed\n\tconst updatedService = getSystemState().services[serviceName];\n\tif (status === 'healthy' && updatedService.metrics.initializationDuration) {\n\t\tconst duration = updatedService.metrics.initializationDuration;\n\t\ttrackStateTransition(serviceName, 'initializing', 'healthy', duration, systemStateStore);\n\t}\n\n\t// Auto-calibrate thresholds periodically (every 10 health checks)\n\tconst currentMetrics = updatedService.metrics;\n\tif (currentMetrics.healthCheckCount > 0 && currentMetrics.healthCheckCount % 10 === 0) {\n\t\tcalibrateAnomalyThresholds(serviceName, systemStateStore);\n\t}\n\n\t// Detect and report anomalies\n\tconst anomalies = detectAnomalies(serviceName, getSystemState());\n\n\t// You can integrate with notification system here\n\tif (anomalies.length > 0 && anomalies.some((a) => a.severity === 'critical' || a.severity === 'high')) {\n\t\t// TODO: Integrate with notification system (email, Slack, etc.)\n\t\tlogger.error(`üö® ${anomalies.length} anomal${anomalies.length > 1 ? 'ies' : 'y'} detected for ${serviceName}`);\n\t}\n}\n\n/**\n * Set the overall system state with transition tracking\n */\nexport function setSystemState(state: SystemState, reason?: string): void {\n\tconst now = Date.now();\n\n\tsystemStateStore.update((current) => {\n\t\tconst transition = {\n\t\t\tfrom: current.overallState,\n\t\t\tto: state,\n\t\t\ttimestamp: now,\n\t\t\t...(reason && { reason })\n\t\t};\n\n\t\t// Keep last 50 transitions for analysis\n\t\tconst stateTransitions = [...current.performanceMetrics.stateTransitions, transition].slice(-50);\n\n\t\t// Track initialization metrics\n\t\tconst performanceMetrics = { ...current.performanceMetrics, stateTransitions };\n\n\t\tif (state === 'INITIALIZING' && current.overallState !== 'INITIALIZING') {\n\t\t\tperformanceMetrics.totalInitializations++;\n\t\t}\n\n\t\tif (state === 'READY' && current.overallState !== 'READY' && performanceMetrics.totalInitializations > 0) {\n\t\t\tconst duration = current.initializationStartedAt ? now - current.initializationStartedAt : 0;\n\t\t\tperformanceMetrics.successfulInitializations++;\n\t\t\tperformanceMetrics.lastInitDuration = duration;\n\n\t\t\t// Update running statistics\n\t\t\tif (!performanceMetrics.averageTotalInitTime) {\n\t\t\t\tperformanceMetrics.averageTotalInitTime = duration;\n\t\t\t\tperformanceMetrics.minTotalInitTime = duration;\n\t\t\t\tperformanceMetrics.maxTotalInitTime = duration;\n\t\t\t} else {\n\t\t\t\tconst count = performanceMetrics.successfulInitializations;\n\t\t\t\tperformanceMetrics.averageTotalInitTime = (performanceMetrics.averageTotalInitTime * (count - 1) + duration) / count;\n\t\t\t\tperformanceMetrics.minTotalInitTime = Math.min(performanceMetrics.minTotalInitTime ?? duration, duration);\n\t\t\t\tperformanceMetrics.maxTotalInitTime = Math.max(performanceMetrics.maxTotalInitTime ?? duration, duration);\n\t\t\t}\n\n\t\t\tlogger.info(`üöÄ System initialization completed in ${duration}ms`, {\n\t\t\t\taverage: performanceMetrics.averageTotalInitTime.toFixed(2),\n\t\t\t\tmin: performanceMetrics.minTotalInitTime,\n\t\t\t\tmax: performanceMetrics.maxTotalInitTime,\n\t\t\t\tsuccessRate: `${((performanceMetrics.successfulInitializations / performanceMetrics.totalInitializations) * 100).toFixed(1)}%`\n\t\t\t});\n\t\t}\n\n\t\tif (state === 'FAILED' && current.overallState === 'INITIALIZING') {\n\t\t\tperformanceMetrics.failedInitializations++;\n\t\t}\n\n\t\tlogger.info(`System state changed: ${current.overallState} ‚Üí ${state}`, { reason });\n\n\t\treturn {\n\t\t\t...current,\n\t\t\toverallState: state,\n\t\t\tlastStateChange: now,\n\t\t\tperformanceMetrics,\n\t\t\t...(state === 'INITIALIZING' && { initializationStartedAt: now }),\n\t\t\t...(state === 'READY' && current.initializationStartedAt && { initializationCompletedAt: now })\n\t\t};\n\t});\n}\n\n// Derive overall system state from individual service statuses\nfunction deriveOverallState(services: SystemStateStore['services']): SystemState {\n\tconst criticalServices = ['database', 'auth'] as const;\n\tconst nonCriticalServices = ['cache', 'contentManager', 'themeManager'] as const;\n\n\t// Check if any critical service is unhealthy\n\tconst criticalUnhealthy = criticalServices.some((service) => services[service].status === 'unhealthy');\n\tif (criticalUnhealthy) {\n\t\treturn 'FAILED';\n\t}\n\n\t// Check if any critical service is still initializing\n\tconst criticalInitializing = criticalServices.some((service) => services[service].status === 'initializing');\n\tif (criticalInitializing) {\n\t\treturn 'INITIALIZING';\n\t}\n\n\t// Check if any non-critical service is unhealthy\n\tconst nonCriticalUnhealthy = nonCriticalServices.some((service) => services[service].status === 'unhealthy');\n\tif (nonCriticalUnhealthy) {\n\t\treturn 'DEGRADED';\n\t}\n\n\t// All critical services are healthy\n\treturn 'READY';\n}\n\n// Get the current system state (synchronous)\nexport function getSystemState(): SystemStateStore {\n\treturn get(systemStateStore);\n}\n\n// Check if the system is ready (synchronous)\nexport function isSystemReady(): boolean {\n\tconst state = getSystemState();\n\treturn state.overallState === 'READY' || state.overallState === 'DEGRADED';\n}\n\n// Check if a specific service is healthy (synchronous)\nexport function isServiceHealthy(serviceName: ServiceName): boolean {\n\tconst state = getSystemState();\n\treturn state.services[serviceName].status === 'healthy';\n}\n\n// Reset system state to IDLE (used for shutdown or reinitialization)\nexport function resetSystemState(): void {\n\tlogger.info('Resetting system state to IDLE');\n\tsystemStateStore.set({\n\t\t...structuredClone(initialState),\n\t\tlastStateChange: Date.now()\n\t});\n}\n\n// Get a readable store for the system state (for Svelte components)\nexport const systemState: Readable<SystemStateStore> = derived(systemStateStore, ($state) => $state);\n\n// Get a readable store for just the overall state (for simple checks)\nexport const overallState: Readable<SystemState> = derived(systemStateStore, ($state) => $state.overallState);\n\n// --- Granular Derived Stores for Improved Reactivity ---\n\n/**\n * A derived store that returns true if the system is in a ready or degraded state.\n * Ideal for use in UI components to show/hide content based on system readiness.\n */\nexport const isReady: Readable<boolean> = derived(overallState, ($s) => $s === 'READY' || $s === 'DEGRADED');\n\n/**\n * A derived store that returns true if the system is currently initializing.\n */\nexport const isInitializing: Readable<boolean> = derived(overallState, ($s) => $s === 'INITIALIZING');\n\n/**\n * A derived store that returns true if the system has failed.\n */\nexport const isFailed: Readable<boolean> = derived(overallState, ($s) => $s === 'FAILED');\n\n/**\n * A derived store that returns true if the system is in a degraded state.\n */\nexport const isDegraded: Readable<boolean> = derived(overallState, ($s) => $s === 'DEGRADED');\n\n/**\n * A derived store containing the status of all individual services.\n */\nexport const servicesStatus: Readable<SystemStateStore['services']> = derived(systemState, ($s) => $s.services);\n\n/**\n * Individual derived stores for each service's status.\n * This allows components to subscribe to only the service they care about.\n */\nexport const databaseStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.database);\nexport const authStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.auth);\nexport const cacheStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.cache);\nexport const contentManagerStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.contentManager);\nexport const themeManagerStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.themeManager);\n"],"names":["DEFAULT_ANOMALY_THRESHOLDS","initialServiceMetrics","initialState","trackStateTransition","serviceName","fromState","toState","duration","store","current","service","stateTimings","startup","prevAvg","calibrateAnomalyThresholds","metrics","thresholds","logger","avgBased","maxBased","actualUptime","detectAnomalies","state","anomalies","excessPercent","anomaly","updateUptimeMetrics","healthyChecks","systemStateStore","writable","transitionServiceState","newStatus","message","error","now","alpha","updatedState","derivedState","deriveOverallState","updateServiceHealth","status","updatedService","getSystemState","currentMetrics","a","services","criticalServices","nonCriticalServices","get","systemState","derived","$state","overallState","$s","servicesStatus"],"mappings":"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"}