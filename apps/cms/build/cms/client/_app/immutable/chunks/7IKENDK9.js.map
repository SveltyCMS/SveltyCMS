{"version":3,"file":"7IKENDK9.js","sources":["../../../../../../../../shared/stores/src/loadingStore.svelte.ts"],"sourcesContent":["/**\n * @file src/stores/loadingStore.svelte.ts\n * @description Enterprise-grade global loading state management aligned with SSR architecture.\n * Prevents UI flashes with intelligent context-aware loading states. Follows SveltyCMS state\n * management patterns: server-first, reactive, and self-optimizing.\n *\n * @example\n * import { globalLoadingStore, loadingOperations } from '@shared/stores/loadingStore.svelte';\n * // Manual control\n * globalLoadingStore.startLoading(loadingOperations.dataFetch);\n * await fetchData();\n * globalLoadingStore.stopLoading(loadingOperations.dataFetch);\n *\n * await globalLoadingStore.withLoading(\n *   loadingOperations.dataFetch,\n *   async () => await fetchData()\n * );\n *\n * Features:\n * - SSR-safe: Guards against server-side execution\n * - Smart context detection: Auto-detects operation type from context\n * - Stack-based: Handles concurrent operations gracefully\n * - Auto-cleanup: Prevents stuck loading states with timeouts\n * - TypeScript: Full type safety with discriminated unions\n */\n\nimport { SvelteSet } from 'svelte/reactivity';\nimport { SvelteMap } from 'svelte/reactivity';\nimport { browser } from '$app/environment';\n\n// Predefined loading operations for consistency\nexport const loadingOperations = {\n\tnavigation: 'navigation',\n\tdataFetch: 'data-fetch',\n\tauthentication: 'authentication',\n\tinitialization: 'initialization',\n\timageUpload: 'image-upload',\n\tformSubmission: 'form-submission',\n\tconfigSave: 'config-save',\n\troleManagement: 'role-management',\n\tpermissionUpdate: 'permission-update',\n\ttokenGeneration: 'token-generation',\n\tcollectionLoad: 'collection-load',\n\twidgetInit: 'widget-init'\n} as const;\n\nexport type LoadingOperation = (typeof loadingOperations)[keyof typeof loadingOperations];\n\n// Enhanced loading state with metadata\ninterface LoadingEntry {\n\treason: string;\n\tstartTime: number;\n\tcontext?: string;\n\ttimeoutId?: ReturnType<typeof setTimeout>;\n\tprogress?: number;\n\tcanCancel?: boolean;\n\tonCancel?: () => void;\n}\n\n// Enterprise-grade loading store with automatic cleanup and SSR safety\nexport class LoadingStore {\n\tprivate _isLoading = $state(false);\n\tprivate _loadingReason = $state<string | null>(null);\n\tprivate _loadingStack = $state<SvelteSet<string>>(new SvelteSet());\n\tprivate _loadingEntries = new SvelteMap<string, LoadingEntry>();\n\tprivate _maxTimeout = 30000; // 30 second max timeout for safety\n\tprivate _progress = $state<number | null>(null);\n\tprivate _canCancel = $state(false);\n\tprivate _onCancel = $state<(() => void) | undefined>(undefined);\n\n\t// Public getters\n\tget isLoading() {\n\t\treturn this._isLoading;\n\t}\n\n\tget loadingReason() {\n\t\treturn this._loadingReason;\n\t}\n\n\tget loadingStack() {\n\t\treturn this._loadingStack;\n\t}\n\n\tget progress() {\n\t\treturn this._progress;\n\t}\n\n\tget canCancel() {\n\t\treturn this._canCancel;\n\t}\n\n\tget onCancel() {\n\t\treturn this._onCancel;\n\t}\n\n\t/**\n\t * Start a loading operation with automatic timeout protection\n\t * @param reason - The loading operation type\n\t * @param context - Optional context for debugging\n\t * @param timeout - Custom timeout in ms (default: 30s)\n\t */\n\tstartLoading(reason: string, context?: string, timeout: number = this._maxTimeout) {\n\t\t// SSR guard: Only run in browser\n\t\tif (!browser) return;\n\n\t\t// Prevent duplicate entries\n\t\tif (this._loadingStack.has(reason)) {\n\t\t\tconsole.warn(`[LoadingStore] Operation \"${reason}\" already in progress`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create timeout to auto-cleanup stuck states\n\t\tconst timeoutId = setTimeout(() => {\n\t\t\tconsole.warn(`[LoadingStore] Auto-cleanup: \"${reason}\" exceeded ${timeout}ms`);\n\t\t\tthis.stopLoading(reason);\n\t\t}, timeout);\n\n\t\t// Add to stack and entries\n\t\tthis._loadingStack.add(reason);\n\t\tthis._loadingEntries.set(reason, {\n\t\t\treason,\n\t\t\tstartTime: Date.now(),\n\t\t\tcontext,\n\t\t\ttimeoutId\n\t\t});\n\n\t\tthis._isLoading = true;\n\t\tthis._loadingReason = reason;\n\n\t\tif (context) {\n\t\t\tconsole.debug(`[LoadingStore] Started: ${reason} (${context})`);\n\t\t}\n\t}\n\n\t/**\n\t * Stop a loading operation and clean up\n\t * @param reason - The loading operation type to stop\n\t */\n\tstopLoading(reason: string) {\n\t\t// SSR guard\n\t\tif (!browser) return;\n\n\t\tif (!this._loadingStack.has(reason)) {\n\t\t\treturn; // Already stopped or never started\n\t\t}\n\n\t\t// Clear timeout and remove entry\n\t\tconst entry = this._loadingEntries.get(reason);\n\t\tif (entry?.timeoutId) {\n\t\t\tclearTimeout(entry.timeoutId);\n\t\t}\n\t\tthis._loadingEntries.delete(reason);\n\n\t\t// Remove from stack\n\t\tthis._loadingStack.delete(reason);\n\n\t\t// Update state\n\t\tif (this._loadingStack.size === 0) {\n\t\t\tthis._isLoading = false;\n\t\t\tthis._loadingReason = null;\n\t\t\tthis._progress = null;\n\t\t\tthis._canCancel = false;\n\t\t\tthis._onCancel = undefined;\n\t\t} else {\n\t\t\t// Update to most recent operation\n\t\t\tconst entries = Array.from(this._loadingStack);\n\t\t\tconst newReason = entries[entries.length - 1];\n\t\t\tthis._loadingReason = newReason;\n\n\t\t\t// Restore progress/cancel state of the active operation\n\t\t\tconst newEntry = this._loadingEntries.get(newReason);\n\t\t\tif (newEntry) {\n\t\t\t\tthis._progress = newEntry.progress ?? null;\n\t\t\t\tthis._canCancel = newEntry.canCancel ?? false;\n\t\t\t\tthis._onCancel = newEntry.onCancel;\n\t\t\t}\n\t\t}\n\n\t\tif (entry) {\n\t\t\tconst duration = Date.now() - entry.startTime;\n\t\t\tconsole.debug(`[LoadingStore] Stopped: ${reason} (${duration}ms)`);\n\t\t}\n\t}\n\n\t/**\n\t * Update loading progress and cancellation for the current operation\n\t */\n\tupdateStatus(reason: string, progress?: number, canCancel?: boolean, onCancel?: () => void) {\n\t\tif (!browser || !this._loadingEntries.has(reason)) return;\n\n\t\tconst entry = this._loadingEntries.get(reason)!;\n\n\t\tif (progress !== undefined) {\n\t\t\tentry.progress = progress;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._progress = progress;\n\t\t\t}\n\t\t}\n\n\t\tif (canCancel !== undefined) {\n\t\t\tentry.canCancel = canCancel;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._canCancel = canCancel;\n\t\t\t}\n\t\t}\n\n\t\tif (onCancel !== undefined) {\n\t\t\tentry.onCancel = onCancel;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._onCancel = onCancel;\n\t\t\t}\n\t\t}\n\n\t\tthis._loadingEntries.set(reason, entry);\n\t}\n\n\t// Forcefully clear all loading states (emergency use only)\n\tclearLoading() {\n\t\tif (!browser) return;\n\n\t\t// Clear all timeouts\n\t\tfor (const entry of this._loadingEntries.values()) {\n\t\t\tif (entry.timeoutId) {\n\t\t\t\tclearTimeout(entry.timeoutId);\n\t\t\t}\n\t\t}\n\n\t\tthis._loadingEntries.clear();\n\t\tthis._loadingStack.clear();\n\t\tthis._isLoading = false;\n\t\tthis._loadingReason = null;\n\t\tthis._progress = null;\n\t\tthis._canCancel = false;\n\t\tthis._onCancel = undefined;\n\n\t\tconsole.warn('[LoadingStore] Force cleared all loading states');\n\t}\n\n\t// Check if a specific operation is currently loading\n\tisLoadingReason(reason: string): boolean {\n\t\treturn this._loadingStack.has(reason);\n\t}\n\n\t/**\n\t * Wrap an async operation with automatic loading state management\n\t * Handles errors and ensures cleanup even if promise rejects\n\t *\n\t * @example\n\t * await globalLoadingStore.withLoading(\n\t *   loadingOperations.dataFetch,\n\t *   async () => {\n\t *     const data = await fetch('/api/data');\n\t *     return data.json();\n\t *   }\n\t * );\n\t */\n\tasync withLoading<T>(reason: string, operation: () => Promise<T>, context?: string): Promise<T> {\n\t\tthis.startLoading(reason, context);\n\t\ttry {\n\t\t\tconst result = await operation();\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[LoadingStore] Operation \"${reason}\" failed:`, error);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tthis.stopLoading(reason);\n\t\t}\n\t}\n\n\t// Get loading statistics (for debugging)\n\tgetStats() {\n\t\tif (!browser) return null;\n\n\t\treturn {\n\t\t\tisLoading: this._isLoading,\n\t\t\tcurrentReason: this._loadingReason,\n\t\t\tactiveCount: this._loadingStack.size,\n\t\t\tactiveOperations: Array.from(this._loadingStack),\n\t\t\tentries: Array.from(this._loadingEntries.entries()).map(([reason, entry]) => ({\n\t\t\t\treason,\n\t\t\t\tduration: Date.now() - entry.startTime,\n\t\t\t\tcontext: entry.context\n\t\t\t}))\n\t\t};\n\t}\n}\n\n// Create and export singleton instance\nexport const globalLoadingStore = new LoadingStore();\n"],"names":["loadingOperations","LoadingStore","#_isLoading","$.state","value","#_loadingReason","#_loadingStack","SvelteSet","SvelteMap","#_progress","#_canCancel","#_onCancel","reason","context","timeout","timeoutId","entry","entries","newReason","newEntry","duration","progress","canCancel","onCancel","operation","error","globalLoadingStore"],"mappings":"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"}