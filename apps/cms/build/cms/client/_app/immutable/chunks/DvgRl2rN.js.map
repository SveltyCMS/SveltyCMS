{"version":3,"file":"DvgRl2rN.js","sources":["../../../../../../../../node_modules/svelte/src/store/utils.js","../../../../../../../../node_modules/svelte/src/store/shared/index.js"],"sourcesContent":["/** @import { Readable } from './public' */\nimport { untrack } from '../index-client.js';\nimport { noop } from '../internal/shared/utils.js';\n\n/**\n * @template T\n * @param {Readable<T> | null | undefined} store\n * @param {(value: T) => void} run\n * @param {(value: T) => void} [invalidate]\n * @returns {() => void}\n */\nexport function subscribe_to_store(store, run, invalidate) {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined);\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined);\n\n\t\treturn noop;\n\t}\n\n\t// Svelte store takes a private second argument\n\t// StartStopNotifier could mutate state, and we want to silence the corresponding validation error\n\tconst unsub = untrack(() =>\n\t\tstore.subscribe(\n\t\t\trun,\n\t\t\t// @ts-expect-error\n\t\t\tinvalidate\n\t\t)\n\t);\n\n\t// Also support RxJS\n\t// @ts-expect-error TODO fix this in the types?\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n","/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */\n/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */\nimport { noop, run_all } from '../../internal/shared/utils.js';\nimport { safe_not_equal } from '../../internal/client/reactivity/equality.js';\nimport { subscribe_to_store } from '../utils.js';\n\n/**\n * @type {Array<SubscribeInvalidateTuple<any> | any>}\n */\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {Unsubscriber | null} */\n\tlet stop = null;\n\n\t/** @type {Set<SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\n\t/**\n\t * @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(/** @type {T} */ (value)));\n\t}\n\n\t/**\n\t * @param {Subscriber<T>} run\n\t * @param {() => void} [invalidate]\n\t * @returns {Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(/** @type {T} */ (value));\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>) => T} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * @template {Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\t/** @type {T[]} */\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = typeof result === 'function' ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe_to_store(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @template T\n * @param {Readable<T>} store  - store to make readonly\n * @returns {Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\t// @ts-expect-error TODO i suspect the bind is unnecessary\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get(store) {\n\tlet value;\n\tsubscribe_to_store(store, (_) => (value = _))();\n\t// @ts-expect-error\n\treturn value;\n}\n"],"names":["subscribe_to_store","store","run","invalidate","noop","unsub","untrack","subscriber_queue","readable","value","start","writable","stop","subscribers","set","new_value","safe_not_equal","run_queue","subscriber","i","update","fn","subscribe","derived","stores","initial_value","single","stores_array","auto","started","values","pending","cleanup","sync","result","unsubscribers","run_all","get","_"],"mappings":"wDAWO,SAASA,EAAmBC,EAAOC,EAAKC,EAAY,CAC1D,GAAIF,GAAS,KAEZ,OAAAC,EAAI,MAAS,EAGTC,GAAYA,EAAW,MAAS,EAE7BC,EAKR,MAAMC,EAAQC,EAAQ,IACrBL,EAAM,UACLC,EAEAC,CACH,CACA,EAIC,OAAOE,EAAM,YAAc,IAAMA,EAAM,YAAW,EAAKA,CACxD,CC1BA,MAAME,EAAmB,CAAA,EAUlB,SAASC,EAASC,EAAOC,EAAO,CACtC,MAAO,CACN,UAAWC,EAASF,EAAOC,CAAK,EAAE,SACpC,CACA,CAUO,SAASC,EAASF,EAAOC,EAAQN,EAAM,CAE7C,IAAIQ,EAAO,KAGX,MAAMC,EAAc,IAAI,IAMxB,SAASC,EAAIC,EAAW,CACvB,GAAIC,EAAeP,EAAOM,CAAS,IAClCN,EAAQM,EACJH,GAAM,CAET,MAAMK,EAAY,CAACV,EAAiB,OACpC,UAAWW,KAAcL,EACxBK,EAAW,CAAC,EAAC,EACbX,EAAiB,KAAKW,EAAYT,CAAK,EAExC,GAAIQ,EAAW,CACd,QAASE,EAAI,EAAGA,EAAIZ,EAAiB,OAAQY,GAAK,EACjDZ,EAAiBY,CAAC,EAAE,CAAC,EAAEZ,EAAiBY,EAAI,CAAC,CAAC,EAE/CZ,EAAiB,OAAS,CAC3B,CACD,CAEF,CAMA,SAASa,EAAOC,EAAI,CACnBP,EAAIO,EAAqBZ,EAAO,CACjC,CAOA,SAASa,EAAUpB,EAAKC,EAAaC,EAAM,CAE1C,MAAMc,EAAa,CAAChB,EAAKC,CAAU,EACnC,OAAAU,EAAY,IAAIK,CAAU,EACtBL,EAAY,OAAS,IACxBD,EAAOF,EAAMI,EAAKM,CAAM,GAAKhB,GAE9BF,EAAsBO,CAAK,EACpB,IAAM,CACZI,EAAY,OAAOK,CAAU,EACzBL,EAAY,OAAS,GAAKD,IAC7BA,EAAI,EACJA,EAAO,KAET,CACD,CACA,MAAO,CAAE,IAAAE,EAAK,OAAAM,EAAQ,UAAAE,CAAS,CAChC,CAkCO,SAASC,EAAQC,EAAQH,EAAII,EAAe,CAClD,MAAMC,EAAS,CAAC,MAAM,QAAQF,CAAM,EAE9BG,EAAeD,EAAS,CAACF,CAAM,EAAIA,EACzC,GAAI,CAACG,EAAa,MAAM,OAAO,EAC9B,MAAM,IAAI,MAAM,sDAAsD,EAEvE,MAAMC,EAAOP,EAAG,OAAS,EACzB,OAAOb,EAASiB,EAAe,CAACX,EAAKM,IAAW,CAC/C,IAAIS,EAAU,GAEd,MAAMC,EAAS,CAAA,EACf,IAAIC,EAAU,EACVC,EAAU5B,EACd,MAAM6B,EAAO,IAAM,CAClB,GAAIF,EACH,OAEDC,EAAO,EACP,MAAME,EAASb,EAAGK,EAASI,EAAO,CAAC,EAAIA,EAAQhB,EAAKM,CAAM,EACtDQ,EACHd,EAAIoB,CAAM,EAEVF,EAAU,OAAOE,GAAW,WAAaA,EAAS9B,CAEpD,EACM+B,EAAgBR,EAAa,IAAI,CAAC1B,EAAOkB,IAC9CnB,EACCC,EACCQ,GAAU,CACVqB,EAAOX,CAAC,EAAIV,EACZsB,GAAW,EAAE,GAAKZ,GACdU,GACHI,EAAI,CAEN,EACA,IAAM,CACLF,GAAW,GAAKZ,CACjB,CACJ,CACA,EACE,OAAAU,EAAU,GACVI,EAAI,EACG,UAAgB,CACtBG,EAAQD,CAAa,EACrBH,EAAO,EAIPH,EAAU,EACX,CACD,CAAC,CACF,CAuBO,SAASQ,EAAIpC,EAAO,CAC1B,IAAIQ,EACJ,OAAAT,EAAmBC,EAAQqC,GAAO7B,EAAQ6B,CAAE,EAAC,EAEtC7B,CACR","x_google_ignoreList":[0,1]}