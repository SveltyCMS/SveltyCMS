{"version":3,"mappings":";kaAkBA,MAAMA,EAAU,EACVC,EAAO,EAcN,SAASC,GAAYC,EAAMC,EAAWC,EAAYC,EAASC,EAAU,CACvEC,GACHC,EAAY,EAKb,IAAIC,EAAsBC,EACtBC,EAAgBC,EAAOH,CAAC,EACxBI,EAAgBD,EAAOH,CAAC,EAExBK,EAAW,IAAIC,GAAcb,CAAI,EAErCc,EAAM,IAAM,CACX,IAAIC,EAAQd,EAAS,EACjBe,EAAY,GAIhB,IAAIC,EAAWZ,GAAaa,EAAWH,CAAK,KAAOf,EAAK,OAASmB,GAQjE,GANIF,IAEHG,EAAiBC,EAAU,CAAE,EAC7BC,EAAc,EAAK,GAGhBJ,EAAWH,CAAK,EAAG,CACtB,IAAIQ,EAAUC,EAAO,EACjBC,EAAW,GAKf,MAAMC,EAAWC,GAAO,CACvB,GAAI,CAAAX,EAEJ,CAAAS,EAAW,GAGXF,EAAQ,EAAK,EAEbK,EAAM,OAAM,EAERvB,GAGHiB,EAAc,EAAK,EAGpB,GAAI,CACHK,EAAE,CACH,QAAC,CACAE,EAAa,EAIRC,GAAkBC,EAAS,CACjC,EACD,EAEAhB,EAAM,KACJR,GAAM,CACNmB,EAAQ,IAAM,CACbM,EAAavB,EAAOF,CAAC,EACrBK,EAAS,OAAOd,EAAMK,IAAa8B,GAAW9B,EAAQ8B,EAAQxB,CAAK,EAAE,CACtE,CAAC,CACF,EACCyB,GAAM,CACNR,EAAQ,IAAM,CAIb,GAHAM,EAAarB,EAAOuB,CAAC,EACrBtB,EAAS,OAAOd,EAAMM,IAAc6B,GAAW7B,EAAS6B,EAAQtB,CAAK,EAAE,EAEnE,CAACP,EAEJ,MAAMO,EAAM,CAEd,CAAC,CACF,CACJ,EAEON,EACHO,EAAS,OAAOf,EAASK,CAAU,EAInCiC,EAAiB,IAAM,CACjBV,GACJC,EAAQ,IAAM,CACbd,EAAS,OAAOf,EAASK,CAAU,CACpC,CAAC,CAEH,CAAC,CAEH,MACC8B,EAAavB,EAAOM,CAAK,EACzBH,EAAS,OAAOd,EAAMK,IAAa8B,GAAW9B,EAAQ8B,EAAQxB,CAAK,EAAE,EAGtE,OAAIQ,GAEHK,EAAc,EAAI,EAGZ,IAAM,CACZN,EAAY,EACb,CACD,CAAC,CACF,olBC5HA,SAYO,MAAAoB,EAASC,EAAA,SAAAC,EAAA,KAEd,KAAIA,EAAA,KAAO,MAAQ,uGAMJ,uBAA6B,6GAE1CC,EAAGC,GAAA,MAAHD,CAAG,MAMEE,IAAM,OAEJC,EAAqBL,EAAA,IAAAM,EAAGF,CAAM,EAAC,YAAY,yCAClDG,EAAqBC,EAAA,0BAAET,CAAS,kBAC1BzB,IAAK,KAEXmC,EAAGC,GAAA,EAEFC,MAFDF,CAAG,SAEFE,EAAG,MAAHA,CAAG,IAFJF,CAAG,EAEwBG,EAAA,IAAAC,GAAAC,EAAAR,EAAAhC,CAAK,EAAC,OAAO,OAFxCmC,CAAG,oBAfMM,EAAAC,CAAA,sBAsBXC,EAAGC,GAAA,MAAHD,CAAG,WAvBAX,EAAAP,CAAS,EAAC,OAAKO,EAAIP,CAAS,EAAC,MAAM,OAAMgB,EAAAI,CAAA,EAAAJ,EAAAK,EAAA,gBAFtC","names":["PENDING","THEN","await_block","node","get_input","pending_fn","then_fn","catch_fn","hydrating","hydrate_next","v","UNINITIALIZED","value","source","error","branches","BranchManager","block","input","destroyed","mismatch","is_promise","HYDRATION_START_ELSE","set_hydrate_node","skip_nodes","set_hydrating","restore","capture","resolved","resolve","fn","Batch","unset_context","is_flushing_sync","flushSync","internal_set","target","e","queue_micro_task","emailList","$.derived","$$props","div_1","root_5","module","EmailPreviewComponent","$.get","EmailPreviewComponent_1","$$anchor","div","root_4","pre","$.template_effect","$.set_text","text","$$render","consequent","div_2","root_6","consequent_1","alternate"],"ignoreList":[0],"sources":["../../../../../../../../node_modules/svelte/src/internal/client/dom/blocks/await.js","../../../../../../src/routes/email-previews/+page.svelte"],"sourcesContent":["/** @import { Source, TemplateNode } from '#client' */\nimport { is_promise } from '../../../shared/utils.js';\nimport { block } from '../../reactivity/effects.js';\nimport { internal_set, mutable_source, source } from '../../reactivity/sources.js';\nimport {\n\thydrate_next,\n\thydrating,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport { is_runes } from '../../context.js';\nimport { Batch, flushSync, is_flushing_sync } from '../../reactivity/batch.js';\nimport { BranchManager } from './branches.js';\nimport { capture, unset_context } from '../../reactivity/async.js';\n\nconst PENDING = 0;\nconst THEN = 1;\nconst CATCH = 2;\n\n/** @typedef {typeof PENDING | typeof THEN | typeof CATCH} AwaitState */\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {(() => any)} get_input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(node, get_input, pending_fn, then_fn, catch_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar runes = is_runes();\n\n\tvar v = /** @type {V} */ (UNINITIALIZED);\n\tvar value = runes ? source(v) : mutable_source(v, false, false);\n\tvar error = runes ? source(v) : mutable_source(v, false, false);\n\n\tvar branches = new BranchManager(node);\n\n\tblock(() => {\n\t\tvar input = get_input();\n\t\tvar destroyed = false;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\t// @ts-ignore coercing `node` to a `Comment` causes TypeScript and Prettier to fight\n\t\tlet mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);\n\n\t\tif (mismatch) {\n\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh\n\t\t\tset_hydrate_node(skip_nodes());\n\t\t\tset_hydrating(false);\n\t\t}\n\n\t\tif (is_promise(input)) {\n\t\t\tvar restore = capture();\n\t\t\tvar resolved = false;\n\n\t\t\t/**\n\t\t\t * @param {() => void} fn\n\t\t\t */\n\t\t\tconst resolve = (fn) => {\n\t\t\t\tif (destroyed) return;\n\n\t\t\t\tresolved = true;\n\t\t\t\t// We don't want to restore the previous batch here; {#await} blocks don't follow the async logic\n\t\t\t\t// we have elsewhere, instead pending/resolve/fail states are each their own batch so to speak.\n\t\t\t\trestore(false);\n\t\t\t\t// Make sure we have a batch, since the branch manager expects one to exist\n\t\t\t\tBatch.ensure();\n\n\t\t\t\tif (hydrating) {\n\t\t\t\t\t// `restore()` could set `hydrating` to `true`, which we very much\n\t\t\t\t\t// don't want â€” we want to restore everything _except_ this\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tfn();\n\t\t\t\t} finally {\n\t\t\t\t\tunset_context();\n\n\t\t\t\t\t// without this, the DOM does not update until two ticks after the promise\n\t\t\t\t\t// resolves, which is unexpected behaviour (and somewhat irksome to test)\n\t\t\t\t\tif (!is_flushing_sync) flushSync();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tinput.then(\n\t\t\t\t(v) => {\n\t\t\t\t\tresolve(() => {\n\t\t\t\t\t\tinternal_set(value, v);\n\t\t\t\t\t\tbranches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(e) => {\n\t\t\t\t\tresolve(() => {\n\t\t\t\t\t\tinternal_set(error, e);\n\t\t\t\t\t\tbranches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error)));\n\n\t\t\t\t\t\tif (!catch_fn) {\n\t\t\t\t\t\t\t// Rethrow the error if no catch block exists\n\t\t\t\t\t\t\tthrow error.v;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (hydrating) {\n\t\t\t\tbranches.ensure(PENDING, pending_fn);\n\t\t\t} else {\n\t\t\t\t// Wait a microtask before checking if we should show the pending state as\n\t\t\t\t// the promise might have resolved by then\n\t\t\t\tqueue_micro_task(() => {\n\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\tresolve(() => {\n\t\t\t\t\t\t\tbranches.ensure(PENDING, pending_fn);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(value, input);\n\t\t\tbranches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\treturn () => {\n\t\t\tdestroyed = true;\n\t\t};\n\t});\n}\n","<!-- \n@file src/routes/email-previews/+page.svelte\n@component\n**Email Preview Page**\n- Lazy-loads the previewer to prevent SSR crashes and reduce bundle size.\n- Uses Svelte's {#await} block for cleaner async handling.\n\n@example\n<EmailPreview />\n\n### Props\n- `data` {object} - Object containing user data\n\n### Features\n- Displays widgets for previewing email templates\n-->\n\n<script lang=\"ts\">\n\timport { browser } from '$app/environment';\n\timport type { PageData } from './$types';\n\n\t// props\n\tinterface Props {\n\t\tdata: PageData;\n\t}\n\n\tconst { data }: Props = $props();\n\n\t// Use $derived to ensure reactivity\n\tconst emailList = $derived({\n\t\t...data,\n\t\tpath: data.path ?? null\n\t});\n</script>\n\n{#if emailList.files && emailList.files.length}\n\t{#if browser}\n\t\t{#await import('better-svelte-email/preview')}\n\t\t\t<!-- Loading State -->\n\t\t\t<div class=\"flex h-full items-center justify-center p-10\">\n\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t<div class=\"mb-2 text-xl font-semibold\">Loading Previewer...</div>\n\t\t\t\t\t<p class=\"text-sm text-gray-500\">Fetching email templates</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{:then module}\n\t\t\t<!-- Resolved State - Dynamic component with any typing for third-party module -->\n\t\t\t{@const EmailPreviewComponent = module.EmailPreview as any}\n\t\t\t<EmailPreviewComponent {emailList} />\n\t\t{:catch error}\n\t\t\t<!-- Error State -->\n\t\t\t<div class=\"rounded border border-red-200 bg-red-50 p-4 text-red-500\">\n\t\t\t\t<p class=\"font-bold\">Failed to load email previewer</p>\n\t\t\t\t<pre class=\"mt-2 text-xs\">{error.message}</pre>\n\t\t\t</div>\n\t\t{/await}\n\t{/if}\n{:else}\n\t<div class=\"p-8 text-center text-gray-500\">\n\t\t<p>No email templates found in <code class=\"rounded bg-gray-100 px-1 py-0.5\">/src/components/emails</code>.</p>\n\t</div>\n{/if}\n"],"file":"17.DIIjyaR7.js"}