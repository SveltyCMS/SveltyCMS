/**
 * @file apps/cms/vite.config.ts
 * @description Vite configuration for the CMS application
 *
 * Extends the global base configuration with CMS-specific plugins:
 * - Startups Checks & Setup Wizard
 * - Content Compilation & File Watching
 * - Plesk Deployment
 */

import { defineConfig, type Plugin, type ViteDevServer } from 'vite';
import { paraglideVitePlugin } from '@inlang/paraglide-js';
import path from 'path';
import { fileURLToPath } from 'url';
import { existsSync, promises as fs } from 'fs';
import { getBaseViteConfig } from '../../vite.config.base.js';

// Import Shared Utilities
import { compile } from '../../shared/utils/src/compilation/compile';
import { isSetupComplete } from '../../shared/utils/src/setupCheck';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const WORKSPACE_ROOT = path.resolve(__dirname, '../../');

// Paths config
const paths = {
	configDir: path.resolve(WORKSPACE_ROOT, 'config'),
	privateConfig: path.resolve(WORKSPACE_ROOT, 'config/private.ts'),
	userCollections: path.resolve(WORKSPACE_ROOT, 'config/collections'),
	compiledCollections: path.resolve(WORKSPACE_ROOT, '.compiledCollections'),
	widgets: path.resolve(__dirname, 'src/widgets')
};

// Logger Config
const useColor = process.stdout.isTTY;
const TAG = useColor ? `\x1b[34m[SveltyCMS]\x1b[0m` : `[SveltyCMS]`;

const log = {
	info: (message: string) => console.log(`${TAG} ${message}`),
	success: (message: string) => console.log(`${TAG} ${useColor ? `✅ \x1b[32m${message}\x1b[0m` : `✅ ${message}`}`),
	warn: (message: string) => console.warn(`${TAG} ${useColor ? `⚠️ \x1b[33m${message}\x1b[0m` : `⚠️ ${message}`}`),
	error: (message: string, error?: unknown) => console.error(`${TAG} ${useColor ? `❌ \x1b[31m${message}\x1b[0m` : `❌ ${message}`}`, error ?? '')
};

// --- Utilities ---
/**
 * Ensures collection directories exist and performs an initial compilation if needed.
 */
async function initializeCollectionsStructure() {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	if ((globalThis as any).__COLLECTIONS_COMPILED__) return;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	(globalThis as any).__COLLECTIONS_COMPILED__ = true;

	await fs.mkdir(paths.userCollections, { recursive: true });
	await fs.mkdir(paths.compiledCollections, { recursive: true });

	const sourceFiles = (await fs.readdir(paths.userCollections, { recursive: true })).filter(
		(file): file is string => typeof file === 'string' && (file.endsWith('.ts') || file.endsWith('.js'))
	);

	if (sourceFiles.length > 0) {
		log.info(`Found \x1b[32m${sourceFiles.length}\x1b[0m collection(s), compiling...`);
		await compile({ userCollections: paths.userCollections, compiledCollections: paths.compiledCollections });
		log.success('Initial collection compilation successful!');
	} else {
		log.info('No user collections found. Creating placeholder structure.');
		const placeholderContent = '// This is a placeholder file generated by Vite.\nexport default {};';
		const collectionsDir = path.resolve(paths.compiledCollections, 'Collections');
		const menuDir = path.resolve(paths.compiledCollections, 'Menu');

		await fs.mkdir(collectionsDir, { recursive: true });
		await fs.mkdir(menuDir, { recursive: true });
		await fs.writeFile(path.resolve(collectionsDir, '_placeholder.js'), placeholderContent);
		await fs.writeFile(path.resolve(menuDir, '_placeholder.js'), placeholderContent);
	}
}

// --- Plugins ---

// Plugin to stub server modules for browser build
function stubServerModulesPlugin(): Plugin {
	return {
		name: 'stub-server-modules',
		enforce: 'pre',
		resolveId(id, importer, options) {
			// Skip SSR builds - we want the real modules there
			if (options?.ssr) return null;

			// Stub heavy server-only modules for client build
			if (
				id === 'drizzle-orm' ||
				id.startsWith('drizzle-orm/') ||
				id.startsWith('mysql2') ||
				id === 'node-fetch' ||
				id.includes('better-svelte-email/preview')
			) {
				return `\0virtual:${id}`;
			}
			return null;
		},
		load(id) {
			if (id.includes('better-svelte-email/preview')) {
				return 'export const EmailPreview = () => null; export const createEmail = () => {}; export const sendEmail = () => {}; export const emailList = [];';
			}
			// specific subpath: drizzle-orm/mysql2
			if (id === '\0virtual:drizzle-orm/mysql2') {
				return 'export const drizzle = () => {}; export default {};';
			}

			if (id === '\0virtual:node-fetch') {
				return `
                    export const Request = globalThis.Request;
                    export const Response = globalThis.Response;
                    export const Headers = globalThis.Headers;
                    export default globalThis.fetch;
                `;
			}

			// Return minimal shims to satisfy imports
			if (id.startsWith('\0virtual:drizzle-orm')) {
				return `
					export const eq = () => {};
					export const and = () => {};
					export const or = () => {};
					export const like = () => {};
					export const ilike = () => {}; 
					export const inArray = () => {};
					export const desc = () => {};
					export const asc = () => {};
					export const sql = () => {};
					export const count = () => {};
					export const gt = () => {};
					export const lt = () => {};
					export const gte = () => {};
					export const lte = () => {};
					export const ne = () => {};
					export const notInArray = () => {};
					export const isNull = () => {};
					export const isNotNull = () => {};
					
					// mysql-core exports
					export const mysqlTable = () => ({});
					export const int = () => {};
					export const tinyint = () => {};
					export const bigint = () => {};
					export const varchar = () => {};
					export const text = () => {};
					export const boolean = () => {};
					export const datetime = () => {};
					export const timestamp = () => {};
					export const date = () => {};
					export const json = () => {};
					export const index = () => {};
					export const unique = () => {};
					export const primaryKey = () => {};
					export const foreignKey = () => {};
					
					export default {};
				`;
			}
			if (id.startsWith('\0virtual:mysql2')) {
				return 'export default {};';
			}
			return null;
		}
	};
}

/**
 * Plesk Deploy Plugin - copies runtime files and triggers Passenger restart
 */
const createPleskDeployPlugin = (projectRoot: string) => ({
	name: 'plesk-deploy-plugin',
	closeBundle() {
		const buildDir = path.join(projectRoot, 'build');
		if (!existsSync(buildDir)) return;
		console.log('\n✓ Build complete for cms');
		console.log('  Ready for Plesk deployment');
	}
});

// Plugin to handle missing private config during build
function privateConfigFallbackPlugin(): Plugin {
	const virtualModuleId = '\0virtual:private-config';
	return {
		name: 'svelty-cms-private-config-fallback',
		resolveId(id) {
			if (id === '@config/private' || id.includes('config/private')) {
				if (!existsSync(paths.privateConfig)) {
					return virtualModuleId;
				}
			}
			return null;
		},
		load(id) {
			if (id === virtualModuleId) {
				return 'export const privateEnv = null;';
			}
			return null;
		}
	};
}

/**
 * Setup Wizard Plugin (Monorepo Adapted)
 */
function setupWizardPlugin(): Plugin {
	let wasPrivateConfigMissing = false;
	return {
		name: 'svelty-cms-setup-wizard',
		async buildStart() {
			wasPrivateConfigMissing = !existsSync(paths.privateConfig);
			if (wasPrivateConfigMissing) {
				await fs.mkdir(paths.configDir, { recursive: true });
				log.info('Setup mode: config/private.ts will be created during setup wizard');
			}
			await initializeCollectionsStructure();
		},
		config: () => ({ define: { __FRESH_INSTALL__: JSON.stringify(wasPrivateConfigMissing) } }),
		configureServer() {
			if (!wasPrivateConfigMissing) return;
			// In monorepo, smart-dev handles opening, so we just log here
			log.info(`Setup wizard active.`);
		}
	};
}

/**
 * CMS Watcher Plugin - Handles HMR for Collections & Widgets
 */
function cmsWatcherPlugin(): Plugin {
	let compileTimeout: NodeJS.Timeout;
	let widgetTimeout: NodeJS.Timeout;

	const handleHmr = async (server: ViteDevServer, file: string) => {
		const isCollectionFile = file.startsWith(paths.userCollections) && /\.(ts|js)$/.test(file);
		const isWidgetFile = file.startsWith(paths.widgets) && (file.endsWith('index.ts') || file.endsWith('.svelte'));

		if (isCollectionFile) {
			clearTimeout(compileTimeout);
			compileTimeout = setTimeout(async () => {
				log.info(`Collection change detected. Recompiling...`);
				try {
					await compile({
						userCollections: paths.userCollections,
						compiledCollections: paths.compiledCollections,
						targetFile: file
					});
					log.success(`Re-compilation successful for ${path.basename(file)}!`);

					try {
						// Use workspace root resolution for database module
						const dbModulePath = path.resolve(WORKSPACE_ROOT, 'shared/database/src/db.ts');
						const { dbAdapter } = await server.ssrLoadModule(dbModulePath);
						if (dbAdapter && dbAdapter.collection) {
							const scannerPath = path.resolve(__dirname, 'src/content/collectionScanner.ts');
							const { scanCompiledCollections } = await server.ssrLoadModule(scannerPath);
							const collections = await scanCompiledCollections();
							log.info(`Found ${collections.length} collections, registering models...`);
							for (const schema of collections) {
								await dbAdapter.collections.createModel(schema);
								await new Promise((resolve) => setTimeout(resolve, 100));
							}
							log.success(`Collection models registered! (${collections.length} total)`);
						}
					} catch (dbError) {
						log.error('Failed to register collection models (non-fatal):', dbError);
					}

					const viteUtilsPath = path.resolve(__dirname, 'src/content/vite.ts');
					const { generateContentTypes } = await server.ssrLoadModule(viteUtilsPath);
					await generateContentTypes(server);
					log.info('Content structure types regenerated.');
					server.ws.send({ type: 'full-reload', path: '*' });
				} catch (error) {
					log.error(`Error recompiling collections:`, error);
				}
			}, 150);
		}

		if (isWidgetFile) {
			clearTimeout(widgetTimeout);
			widgetTimeout = setTimeout(async () => {
				log.info(`Widget file change detected. Reloading widget store...`);
				try {
					const widgetStorePath = path.resolve(__dirname, 'src/stores/widgetStore.svelte.ts');
					const { widgetStoreActions } = await server.ssrLoadModule(widgetStorePath);
					await widgetStoreActions.reload();
					server.ws.send({ type: 'full-reload', path: '*' });
					log.success('Widgets reloaded and client updated.');
				} catch (err) {
					log.error('Error reloading widgets:', err);
				}
			}, 150);
		}
	};

	return {
		name: 'svelty-cms-watcher',
		enforce: 'post',
		async buildStart() {
			await initializeCollectionsStructure();
		},
		configureServer(server) {
			server.watcher.on('all', (event, file) => {
				if (event === 'add' || event === 'change' || event === 'unlink') {
					handleHmr(server, file);
				}
			});
		}
	};
}

// --- Construction ---
const setupComplete = isSetupComplete();

// Get Base Config
const baseConfig = getBaseViteConfig(__dirname, {
	port: Number(process.env.PORT) || 5173,
	additionalPlugins: [
		stubServerModulesPlugin(),
		privateConfigFallbackPlugin(),
		!setupComplete ? setupWizardPlugin() : cmsWatcherPlugin(),
		createPleskDeployPlugin(__dirname)
	],
	optimizeDeps: {
		include: ['iconify-icon'],
		exclude: ['drizzle-orm']
	}
});

export default defineConfig({
	...baseConfig,
	// Add any CMS-specific overrides here if needed
	define: {
		...baseConfig.define,
		'import.meta.env.VITE_COLLECTIONS_FOLDER': JSON.stringify('compiledCollections'),
		__FRESH_INSTALL__: !setupComplete
	},
	ssr: {
		noExternal: ['@skeletonlabs/skeleton-svelte', '@zag-js/svelte', 'better-svelte-email'],
		external: ['drizzle-orm', 'mysql2', 'mariadb', 'pg', 'redis', 'ioredis', 'sharp', 'cloudinary', 'resend', '@react-email/render']
	},
	// Server overrides (merging usually handled by Vite, but safe to be explicit for critical paths)
	server: {
		...baseConfig.server,
		watch: {
			ignored: [
				'**/config/private.ts',
				'**/config/private.backup.*.ts',
				'**/compiledCollections/**',
				'**/tests/**',
				'**/src/content/types.ts',
				'**/src/lib/paraglide/**'
			]
		}
	},
	build: {
		sourcemap: false, // Disabled for production build optimization
		rollupOptions: {
			onwarn(warning, warn) {
				// Suppress circular dependency warnings from node_modules
				if (warning.code === 'CIRCULAR_DEPENDENCY' && warning.ids?.some((id) => id.includes('node_modules'))) {
					return;
				}

				// Suppress specific unused import warnings that are false positives or from 3rd-party libs
				if (warning.code === 'UNUSED_EXTERNAL_IMPORT' || warning.code === 'UNUSED_IMPORT') {
					// dndzone is used via use:dndzone, but Rollup sometimes misses this in Svelte 5
					if (warning.names?.includes('dndzone') || warning.message?.includes('dndzone')) {
						return;
					}
					// 3rd-party library warnings
					if (warning.ids?.some((id) => id.includes('better-svelte-email') || id.includes('@zag-js') || id.includes('postcss'))) {
						return;
					}
				}

				warn(warning);
			}
		}
	}
});
