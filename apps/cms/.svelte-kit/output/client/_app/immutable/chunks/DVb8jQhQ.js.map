{"version":3,"file":"DVb8jQhQ.js","sources":["../../../../../../../../shared/utils/src/apiClient.ts"],"sourcesContent":["/**\n * @file src/utils/apiClient.ts\n * @description Modern API client for RESTful collection endpoints with enhanced performance and caching\n * @example GET /api/collections/posts?limit=10&offset=0\n *\n * Features:\n *    * Performance optimization with QueryBuilder\n *    * Caching support for efficient data fetching\n *    * Error handling and logging\n *    * Custom log formatters\n *    * Conditional source file tracking\n *    * Error tracking service integration\n */\n\nimport type { ISODateString } from '@cms-types/content';\nimport { logger } from '@shared/utils/logger';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\n\n// --- Type Definitions ---\nexport interface ApiResponse<T = unknown> {\n\tsuccess: boolean;\n\tdata?: T;\n\terror?: string;\n}\n\nexport interface RevisionDiff {\n\tdiff: Record<string, { status: 'modified' | 'added' | 'deleted'; old?: unknown; new?: unknown; value?: unknown }>;\n\trevisionData: Record<string, unknown>;\n}\n\nexport interface RevisionMeta {\n\t_id: string;\n\trevision_at: ISODateString; // ISO date string\n\trevision_by: string;\n}\n\nexport interface Collection {\n\t_id: string;\n\tname: string;\n\tfields: Record<string, unknown>[];\n\t// Add other collection properties as needed\n}\n\ninterface GetDataResponse {\n\titems: Record<string, unknown>[];\n\ttotal: number;\n\ttotalPages: number;\n\tpage?: number;\n\tpageSize?: number;\n}\n\n// --- Core API Functions ---\nasync function fetchApi<T>(endpoint: string, options: RequestInit): Promise<ApiResponse<T>> {\n\ttry {\n\t\tconst response = await fetch(endpoint, {\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\tcredentials: 'include',\n\t\t\t...options\n\t\t});\n\t\tif (!response.ok) {\n\t\t\tconst errorData = await response.json().catch(() => ({ error: `HTTP error! Status: ${response.status}` }));\n\t\t\tthrow new Error(errorData.error || `An unknown error occurred.`);\n\t\t}\n\t\treturn await response.json();\n\t} catch (error) {\n\t\tconst err = error as Error;\n\t\tlogger.error(`[API Client Error]`, err);\n\t\treturn { success: false, error: err.message };\n\t}\n}\n\n// --- Entry Action Functions ---\nexport function createEntry(collectionId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(payload)\n\t});\n}\n\nexport function updateEntry(collectionId: string, entryId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}`, {\n\t\tmethod: 'PATCH',\n\t\tbody: JSON.stringify(payload)\n\t});\n}\n\nexport function batchUpdateEntries(collectionId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\t// Use the status endpoint for batch status updates\n\tconst { ids, status, ...otherFields } = payload;\n\tif (status && ids && Array.isArray(ids)) {\n\t\t// Use status endpoint for status changes\n\t\treturn fetchApi(`/api/collections/${collectionId}/${ids[0]}/status`, {\n\t\t\tmethod: 'PATCH',\n\t\t\tbody: JSON.stringify({ status, entries: ids, ...otherFields })\n\t\t});\n\t}\n\t// For other batch operations, we might need a different approach\n\t// For now, throw error if not status update\n\tthrow new Error('Batch updates only supported for status changes');\n}\n\nexport function updateEntryStatus(collectionId: string, entryId: string, status: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}/status`, {\n\t\tmethod: 'PATCH',\n\t\tbody: JSON.stringify({ status })\n\t});\n}\n\nexport function deleteEntry(collectionId: string, entryId: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}`, {\n\t\tmethod: 'DELETE'\n\t});\n}\n\nexport function batchDeleteEntries(collectionId: string, entryIds: string[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'delete', entryIds })\n\t});\n}\n\nexport function createClones(collectionId: string, entries: Record<string, unknown>[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch-clone`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ entries })\n\t});\n}\n\n// Batch operations for entries\nexport function batchCloneEntries(collectionId: string, entryIds: string[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'clone', entryIds })\n\t});\n}\n\nexport function batchUpdateEntriesStatus(collectionId: string, entryIds: string[], status: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'status', entryIds, status })\n\t});\n}\n\n// --- Revision Functions ---\n\n// A wrapper for a POST request to compare a revision with current data\nexport async function getRevisionDiff(params: {\n\tcollectionId: string;\n\tentryId: string;\n\trevisionId: string;\n\tcurrentData: Record<string, unknown>;\n}): Promise<ApiResponse<RevisionDiff>> {\n\tconst { collectionId, entryId, revisionId, currentData } = params;\n\tconst endpoint = `/api/collections/${collectionId}/${entryId}/revisions/diff`;\n\n\treturn fetchApi(endpoint, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ revisionId, currentData })\n\t});\n}\n\n// Specialized function for revisions\nexport async function getRevisions(\n\tcollectionId: string,\n\tentryId: string,\n\toptions: {\n\t\tpage?: number;\n\t\tlimit?: number;\n\t\trevisionId?: string;\n\t\tcompareWith?: string;\n\t\tmetaOnly?: boolean;\n\t} = {}\n): Promise<ApiResponse<RevisionMeta[]>> {\n\tconst endpoint = `/api/collections/${collectionId}/${entryId}/revisions`;\n\tconst searchParams = new URLSearchParams(options as Record<string, string>).toString();\n\tconst url = `${endpoint}?${searchParams}`;\n\n\treturn fetchApi(url, { method: 'GET' });\n}\n\n// --- Data & Cache Functions ---\nconst CACHE_TTL_MS = 30 * 1000; // 30 seconds cache TTL\n\ninterface CacheEntry {\n\tdata: GetDataResponse;\n\ttimestamp: number;\n\tttl: number;\n}\nconst dataCache = new Map<string, CacheEntry>();\n\nfunction generateCacheKey(query: Record<string, unknown>): string {\n\tconst normalizedQuery = {\n\t\tcollectionId: (query.collectionId as string)?.trim().toLowerCase(),\n\t\tpage: query.page || 1,\n\t\tpageSize: query.pageSize || query.limit || 25,\n\t\tcontentLanguage: query.contentLanguage || publicEnv.DEFAULT_CONTENT_LANGUAGE,\n\t\tfilter: query.filter || '{}',\n\t\tsortField: query.sortField || 'createdAt',\n\t\tsortDirection: query.sortDirection || 'desc',\n\t\t_langChange: query._langChange || 0\n\t};\n\treturn JSON.stringify(normalizedQuery);\n}\n\nfunction isCacheValid(cacheEntry: CacheEntry): boolean {\n\treturn Date.now() - cacheEntry.timestamp < cacheEntry.ttl;\n}\n\nexport function invalidateCollectionCache(collectionId: string): void {\n\tconst normalizedCollectionId = collectionId.trim().toLowerCase();\n\tfor (const [key] of dataCache.entries()) {\n\t\tif (key.includes(`\"collectionId\":\"${normalizedCollectionId}\"`)) {\n\t\t\tdataCache.delete(key);\n\t\t}\n\t}\n\tlogger.info(`[Cache] Invalidated for collection ${collectionId}`);\n}\n\n// Enhanced getData function using new RESTful endpoints\nexport async function getData(query: {\n\tcollectionId: string;\n\tpage?: number;\n\tpageSize?: number;\n\tlimit?: number; // Backward compatibility\n\tcontentLanguage?: string;\n\tfilter?: string;\n\tsortField?: string;\n\tsortDirection?: 'asc' | 'desc';\n\tsort?: string; // Backward compatibility\n\t_langChange?: number;\n}): Promise<ApiResponse<GetDataResponse>> {\n\tconst cacheKey = generateCacheKey(query);\n\tconst cached = dataCache.get(cacheKey);\n\n\tif (cached && isCacheValid(cached)) {\n\t\tlogger.info(`[Cache] HIT for ${cacheKey}`);\n\t\treturn { success: true, data: cached.data };\n\t}\n\tlogger.info(`[Cache] MISS for ${cacheKey}`);\n\n\tconst { collectionId, ...params } = query;\n\tconst searchParams = new URLSearchParams(params as Record<string, string>).toString();\n\tconst endpoint = `/api/collections/${collectionId}?${searchParams}`;\n\n\tconst result = await fetchApi<GetDataResponse>(endpoint, { method: 'GET' });\n\n\t// Add debugging for production issues\n\tif (result.success && result.data) {\n\t\t// Validate the response format\n\t\tif (!result.data.items || !Array.isArray(result.data.items)) {\n\t\t\tlogger.error(`[getData] Invalid response format:`, {\n\t\t\t\tendpoint,\n\t\t\t\thasItems: !!result.data.items,\n\t\t\t\titemsType: typeof result.data.items,\n\t\t\t\tresponseKeys: Object.keys(result.data)\n\t\t\t});\n\t\t\treturn { success: false, error: 'Invalid response format from server' };\n\t\t}\n\n\t\tdataCache.set(cacheKey, { data: result.data, timestamp: Date.now(), ttl: CACHE_TTL_MS });\n\t\tlogger.info(`[getData] Success:`, {\n\t\t\tendpoint,\n\t\t\titemCount: result.data.items.length,\n\t\t\ttotal: result.data.total,\n\t\t\tcached: true\n\t\t});\n\t} else if (!result.success) {\n\t\tlogger.error(`[getData] API Error:`, { endpoint, error: result.error });\n\t}\n\n\treturn result;\n}\n\n// Get all collections list\nexport async function getCollections(\n\toptions: {\n\t\tincludeFields?: boolean;\n\t\tincludeStats?: boolean;\n\t} = {}\n): Promise<ApiResponse<Collection[]>> {\n\tconst params = new URLSearchParams(options as Record<string, string>);\n\tconst endpoint = `/api/collections?${params.toString()}`;\n\treturn fetchApi(endpoint, { method: 'GET' });\n}\n"],"names":["fetchApi","endpoint","options","response","errorData","error","err","logger","createEntry","collectionId","payload","updateEntry","entryId","batchUpdateEntries","ids","status","otherFields","updateEntryStatus","deleteEntry","batchDeleteEntries","entryIds","createClones","entries","dataCache","invalidateCollectionCache","normalizedCollectionId","key","getCollections"],"mappings":"wDAoDA,eAAeA,EAAYC,EAAkBC,EAA+C,CAC3F,GAAI,CACH,MAAMC,EAAW,MAAM,MAAMF,EAAU,CACtC,QAAS,CAAE,eAAgB,kBAAA,EAC3B,YAAa,UACb,GAAGC,CAAA,CACH,EACD,GAAI,CAACC,EAAS,GAAI,CACjB,MAAMC,EAAY,MAAMD,EAAS,KAAA,EAAO,MAAM,KAAO,CAAE,MAAO,uBAAuBA,EAAS,MAAM,IAAK,EACzG,MAAM,IAAI,MAAMC,EAAU,OAAS,4BAA4B,CAChE,CACA,OAAO,MAAMD,EAAS,KAAA,CACvB,OAASE,EAAO,CACf,MAAMC,EAAMD,EACZ,OAAAE,EAAO,MAAM,qBAAsBD,CAAG,EAC/B,CAAE,QAAS,GAAO,MAAOA,EAAI,OAAA,CACrC,CACD,CAGO,SAASE,EAAYC,EAAsBC,EAAiE,CAClH,OAAOV,EAAS,oBAAoBS,CAAY,GAAI,CACnD,OAAQ,OACR,KAAM,KAAK,UAAUC,CAAO,CAAA,CAC5B,CACF,CAEO,SAASC,EAAYF,EAAsBG,EAAiBF,EAAiE,CACnI,OAAOV,EAAS,oBAAoBS,CAAY,IAAIG,CAAO,GAAI,CAC9D,OAAQ,QACR,KAAM,KAAK,UAAUF,CAAO,CAAA,CAC5B,CACF,CAEO,SAASG,EAAmBJ,EAAsBC,EAAiE,CAEzH,KAAM,CAAE,IAAAI,EAAK,OAAAC,EAAQ,GAAGC,GAAgBN,EACxC,GAAIK,GAAUD,GAAO,MAAM,QAAQA,CAAG,EAErC,OAAOd,EAAS,oBAAoBS,CAAY,IAAIK,EAAI,CAAC,CAAC,UAAW,CACpE,OAAQ,QACR,KAAM,KAAK,UAAU,CAAE,OAAAC,EAAQ,QAASD,EAAK,GAAGE,CAAA,CAAa,CAAA,CAC7D,EAIF,MAAM,IAAI,MAAM,iDAAiD,CAClE,CAEO,SAASC,EAAkBR,EAAsBG,EAAiBG,EAA+C,CACvH,OAAOf,EAAS,oBAAoBS,CAAY,IAAIG,CAAO,UAAW,CACrE,OAAQ,QACR,KAAM,KAAK,UAAU,CAAE,OAAAG,EAAQ,CAAA,CAC/B,CACF,CAEO,SAASG,EAAYT,EAAsBG,EAAgD,CACjG,OAAOZ,EAAS,oBAAoBS,CAAY,IAAIG,CAAO,GAAI,CAC9D,OAAQ,QAAA,CACR,CACF,CAEO,SAASO,EAAmBV,EAAsBW,EAAmD,CAC3G,OAAOpB,EAAS,oBAAoBS,CAAY,SAAU,CACzD,OAAQ,OACR,KAAM,KAAK,UAAU,CAAE,OAAQ,SAAU,SAAAW,EAAU,CAAA,CACnD,CACF,CAEO,SAASC,EAAaZ,EAAsBa,EAAmE,CACrH,OAAOtB,EAAS,oBAAoBS,CAAY,eAAgB,CAC/D,OAAQ,OACR,KAAM,KAAK,UAAU,CAAE,QAAAa,EAAS,CAAA,CAChC,CACF,CA8DA,MAAMC,MAAgB,IAoBf,SAASC,EAA0Bf,EAA4B,CACrE,MAAMgB,EAAyBhB,EAAa,KAAA,EAAO,YAAA,EACnD,SAAW,CAACiB,CAAG,IAAKH,EAAU,UACzBG,EAAI,SAAS,mBAAmBD,CAAsB,GAAG,GAC5DF,EAAU,OAAOG,CAAG,EAGtBnB,EAAO,KAAK,sCAAsCE,CAAY,EAAE,CACjE,CA0DA,eAAsBkB,EACrBzB,EAGI,GACiC,CAErC,MAAMD,EAAW,oBADF,IAAI,gBAAgBC,CAAiC,EACxB,SAAA,CAAU,GACtD,OAAOF,EAASC,EAAU,CAAE,OAAQ,MAAO,CAC5C"}