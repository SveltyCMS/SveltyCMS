{"version":3,"file":"D3eOXrHH.js","sources":["../../../../../../../../shared/utils/src/entryActionsMessages.ts","../../../../../../../../shared/utils/src/entryActions.ts"],"sourcesContent":["/**\n * @file src/utils/entryActionsMessages.ts\n * @description Centralized messages for entry actions to improve localization\n */\n\nimport * as m from '@shared/paraglide/messages';\n\nexport const entryMessages = {\n\t// Status update messages\n\tentriesArchived: (count: number) => m.entries_archived?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} archived successfully`,\n\n\tentriesPublished: (count: number) => m.entries_published?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} published successfully`,\n\n\tentriesUnpublished: (count: number) =>\n\t\tm.entries_unpublished?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} unpublished successfully`,\n\n\tentriesSetToTest: (count: number) => m.entries_set_to_test?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} set to test successfully`,\n\n\tentriesDeleted: (count: number) => m.entries_deleted?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} deleted successfully`,\n\n\tentriesScheduled: (count: number) => m.entries_scheduled?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} scheduled successfully`,\n\n\tentriesCloned: (count: number) => m.entries_cloned?.({ count }) || `${count} ${count === 1 ? 'entry' : 'entries'} cloned successfully`,\n\n\tentriesUpdated: (count: number, status: string) =>\n\t\tm.entries_updated?.({ count, status }) || `${count} ${count === 1 ? 'entry' : 'entries'} updated to ${status}`,\n\n\t// Error messages\n\tupdateFailed: (operation: string) => m.update_failed?.({ operation }) || `Failed to ${operation} entries`,\n\n\tdeleteFailed: (operation: string) => m.delete_failed?.({ operation }) || `Failed to ${operation} entries`,\n\n\tnoEntriesSelected: () => m.no_entries_selected?.() || 'No entries selected',\n\n\tnoCollectionFound: () => m.no_collection_found?.() || 'Collection not found',\n\n\t// Single entry messages\n\tentryArchived: () => m.entry_archived?.() || 'Entry archived successfully',\n\n\tentryDeleted: () => m.entry_deleted_success?.() || 'Entry deleted successfully',\n\n\tentrySaved: () => m.entry_saved?.() || 'Entry saved successfully',\n\n\tentryStatusUpdated: (status: string) => m.entry_status_updated?.({ status }) || `Entry status updated to ${status}`,\n\n\tentryScheduled: (date: string) => m.entry_scheduled?.({ date }) || `Entry scheduled for ${date}`,\n\n\tentryCloned: () => m.entry_cloned_success?.() || 'Entry cloned successfully',\n\n\t// Admin permissions\n\tonlyAdminsCanDelete: () => m.only_admins_can_delete?.() || 'Only administrators can delete archived entries',\n\n\tstatusReservedForSystem: (status: string) => m.status_reserved_for_system?.({ status }) || `${status} status is reserved for system operations`,\n\n\t// Unsaved changes\n\tunsavedChangesTitle: () => m.unsaved_changes_title?.() || 'Unsaved Changes',\n\n\tunsavedChangesBody: () => m.unsaved_changes_body?.() || 'You have unsaved changes. Do you want to save them as a draft before leaving?',\n\n\tsaveAsDraftAndLeave: () => m.save_as_draft_and_leave?.() || 'Save as Draft and Leave',\n\n\tstayAndContinueEditing: () => m.stay_and_continue_editing?.() || 'Stay and Continue Editing',\n\n\tchangesSavedAsDraft: () => m.changes_saved_as_draft?.() || 'Changes saved as draft',\n\n\terrorSavingDraft: (error: string) => m.error_saving_draft?.({ error }) || `Error saving draft: ${error}`,\n\n\t// Scheduling\n\tnoEntryForScheduling: () => m.no_entry_for_scheduling?.() || 'No entry selected for scheduling',\n\n\tentryScheduledStatus: () => m.entry_scheduled_status?.() || 'Entry status changed to scheduled',\n\n\terrorScheduling: (error: string) => m.error_scheduling?.({ error }) || `Error scheduling entry: ${error}`,\n\n\t// Common actions\n\tconfirm: () => m.button_confirm?.() || 'Confirm',\n\n\tcancel: () => m.button_cancel?.() || 'Cancel',\n\n\tdelete: () => m.button_delete?.() || 'Delete',\n\n\tarchive: () => m.button_archive?.() || 'Archive',\n\n\tpublish: () => m.entrylist_multibutton_publish?.() || 'Publish',\n\n\tunpublish: () => m.entrylist_multibutton_unpublish?.() || 'Unpublish',\n\n\tschedule: () => m.entrylist_multibutton_schedule?.() || 'Schedule',\n\n\tclone: () => m.entrylist_multibutton_clone?.() || 'Clone',\n\n\ttest: () => m.button_test?.() || 'Test'\n};\n","/**\n * @file src/utils/entryActions.ts\n * @description Centralized functions for performing actions on collection entries.\n */\n\nimport type { StatusType } from '@cms-types/content';\nimport { StatusTypes } from '@cms-types/content';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\n\n// ParaglideJS\nimport * as m from '@shared/paraglide/messages';\nimport { collection, collectionValue, setCollectionValue, setMode } from '@shared/stores/collectionStore.svelte';\nimport { toaster } from '@shared/stores/store.svelte';\nimport { logger } from './logger';\nimport {\n\tbatchDeleteEntries,\n\tbatchUpdateEntries,\n\tcreateClones,\n\tcreateEntry,\n\tdeleteEntry,\n\tinvalidateCollectionCache,\n\tupdateEntry,\n\tupdateEntryStatus\n} from './apiClient';\nimport { entryMessages } from './entryActionsMessages';\nimport { showConfirm, showScheduleModal, showCloneModal } from '@shared/utils/modalUtils';\n// Helper function to update entry status\nasync function updateStatus(collectionId: string, entryId: string, status: string) {\n\tconst result = await updateEntryStatus(collectionId, entryId, status);\n\tif (!result.success) {\n\t\tthrow new Error(result.error || 'Failed to update status');\n\t}\n\treturn result;\n}\n\n// Sets the status for one or more entries\nexport async function setEntriesStatus(entryIds: string[], status: StatusType, onSuccess: () => void, payload: Record<string, unknown> = {}) {\n\tif (!entryIds.length) return;\n\tconst collId = collection.value?._id;\n\tif (!collId) return;\n\n\tconst result = await batchUpdateEntries(collId, { ids: entryIds, status, ...payload });\n\tif (result.success) {\n\t\t// Use centralized messaging\n\t\tconst count = entryIds.length;\n\t\tlet message: string;\n\n\t\tswitch (status) {\n\t\t\tcase StatusTypes.archive:\n\t\t\t\tmessage = entryMessages.entriesArchived(count);\n\t\t\t\tbreak;\n\t\t\tcase StatusTypes.publish:\n\t\t\t\tmessage = entryMessages.entriesPublished(count);\n\t\t\t\tbreak;\n\t\t\tcase StatusTypes.unpublish:\n\t\t\t\tmessage = entryMessages.entriesUnpublished(count);\n\t\t\t\tbreak;\n\t\t\tcase StatusTypes.draft:\n\t\t\t\tmessage = entryMessages.entriesUpdated(count, StatusTypes.draft);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmessage = entryMessages.entriesUpdated(count, status);\n\t\t}\n\n\t\ttoaster.success({ description: message });\n\t\tonSuccess();\n\t} else {\n\t\ttoaster.error({ description: result.error || entryMessages.updateFailed('update') });\n\t}\n} // Deletes or archives one or more entries with improved batch delete\nexport async function deleteEntries(entryIds: string[], isPermanentDelete: boolean, onSuccess: () => void) {\n\tif (!entryIds.length) return;\n\tconst collId = collection.value?._id;\n\tif (!collId) return;\n\n\tconst isArchiving = publicEnv.USE_ARCHIVE_ON_DELETE && !isPermanentDelete;\n\n\ttry {\n\t\tif (isArchiving) {\n\t\t\t// Archive entries by updating their status to 'archive'\n\t\t\tconst result = await batchUpdateEntries(collId, { ids: entryIds, status: StatusTypes.archive });\n\t\t\tif (result.success) {\n\t\t\t\ttoaster.success({ description: entryMessages.entriesArchived(entryIds.length) });\n\t\t\t\tonSuccess();\n\t\t\t} else {\n\t\t\t\ttoaster.error({ description: result.error || entryMessages.updateFailed(StatusTypes.archive) });\n\t\t\t}\n\t\t} else {\n\t\t\t// Use batch delete API if available, fallback to individual deletes\n\t\t\ttry {\n\t\t\t\tconst result = await batchDeleteEntries(collId, entryIds);\n\t\t\t\tif (result.success) {\n\t\t\t\t\ttoaster.success({ description: entryMessages.entriesDeleted(entryIds.length) });\n\t\t\t\t\tonSuccess();\n\t\t\t\t} else {\n\t\t\t\t\t// Fallback to individual deletes if batch delete fails\n\t\t\t\t\tthrow new Error('Batch delete not supported, falling back to individual deletes');\n\t\t\t\t}\n\t\t\t} catch (batchError) {\n\t\t\t\t// Fallback: delete entries one by one\n\t\t\t\tlogger.warn('Batch delete failed, using individual deletes:', batchError);\n\t\t\t\tawait Promise.all(entryIds.map((entryId) => deleteEntry(collId, entryId)));\n\t\t\t\ttoaster.success({ description: entryMessages.entriesDeleted(entryIds.length) });\n\t\t\t\tonSuccess();\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\ttoaster.error({ description: entryMessages.deleteFailed(isArchiving ? StatusTypes.archive : StatusTypes.delete) + `: ${(e as Error).message}` });\n\t}\n}\n\n// Clones one or more entries\nexport async function cloneEntries(rawEntries: Record<string, unknown>[], onSuccess: () => void) {\n\tif (!rawEntries.length) return;\n\tconst collId = collection.value?._id;\n\tif (!collId) return;\n\n\tconst entriesToClone = rawEntries.map((entry) => {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { _id, createdAt, updatedAt, ...rest } = entry;\n\t\treturn { ...rest, clonedFrom: _id };\n\t});\n\n\tconst result = await createClones(collId, entriesToClone);\n\tif (result.success) {\n\t\ttoaster.success({ description: 'Entries cloned' });\n\t\tonSuccess();\n\t} else {\n\t\ttoaster.error({ description: result.error || 'Failed to clone entries' });\n\t}\n}\n\n// Saves a new or existing entry\nexport async function saveEntry(entryData: Record<string, unknown>, publish: boolean = false): Promise<boolean> {\n\tconst collId = collection.value?._id;\n\tif (!collId) {\n\t\ttoaster.warning({ description: 'Collection not found' });\n\t\treturn false;\n\t}\n\n\tconst entryId = entryData._id as string | undefined;\n\n\t// Preserve user's chosen status unless explicitly publishing\n\tconst payload = { ...entryData };\n\tif (publish) {\n\t\tpayload.status = StatusTypes.publish;\n\t} else if (!payload.status) {\n\t\t// Use collection's default status if no status is specified (new entries)\n\t\tpayload.status = collection.value?.status || StatusTypes.draft;\n\t}\n\t// Otherwise preserve the existing status from entryData\n\n\tconst result = entryId ? await updateEntry(collId, entryId, payload) : await createEntry(collId, payload);\n\n\tif (result.success) {\n\t\ttoaster.success({ description: 'Entry saved' });\n\t\tif (result.data) {\n\t\t\tsetCollectionValue(result.data as Record<string, unknown>);\n\t\t}\n\t\t// setMode('view'); // Handled by caller to ensure proper navigation flow\n\t\tinvalidateCollectionCache(collId);\n\n\t\t// Trigger SvelteKit SSR reload - Handled by caller via goto(..., { invalidateAll: true })\n\t\t// await invalidateAll();\n\n\t\t// Clear client-side cache in EntryList component\n\t\tif (typeof document !== 'undefined') {\n\t\t\tdocument.dispatchEvent(\n\t\t\t\tnew CustomEvent('clearEntryListCache', {\n\t\t\t\t\tdetail: { reason: 'entry-saved', collectionId: collId }\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\treturn true;\n\t} else {\n\t\ttoaster.error({ description: result.error || 'Failed to save entry' });\n\t\treturn false;\n\t}\n}\n\n// Deletes the currently active entry after confirmation\nexport async function deleteCurrentEntry(isAdmin: boolean = false) {\n\tconst entry = collectionValue.value;\n\tconst coll = collection.value;\n\tif (!entry?._id || !coll?._id) {\n\t\ttoaster.warning({ description: m.delete_entry_no_selection_error() });\n\t\treturn;\n\t}\n\n\t// Type assertions after null check\n\tconst collectionId = coll._id as string;\n\tconst entryId = entry._id as string;\n\n\tconst entryStatus: StatusType = (entry.status as StatusType) || StatusTypes.draft;\n\tconst isArchived = entryStatus === StatusTypes.archive;\n\tconst useArchiving = publicEnv.USE_ARCHIVE_ON_DELETE;\n\n\t// Determine what options to show based on rules\n\tif (!useArchiving) {\n\t\t// USE_ARCHIVE_ON_DELETE: false - Always delete directly\n\t\tshowDeleteConfirmationModal(collectionId, entryId, StatusTypes.delete);\n\t} else if (isArchived) {\n\t\t// Archived entry - only admins can permanently delete\n\t\tif (isAdmin) {\n\t\t\tshowDeleteConfirmationModal(collectionId, entryId, StatusTypes.delete);\n\t\t} else {\n\t\t\ttoaster.warning({ description: 'Only administrators can delete archived entries.' });\n\t\t}\n\t} else {\n\t\t// Active entry (draft, clone, publish, unpublish, test)\n\t\tif (isAdmin) {\n\t\t\t// Admin can choose: show both options in one modal\n\t\t\tshowAdminChoiceModal(collectionId, entryId);\n\t\t} else {\n\t\t\t// Non-admin can only archive\n\t\t\tshowDeleteConfirmationModal(collectionId, entryId, StatusTypes.archive);\n\t\t}\n\t}\n}\n\n// Helper function to show admin choice modal (Archive or Delete options)\nfunction showAdminChoiceModal(collectionId: string, entryId: string) {\n\t// First show archive option with Cancel leading to delete option\n\tshowConfirm({\n\t\ttitle: 'Archive Entry',\n\t\tbody: `\n\t\t\t<div class=\"space-y-3\">\n\t\t\t\t<p>Do you want to <strong class=\"text-warning-600\">archive</strong> this entry?</p>\n\t\t\t\t<p class=\"text-sm text-surface-600 dark:text-surface-50\">Archived entries are hidden from view but kept in the database and can be restored later.</p>\n\t\t\t</div>\n\t\t`,\n\t\tconfirmText: 'Archive',\n\t\tcancelText: 'Show Delete Option',\n\t\tonConfirm: () => showDeleteConfirmationModal(collectionId, entryId, StatusTypes.archive),\n\t\tonCancel: () =>\n\t\t\tshowConfirm({\n\t\t\t\ttitle: 'Delete Entry Permanently',\n\t\t\t\tbody: `\n\t\t\t\t\t<div class=\"space-y-3\">\n\t\t\t\t\t\t<p>Do you want to <strong class=\"text-error-600\">permanently delete</strong> this entry?</p>\n\t\t\t\t\t\t<p class=\"text-sm text-surface-600 dark:text-surface-50\">This will completely remove the entry from the database. This action cannot be undone.</p>\n\t\t\t\t\t</div>\n\t\t\t\t`,\n\t\t\t\tconfirmText: 'Delete Permanently',\n\t\t\t\tonConfirm: () => showDeleteConfirmationModal(collectionId, entryId, StatusTypes.delete)\n\t\t\t})\n\t});\n}\n\n// Helper function to show final confirmation modal\nfunction showDeleteConfirmationModal(collectionId: string, entryId: string, action: typeof StatusTypes.archive | typeof StatusTypes.delete) {\n\tconst isArchive = action === StatusTypes.archive;\n\tshowConfirm({\n\t\ttitle: `Please Confirm <span class=\"text-error-500 font-bold\">${isArchive ? 'Archiving' : 'Deletion'}</span>`,\n\t\tbody: isArchive\n\t\t\t? `Are you sure you want to <span class=\"text-warning-500 font-semibold\">archive</span> this entry? Archived items can be restored later.`\n\t\t\t: `Are you sure you want to <span class=\"text-error-500 font-semibold\">delete</span> this entry? This action will remove the entry from the system.`,\n\t\tconfirmText: isArchive ? 'Archive' : 'Delete',\n\t\tcancelText: m.button_cancel(),\n\t\tonConfirm: async () => {\n\t\t\ttry {\n\t\t\t\tif (isArchive) {\n\t\t\t\t\tawait updateStatus(collectionId, entryId, StatusTypes.archive);\n\t\t\t\t\tsetCollectionValue({ ...collectionValue.value, status: StatusTypes.archive });\n\t\t\t\t\ttoaster.success({ description: 'Entry archived successfully.' });\n\t\t\t\t} else {\n\t\t\t\t\tawait deleteEntry(collectionId, entryId);\n\t\t\t\t\ttoaster.success({ description: m.entry_deleted_success() });\n\t\t\t\t}\n\t\t\t\tsetMode('view');\n\t\t\t\tsetCollectionValue({});\n\t\t\t\tinvalidateCollectionCache(collectionId);\n\t\t\t} catch (e) {\n\t\t\t\ttoaster.error({ description: m.delete_entry_error({ error: (e as Error).message }) });\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport async function permanentlyDeleteEntry(entryId: string) {\n\tconst coll = collection.value;\n\tif (!coll?._id) {\n\t\ttoaster.warning({ description: m.clone_entry_no_selection_error() });\n\t\treturn;\n\t}\n\n\tconst collectionId = coll._id as string;\n\n\tshowConfirm({\n\t\ttitle: 'Confirm Permanent Deletion',\n\t\tbody: 'This will permanently delete the archived entry from the database. This action cannot be undone.',\n\t\tconfirmText: 'Permanently Delete',\n\t\tonConfirm: async () => {\n\t\t\ttry {\n\t\t\t\tawait deleteEntry(collectionId, entryId);\n\t\t\t\ttoaster.success({ description: 'Entry permanently deleted.' });\n\t\t\t\tinvalidateCollectionCache(collectionId);\n\t\t\t\tsetMode('view');\n\t\t\t} catch (e) {\n\t\t\t\ttoaster.error({ description: `Error permanently deleting entry: ${(e as Error).message}` });\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport async function setEntryStatus(newStatus: StatusType) {\n\tconst entry = collectionValue.value;\n\tconst coll = collection.value;\n\tif (!entry?._id || !coll?._id) {\n\t\ttoaster.warning({ description: m.set_status_no_selection_error() });\n\t\treturn;\n\t}\n\n\tconst collectionId = coll._id as string;\n\tconst entryId = entry._id as string;\n\n\tif (newStatus === 'draft' || newStatus === StatusTypes.archive) {\n\t\ttoaster.error({ description: `${newStatus} status is reserved for system operations.` });\n\t\treturn;\n\t}\n\ttry {\n\t\tawait updateStatus(collectionId, entryId, newStatus);\n\t\tsetCollectionValue({ ...collectionValue.value, status: newStatus });\n\t\ttoaster.success({ description: m.entry_status_updated({ status: newStatus }) });\n\t} catch (e) {\n\t\ttoaster.error({ description: m.set_status_error({ error: (e as Error).message }) });\n\t}\n}\n\n// Schedule entry for future publication with improved date picker integration\nexport async function scheduleCurrentEntry(scheduledDate?: Date) {\n\tconst entry = collectionValue.value;\n\tconst coll = collection.value;\n\n\tif (!entry?._id || !coll?._id) {\n\t\ttoaster.warning({ description: entryMessages.noEntryForScheduling() });\n\t\treturn;\n\t}\n\n\tconst collectionId = coll._id as string;\n\tconst entryId = entry._id as string;\n\n\tif (scheduledDate) {\n\t\t// If date is provided, directly schedule\n\t\ttry {\n\t\t\t// 'scheduled' is not a valid StatusType, use 'publish' or 'draft' as needed\n\t\t\tawait updateStatus(collectionId, entryId, StatusTypes.publish);\n\t\t\tsetCollectionValue({\n\t\t\t\t...collectionValue.value,\n\t\t\t\tstatus: StatusTypes.publish,\n\t\t\t\tscheduledDate: scheduledDate.toISOString()\n\t\t\t});\n\t\t\ttoaster.success({ description: entryMessages.entryScheduled(scheduledDate.toLocaleDateString()) });\n\t\t} catch (e) {\n\t\t\ttoaster.error({ description: entryMessages.errorScheduling((e as Error).message) });\n\t\t}\n\t} else {\n\t\t// Show the schedule modal via helper\n\t\tshowScheduleModal({\n\t\t\tinitialAction: StatusTypes.publish,\n\t\t\tonSchedule: async (date: Date, action: string) => {\n\t\t\t\ttry {\n\t\t\t\t\tawait updateStatus(collectionId, entryId, StatusTypes.publish);\n\t\t\t\t\tsetCollectionValue({\n\t\t\t\t\t\t...collectionValue.value,\n\t\t\t\t\t\tstatus: StatusTypes.publish,\n\t\t\t\t\t\tscheduledDate: date.toISOString(),\n\t\t\t\t\t\tscheduledAction: action\n\t\t\t\t\t});\n\t\t\t\t\ttoaster.success({ description: entryMessages.entryScheduled(date.toLocaleDateString()) });\n\t\t\t\t} catch (e) {\n\t\t\t\t\ttoaster.error({ description: entryMessages.errorScheduling((e as Error).message) });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\n// Clones the currently active entry with improved modal\nexport async function cloneCurrentEntry() {\n\tconst entry = collectionValue.value;\n\tconst coll = collection.value;\n\tif (!entry || !coll?._id) {\n\t\ttoaster.warning({ description: m.clone_entry_no_selection_error() });\n\t\treturn;\n\t}\n\n\tconst collectionId = coll._id as string;\n\n\tshowCloneModal({\n\t\tcount: 1,\n\t\tonConfirm: async () => {\n\t\t\ttry {\n\t\t\t\t// Create a deep copy of the entry with all its data\n\t\t\t\tconst clonedPayload = JSON.parse(JSON.stringify(entry));\n\n\t\t\t\t// Remove unique identifiers and timestamps\n\t\t\t\tdelete clonedPayload._id;\n\t\t\t\tdelete clonedPayload.createdAt;\n\t\t\t\tdelete clonedPayload.updatedAt;\n\n\t\t\t\t// Set clone status and reference to original\n\t\t\t\tclonedPayload.status = StatusTypes.draft;\n\t\t\t\tclonedPayload.clonedFrom = entry._id;\n\n\t\t\t\tlogger.debug('Cloning entry with payload:', clonedPayload);\n\n\t\t\t\tconst result = await createEntry(collectionId, clonedPayload);\n\t\t\t\tif (result.success) {\n\t\t\t\t\ttoaster.success({ description: entryMessages.entryCloned() });\n\t\t\t\t\tinvalidateCollectionCache(collectionId);\n\t\t\t\t\tsetMode('view');\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(result.error || 'Failed to create clone');\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\ttoaster.error({ description: m.clone_entry_error({ error: (e as Error).message }) });\n\t\t\t}\n\t\t}\n\t});\n}\n\n// Auto-draft functionality for unsaved changes\nlet hasUnsavedChanges = false;\n\n// Initialize editing mode\nexport function startEditing() {\n\thasUnsavedChanges = false;\n}\n\n// Mark that changes have been made\nexport function markAsChanged() {\n\thasUnsavedChanges = true;\n}\n\n// Check if there are unsaved changes\nexport function getHasUnsavedChanges(): boolean {\n\treturn hasUnsavedChanges;\n}\n\n// Save current data as draft when user tries to leave\nexport async function saveDraftAndLeave(): Promise<boolean> {\n\tconst entry = collectionValue.value;\n\tconst coll = collection.value;\n\n\tif (!hasUnsavedChanges || !entry || !coll?._id) {\n\t\treturn true; // Allow navigation if no unsaved changes\n\t}\n\n\tconst collectionId = coll._id as string;\n\n\treturn new Promise((resolve) => {\n\t\tshowConfirm({\n\t\t\ttitle: 'Unsaved Changes',\n\t\t\tbody: 'You have unsaved changes. Do you want to save them as a draft before leaving?',\n\t\t\tconfirmText: 'Save as Draft and Leave',\n\t\t\tcancelText: 'Stay and Continue Editing',\n\t\t\tonConfirm: async () => {\n\t\t\t\t// Save as draft and allow navigation\n\t\t\t\ttry {\n\t\t\t\t\tconst draftData = { ...entry };\n\n\t\t\t\t\tif (entry._id) {\n\t\t\t\t\t\t// Update existing entry with draft status\n\t\t\t\t\t\tconst entryId = entry._id as string;\n\t\t\t\t\t\tconst result = await updateEntry(collectionId, entryId, draftData);\n\t\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\t\tthrow new Error(result.error || 'Failed to update entry');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait updateStatus(collectionId, entryId, StatusTypes.draft);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create new entry with draft status\n\t\t\t\t\t\tdraftData.status = StatusTypes.draft;\n\t\t\t\t\t\tconst result = await createEntry(collectionId, draftData);\n\t\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\t\tthrow new Error(result.error || 'Failed to create entry');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttoaster.warning({ description: 'Changes saved as draft.' });\n\n\t\t\t\t\tinvalidateCollectionCache(collectionId);\n\t\t\t\t\thasUnsavedChanges = false;\n\t\t\t\t\tresolve(true); // Allow navigation\n\t\t\t\t} catch (e) {\n\t\t\t\t\ttoaster.error({ description: `Error saving draft: ${(e as Error).message}` });\n\t\t\t\t\tresolve(false); // Prevent navigation due to error\n\t\t\t\t}\n\t\t\t},\n\t\t\tonCancel: () => {\n\t\t\t\t// User chose to stay and continue editing\n\t\t\t\tresolve(false); // Prevent navigation\n\t\t\t}\n\t\t});\n\t});\n}\n\n// Reset the unsaved changes state\nexport function resetUnsavedChanges() {\n\thasUnsavedChanges = false;\n}\n"],"names":["entryMessages","count","m.entries_archived","m.entries_published","m.entries_unpublished","m.entries_set_to_test","m.entries_deleted","m.entries_scheduled","m.entries_cloned","status","m.entries_updated","operation","m.update_failed","m.delete_failed","m.no_entries_selected","m.no_collection_found","m.entry_archived","m.entry_deleted_success","m.entry_saved","m.entry_status_updated","date","m.entry_scheduled","m.entry_cloned_success","m.only_admins_can_delete","m.status_reserved_for_system","m.unsaved_changes_title","m.unsaved_changes_body","m.save_as_draft_and_leave","m.stay_and_continue_editing","m.changes_saved_as_draft","error","m.error_saving_draft","m.no_entry_for_scheduling","m.entry_scheduled_status","m.error_scheduling","m.button_confirm","m.button_cancel","m.button_delete","m.button_archive","m.entrylist_multibutton_publish","m.entrylist_multibutton_unpublish","m.entrylist_multibutton_schedule","m.entrylist_multibutton_clone","m.button_test","updateStatus","collectionId","entryId","result","updateEntryStatus","setEntriesStatus","entryIds","onSuccess","payload","collId","collection","batchUpdateEntries","message","StatusTypes","toaster","cloneEntries","rawEntries","entriesToClone","entry","_id","createdAt","updatedAt","rest","createClones","saveEntry","entryData","publish","updateEntry","createEntry","setCollectionValue","invalidateCollectionCache","deleteCurrentEntry","isAdmin","collectionValue","coll","m.delete_entry_no_selection_error","isArchived","publicEnv","showDeleteConfirmationModal","showAdminChoiceModal","showConfirm","action","isArchive","deleteEntry","setMode","e","m.delete_entry_error","cloneCurrentEntry","m.clone_entry_no_selection_error","showCloneModal","clonedPayload","logger","m.clone_entry_error"],"mappings":"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"}