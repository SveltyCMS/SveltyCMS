{"version":3,"file":"BKIh0tuc.js","sources":["../../../../../../../../shared/paraglide/src/runtime.js"],"sourcesContent":["/* eslint-disable */\n\n/** @type {any} */\nconst URLPattern = {}\n\n/**\n * The project's base locale.\n *\n * @example\n *   if (locale === baseLocale) {\n *     // do something\n *   }\n */\nexport const baseLocale = \"en\";\n/**\n * The project's locales that have been specified in the settings.\n *\n * @example\n *   if (locales.includes(userSelectedLocale) === false) {\n *     throw new Error('Locale is not available');\n *   }\n */\nexport const locales = /** @type {const} */ ([\"en\", \"de\"]);\n/** @type {string} */\nexport const cookieName = \"PARAGLIDE_LOCALE\";\n/** @type {number} */\nexport const cookieMaxAge = 34560000;\n/** @type {string} */\nexport const cookieDomain = \"\";\n/** @type {string} */\nexport const localStorageKey = \"PARAGLIDE_LOCALE\";\n/**\n * @type {Array<\"cookie\" | \"baseLocale\" | \"globalVariable\" | \"url\" | \"preferredLanguage\" | \"localStorage\" | `custom-${string}`>}\n */\nexport const strategy = [\n  \"cookie\",\n  \"globalVariable\",\n  \"baseLocale\"\n];\n/**\n * The used URL patterns.\n *\n * @type {Array<{ pattern: string, localized: Array<[Locale, string]> }> }\n */\nexport const urlPatterns = [\n  {\n    \"pattern\": \":protocol://:domain(.*)::port?/:path(.*)?\",\n    \"localized\": [\n      [\n        \"de\",\n        \":protocol://:domain(.*)::port?/de/:path(.*)?\"\n      ],\n      [\n        \"en\",\n        \":protocol://:domain(.*)::port?/:path(.*)?\"\n      ]\n    ]\n  }\n];\n/**\n * @typedef {{\n * \t\tgetStore(): {\n *   \t\tlocale?: Locale,\n * \t\t\torigin?: string,\n * \t\t\tmessageCalls?: Set<string>\n *   \t} | undefined,\n * \t\trun: (store: { locale?: Locale, origin?: string, messageCalls?: Set<string>},\n *    cb: any) => any\n * }} ParaglideAsyncLocalStorage\n */\n/**\n * Server side async local storage that is set by `serverMiddleware()`.\n *\n * The variable is used to retrieve the locale and origin in a server-side\n * rendering context without effecting other requests.\n *\n * @type {ParaglideAsyncLocalStorage | undefined}\n */\nexport let serverAsyncLocalStorage = undefined;\nexport const disableAsyncLocalStorage = false;\nexport const experimentalMiddlewareLocaleSplitting = false;\nexport const isServer = import.meta.env?.SSR ?? typeof window === 'undefined';\n/** @type {Locale | undefined} */\n// @ts-ignore - injected by bundlers at compile time\nexport const experimentalStaticLocale = undefined;\n/**\n * Sets the server side async local storage.\n *\n * The function is needed because the `runtime.js` file\n * must define the `serverAsyncLocalStorage` variable to\n * avoid a circular import between `runtime.js` and\n * `server.js` files.\n *\n * @param {ParaglideAsyncLocalStorage | undefined} value\n */\nexport function overwriteServerAsyncLocalStorage(value) {\n    serverAsyncLocalStorage = value;\n}\nconst TREE_SHAKE_COOKIE_STRATEGY_USED = true;\nconst TREE_SHAKE_URL_STRATEGY_USED = false;\nconst TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED = true;\nconst TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED = false;\nconst TREE_SHAKE_DEFAULT_URL_PATTERN_USED = true;\nconst TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED = false;\n\nglobalThis.__paraglide = {}\n\n/**\n * This is a fallback to get started with a custom\n * strategy and avoid type errors.\n *\n * The implementation is overwritten\n * by \\`overwriteGetLocale()\\` and \\`defineSetLocale()\\`.\n *\n * @type {Locale|undefined}\n */\nlet _locale;\nlet localeInitiallySet = false;\n/**\n * Get the current locale.\n *\n * The locale is resolved using your configured strategies (URL, cookie, localStorage, etc.)\n * in the order they are defined. In SSR contexts, the locale is retrieved from AsyncLocalStorage\n * which is set by the `paraglideMiddleware()`.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/strategy - Configure locale detection strategies\n *\n * @example\n *   if (getLocale() === 'de') {\n *     console.log('Germany ðŸ‡©ðŸ‡ª');\n *   } else if (getLocale() === 'nl') {\n *     console.log('Netherlands ðŸ‡³ðŸ‡±');\n *   }\n *\n * @type {() => Locale}\n */\nexport let getLocale = () => {\n    if (experimentalStaticLocale !== undefined) {\n        return assertIsLocale(experimentalStaticLocale);\n    }\n    /** @type {string | undefined} */\n    let locale;\n    // if running in a server-side rendering context\n    // retrieve the locale from the async local storage\n    if (serverAsyncLocalStorage) {\n        const locale = serverAsyncLocalStorage?.getStore()?.locale;\n        if (locale) {\n            return locale;\n        }\n    }\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = extractLocaleFromCookie();\n        }\n        else if (strat === \"baseLocale\") {\n            locale = baseLocale;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            !isServer &&\n            typeof window !== \"undefined\") {\n            locale = extractLocaleFromUrl(window.location.href);\n        }\n        else if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\" &&\n            _locale !== undefined) {\n            locale = _locale;\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\" &&\n            !isServer) {\n            locale = extractLocaleFromNavigator();\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            !isServer) {\n            locale = localStorage.getItem(localStorageKey) ?? undefined;\n        }\n        else if (isCustomStrategy(strat) && customClientStrategies.has(strat)) {\n            const handler = customClientStrategies.get(strat);\n            if (handler) {\n                const result = handler.getLocale();\n                // Handle both sync and async results - skip async in sync getLocale\n                if (result instanceof Promise) {\n                    // Can't await in sync function, skip async strategies\n                    continue;\n                }\n                locale = result;\n            }\n        }\n        // check if match, else continue loop\n        if (locale !== undefined) {\n            const asserted = assertIsLocale(locale);\n            if (!localeInitiallySet) {\n                _locale = asserted;\n                // https://github.com/opral/inlang-paraglide-js/issues/455\n                localeInitiallySet = true;\n                setLocale(asserted, { reload: false });\n            }\n            return asserted;\n        }\n    }\n    throw new Error(\"No locale found. Read the docs https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n/**\n * Overwrite the `getLocale()` function.\n *\n * Use this function to overwrite how the locale is resolved. This is useful\n * for custom locale resolution or advanced use cases like SSG with concurrent rendering.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/strategy\n *\n * @example\n *   overwriteGetLocale(() => {\n *     return Cookies.get('locale') ?? baseLocale\n *   });\n *\n * @type {(fn: () => Locale) => void}\n */\nexport const overwriteGetLocale = (fn) => {\n    getLocale = fn;\n};\n\n/**\n * Navigates to the localized URL, or reloads the current page\n *\n * @param {string} [newLocation] The new location\n * @return {undefined}\n */\nconst navigateOrReload = (newLocation) => {\n    if (newLocation) {\n        // reload the page by navigating to the new url\n        window.location.href = newLocation;\n    }\n    else {\n        // reload the page to reflect the new locale\n        window.location.reload();\n    }\n};\n/**\n * @typedef {(newLocale: Locale, options?: { reload?: boolean }) => void | Promise<void>} SetLocaleFn\n */\n/**\n * Set the locale.\n *\n * Updates the locale using your configured strategies (cookie, localStorage, URL, etc.).\n * By default, this reloads the page on the client to reflect the new locale. Reloading\n * can be disabled by passing `reload: false` as an option, but you'll need to ensure\n * the UI updates to reflect the new locale.\n *\n * If any custom strategy's `setLocale` function is async, then this function\n * will become async as well.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/strategy\n *\n * @example\n *   setLocale('en');\n *\n * @example\n *   setLocale('en', { reload: false });\n *\n * @type {SetLocaleFn}\n */\nexport let setLocale = (newLocale, options) => {\n    const optionsWithDefaults = {\n        reload: true,\n        ...options,\n    };\n    // locale is already set\n    // https://github.com/opral/inlang-paraglide-js/issues/430\n    /** @type {Locale | undefined} */\n    let currentLocale;\n    try {\n        currentLocale = getLocale();\n    }\n    catch {\n        // do nothing, no locale has been set yet.\n    }\n    /** @type {Array<Promise<any>>} */\n    const customSetLocalePromises = [];\n    /** @type {string | undefined} */\n    let newLocation = undefined;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\") {\n            // a default for a custom strategy to get started quickly\n            // is likely overwritten by `defineSetLocale()`\n            _locale = newLocale;\n        }\n        else if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            if (isServer ||\n                typeof document === \"undefined\" ||\n                typeof window === \"undefined\") {\n                continue;\n            }\n            // set the cookie\n            const cookieString = `${cookieName}=${newLocale}; path=/; max-age=${cookieMaxAge}`;\n            document.cookie = cookieDomain\n                ? `${cookieString}; domain=${cookieDomain}`\n                : cookieString;\n        }\n        else if (strat === \"baseLocale\") {\n            // nothing to be set here. baseLocale is only a fallback\n            continue;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            typeof window !== \"undefined\") {\n            // route to the new url\n            //\n            // this triggers a page reload but a user rarely\n            // switches locales, so this should be fine.\n            //\n            // if the behavior is not desired, the implementation\n            // can be overwritten by `defineSetLocale()` to avoid\n            // a full page reload.\n            newLocation = localizeUrl(window.location.href, {\n                locale: newLocale,\n            }).href;\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            typeof window !== \"undefined\") {\n            // set the localStorage\n            localStorage.setItem(localStorageKey, newLocale);\n        }\n        else if (isCustomStrategy(strat) && customClientStrategies.has(strat)) {\n            const handler = customClientStrategies.get(strat);\n            if (handler) {\n                let result = handler.setLocale(newLocale);\n                // Handle async setLocale\n                if (result instanceof Promise) {\n                    result = result.catch((error) => {\n                        throw new Error(`Custom strategy \"${strat}\" setLocale failed.`, {\n                            cause: error,\n                        });\n                    });\n                    customSetLocalePromises.push(result);\n                }\n            }\n        }\n    }\n    const runReload = () => {\n        if (!isServer &&\n            optionsWithDefaults.reload &&\n            window.location &&\n            newLocale !== currentLocale) {\n            navigateOrReload(newLocation);\n        }\n    };\n    if (customSetLocalePromises.length) {\n        return Promise.all(customSetLocalePromises).then(() => {\n            runReload();\n        });\n    }\n    runReload();\n    return;\n};\n/**\n * Overwrite the \\`setLocale()\\` function.\n *\n * Use this function to overwrite how the locale is set. For example,\n * modify a cookie, env variable, or a user's preference.\n *\n * @example\n *   overwriteSetLocale((newLocale) => {\n *     // set the locale in a cookie\n *     return Cookies.set('locale', newLocale)\n *   });\n *\n * @param {SetLocaleFn} fn\n */\nexport const overwriteSetLocale = (fn) => {\n    setLocale = /** @type {SetLocaleFn} */ (fn);\n};\n\n/**\n * The origin of the current URL.\n *\n * Defaults to \"http://y.com\" in non-browser environments. If this\n * behavior is not desired, the implementation can be overwritten\n * by `overwriteGetUrlOrigin()`.\n *\n * @type {() => string}\n */\nexport let getUrlOrigin = () => {\n    if (serverAsyncLocalStorage) {\n        return serverAsyncLocalStorage.getStore()?.origin ?? \"http://fallback.com\";\n    }\n    else if (typeof window !== \"undefined\") {\n        return window.location.origin;\n    }\n    return \"http://fallback.com\";\n};\n/**\n * Overwrite the getUrlOrigin function.\n *\n * Use this function in server environments to\n * define how the URL origin is resolved.\n *\n * @type {(fn: () => string) => void}\n */\nexport let overwriteGetUrlOrigin = (fn) => {\n    getUrlOrigin = fn;\n};\n\n/**\n * Check if something is an available locale.\n *\n * @example\n *   if (isLocale(params.locale)) {\n *     setLocale(params.locale);\n *   } else {\n *     setLocale('en');\n *   }\n *\n * @param {any} locale\n * @returns {locale is Locale}\n */\nexport function isLocale(locale) {\n    if (typeof locale !== \"string\")\n        return false;\n    return !locale\n        ? false\n        : locales.some((item) => item.toLowerCase() === locale.toLowerCase());\n}\n\n/**\n * Asserts that the input is a locale.\n *\n * @param {any} input - The input to check.\n * @returns {Locale} The input if it is a locale.\n * @throws {Error} If the input is not a locale.\n */\nexport function assertIsLocale(input) {\n    if (typeof input !== \"string\") {\n        throw new Error(`Invalid locale: ${input}. Expected a string.`);\n    }\n    const lowerInput = input.toLowerCase();\n    const matchedLocale = locales.find((item) => item.toLowerCase() === lowerInput);\n    if (!matchedLocale) {\n        throw new Error(`Invalid locale: ${input}. Expected one of: ${locales.join(\", \")}`);\n    }\n    return matchedLocale;\n}\n\n/**\n * Extracts a locale from a request.\n *\n * Use the function on the server to extract the locale\n * from a request.\n *\n * The function goes through the strategies in the order\n * they are defined. If a strategy returns an invalid locale,\n * it will fall back to the next strategy.\n *\n * Note: Custom server strategies are not supported in this synchronous version.\n * Use `extractLocaleFromRequestAsync` if you need custom server strategies with async getLocale methods.\n *\n * @example\n *   const locale = extractLocaleFromRequest(request);\n *\n * @type {(request: Request) => Locale}\n */\nexport const extractLocaleFromRequest = (request) => {\n    /** @type {string|undefined} */\n    let locale;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = request.headers\n                .get(\"cookie\")\n                ?.split(\"; \")\n                .find((c) => c.startsWith(cookieName + \"=\"))\n                ?.split(\"=\")[1];\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED && strat === \"url\") {\n            locale = extractLocaleFromUrl(request.url);\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\") {\n            locale = extractLocaleFromHeader(request);\n        }\n        else if (strat === \"globalVariable\") {\n            locale = _locale;\n        }\n        else if (strat === \"baseLocale\") {\n            return baseLocale;\n        }\n        else if (strat === \"localStorage\") {\n            continue;\n        }\n        else if (isCustomStrategy(strat)) {\n            // Custom strategies are not supported in sync version\n            // Use extractLocaleFromRequestAsync for custom server strategies\n            continue;\n        }\n        if (locale !== undefined) {\n            if (!isLocale(locale)) {\n                locale = undefined;\n            }\n            else {\n                return assertIsLocale(locale);\n            }\n        }\n    }\n    throw new Error(\"No locale found. There is an error in your strategy. Try adding 'baseLocale' as the very last strategy. Read more here https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n\n/**\n * Asynchronously extracts a locale from a request.\n *\n * This function supports async custom server strategies, unlike the synchronous\n * `extractLocaleFromRequest`. Use this function when you have custom server strategies\n * that need to perform asynchronous operations (like database calls) in their getLocale method.\n *\n * The function first processes any custom server strategies asynchronously, then falls back\n * to the synchronous `extractLocaleFromRequest` for all other strategies.\n *\n * @see {@link https://github.com/opral/inlang-paraglide-js/issues/527#issuecomment-2978151022}\n *\n * @example\n *   // Basic usage\n *   const locale = await extractLocaleFromRequestAsync(request);\n *\n * @example\n *   // With custom async server strategy\n *   defineCustomServerStrategy(\"custom-database\", {\n *     getLocale: async (request) => {\n *       const userId = extractUserIdFromRequest(request);\n *       return await getUserLocaleFromDatabase(userId);\n *     }\n *   });\n *\n *   const locale = await extractLocaleFromRequestAsync(request);\n *\n * @type {(request: Request) => Promise<Locale>}\n */\nexport const extractLocaleFromRequestAsync = async (request) => {\n    /** @type {string|undefined} */\n    let locale;\n    // Process custom strategies first, in order\n    for (const strat of strategy) {\n        if (isCustomStrategy(strat) && customServerStrategies.has(strat)) {\n            const handler = customServerStrategies.get(strat);\n            if (handler) {\n                /** @type {string|undefined} */\n                locale = await handler.getLocale(request);\n            }\n            // If we got a valid locale from this custom strategy, use it\n            if (locale !== undefined && isLocale(locale)) {\n                return assertIsLocale(locale);\n            }\n        }\n    }\n    // If no custom strategy provided a valid locale, fall back to sync version\n    locale = extractLocaleFromRequest(request);\n    return assertIsLocale(locale);\n};\n\n/**\n * Extracts a cookie from the document.\n *\n * Will return undefined if the document is not available or if the cookie is not set.\n * The `document` object is not available in server-side rendering, so this function should not be called in that context.\n *\n * @returns {string | undefined}\n */\nexport function extractLocaleFromCookie() {\n    if (typeof document === \"undefined\" || !document.cookie) {\n        return;\n    }\n    const match = document.cookie.match(new RegExp(`(^| )${cookieName}=([^;]+)`));\n    const locale = match?.[2];\n    if (isLocale(locale)) {\n        return locale;\n    }\n    return undefined;\n}\n\n/**\n * Extracts a locale from the accept-language header.\n *\n * Use the function on the server to extract the locale\n * from the accept-language header that is sent by the client.\n *\n * @example\n *   const locale = extractLocaleFromHeader(request);\n *\n * @type {(request: Request) => Locale}\n * @param {Request} request - The request object to extract the locale from.\n * @returns {string|undefined} The negotiated preferred language.\n */\nexport function extractLocaleFromHeader(request) {\n    const acceptLanguageHeader = request.headers.get(\"accept-language\");\n    if (acceptLanguageHeader) {\n        // Parse language preferences with their q-values and base language codes\n        const languages = acceptLanguageHeader\n            .split(\",\")\n            .map((lang) => {\n            const [tag, q = \"1\"] = lang.trim().split(\";q=\");\n            // Get both the full tag and base language code\n            const baseTag = tag?.split(\"-\")[0]?.toLowerCase();\n            return {\n                fullTag: tag?.toLowerCase(),\n                baseTag,\n                q: Number(q),\n            };\n        })\n            .sort((a, b) => b.q - a.q);\n        for (const lang of languages) {\n            if (isLocale(lang.fullTag)) {\n                return lang.fullTag;\n            }\n            else if (isLocale(lang.baseTag)) {\n                return lang.baseTag;\n            }\n        }\n        return undefined;\n    }\n    return undefined;\n}\n\n/**\n * Negotiates a preferred language from navigator.languages.\n *\n * Use the function on the client to extract the locale\n * from the navigator.languages array.\n *\n * @example\n *   const locale = extractLocaleFromNavigator();\n *\n * @type {() => Locale | undefined}\n * @returns {string | undefined}\n */\nexport function extractLocaleFromNavigator() {\n    if (!navigator?.languages?.length) {\n        return undefined;\n    }\n    const languages = navigator.languages.map((lang) => ({\n        fullTag: lang.toLowerCase(),\n        baseTag: lang.split(\"-\")[0]?.toLowerCase(),\n    }));\n    for (const lang of languages) {\n        if (isLocale(lang.fullTag)) {\n            return lang.fullTag;\n        }\n        else if (isLocale(lang.baseTag)) {\n            return lang.baseTag;\n        }\n    }\n    return undefined;\n}\n\n/**\n * If extractLocaleFromUrl is called many times on the same page and the URL\n * hasn't changed, we don't need to recompute it every time which can get expensive.\n * We might use a LRU cache if needed, but for now storing only the last result is enough.\n * https://github.com/opral/monorepo/pull/3575#discussion_r2066731243\n */\n/** @type {string|undefined} */\nlet cachedUrl;\n/** @type {Locale|undefined} */\nlet cachedLocale;\n/**\n * Extracts the locale from a given URL using native URLPattern.\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nexport function extractLocaleFromUrl(url) {\n    const urlString = typeof url === \"string\" ? url : url.href;\n    if (cachedUrl === urlString) {\n        return cachedLocale;\n    }\n    let result;\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        result = defaultUrlPatternExtractLocale(url);\n    }\n    else {\n        const urlObj = typeof url === \"string\" ? new URL(url) : url;\n        // Iterate over URL patterns\n        for (const element of urlPatterns) {\n            for (const [locale, localizedPattern] of element.localized) {\n                const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n                if (!match) {\n                    continue;\n                }\n                // Check if the locale is valid\n                if (assertIsLocale(locale)) {\n                    result = locale;\n                    break;\n                }\n            }\n            if (result)\n                break;\n        }\n    }\n    cachedUrl = urlString;\n    cachedLocale = result;\n    return result;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nfunction defaultUrlPatternExtractLocale(url) {\n    const urlObj = new URL(url, \"http://dummy.com\");\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    if (pathSegments.length > 0) {\n        const potentialLocale = pathSegments[0];\n        if (isLocale(potentialLocale)) {\n            return potentialLocale;\n        }\n    }\n    // everything else has to be the base locale\n    return baseLocale;\n}\n\n/**\n * Lower-level URL localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `localizeHref()` instead, which provides\n * a more convenient API with relative paths and automatic locale detection.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/i18n-routing\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const localized = localizeUrl(url, { locale: \"de\" });\n *\n *   if (localized.href !== url.href) {\n *     return res.redirect(localized.href);\n *   }\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/about\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://example.com/de/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://example.com/store\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://de.example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to localize. If string, must be absolute.\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses getLocale()\n * @returns {URL} The localized URL, always absolute\n */\nexport function localizeUrl(url, options) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return localizeUrlDefaultPattern(url, options);\n    }\n    const targetLocale = options?.locale ?? getLocale();\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // match localized patterns\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (!match) {\n                continue;\n            }\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (!targetPattern) {\n                continue;\n            }\n            const localizedUrl = fillPattern(targetPattern, aggregateGroups(match), urlObj.origin);\n            return fillMissingUrlParts(localizedUrl, match);\n        }\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (targetPattern) {\n                const localizedUrl = fillPattern(targetPattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n                return fillMissingUrlParts(localizedUrl, unlocalizedMatch);\n            }\n        }\n    }\n    // If no match found, return the original URL\n    return urlObj;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {string | URL} url\n * @param {Object} [options]\n * @param {string} [options.locale]\n * @returns {URL}\n */\nfunction localizeUrlDefaultPattern(url, options) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const locale = options?.locale ?? getLocale();\n    const currentLocale = extractLocaleFromUrl(urlObj);\n    // If current locale matches target locale, no change needed\n    if (currentLocale === locale) {\n        return urlObj;\n    }\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If current path starts with a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        pathSegments.shift();\n    }\n    // For base locale, don't add prefix\n    if (locale === baseLocale) {\n        urlObj.pathname = \"/\" + pathSegments.join(\"/\");\n    }\n    else {\n        // For other locales, add prefix\n        urlObj.pathname = \"/\" + locale + \"/\" + pathSegments.join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Low-level URL de-localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL de-localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `deLocalizeHref()` instead, which provides\n * a more convenient API with relative paths.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/i18n-routing\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const baseUrl = deLocalizeUrl(url);\n *\n *   // Store the base URL for later use\n *   req.baseUrl = baseUrl;\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/de/about\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://de.example.com/store\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to de-localize. If string, must be absolute.\n * @returns {URL} The de-localized URL, always absolute\n */\nexport function deLocalizeUrl(url) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return deLocalizeUrlDefaultPattern(url);\n    }\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // Iterate over localized versions\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (match) {\n                // Convert localized URL back to the base pattern\n                const groups = aggregateGroups(match);\n                const baseUrl = fillPattern(element.pattern, groups, urlObj.origin);\n                return fillMissingUrlParts(baseUrl, match);\n            }\n        }\n        // match unlocalized pattern\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const baseUrl = fillPattern(element.pattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n            return fillMissingUrlParts(baseUrl, unlocalizedMatch);\n        }\n    }\n    // no match found return the original url\n    return urlObj;\n}\n/**\n * De-localizes a URL using the default pattern (/:locale/*)\n * @param {string|URL} url\n * @returns {URL}\n */\nfunction deLocalizeUrlDefaultPattern(url) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If first segment is a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        urlObj.pathname = \"/\" + pathSegments.slice(1).join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Takes matches of implicit wildcards in the UrlPattern (when a part is missing\n * it is equal to '*') and adds them back to the result of fillPattern.\n *\n * At least protocol and hostname are required to create a valid URL inside fillPattern.\n *\n * @param {URL} url\n * @param {any} match\n * @returns {URL}\n */\nfunction fillMissingUrlParts(url, match) {\n    if (match.protocol.groups[\"0\"]) {\n        url.protocol = match.protocol.groups[\"0\"] ?? \"\";\n    }\n    if (match.hostname.groups[\"0\"]) {\n        url.hostname = match.hostname.groups[\"0\"] ?? \"\";\n    }\n    if (match.username.groups[\"0\"]) {\n        url.username = match.username.groups[\"0\"] ?? \"\";\n    }\n    if (match.password.groups[\"0\"]) {\n        url.password = match.password.groups[\"0\"] ?? \"\";\n    }\n    if (match.port.groups[\"0\"]) {\n        url.port = match.port.groups[\"0\"] ?? \"\";\n    }\n    if (match.pathname.groups[\"0\"]) {\n        url.pathname = match.pathname.groups[\"0\"] ?? \"\";\n    }\n    if (match.search.groups[\"0\"]) {\n        url.search = match.search.groups[\"0\"] ?? \"\";\n    }\n    if (match.hash.groups[\"0\"]) {\n        url.hash = match.hash.groups[\"0\"] ?? \"\";\n    }\n    return url;\n}\n/**\n * Fills a URL pattern with values for named groups, supporting all URLPattern-style modifiers.\n *\n * This function will eventually be replaced by https://github.com/whatwg/urlpattern/issues/73\n *\n * Matches:\n * - :name        -> Simple\n * - :name?       -> Optional\n * - :name+       -> One or more\n * - :name*       -> Zero or more\n * - :name(...)   -> Regex group\n * - {text}       -> Group delimiter\n * - {text}?      -> Optional group delimiter\n *\n * If the value is `null`, the segment is removed.\n *\n * @param {string} pattern - The URL pattern containing named groups.\n * @param {Record<string, string | null | undefined>} values - Object of values for named groups.\n * @param {string} origin - Base URL to use for URL construction.\n * @returns {URL} - The constructed URL with named groups filled.\n */\nfunction fillPattern(pattern, values, origin) {\n    // Pre-process the pattern to handle explicit port numbers\n    // This detects patterns like \"http://localhost:5173\" and protects the port number\n    // from being interpreted as a parameter\n    let processedPattern = pattern.replace(/(https?:\\/\\/[^:/]+):(\\d+)(\\/|$)/g, (_, protocol, port, slash) => {\n        // Replace \":5173\" with \"#PORT-5173#\" to protect it from parameter replacement\n        return `${protocol}#PORT-${port}#${slash}`;\n    });\n    // First, handle group delimiters with curly braces\n    let processedGroupDelimiters = processedPattern.replace(/\\{([^{}]*)\\}([?+*]?)/g, (_, content, modifier) => {\n        // For optional group delimiters\n        if (modifier === \"?\") {\n            // For optional groups, we'll include the content\n            return content;\n        }\n        // For non-optional group delimiters, always include the content\n        return content;\n    });\n    // Then handle named groups\n    let filled = processedGroupDelimiters.replace(/(\\/?):([a-zA-Z0-9_]+)(\\([^)]*\\))?([?+*]?)/g, (_, slash, name, __, modifier) => {\n        const value = values[name];\n        if (value === null) {\n            // If value is null, remove the entire segment including the preceding slash\n            return \"\";\n        }\n        if (modifier === \"?\") {\n            // Optional segment\n            return value !== undefined ? `${slash}${value}` : \"\";\n        }\n        if (modifier === \"+\" || modifier === \"*\") {\n            // Repeatable segments\n            if (value === undefined && modifier === \"+\") {\n                throw new Error(`Missing value for \"${name}\" (one or more required)`);\n            }\n            return value ? `${slash}${value}` : \"\";\n        }\n        // Simple named group (no modifier)\n        if (value === undefined) {\n            throw new Error(`Missing value for \"${name}\"`);\n        }\n        return `${slash}${value}`;\n    });\n    // Restore port numbers\n    filled = filled.replace(/#PORT-(\\d+)#/g, \":$1\");\n    return new URL(filled, origin);\n}\n/**\n * Aggregates named groups from various parts of the URLPattern match result.\n *\n *\n * @type {(match: any) => Record<string, string | null | undefined>}\n */\nexport function aggregateGroups(match) {\n    return {\n        ...match.hash.groups,\n        ...match.hostname.groups,\n        ...match.password.groups,\n        ...match.pathname.groups,\n        ...match.port.groups,\n        ...match.protocol.groups,\n        ...match.search.groups,\n        ...match.username.groups,\n    };\n}\n\n/**\n * @typedef {object} ShouldRedirectServerInput\n * @property {Request} request\n * @property {string | URL} [url]\n * @property {ReturnType<typeof assertIsLocale>} [locale]\n *\n * @typedef {object} ShouldRedirectClientInput\n * @property {undefined} [request]\n * @property {string | URL} [url]\n * @property {ReturnType<typeof assertIsLocale>} [locale]\n *\n * @typedef {ShouldRedirectServerInput | ShouldRedirectClientInput} ShouldRedirectInput\n *\n * @typedef {object} ShouldRedirectResult\n * @property {boolean} shouldRedirect - Indicates whether the consumer should perform a redirect.\n * @property {ReturnType<typeof assertIsLocale>} locale - Locale resolved using the configured strategies.\n * @property {URL | undefined} redirectUrl - Destination URL when a redirect is required.\n */\n/**\n * Determines whether a redirect is required to align the current URL with the active locale.\n *\n * This helper mirrors the logic that powers `paraglideMiddleware`, but works in both server\n * and client environments. It evaluates the configured strategies in order, computes the\n * canonical localized URL, and reports when the current URL does not match.\n *\n * When called in the browser without arguments, the current `window.location.href` is used.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/i18n-routing#client-side-redirects\n *\n * @example\n * // Client side usage (e.g. TanStack Router beforeLoad hook)\n * async function beforeLoad({ location }) {\n *   const decision = await shouldRedirect({ url: location.href });\n *\n *   if (decision.shouldRedirect) {\n *     throw redirect({ to: decision.redirectUrl.href });\n *   }\n * }\n *\n * @example\n * // Server side usage with a Request\n * export async function handle(request) {\n *   const decision = await shouldRedirect({ request });\n *\n *   if (decision.shouldRedirect) {\n *     return Response.redirect(decision.redirectUrl, 307);\n *   }\n *\n *   return render(request, decision.locale);\n * }\n *\n * @param {ShouldRedirectInput} [input]\n * @returns {Promise<ShouldRedirectResult>}\n */\nexport async function shouldRedirect(input = {}) {\n    const locale = /** @type {ReturnType<typeof assertIsLocale>} */ (await resolveLocale(input));\n    if (!strategy.includes(\"url\")) {\n        return { shouldRedirect: false, locale, redirectUrl: undefined };\n    }\n    const currentUrl = resolveUrl(input);\n    const localizedUrl = localizeUrl(currentUrl.href, { locale });\n    const shouldRedirectToLocalizedUrl = normalizeUrl(localizedUrl.href) !== normalizeUrl(currentUrl.href);\n    return {\n        shouldRedirect: shouldRedirectToLocalizedUrl,\n        locale,\n        redirectUrl: shouldRedirectToLocalizedUrl ? localizedUrl : undefined,\n    };\n}\n/**\n * Resolves the locale either from the provided input or by using the configured strategies.\n *\n * @param {ShouldRedirectInput} input\n * @returns {Promise<ReturnType<typeof assertIsLocale>>}\n */\nasync function resolveLocale(input) {\n    if (input.locale) {\n        return assertIsLocale(input.locale);\n    }\n    if (input.request) {\n        return extractLocaleFromRequestAsync(input.request);\n    }\n    return getLocale();\n}\n/**\n * Resolves the current URL from the provided input or runtime context.\n *\n * @param {ShouldRedirectInput} input\n * @returns {URL}\n */\nfunction resolveUrl(input) {\n    if (input.request) {\n        return new URL(input.request.url);\n    }\n    if (input.url instanceof URL) {\n        return new URL(input.url.href);\n    }\n    if (typeof input.url === \"string\") {\n        return new URL(input.url, getUrlOrigin());\n    }\n    if (typeof window !== \"undefined\" && window?.location?.href) {\n        return new URL(window.location.href);\n    }\n    throw new Error(\"shouldRedirect() requires either a request, an absolute URL, or must run in a browser environment.\");\n}\n/**\n * Normalize url for comparison by stripping the trailing slash.\n *\n * @param {string} url\n * @returns {string}\n */\nfunction normalizeUrl(url) {\n    const urlObj = new URL(url);\n    urlObj.pathname = urlObj.pathname.replace(/\\/$/, \"\");\n    return urlObj.href;\n}\n\n/**\n * High-level URL localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `localizeUrl()` that provides features\n * needed in UI:\n *\n * - Accepts relative paths (e.g., \"/about\")\n * - Returns relative paths when possible\n * - Automatically detects current locale if not specified\n * - Handles string input/output instead of URL objects\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/i18n-routing\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const NavLink = ({ href }) => {\n *   // Automatically uses current locale, keeps path relative\n *   return <a href={localizeHref(href)}>...</a>;\n * };\n *\n * // Examples:\n * localizeHref(\"/about\")\n * // => \"/de/about\" (if current locale is \"de\")\n * localizeHref(\"/store\", { locale: \"fr\" })\n * // => \"/fr/store\" (explicit locale)\n *\n * // Cross-origin links remain absolute\n * localizeHref(\"https://other-site.com/about\")\n * // => \"https://other-site.com/de/about\"\n * ```\n *\n * For server-side URL localization (e.g., in middleware), use `localizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to localize (can be relative or absolute)\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses `getLocale()`\n * @returns {string} The localized href, relative if input was relative\n */\nexport function localizeHref(href, options) {\n    const currentLocale = getLocale();\n    const locale = options?.locale ?? currentLocale;\n    const url = new URL(href, getUrlOrigin());\n    const localized = localizeUrl(url, { locale });\n    // if the origin is identical and the href is relative,\n    // return the relative path\n    if (href.startsWith(\"/\") && url.origin === localized.origin) {\n        // check for cross origin localization in which case an absolute URL must be returned.\n        if (locale !== currentLocale) {\n            const localizedCurrentLocale = localizeUrl(url, {\n                locale: currentLocale,\n            });\n            if (localizedCurrentLocale.origin !== localized.origin) {\n                return localized.href;\n            }\n        }\n        return localized.pathname + localized.search + localized.hash;\n    }\n    return localized.href;\n}\n/**\n * High-level URL de-localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `deLocalizeUrl()` that provides features\n * needed in the UI:\n *\n * - Accepts relative paths (e.g., \"/de/about\")\n * - Returns relative paths when possible\n * - Handles string input/output instead of URL objects\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/i18n-routing\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const LocaleSwitcher = ({ href }) => {\n *   // Remove locale prefix before switching\n *   const baseHref = deLocalizeHref(href);\n *   return locales.map(locale =>\n *     <a href={localizeHref(baseHref, { locale })}>\n *       Switch to {locale}\n *     </a>\n *   );\n * };\n *\n * // Examples:\n * deLocalizeHref(\"/de/about\")  // => \"/about\"\n * deLocalizeHref(\"/fr/store\")  // => \"/store\"\n *\n * // Cross-origin links remain absolute\n * deLocalizeHref(\"https://example.com/de/about\")\n * // => \"https://example.com/about\"\n * ```\n *\n * For server-side URL de-localization (e.g., in middleware), use `deLocalizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to de-localize (can be relative or absolute)\n * @returns {string} The de-localized href, relative if input was relative\n */\nexport function deLocalizeHref(href) {\n    const url = new URL(href, getUrlOrigin());\n    const deLocalized = deLocalizeUrl(url);\n    // If the origin is identical and the href is relative,\n    // return the relative path instead of the full URL.\n    if (href.startsWith(\"/\") && url.origin === deLocalized.origin) {\n        return deLocalized.pathname + deLocalized.search + deLocalized.hash;\n    }\n    return deLocalized.href;\n}\n\n/**\n * @param {string} safeModuleId\n * @param {Locale} locale\n */\nexport function trackMessageCall(safeModuleId, locale) {\n    if (isServer === false)\n        return;\n    const store = serverAsyncLocalStorage?.getStore();\n    if (store) {\n        store.messageCalls?.add(`${safeModuleId}:${locale}`);\n    }\n}\n\n/**\n * Generates localized URL variants for all provided URLs based on your configured locales and URL patterns.\n *\n * This function is essential for Static Site Generation (SSG) where you need to tell your framework\n * which pages to pre-render at build time. It's also useful for generating sitemaps and\n * `<link rel=\"alternate\" hreflang>` tags for SEO.\n *\n * The function respects your `urlPatterns` configuration - if you have translated pathnames\n * (e.g., `/about` â†’ `/ueber-uns` for German), it will generate the correct localized paths.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/static-site-generation\n *\n * @example\n * // Basic usage - generate all locale variants for a list of paths\n * const localizedUrls = generateStaticLocalizedUrls([\n *   \"/\",\n *   \"/about\",\n *   \"/blog/post-1\",\n * ]);\n * // Returns URL objects for each locale:\n * // [\"/en/\", \"/de/\", \"/en/about\", \"/de/about\", \"/en/blog/post-1\", \"/de/blog/post-1\"]\n *\n * @example\n * // Use with framework SSG APIs\n * // SvelteKit\n * export function entries() {\n *   const paths = [\"/\", \"/about\", \"/contact\"];\n *   return generateStaticLocalizedUrls(paths).map(url => ({\n *     locale: extractLocaleFromUrl(url)\n *   }));\n * }\n *\n * @example\n * // Sitemap generation\n * const allPages = [\"/\", \"/about\", \"/blog\"];\n * const sitemapUrls = generateStaticLocalizedUrls(allPages);\n *\n * @param {(string | URL)[]} urls - List of canonical URLs or paths to generate localized versions for.\n *   Can be absolute URLs (`https://example.com/about`) or paths (`/about`).\n *   Paths are resolved against `http://localhost` internally.\n * @returns {URL[]} Array of URL objects representing all localized variants.\n *   The order follows each input URL with all its locale variants before moving to the next URL.\n */\nexport function generateStaticLocalizedUrls(urls) {\n    const localizedUrls = new Set();\n    // For default URL pattern, we can optimize the generation\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        for (const urlInput of urls) {\n            const url = urlInput instanceof URL\n                ? urlInput\n                : new URL(urlInput, \"http://localhost\");\n            // Base locale doesn't get a prefix\n            localizedUrls.add(url);\n            // Other locales get their code as prefix\n            for (const locale of locales) {\n                if (locale !== baseLocale) {\n                    const localizedPath = `/${locale}${url.pathname}${url.search}${url.hash}`;\n                    const localizedUrl = new URL(localizedPath, url.origin);\n                    localizedUrls.add(localizedUrl);\n                }\n            }\n        }\n        return Array.from(localizedUrls);\n    }\n    // For custom URL patterns, we need to use localizeUrl for each URL and locale\n    for (const urlInput of urls) {\n        const url = urlInput instanceof URL\n            ? urlInput\n            : new URL(urlInput, \"http://localhost\");\n        // Try each URL pattern to find one that matches\n        let patternFound = false;\n        for (const pattern of urlPatterns) {\n            try {\n                // Try to match the unlocalized pattern\n                const unlocalizedMatch = new URLPattern(pattern.pattern, url.href).exec(url.href);\n                if (!unlocalizedMatch)\n                    continue;\n                patternFound = true;\n                // Track unique localized URLs to avoid duplicates when patterns are the same\n                const seenUrls = new Set();\n                // Generate localized URL for each locale\n                for (const [locale] of pattern.localized) {\n                    try {\n                        const localizedUrl = localizeUrl(url, { locale });\n                        const urlString = localizedUrl.href;\n                        // Only add if we haven't seen this exact URL before\n                        if (!seenUrls.has(urlString)) {\n                            seenUrls.add(urlString);\n                            localizedUrls.add(localizedUrl);\n                        }\n                    }\n                    catch {\n                        // Skip if localization fails for this locale\n                        continue;\n                    }\n                }\n                break;\n            }\n            catch {\n                // Skip if pattern matching fails\n                continue;\n            }\n        }\n        // If no pattern matched, use the URL as is\n        if (!patternFound) {\n            localizedUrls.add(url);\n        }\n    }\n    return Array.from(localizedUrls);\n}\n\n/**\n * @typedef {\"cookie\" | \"baseLocale\" | \"globalVariable\" | \"url\" | \"preferredLanguage\" | \"localStorage\"} BuiltInStrategy\n */\n/**\n * @typedef {`custom_${string}`} CustomStrategy\n */\n/**\n * @typedef {BuiltInStrategy | CustomStrategy} Strategy\n */\n/**\n * @typedef {Array<Strategy>} Strategies\n */\n/**\n * @typedef {{ getLocale: (request?: Request) => Promise<string | undefined> | (string | undefined) }} CustomServerStrategyHandler\n */\n/**\n * @typedef {{ getLocale: () => Promise<string|undefined> | (string | undefined), setLocale: (locale: string) => Promise<void> | void }} CustomClientStrategyHandler\n */\n/** @type {Map<string, CustomServerStrategyHandler>} */\nexport const customServerStrategies = new Map();\n/** @type {Map<string, CustomClientStrategyHandler>} */\nexport const customClientStrategies = new Map();\n/**\n * Checks if the given strategy is a custom strategy.\n *\n * @param {any} strategy The name of the custom strategy to validate.\n * Must be a string that starts with \"custom-\" followed by alphanumeric characters, hyphens, or underscores.\n * @returns {boolean} Returns true if it is a custom strategy, false otherwise.\n */\nexport function isCustomStrategy(strategy) {\n    return (typeof strategy === \"string\" && /^custom-[A-Za-z0-9_-]+$/.test(strategy));\n}\n/**\n * Defines a custom strategy that is executed on the server.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/strategy#write-your-own-strategy\n *\n * @param {any} strategy The name of the custom strategy to define. Must follow the pattern custom-name with alphanumeric characters, hyphens, or underscores.\n * @param {CustomServerStrategyHandler} handler The handler for the custom strategy, which should implement\n * the method getLocale.\n * @returns {void}\n */\nexport function defineCustomServerStrategy(strategy, handler) {\n    if (!isCustomStrategy(strategy)) {\n        throw new Error(`Invalid custom strategy: \"${strategy}\". Must be a custom strategy following the pattern custom-name.`);\n    }\n    customServerStrategies.set(strategy, handler);\n}\n/**\n * Defines a custom strategy that is executed on the client.\n *\n * @see https://inlang.com/m/gerre34r/library-inlang-paraglideJs/strategy#write-your-own-strategy\n *\n * @param {any} strategy The name of the custom strategy to define. Must follow the pattern custom-name with alphanumeric characters, hyphens, or underscores.\n * @param {CustomClientStrategyHandler} handler The handler for the custom strategy, which should implement the\n * methods getLocale and setLocale.\n * @returns {void}\n */\nexport function defineCustomClientStrategy(strategy, handler) {\n    if (!isCustomStrategy(strategy)) {\n        throw new Error(`Invalid custom strategy: \"${strategy}\". Must be a custom strategy following the pattern custom-name.`);\n    }\n    customClientStrategies.set(strategy, handler);\n}\n\n// ------ TYPES ------\n\n/**\n * A locale that is available in the project.\n *\n * @example\n *   setLocale(request.locale as Locale)\n *\n * @typedef {(typeof locales)[number]} Locale\n */\n\n/**\n * A branded type representing a localized string.\n *\n * Message functions return this type instead of `string`, enabling TypeScript\n * to distinguish translated strings from regular strings at compile time.\n * This allows you to enforce that only properly localized content is used\n * in your UI components.\n *\n * Since `LocalizedString` is a branded subtype of `string`, it remains fully\n * backward compatibleâ€”you can pass it anywhere a `string` is expected.\n *\n * @example\n *   // Enforce localized strings in your components\n *   function PageTitle(props: { title: LocalizedString }) {\n *     return <h1>{props.title}</h1>\n *   }\n *\n *   // âœ… Correct: using a message function\n *   <PageTitle title={m.welcome_title()} />\n *\n *   // âŒ Type error: raw strings are not LocalizedString\n *   <PageTitle title=\"Welcome\" />\n *\n * @example\n *   // LocalizedString is assignable to string (backward compatible)\n *   const localized: LocalizedString = m.greeting()\n *   const str: string = localized  // âœ… works fine\n *\n *   // But string is not assignable to LocalizedString\n *   const raw: LocalizedString = \"Hello\"  // âŒ Type error\n *\n * @example\n *   // Catches accidental string concatenation\n *   function showMessage(msg: LocalizedString) { ... }\n *\n *   showMessage(m.hello())                    // âœ…\n *   showMessage(\"Hello \" + userName)          // âŒ Type error\n *   showMessage(m.hello_user({ name: userName }))  // âœ… use params instead\n *\n * @typedef {string & { readonly __brand: 'LocalizedString' }} LocalizedString\n */\n\n"],"names":["locales","cookieName","strategy","_locale","localeInitiallySet","getLocale","locale","strat","extractLocaleFromCookie","isCustomStrategy","customClientStrategies","handler","result","asserted","assertIsLocale","setLocale","navigateOrReload","newLocation","newLocale","options","optionsWithDefaults","currentLocale","customSetLocalePromises","cookieString","error","runReload","isLocale","item","input","lowerInput","matchedLocale"],"mappings":"AAsBO,MAAMA,EAAgC,CAAC,KAAM,IAAI,EAE3CC,EAAa,mBAUnB,MAAMC,EAAW,CACtB,SACA,iBACA,YACF,EAmEA,WAAW,YAAc,CAAA,EAWzB,IAAIC,EACAC,EAAqB,GAmBdC,EAAY,IAAM,CAKzB,IAAIC,EASJ,UAAWC,KAASL,EAAU,CAC1B,GAAuCK,IAAU,SAC7CD,EAASE,EAAA,UAEJD,IAAU,aACfD,EAAS,aASTC,IAAU,kBACVJ,IAAY,OACZG,EAASH,UAYJM,EAAiBF,CAAK,GAAKG,EAAuB,IAAIH,CAAK,EAAG,CACnE,MAAMI,EAAUD,EAAuB,IAAIH,CAAK,EAChD,GAAII,EAAS,CACT,MAAMC,EAASD,EAAQ,UAAA,EAEvB,GAAIC,aAAkB,QAElB,SAEJN,EAASM,CACb,CACJ,CAEA,GAAIN,IAAW,OAAW,CACtB,MAAMO,EAAWC,EAAeR,CAAM,EACtC,OAAKF,IACDD,EAAUU,EAEVT,EAAqB,GACrBW,EAAUF,EAAU,CAAE,OAAQ,EAAA,CAAO,GAElCA,CACX,CACJ,CACA,MAAM,IAAI,MAAM,gHAAgH,CACpI,EA0BA,MAAMG,EAAoBC,GAAgB,CAOlC,OAAO,SAAS,OAAA,CAExB,EAyBO,IAAIF,EAAY,CAACG,EAAWC,IAAY,CAC3C,MAAMC,EAAsB,CACxB,OAAQ,GACR,GAAGD,CAAA,EAKP,IAAIE,EACJ,GAAI,CACAA,EAAgBhB,EAAA,CACpB,MACM,CAEN,CAEA,MAAMiB,EAA0B,CAAA,EAGhC,UAAWf,KAASL,EAChB,GACIK,IAAU,iBAGVJ,EAAUe,UAE8BX,IAAU,SAAU,CAC5D,GACI,OAAO,SAAa,KACpB,OAAO,OAAW,IAClB,SAGJ,MAAMgB,EAAe,GAAGtB,CAAU,IAAIiB,CAAS,6BAC/C,SAAS,OAEHK,CACV,KAAA,IACShB,IAAU,aAEf,YAuBKE,EAAiBF,CAAK,GAAKG,EAAuB,IAAIH,CAAK,EAAG,CACnE,MAAMI,EAAUD,EAAuB,IAAIH,CAAK,EAChD,GAAII,EAAS,CACT,IAAIC,EAASD,EAAQ,UAAUO,CAAS,EAEpCN,aAAkB,UAClBA,EAASA,EAAO,MAAOY,GAAU,CAC7B,MAAM,IAAI,MAAM,oBAAoBjB,CAAK,sBAAuB,CAC5D,MAAOiB,CAAA,CACV,CACL,CAAC,EACDF,EAAwB,KAAKV,CAAM,EAE3C,CACJ,EAEJ,MAAMa,EAAY,IAAM,CAEhBL,EAAoB,QACpB,OAAO,UACPF,IAAcG,GACdL,EAA4B,CAEpC,EACA,GAAIM,EAAwB,OACxB,OAAO,QAAQ,IAAIA,CAAuB,EAAE,KAAK,IAAM,CACnDG,EAAA,CACJ,CAAC,EAELA,EAAA,CAEJ,EA8DO,SAASC,EAASpB,EAAQ,CAC7B,OAAI,OAAOA,GAAW,SACX,GACHA,EAEFN,EAAQ,KAAM2B,GAASA,EAAK,YAAA,IAAkBrB,EAAO,YAAA,CAAa,EADlE,EAEV,CASO,SAASQ,EAAec,EAAO,CAClC,GAAI,OAAOA,GAAU,SACjB,MAAM,IAAI,MAAM,mBAAmBA,CAAK,sBAAsB,EAElE,MAAMC,EAAaD,EAAM,YAAA,EACnBE,EAAgB9B,EAAQ,KAAM2B,GAASA,EAAK,YAAA,IAAkBE,CAAU,EAC9E,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,mBAAmBF,CAAK,sBAAsB5B,EAAQ,KAAK,IAAI,CAAC,EAAE,EAEtF,OAAO8B,CACX,CA2HO,SAAStB,GAA0B,CACtC,GAAI,OAAO,SAAa,KAAe,CAAC,SAAS,OAC7C,OAGJ,MAAMF,EADQ,SAAS,OAAO,MAAM,IAAI,OAAO,QAAQL,CAAU,UAAU,CAAC,IACrD,CAAC,EACxB,GAAIyB,EAASpB,CAAM,EACf,OAAOA,CAGf,CA2zBO,MAAMI,MAA6B,IAQnC,SAASD,EAAiBP,EAAU,CACvC,OAAQ,OAAOA,GAAa,UAAY,0BAA0B,KAAKA,CAAQ,CACnF"}