{"version":3,"file":"C9E6SjbS.js","sources":["../../../../../../../../shared/stores/src/globalSettings.svelte.ts","../../../../../../../../node_modules/svelte/src/reactivity/set.js","../../../../../../../../node_modules/svelte/src/reactivity/map.js"],"sourcesContent":["/**\n * @file src/stores/globalSettings.svelte.ts\n * @description Global Settings Store for PUBLIC ONLY\n *\n * ðŸ”’ SECURITY: This file only contains PUBLIC settings safe for client-side use.\n * Private settings (DB passwords, API keys, etc.) are NEVER exposed here.\n * They remain server-only in src/services/settingsService.ts\n *\n * ### Features\n * - Reactive PUBLIC settings using Svelte 5 $state/$derived runes\n * - Automatic UI updates when settings change\n * - Populated by root layout load function\n * - Type-safe access to public configuration\n */\n\nimport { browser } from '$app/environment';\nimport { publicConfigSchema } from '@shared/database/schemas';\nimport { type InferOutput } from 'valibot';\n\n// Universal Logger (safe for client and server)\nimport { logger } from '@shared/utils/logger';\n\ntype PublicEnv = InferOutput<typeof publicConfigSchema> & { PKG_VERSION?: string };\n\n/**\n * The reactive state for all public environment settings.\n * Initialized empty and populated by initPublicEnv() from layout load.\n */\nconst state = $state<PublicEnv>({} as PublicEnv);\nlet eventSource: EventSource | null = null;\n\n/**\n * Check if settings have been loaded on the client.\n * Returns a reactive value using $derived internally.\n */\nexport function isInitialized(): boolean {\n\treturn Object.keys(state).length > 0;\n}\n\n// Fetches the latest public settings from the server\nasync function fetchPublicSettings() {\n\ttry {\n\t\tconst response = await fetch('/api/settings/public');\n\t\tif (response.ok) {\n\t\t\tconst data = await response.json();\n\t\t\tObject.assign(state, data);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Failed to fetch public settings:', error);\n\t}\n}\n\n/**\n * Starts listening for real-time settings changes via Server-Sent Events.\n * This replaces the old polling mechanism for better efficiency.\n */\nfunction startListening() {\n\tif (!browser || eventSource) return;\n\n\t// Do not connect to stream on login page to avoid 401 errors\n\tif (window.location.pathname.startsWith('/login')) return;\n\n\ttry {\n\t\teventSource = new EventSource('/api/settings/public/stream');\n\n\t\teventSource.addEventListener('message', async (event) => {\n\t\t\ttry {\n\t\t\t\tconst data = JSON.parse(event.data);\n\n\t\t\t\tif (data.type === 'connected') {\n\t\t\t\t\tlogger.debug('Connected to settings stream');\n\t\t\t\t} else if (data.type === 'update') {\n\t\t\t\t\tlogger.debug('Settings updated, fetching new values...');\n\t\t\t\t\tawait fetchPublicSettings();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Failed to process settings update:', error);\n\t\t\t}\n\t\t});\n\n\t\teventSource.addEventListener('error', (error) => {\n\t\t\tlogger.warn('Settings stream connection error, will auto-reconnect...', error);\n\t\t\t// EventSource automatically reconnects on error\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Failed to start settings listener:', error);\n\t}\n}\n\n/**\n * Initializes or updates the client-side public environment store.\n * This should be called from a root layout's load function.\n * @param data The public settings loaded from the server.\n */\nexport function initPublicEnv(data: PublicEnv): void {\n\tObject.assign(state, data);\n\tstartListening();\n}\n\n/**\n * Type-safe getter for a specific public setting.\n */\nexport function getPublicSetting<K extends keyof PublicEnv>(key: K): PublicEnv[K] {\n\treturn state[key];\n}\n\n/**\n * Get the reactive public environment for use across the app.\n * Access properties directly: publicEnv.SITE_NAME (no $ prefix needed)\n *\n * Note: This returns the state object directly, which is reactive in Svelte 5.\n */\nexport function getPublicEnv(): PublicEnv {\n\treturn state;\n}\n\n/**\n * Direct export of reactive state as publicEnv for backward compatibility.\n * All properties are reactive and will automatically update components.\n */\nexport const publicEnv: PublicEnv = state;\n","/** @import { Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { source, set, state, increment } from '../internal/client/reactivity/sources.js';\nimport { label, tag } from '../internal/client/dev/tracing.js';\nimport { get, update_version } from '../internal/client/runtime.js';\n\nvar read_methods = ['forEach', 'isDisjointFrom', 'isSubsetOf', 'isSupersetOf'];\nvar set_like_methods = ['difference', 'intersection', 'symmetricDifference', 'union'];\n\nvar inited = false;\n\n/**\n * A reactive version of the built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) object.\n * Reading contents of the set (by iterating, or by reading `set.size` or calling `set.has(...)` as in the [example](https://svelte.dev/playground/53438b51194b4882bcc18cddf9f96f15) below) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived)\n * will cause it to be re-evaluated as necessary when the set is updated.\n *\n * Note that values in a reactive set are _not_ made [deeply reactive](https://svelte.dev/docs/svelte/$state#Deep-state).\n *\n * ```svelte\n * <script>\n * \timport { SvelteSet } from 'svelte/reactivity';\n * \tlet monkeys = new SvelteSet();\n *\n * \tfunction toggle(monkey) {\n * \t\tif (monkeys.has(monkey)) {\n * \t\t\tmonkeys.delete(monkey);\n * \t\t} else {\n * \t\t\tmonkeys.add(monkey);\n * \t\t}\n * \t}\n * </script>\n *\n * {#each ['ðŸ™ˆ', 'ðŸ™‰', 'ðŸ™Š'] as monkey}\n * \t<button onclick={() => toggle(monkey)}>{monkey}</button>\n * {/each}\n *\n * <button onclick={() => monkeys.clear()}>clear</button>\n *\n * {#if monkeys.has('ðŸ™ˆ')}<p>see no evil</p>{/if}\n * {#if monkeys.has('ðŸ™‰')}<p>hear no evil</p>{/if}\n * {#if monkeys.has('ðŸ™Š')}<p>speak no evil</p>{/if}\n * ```\n *\n * @template T\n * @extends {Set<T>}\n */\nexport class SvelteSet extends Set {\n\t/** @type {Map<T, Source<boolean>>} */\n\t#sources = new Map();\n\t#version = state(0);\n\t#size = state(0);\n\t#update_version = update_version || -1;\n\n\t/**\n\t * @param {Iterable<T> | null | undefined} [value]\n\t */\n\tconstructor(value) {\n\t\tsuper();\n\n\t\tif (DEV) {\n\t\t\t// If the value is invalid then the native exception will fire here\n\t\t\tvalue = new Set(value);\n\n\t\t\ttag(this.#version, 'SvelteSet version');\n\t\t\ttag(this.#size, 'SvelteSet.size');\n\t\t}\n\n\t\tif (value) {\n\t\t\tfor (var element of value) {\n\t\t\t\tsuper.add(element);\n\t\t\t}\n\t\t\tthis.#size.v = super.size;\n\t\t}\n\n\t\tif (!inited) this.#init();\n\t}\n\n\t/**\n\t * If the source is being created inside the same reaction as the SvelteSet instance,\n\t * we use `state` so that it will not be a dependency of the reaction. Otherwise we\n\t * use `source` so it will be.\n\t *\n\t * @template T\n\t * @param {T} value\n\t * @returns {Source<T>}\n\t */\n\t#source(value) {\n\t\treturn update_version === this.#update_version ? state(value) : source(value);\n\t}\n\n\t// We init as part of the first instance so that we can treeshake this class\n\t#init() {\n\t\tinited = true;\n\n\t\tvar proto = SvelteSet.prototype;\n\t\tvar set_proto = Set.prototype;\n\n\t\tfor (const method of read_methods) {\n\t\t\t// @ts-ignore\n\t\t\tproto[method] = function (...v) {\n\t\t\t\tget(this.#version);\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn set_proto[method].apply(this, v);\n\t\t\t};\n\t\t}\n\n\t\tfor (const method of set_like_methods) {\n\t\t\t// @ts-ignore\n\t\t\tproto[method] = function (...v) {\n\t\t\t\tget(this.#version);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar set = /** @type {Set<T>} */ (set_proto[method].apply(this, v));\n\t\t\t\treturn new SvelteSet(set);\n\t\t\t};\n\t\t}\n\t}\n\n\t/** @param {T} value */\n\thas(value) {\n\t\tvar has = super.has(value);\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(value);\n\n\t\tif (s === undefined) {\n\t\t\tif (!has) {\n\t\t\t\t// If the value doesn't exist, track the version in case it's added later\n\t\t\t\t// but don't create sources willy-nilly to track all possible values\n\t\t\t\tget(this.#version);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ts = this.#source(true);\n\n\t\t\tif (DEV) {\n\t\t\t\ttag(s, `SvelteSet has(${label(value)})`);\n\t\t\t}\n\n\t\t\tsources.set(value, s);\n\t\t}\n\n\t\tget(s);\n\t\treturn has;\n\t}\n\n\t/** @param {T} value */\n\tadd(value) {\n\t\tif (!super.has(value)) {\n\t\t\tsuper.add(value);\n\t\t\tset(this.#size, super.size);\n\t\t\tincrement(this.#version);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @param {T} value */\n\tdelete(value) {\n\t\tvar deleted = super.delete(value);\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(value);\n\n\t\tif (s !== undefined) {\n\t\t\tsources.delete(value);\n\t\t\tset(s, false);\n\t\t}\n\n\t\tif (deleted) {\n\t\t\tset(this.#size, super.size);\n\t\t\tincrement(this.#version);\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\tclear() {\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\t\t// Clear first, so we get nice console.log outputs with $inspect\n\t\tsuper.clear();\n\t\tvar sources = this.#sources;\n\n\t\tfor (var s of sources.values()) {\n\t\t\tset(s, false);\n\t\t}\n\n\t\tsources.clear();\n\t\tset(this.#size, 0);\n\t\tincrement(this.#version);\n\t}\n\n\tkeys() {\n\t\treturn this.values();\n\t}\n\n\tvalues() {\n\t\tget(this.#version);\n\t\treturn super.values();\n\t}\n\n\tentries() {\n\t\tget(this.#version);\n\t\treturn super.entries();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.keys();\n\t}\n\n\tget size() {\n\t\treturn get(this.#size);\n\t}\n}\n","/** @import { Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { set, source, state, increment } from '../internal/client/reactivity/sources.js';\nimport { label, tag } from '../internal/client/dev/tracing.js';\nimport { get, update_version } from '../internal/client/runtime.js';\n\n/**\n * A reactive version of the built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) object.\n * Reading contents of the map (by iterating, or by reading `map.size` or calling `map.get(...)` or `map.has(...)` as in the [tic-tac-toe example](https://svelte.dev/playground/0b0ff4aa49c9443f9b47fe5203c78293) below) in an [effect](https://svelte.dev/docs/svelte/$effect) or [derived](https://svelte.dev/docs/svelte/$derived)\n * will cause it to be re-evaluated as necessary when the map is updated.\n *\n * Note that values in a reactive map are _not_ made [deeply reactive](https://svelte.dev/docs/svelte/$state#Deep-state).\n *\n * ```svelte\n * <script>\n * \timport { SvelteMap } from 'svelte/reactivity';\n * \timport { result } from './game.js';\n *\n * \tlet board = new SvelteMap();\n * \tlet player = $state('x');\n * \tlet winner = $derived(result(board));\n *\n * \tfunction reset() {\n * \t\tplayer = 'x';\n * \t\tboard.clear();\n * \t}\n * </script>\n *\n * <div class=\"board\">\n * \t{#each Array(9), i}\n * \t\t<button\n * \t\t\tdisabled={board.has(i) || winner}\n * \t\t\tonclick={() => {\n * \t\t\t\tboard.set(i, player);\n * \t\t\t\tplayer = player === 'x' ? 'o' : 'x';\n * \t\t\t}}\n * \t\t>{board.get(i)}</button>\n * \t{/each}\n * </div>\n *\n * {#if winner}\n * \t<p>{winner} wins!</p>\n * \t<button onclick={reset}>reset</button>\n * {:else}\n * \t<p>{player} is next</p>\n * {/if}\n * ```\n *\n * @template K\n * @template V\n * @extends {Map<K, V>}\n */\nexport class SvelteMap extends Map {\n\t/** @type {Map<K, Source<number>>} */\n\t#sources = new Map();\n\t#version = state(0);\n\t#size = state(0);\n\t#update_version = update_version || -1;\n\n\t/**\n\t * @param {Iterable<readonly [K, V]> | null | undefined} [value]\n\t */\n\tconstructor(value) {\n\t\tsuper();\n\n\t\tif (DEV) {\n\t\t\t// If the value is invalid then the native exception will fire here\n\t\t\tvalue = new Map(value);\n\n\t\t\ttag(this.#version, 'SvelteMap version');\n\t\t\ttag(this.#size, 'SvelteMap.size');\n\t\t}\n\n\t\tif (value) {\n\t\t\tfor (var [key, v] of value) {\n\t\t\t\tsuper.set(key, v);\n\t\t\t}\n\t\t\tthis.#size.v = super.size;\n\t\t}\n\t}\n\n\t/**\n\t * If the source is being created inside the same reaction as the SvelteMap instance,\n\t * we use `state` so that it will not be a dependency of the reaction. Otherwise we\n\t * use `source` so it will be.\n\t *\n\t * @template T\n\t * @param {T} value\n\t * @returns {Source<T>}\n\t */\n\t#source(value) {\n\t\treturn update_version === this.#update_version ? state(value) : source(value);\n\t}\n\n\t/** @param {K} key */\n\thas(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\n\t\tif (s === undefined) {\n\t\t\tvar ret = super.get(key);\n\t\t\tif (ret !== undefined) {\n\t\t\t\ts = this.#source(0);\n\n\t\t\t\tif (DEV) {\n\t\t\t\t\ttag(s, `SvelteMap get(${label(key)})`);\n\t\t\t\t}\n\n\t\t\t\tsources.set(key, s);\n\t\t\t} else {\n\t\t\t\t// We should always track the version in case\n\t\t\t\t// the Set ever gets this value in the future.\n\t\t\t\tget(this.#version);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tget(s);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn\n\t * @param {any} [this_arg]\n\t */\n\tforEach(callbackfn, this_arg) {\n\t\tthis.#read_all();\n\t\tsuper.forEach(callbackfn, this_arg);\n\t}\n\n\t/** @param {K} key */\n\tget(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\n\t\tif (s === undefined) {\n\t\t\tvar ret = super.get(key);\n\t\t\tif (ret !== undefined) {\n\t\t\t\ts = this.#source(0);\n\n\t\t\t\tif (DEV) {\n\t\t\t\t\ttag(s, `SvelteMap get(${label(key)})`);\n\t\t\t\t}\n\n\t\t\t\tsources.set(key, s);\n\t\t\t} else {\n\t\t\t\t// We should always track the version in case\n\t\t\t\t// the Set ever gets this value in the future.\n\t\t\t\tget(this.#version);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tget(s);\n\t\treturn super.get(key);\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @param {V} value\n\t * */\n\tset(key, value) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\t\tvar prev_res = super.get(key);\n\t\tvar res = super.set(key, value);\n\t\tvar version = this.#version;\n\n\t\tif (s === undefined) {\n\t\t\ts = this.#source(0);\n\n\t\t\tif (DEV) {\n\t\t\t\ttag(s, `SvelteMap get(${label(key)})`);\n\t\t\t}\n\n\t\t\tsources.set(key, s);\n\t\t\tset(this.#size, super.size);\n\t\t\tincrement(version);\n\t\t} else if (prev_res !== value) {\n\t\t\tincrement(s);\n\n\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n\t\t\tvar v_reactions = version.reactions === null ? null : new Set(version.reactions);\n\t\t\tvar needs_version_increase =\n\t\t\t\tv_reactions === null ||\n\t\t\t\t!s.reactions?.every((r) =>\n\t\t\t\t\t/** @type {NonNullable<typeof v_reactions>} */ (v_reactions).has(r)\n\t\t\t\t);\n\t\t\tif (needs_version_increase) {\n\t\t\t\tincrement(version);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/** @param {K} key */\n\tdelete(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\t\tvar res = super.delete(key);\n\n\t\tif (s !== undefined) {\n\t\t\tsources.delete(key);\n\t\t\tset(this.#size, super.size);\n\t\t\tset(s, -1);\n\t\t\tincrement(this.#version);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tclear() {\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\t\t// Clear first, so we get nice console.log outputs with $inspect\n\t\tsuper.clear();\n\t\tvar sources = this.#sources;\n\t\tset(this.#size, 0);\n\t\tfor (var s of sources.values()) {\n\t\t\tset(s, -1);\n\t\t}\n\t\tincrement(this.#version);\n\t\tsources.clear();\n\t}\n\n\t#read_all() {\n\t\tget(this.#version);\n\n\t\tvar sources = this.#sources;\n\t\tif (this.#size.v !== sources.size) {\n\t\t\tfor (var key of super.keys()) {\n\t\t\t\tif (!sources.has(key)) {\n\t\t\t\t\tvar s = this.#source(0);\n\t\t\t\t\tif (DEV) {\n\t\t\t\t\t\ttag(s, `SvelteMap get(${label(key)})`);\n\t\t\t\t\t}\n\n\t\t\t\t\tsources.set(key, s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ([, s] of this.#sources) {\n\t\t\tget(s);\n\t\t}\n\t}\n\n\tkeys() {\n\t\tget(this.#version);\n\t\treturn super.keys();\n\t}\n\n\tvalues() {\n\t\tthis.#read_all();\n\t\treturn super.values();\n\t}\n\n\tentries() {\n\t\tthis.#read_all();\n\t\treturn super.entries();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\tget size() {\n\t\tget(this.#size);\n\t\treturn super.size;\n\t}\n}\n"],"names":["state","$.proxy","eventSource","fetchPublicSettings","response","data","error","logger","startListening","event","initPublicEnv","getPublicSetting","key","publicEnv","read_methods","set_like_methods","inited","SvelteSet","#sources","#version","#size","#update_version","update_version","value","element","#init","#source","source","proto","set_proto","method","v","get","set","has","sources","s","increment","deleted","SvelteMap","ret","callbackfn","this_arg","#read_all","prev_res","res","version","v_reactions","needs_version_increase","r"],"mappings":"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","x_google_ignoreList":[1,2]}