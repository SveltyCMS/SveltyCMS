{"version":3,"file":"D3eWcrZU.js","sources":["../../../../../../src/types/definitions.ts","../../../../../../../../shared/utils/src/utils.ts"],"sourcesContent":["/**\n * @file shared/types/src/definitions.ts\n * @description Combined core types to resolve circular dependencies between content and widgets\n */\n\nimport type { SvelteComponent } from 'svelte';\n\n// --- From content.ts ---\n\n// Define core value and status types\nexport type FieldValue = string | number | boolean | object | null;\n\n// Status types for collections and entries\nexport const StatusTypes = {\n\tarchive: 'archive',\n\tdraft: 'draft',\n\tpublish: 'publish',\n\tunpublish: 'unpublish',\n\tschedule: 'schedule',\n\tclone: 'clone',\n\tdelete: 'delete'\n} as const;\n\nexport type StatusType = (typeof StatusTypes)[keyof typeof StatusTypes];\n\n// --- Strongly-Typed Identifiers ---\nexport type DatabaseId = string & { readonly __brand: 'DatabaseId' };\nexport type ISODateString = string & { readonly __isoDate: 'ISODateString' };\n\nexport interface BaseEntity {\n\t_id: DatabaseId;\n\tcreatedAt: ISODateString;\n\tupdatedAt: ISODateString;\n\tisDeleted?: boolean; // Soft delete flag\n\tdeletedAt?: ISODateString; // Timestamp of deletion\n\tdeletedBy?: string; // User who performed deletion\n\ttenantId?: string; // For multi-tenant support\n}\n\nexport interface Translation {\n\tlanguageTag: string;\n\ttranslationName: string;\n\tisDefault?: boolean;\n}\n\n// Unified Content Node\nexport interface ContentNode {\n\t_id: DatabaseId;\n\tname: string;\n\tslug?: string;\n\tdescription?: string;\n\tnodeType: 'category' | 'collection';\n\ticon?: string;\n\torder: number;\n\tparentId?: DatabaseId;\n\tpath?: string;\n\ttranslations: Translation[];\n\tcollectionDef?: Schema;\n\tchildren?: ContentNode[];\n\tcreatedAt: ISODateString;\n\tupdatedAt: ISODateString;\n\ttenantId?: string;\n\tdeletedAt?: ISODateString;\n\tdeletedBy?: string;\n}\n\nexport interface ContentNodeOperation {\n\ttype: 'create' | 'update' | 'delete' | 'move' | 'rename';\n\tnode: ContentNode;\n}\n\nexport type ConfigEntity = {\n\tuuid: string;\n\ttype: string;\n\tname: string;\n\thash: string;\n\tentity: Record<string, unknown>;\n};\n\nexport type ConfigSyncStatus = {\n\tstatus: 'in_sync' | 'changes_detected';\n\tchanges: { new: ConfigEntity[]; updated: ConfigEntity[]; deleted: ConfigEntity[] };\n\tunmetRequirements: Array<{ key: string; value?: unknown }>;\n};\n\nexport interface IContentManager {\n\tinitialize(): Promise<void>;\n\tgetCollections(): Promise<Schema[]>;\n\tgetCollection(identifier: string, tenantId?: string): Promise<Schema | undefined>;\n\tgetCollectionById(collectionId: string, tenantId?: string): Promise<Schema | undefined>;\n\tgetCollectionStats(identifier: string, tenantId?: string): Promise<any>;\n}\n\n// Field Instance - An actual field using a widget with specific configuration\nexport interface FieldInstance {\n\t/** A reference to the widget's immutable definition. */\n\twidget: WidgetDefinition;\n\n\t// Field properties\n\tlabel: string;\n\tdb_fieldName: string;\n\ttranslated: boolean;\n\trequired: boolean;\n\tunique?: boolean;\n\tdefault?: FieldValue;\n\n\t// UI properties\n\ticon?: string;\n\twidth?: number;\n\thelper?: string;\n\n\t// Permissions\n\tpermissions?: Record<string, Record<string, boolean>>;\n\n\t// Functions\n\tvalidate?: (value: FieldValue) => boolean | Promise<boolean>;\n\tdisplay?: (args: {\n\t\tdata: Record<string, FieldValue>;\n\t\tcollection?: string;\n\t\tfield?: FieldInstance;\n\t\tentry?: Record<string, FieldValue>;\n\t\tcontentLanguage?: string;\n\t}) => Promise<string> | string;\n\tcallback?: (args: { data: Record<string, FieldValue> }) => void;\n\tmodifyRequest?: (args: Record<string, unknown>) => Promise<Record<string, unknown>>;\n\tmodifyRequestBatch?: (args: {\n\t\tdata: Record<string, unknown>[];\n\t\tcollection: unknown;\n\t\tfield: unknown;\n\t\tuser: unknown;\n\t\ttype: string;\n\t\ttenantId?: string;\n\t}) => Promise<Record<string, unknown>[]>;\n\n\t/** Widget-specific properties, now strongly typed by the factory. */\n\t[key: string]: unknown;\n}\n\n// Field definition\nexport type FieldDefinition = unknown | WidgetPlaceholder;\n\n// Collection Schema Definition\nexport interface Schema {\n\tid?: number;\n\t_id?: string;\n\tname?: string;\n\tlabel?: string;\n\tslug?: string;\n\ticon?: string;\n\torder?: number;\n\tdescription?: string;\n\tstrict?: boolean;\n\trevision?: boolean;\n\trevisionLimit?: number;\n\tpath?: string;\n\tpermissions?: any; // Avoiding circular dependency on RolePermissions\n\tlivePreview?: boolean;\n\tstatus?: StatusType;\n\tlinks?: Array<string>;\n\tfields: FieldDefinition[];\n\ttranslations?: Translation[];\n\n\ttenantId?: string;\n}\n\n// Dashboard types\nexport interface WidgetSize {\n\tw: number; // Width in grid units\n\th: number; // Height in grid units\n}\n\nexport interface DashboardWidgetConfig {\n\tid: string; // Unique widget identifier\n\tcomponent: string; // Svelte component name\n\tlabel: string; // Display label for the widget\n\ticon: string; // Icon identifier (iconify icon)\n\tsize: WidgetSize; // Widget dimensions\n\tsettings: Record<string, unknown>; // Widget-specific settings\n\tgridPosition?: number; // Optional position in the grid layout\n\torder?: number; // Optional order for sorting\n}\n\nexport interface Layout {\n\tid: string; // Layout identifier\n\tname: string; // Human-readable layout name\n\tpreferences: DashboardWidgetConfig[]; // Array of widget configurations\n}\n\nexport interface SystemPreferencesDocument {\n\t_id: string; // Document ID (combination of userId and layoutId)\n\tuserId?: string; // Optional user ID for user-scoped preferences\n\tlayoutId: string; // Layout identifier\n\tlayout: Layout; // Complete layout configuration\n\tscope: 'user' | 'system' | 'widget'; // Preference scope\n\tcreatedAt: ISODateString; // Creation timestamp\n\tupdatedAt: ISODateString; // Last update timestamp\n}\n\nexport interface RevisionData {\n\t_id: string;\n\tentryId: string;\n\tcollectionId: string;\n\tdata: Record<string, unknown>;\n\ttimestamp: ISODateString;\n\tuserId?: string;\n\toperation?: 'create' | 'update' | 'delete' | 'status_change';\n\ttenantId?: string;\n\t[key: string]: unknown;\n}\n\nexport interface CollectionEntry extends Record<string, unknown> {\n\t_id?: string;\n\tstatus?: StatusType;\n\tcreatedAt?: string;\n\tupdatedAt?: string;\n\tcreatedBy?: string;\n\tupdatedBy?: string;\n\ttenantId?: string;\n}\n\n// --- From widgets.ts ---\n\nexport interface GuiFieldConfig {\n\twidget: unknown;\n\trequired: boolean;\n}\n\nexport type WidgetType = 'core' | 'custom' | 'marketplace';\n\nexport interface WidgetMetadata {\n\ttype: WidgetType;\n\tversion?: string;\n\tauthor?: string;\n\tdependencies?: string[];\n\ttags?: string[];\n}\n\n/**\n * The immutable definition of a widget - created once by the factory\n * This is what gets stored in the widget registry\n */\nexport interface WidgetDefinition<TProps extends Record<string, unknown> = Record<string, unknown>> {\n\t// Core identity\n\twidgetId: string;\n\tName: string;\n\tIcon?: string;\n\tDescription?: string;\n\n\t// 3-Pillar Architecture paths\n\tinputComponentPath?: string;\n\tdisplayComponentPath?: string;\n\n\t// Validation (can be static schema or function)\n\tvalidationSchema: unknown | ((field: FieldInstance) => unknown);\n\n\t/** Optional function to return widget-specific translatable paths. */\n\tgetTranslatablePaths?: (basePath: string) => string[];\n\n\t// Default values for widget-specific props\n\tdefaults?: Partial<TProps>;\n\n\t// Configuration UI in Collection Builder\n\tGuiFields?: Record<string, unknown>;\n\tGuiSchema?: Record<string, unknown>; // Compatibility for legacy widgets\n\n\t// Optional advanced features\n\tGraphqlSchema?: (params: { field: unknown; label: string; collection: unknown; collectionNameMapping?: Map<string, string> }) => {\n\t\ttypeID: string | null;\n\t\tgraphql: string;\n\t\tresolver?: Record<string, unknown>;\n\t};\n\n\taggregations?: {\n\t\tfilters?: (params: { field: FieldInstance; filter: string; contentLanguage: string }) => Promise<unknown[]>;\n\t\tsorts?: (params: { field: FieldInstance; sortDirection: number; contentLanguage: string }) => Promise<Record<string, number>>;\n\t};\n\n\t// Metadata\n\tmetadata?: WidgetMetadata;\n}\n\n/**\n * The factory function that creates field instances\n * This is what collection authors use in their schemas\n */\nexport interface WidgetFactory<TProps extends Record<string, unknown> = Record<string, unknown>> {\n\t// The callable function that creates field instances\n\t(config: FieldConfig<TProps>): FieldInstance;\n\n\t// Static properties attached to the function (for compatibility)\n\tName: string;\n\tIcon?: string;\n\tDescription?: string;\n\tGuiSchema?: Record<string, unknown>;\n\tGraphqlSchema?: WidgetDefinition['GraphqlSchema'];\n\taggregations?: WidgetDefinition['aggregations'];\n\t__inputComponentPath?: string;\n\t__displayComponentPath?: string;\n\t__widgetType?: WidgetType;\n\t__dependencies?: string[];\n\n\t// String representation\n\ttoString(): string;\n}\n\n/**\n * Configuration for creating a field instance\n * Combines standard field properties with widget-specific props\n */\nexport type FieldConfig<TProps extends Record<string, unknown> = Record<string, unknown>> = {\n\t// Standard field properties\n\tlabel: string;\n\tdb_fieldName?: string;\n\trequired?: boolean;\n\ttranslated?: boolean;\n\twidth?: number;\n\thelper?: string;\n\ticon?: string;\n\tdisabled?: boolean;\n\treadonly?: boolean;\n\n\t// Permissions\n\tpermissions?: Record<string, Record<string, boolean>>;\n} & Partial<TProps>; // Widget-specific props\n\n/**\n * @deprecated Use WidgetFactory instead\n */\nexport interface Widget {\n\t(field: FieldInstance): FieldInstance;\n\tName: string;\n\tIcon?: string;\n\tDescription?: string;\n\tGuiSchema?: SvelteComponent;\n\tGraphqlSchema?: unknown;\n\taggregations?: unknown;\n\t__widgetType?: WidgetType;\n\t__dependencies?: string[];\n\t__inputComponentPath?: string;\n\t__displayComponentPath?: string;\n\tcomponentPath?: string;\n}\n\n/**\n * @deprecated Use WidgetFactory instead\n */\nexport interface WidgetFunction {\n\t(config: Record<string, unknown>): Widget;\n\t__widgetId?: string;\n\tName: string;\n\tGuiSchema?: typeof SvelteComponent | Record<string, unknown>;\n\tGraphqlSchema?: unknown;\n\tIcon?: string;\n\tDescription?: string;\n\taggregations?: unknown;\n\t__widgetType?: WidgetType;\n\t__isCore?: boolean;\n\t__dependencies?: string[];\n\t__inputComponentPath?: string;\n\t__displayComponentPath?: string;\n\tcomponentPath?: string;\n}\n\nexport type WidgetModule = {\n\tdefault: WidgetFactory;\n};\n\n/**\n * Parameters passed to widget components at runtime\n */\nexport type WidgetParam = {\n\tfield: FieldInstance;\n\tschema: Schema;\n\tuser: any; // Use any for now or import User from auth types if available\n\tvalue: unknown;\n\tvalues: unknown;\n\tonValueChange: (value: unknown) => void;\n\tconfig: GuiFieldConfig;\n\tplaceholder: WidgetPlaceholder;\n};\n\nexport interface WidgetPlaceholder {\n\t__widgetId: string;\n\t__widgetName: string;\n\t__widgetConfig: Record<string, unknown>;\n}\n\nexport interface WidgetRegistryEntry {\n\tdefinition: WidgetDefinition;\n\tfactory: WidgetFactory;\n\tstatus: 'active' | 'inactive' | 'error';\n\tmetadata: WidgetMetadata;\n\tloadedAt?: Date;\n\terror?: string;\n}\n","/**\n * @file src/utils/utils.ts\n * @description A comprehensive utility module for the SvelteKit CMS project.\n *\n * This file contains a wide range of utility functions and helpers used throughout the application, including:\n * - Form data handling and conversion (obj2formData, col2formData)\n * - File and media operations (sanitize, formatBytes, deleteOldTrashFiles)\n * - Date and time formatting (convertTimestampToDateString, formatUptime, ReadableExpireIn)\n * - Data manipulation and validation (extractData, deepCopy, validateValibot)\n * - Internationalization helpers (getTextDirection)\n * - UI-related utilities (getGuiFields, motion)\n * - String manipulation (pascalToCamelCase, getEditDistance)\n * - And various other helper functions\n *\n * The module also defines important constants and types used across the application.\n *\n * @requires various - Including fs, axios, valibot, and custom types/interfaces\n * @requires @stores/store - For accessing Svelte stores\n * @requires @root/config/public - For accessing public environment variables\n *\n * @exports numerous utility functions and constants\n */\n\nimport type { FieldInstance, FieldValue } from '@cms-types/content';\nimport type { GuiFieldConfig } from '@cms-types';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\nimport type { BaseIssue, BaseSchema } from 'valibot';\n\n// Stores\nimport { app } from '@shared/stores/store.svelte';\n\n// System Logger\nimport { logger, type LoggableValue } from '@shared/utils/logger';\n\n// Validation\nimport * as v from 'valibot';\n\nexport const config = {\n\theaders: {\n\t\t'Content-Type': 'multipart/form-data'\n\t}\n};\n\nexport function uniqueItems(items: Record<string, unknown>[], key: string): object[] {\n\tconst uniqueItems = Array.from(new Map(items.map((item) => [item[key], item])).values());\n\n\treturn uniqueItems;\n}\n\n// This function generates GUI fields based on field parameters and a GUI schema.\nexport const getGuiFields = (fieldParams: Record<string, unknown>, GuiSchema: Record<string, GuiFieldConfig>): Record<string, unknown> => {\n\tconst guiFields: Record<string, unknown> = {};\n\tfor (const key in GuiSchema) {\n\t\tif (Object.prototype.hasOwnProperty.call(fieldParams, key) && Array.isArray(fieldParams[key])) {\n\t\t\tguiFields[key] = deepCopy(fieldParams[key] as unknown[]);\n\t\t} else if (Object.prototype.hasOwnProperty.call(fieldParams, key)) {\n\t\t\tguiFields[key] = fieldParams[key];\n\t\t}\n\t}\n\treturn guiFields;\n};\n\n// Function to convert an object to form data\nexport const obj2formData = (obj: Record<string, unknown>) => {\n\tconst formData = new FormData();\n\n\tconst transformValue = (value: unknown): string | Blob => {\n\t\tif (value instanceof Blob) {\n\t\t\treturn value;\n\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\treturn JSON.stringify(value);\n\t\t} else if (typeof value === 'boolean' || typeof value === 'number') {\n\t\t\treturn value.toString();\n\t\t} else if (value === null || value === undefined) {\n\t\t\treturn '';\n\t\t}\n\t\treturn String(value);\n\t};\n\n\tfor (const key in obj) {\n\t\tconst value = obj[key];\n\t\tif (value !== undefined) {\n\t\t\tformData.append(key, transformValue(value));\n\t\t}\n\t}\n\n\treturn formData;\n};\n\n// Converts data to FormData object with optimized file handling and type safety\nexport const col2formData = async (getData: Record<string, () => Promise<unknown> | unknown>): Promise<FormData> => {\n\tconst formData = new FormData();\n\n\tconst processValue = async (value: unknown): Promise<string | Blob> => {\n\t\tif (value instanceof Blob) return value;\n\t\tif (value instanceof Promise) {\n\t\t\tconst resolvedValue = await value;\n\t\t\treturn processValue(resolvedValue);\n\t\t}\n\t\tif (value instanceof Object) {\n\t\t\treturn JSON.stringify(value);\n\t\t}\n\t\treturn String(value);\n\t};\n\n\tconst appendToForm = async () => {\n\t\tfor (const [key, getter] of Object.entries(getData)) {\n\t\t\tconst value = getter();\n\t\t\tconst processedValue = await processValue(value);\n\t\t\tformData.append(key, processedValue);\n\t\t}\n\t};\n\n\tawait appendToForm();\n\treturn formData;\n};\n\n// Helper function to sanitize file names\nexport function sanitize(str: string) {\n\treturn str.replace(/\\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');\n}\n\n// Get the environment variables for image sizes\nconst env_sizes = publicEnv.IMAGE_SIZES || {};\nexport const SIZES = { ...env_sizes, original: 0, thumbnail: 200 } as const;\n\n// Takes an object and recursively parses any values that can be converted to JSON\nexport function parse<T>(obj: unknown): T {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn obj as T;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => parse(item)) as unknown as T;\n\t}\n\n\tconst result = {} as { [key: string]: unknown };\n\tfor (const [key, value] of Object.entries(obj as object)) {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\tresult[key] = JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\tresult[key] = value;\n\t\t\t}\n\t\t} else {\n\t\t\tresult[key] = parse(value);\n\t\t}\n\t}\n\treturn result as T;\n}\n\n// Convert an object to form data\nexport const toFormData = (obj: Record<string, string | number | boolean>): FormData => {\n\tconst formData = new FormData();\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tformData.append(key, String(value));\n\t}\n\treturn formData;\n};\n\n// Converts fields to schema object\ninterface SchemaField {\n\ttype: string;\n\twidget?: unknown;\n\t[key: string]: unknown;\n}\n\nexport const fieldsToSchema = (fields: SchemaField[]): Record<string, unknown> => {\n\tconst schema: Record<string, unknown> = {};\n\n\tfor (const field of fields) {\n\t\tconst { type, ...rest } = field;\n\t\tschema[type] = rest;\n\t}\n\n\treturn schema;\n};\n\n// Returns field's database field name or label\nexport function getFieldName(field: Partial<FieldInstance> & { label: string }, rawName = false): string {\n\tif (!field) return '';\n\n\t// Use explicit db_fieldName if available\n\tif (field.db_fieldName) {\n\t\treturn rawName ? field.db_fieldName : field.db_fieldName;\n\t}\n\n\t// Special field name mappings\n\tconst specialMappings: Record<string, string> = {\n\t\t'First Name': 'first_name',\n\t\t'Last Name': 'last_name'\n\t};\n\n\t// Get the field name from label, or fallback to widget name\n\tlet name = field.label;\n\tif (!name && 'widget' in field && field.widget?.Name) {\n\t\tname = field.widget.Name;\n\t}\n\tif (!name && 'type' in field) {\n\t\tname = field.type as string;\n\t}\n\tif (!name) {\n\t\tname = 'unknown_field';\n\t}\n\n\t// Return raw UI name if requested\n\tif (rawName) return name;\n\n\t// Check special mappings first\n\tif (specialMappings[name]) {\n\t\treturn specialMappings[name];\n\t}\n\n\t// Default sanitization:\n\t// 1. Convert to lowercase\n\t// 2. Replace spaces with underscores\n\t// 3. Remove special characters\n\treturn name\n\t\t.toLowerCase()\n\t\t.replace(/\\s+/g, '_')\n\t\t.replace(/[^a-z0-9_]/g, '');\n}\n\n// Sanitizes field names for use in GraphQL type names\n// GraphQL type names must be valid identifiers: [A-Za-z_][A-Za-z0-9_]*\nexport function sanitizeGraphQLTypeName(name: string): string {\n\tif (!name) return '';\n\n\t// 1. Replace spaces with underscores\n\t// 2. Remove special characters except underscores\n\t// 3. Ensure it starts with a letter or underscore\n\tlet sanitized = name.replace(/\\s+/g, '_').replace(/[^A-Za-z0-9_]/g, '');\n\n\t// Ensure the name starts with a letter or underscore (GraphQL requirement)\n\tif (sanitized && !/^[A-Za-z_]/.test(sanitized)) {\n\t\tsanitized = `_${sanitized}`;\n\t}\n\n\treturn sanitized || '_invalid_name';\n}\n\n// Extract data from fields\nexport async function extractData(fieldsData: Record<string, FieldInstance>): Promise<Record<string, unknown>> {\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, field] of Object.entries(fieldsData)) {\n\t\tif (field.callback) {\n\t\t\tresult[key] = await field.callback({ data: field as unknown as Record<string, FieldValue> });\n\t\t} else {\n\t\t\tresult[key] = field.default ?? null;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction deepCopy<T>(obj: T): T {\n\tif (obj === null || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => deepCopy(item)) as unknown as T;\n\t}\n\n\tconst copy = {} as T;\n\tfor (const key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tcopy[key] = deepCopy(obj[key]);\n\t\t}\n\t}\n\treturn copy;\n}\n\n// Remove file extension\nexport function removeExtension(fileName: string): string {\n\treturn fileName.replace(/\\.[^/.]+$/, '');\n}\n\n/**\n * Formats a file size in bytes to the appropriate unit (bytes, kilobytes, megabytes, or gigabytes).\n * @param sizeInBytes - The size of the file in bytes.\n * @returns The formatted file size as a string.\n */\nexport function formatBytes(bytes: number): string {\n\tif (bytes === 0 || isNaN(bytes)) {\n\t\treturn '0 bytes';\n\t}\n\n\tif (bytes < 0) {\n\t\tthrow Error('Input size cannot be negative');\n\t}\n\n\tconst units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'];\n\tlet power = 0;\n\n\twhile (bytes >= 1024 && power < units.length - 1) {\n\t\tbytes /= 1024;\n\t\tpower++;\n\t}\n\n\treturn `${bytes.toFixed(2)} ${units[power]}`;\n}\n\n// Function to convert Unix timestamp to readable date string\nexport function convertTimestampToDateString(timestamp: number) {\n\tif (timestamp === null || timestamp === undefined) {\n\t\treturn '-';\n\t}\n\n\tconst options: Intl.DateTimeFormatOptions = {\n\t\tday: '2-digit',\n\t\tmonth: '2-digit',\n\t\tyear: 'numeric',\n\t\thour: '2-digit',\n\t\tminute: '2-digit',\n\t\thour12: false\n\t};\n\tconst locale = app.contentLanguage;\n\tconst date = new Date(timestamp * 1000);\n\treturn date.toLocaleDateString(locale, options);\n}\n\nexport function formatUptime(uptime: number) {\n\tconst units = [\n\t\t{ label: ['year', 'years'], value: 365 * 24 * 60 * 60 },\n\t\t{ label: ['month', 'months'], value: 30 * 24 * 60 * 60 },\n\t\t{ label: ['week', 'weeks'], value: 7 * 24 * 60 * 60 },\n\t\t{ label: ['day', 'days'], value: 24 * 60 * 60 },\n\t\t{ label: ['hour', 'hours'], value: 60 * 60 },\n\t\t{ label: ['minute', 'minutes'], value: 60 },\n\t\t{ label: ['second', 'seconds'], value: 1 }\n\t];\n\n\tconst result: string[] = [];\n\tfor (const unit of units) {\n\t\tconst quotient = Math.floor(uptime / unit.value);\n\t\tif (quotient > 0) {\n\t\t\tresult.push(`${quotient} ${unit.label[quotient > 1 ? 1 : 0]}`);\n\t\t\tuptime %= unit.value;\n\t\t}\n\t}\n\n\treturn result.join(' ');\n}\n\n// Export function for ReadableExpireIn\nexport function ReadableExpireIn(expiresIn: string) {\n\tconst expiresInNumber = parseInt(expiresIn, 10);\n\tconst expirationTime = expiresInNumber ? new Date(Date.now() + expiresInNumber * 1000) : new Date();\n\n\tconst daysDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60 * 60 * 24));\n\tconst hoursDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60 * 60)) % 24;\n\tconst minutesDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60)) % 60;\n\n\tconst daysText = daysDiff > 0 ? `${daysDiff} day${daysDiff > 1 ? 's' : ''}` : '';\n\tconst hoursText = hoursDiff > 0 ? `${hoursDiff} hour${hoursDiff > 1 ? 's' : ''}` : '';\n\tconst minutesText = minutesDiff > 0 ? `${minutesDiff} minute${minutesDiff > 1 ? 's' : ''}` : '';\n\n\treturn `${daysText} ${hoursText} ${minutesText}`.trim();\n}\n\n// Get elements by ID\ninterface ElementStore {\n\t[key: string]: {\n\t\tid: string;\n\t\tcallback: (data: unknown) => void;\n\t}[];\n}\n\nexport const get_elements_by_id = {\n\tstore: {} as ElementStore,\n\tadd(collection: string, id: string, callback: (data: unknown) => void) {\n\t\tif (!this.store[collection]) {\n\t\t\tthis.store[collection] = [];\n\t\t}\n\t\tthis.store[collection].push({ id, callback });\n\t},\n\tasync getAll(dbAdapter: { get: (id: string) => Promise<unknown> }) {\n\t\tfor (const collection in this.store) {\n\t\t\tfor (const item of this.store[collection]) {\n\t\t\t\tconst data = await dbAdapter.get(item.id);\n\t\t\t\titem.callback(data);\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Meta data types\ninterface MetaData {\n\tmedia_images_remove?: string[];\n\t[key: string]: unknown;\n}\n\nexport const meta_data = {\n\tmeta_data: {} as MetaData,\n\tadd(key: keyof MetaData, data: unknown) {\n\t\tthis.meta_data[key] = data;\n\t},\n\tget(): MetaData {\n\t\treturn this.meta_data;\n\t},\n\tclear() {\n\t\tthis.meta_data = {};\n\t},\n\tis_empty(): boolean {\n\t\treturn Object.keys(this.meta_data).length === 0;\n\t}\n};\n\n// Convert data to string\ninterface StringHelperParams {\n\tfield?: FieldInstance;\n\tdata: unknown[];\n\tpath?: (lang: string) => string;\n}\n\nexport function toStringHelper({ data }: StringHelperParams): string {\n\tif (!Array.isArray(data)) return '';\n\treturn data.map((item: unknown) => String(item)).join(', ');\n}\n\n// Get random hex string\nexport function getRandomHex(size: number): string {\n\tconst bytes = new Uint8Array(size);\n\tfor (let i = 0; i < size; i++) {\n\t\tbytes[i] = Math.floor(Math.random() * 256);\n\t}\n\treturn Array.from(bytes)\n\t\t.map((byte) => byte.toString(16).padStart(2, '0'))\n\t\t.join('');\n}\n\n// Escape regex metacharacters\nexport function escapeRegex(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// Get current date in YYYY-MM-DD format\nexport function getCurrentDate(): string {\n\tconst d = new Date();\n\treturn d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');\n}\n\n// Convert hex to array buffer\nexport function hex2arrayBuffer(hex: string): ArrayBuffer {\n\tconst bytes = new Uint8Array(hex.length / 2);\n\tfor (let i = 0; i < hex.length; i += 2) {\n\t\tbytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n\t}\n\treturn bytes.buffer;\n}\n\n// Convert array buffer to hex\nexport function arrayBuffer2hex(buffer: ArrayBuffer): string {\n\treturn Array.from(new Uint8Array(buffer))\n\t\t.map((byte) => byte.toString(16).padStart(2, '0'))\n\t\t.join('');\n}\n\n// SHA-256 hash function\nexport async function sha256(buffer: ArrayBuffer): Promise<string> {\n\tconst hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n\treturn arrayBuffer2hex(hashBuffer);\n}\n\n// Enhanced debounce utility with flexible patterns\nexport function debounce(delay: number = 300, immediate: boolean = false) {\n\tlet timer: NodeJS.Timeout | undefined;\n\tlet hasExecuted = false;\n\n\treturn (fn: () => void) => {\n\t\tconst shouldExecuteImmediately = immediate && !hasExecuted;\n\n\t\tif (shouldExecuteImmediately) {\n\t\t\tfn();\n\t\t\thasExecuted = true;\n\t\t\treturn;\n\t\t}\n\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => {\n\t\t\tfn();\n\t\t}, delay);\n\t};\n}\n\n// Traditional debounce pattern - takes function and delay, returns debounced version\ndebounce.create = function <T extends (...args: unknown[]) => unknown>(func: T, wait: number = 300): (...args: Parameters<T>) => void {\n\tlet timeout: ReturnType<typeof setTimeout>;\n\n\treturn function executedFunction(...args: Parameters<T>) {\n\t\tconst later = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tfunc(...args);\n\t\t};\n\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t};\n};\n\n// Validates data against a Valibot schema, returning errors or null if valid\nexport function validateValibot<T>(schema: BaseSchema<T, T, BaseIssue<unknown>>, value?: T): null | { [P in keyof T]?: string[] } {\n\ttry {\n\t\t// Use v.safeParse to handle parsing\n\t\tconst result = v.safeParse(schema, value);\n\n\t\tif (result.success) {\n\t\t\treturn null; // No errors\n\t\t}\n\n\t\tconst fieldErrors = {} as { [P in keyof T]?: string[] };\n\n\t\t// Iterate over issues and populate field errors\n\t\tfor (const issue of result.issues) {\n\t\t\tconst path = issue.path?.[0]?.key as keyof T;\n\t\t\tif (path) {\n\t\t\t\tfieldErrors[path] = fieldErrors[path] || [];\n\t\t\t\tfieldErrors[path]!.push(issue.message);\n\t\t\t}\n\t\t}\n\n\t\treturn fieldErrors;\n\t} catch (error) {\n\t\tlogger.error('Validation error:', error as LoggableValue);\n\t\treturn null;\n\t}\n}\n\nexport function getTextDirection(lang: string): string {\n\tconst rtlLanguages = ['ar', 'he', 'fa', 'ur', 'dv', 'ha', 'khw', 'ks', 'ku', 'ps', 'syr', 'ug', 'yi'];\n\treturn rtlLanguages.includes(lang) ? 'rtl' : 'ltr';\n}\n\nexport async function motion(start: number[], end: number[], duration: number, cb: (current: number[]) => void) {\n\tconst current = [...start];\n\tlet elapsed = 0;\n\tlet time = Date.now();\n\tlet has_passed = false;\n\tsetTimeout(() => {\n\t\thas_passed = true;\n\t}, duration);\n\treturn new Promise<void>((resolve) => {\n\t\tfunction animation(current: number[]) {\n\t\t\telapsed = Date.now() - time;\n\t\t\tconst ds = start.map((s, i) => (s - end[i]) / (duration / elapsed));\n\n\t\t\ttime = Date.now();\n\t\t\tfor (const index in ds) {\n\t\t\t\tcurrent[index] -= ds[index];\n\t\t\t}\n\n\t\t\tif (has_passed) {\n\t\t\t\tcb(end);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcb(current);\n\t\t\t\trequestAnimationFrame(() => animation(current));\n\t\t\t}\n\t\t}\n\n\t\trequestAnimationFrame(() => animation(current));\n\t});\n}\n\nexport function getEditDistance(a: string, b: string): number | undefined {\n\tif (a.length === 0) return b.length;\n\tif (b.length === 0) return a.length;\n\n\tconst insertionCost = 1;\n\tconst deletionCost = 1;\n\tconst substitutionCost = 1;\n\n\tconst matrix: number[][] = [];\n\n\tfor (let i = 0; i <= b.length; i++) {\n\t\tmatrix[i] = [i];\n\t}\n\tfor (let j = 0; j <= a.length; j++) {\n\t\tmatrix[0][j] = j;\n\t}\n\n\tfor (let i = 1; i <= b.length; i++) {\n\t\tfor (let j = 1; j <= a.length; j++) {\n\t\t\tif (b.charAt(i - 1) === a.charAt(j - 1)) {\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j - 1];\n\t\t\t} else {\n\t\t\t\tmatrix[i][j] = Math.min(matrix[i - 1][j - 1] + substitutionCost, Math.min(matrix[i][j - 1] + insertionCost, matrix[i - 1][j] + deletionCost));\n\t\t\t}\n\t\t}\n\t}\n\n\tconst maxDistance = Math.max(a.length, b.length);\n\tconst normalizedDistance = matrix[b.length][a.length] / maxDistance;\n\n\treturn normalizedDistance;\n}\n\n// PascalCase to camelCase conversion\nexport const pascalToCamelCase = (str: string): string => {\n\tif (!str) return str;\n\treturn str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n// Type assertion helper - used for widget type assertions\nexport function asAny<T>(value: unknown): T {\n\treturn value as T;\n}\n"],"names":["StatusTypes","getGuiFields","fieldParams","GuiSchema","guiFields","key","deepCopy","obj2formData","obj","formData","transformValue","value","env_sizes","publicEnv","getFieldName","field","rawName","specialMappings","name","item","copy","formatBytes","bytes","units","power","convertTimestampToDateString","timestamp","options","locale","app","meta_data","data","debounce","delay","immediate","timer","hasExecuted","fn","func","wait","timeout","args","later","getTextDirection","lang","asAny"],"mappings":"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"}