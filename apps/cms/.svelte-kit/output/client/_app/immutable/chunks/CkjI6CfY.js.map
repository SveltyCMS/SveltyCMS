{"version":3,"mappings":"sGAuDA,MAAMA,EAAoC,CACzC,YAAa,EACb,eAAgB,IAChB,WAAY,KACZ,kBAAmB,EACnB,SAAU,GACX,EAMO,MAAMC,CAAmB,CACvB,QAA6B,CACpC,aAAc,EACd,kBAAmB,EACnB,cAAe,EACf,mBAAoB,EACpB,wBAAyB,EACzB,oBAAqB,EACrB,iBAAkB,EAClB,eAAgB,EAAC,EAGV,YACA,eAAiB,GACjB,wBACA,mBAER,YAAYC,EAA+B,CAC1C,KAAK,YAAc,CAAE,GAAGF,EAAsB,GAAGE,CAAA,EACjD,KAAK,uBACN,CAGA,MAAM,iBAAoBC,EAA6BC,EAAuBC,EAA+D,CAC5I,IAAIC,EAEJ,QAASC,EAAU,EAAGA,GAAW,KAAK,YAAY,YAAaA,IAC9D,GAAI,CACH,MAAMC,EAAS,MAAML,EAAA,EAErB,OAAII,EAAU,IAEb,KAAK,QAAQ,oBACbE,EAAO,KAAK,gBAAgBL,CAAa,qBAAqBG,CAAO,aAAa,GAG5EC,CACR,OAASE,EAAO,CAIf,GAHAJ,EAAYI,EACZ,KAAK,QAAQ,eAETH,EAAU,KAAK,YAAY,YAAa,CAC3C,MAAMI,EAAQ,KAAK,sBAAsBJ,CAAO,EAEhDE,EAAO,KAAK,cAAcL,CAAa,qBAAqBG,CAAO,IAAI,KAAK,YAAY,WAAW,kBAAkBI,CAAK,QAAS,CAClI,MAAOL,EAAU,QACjB,EAGGD,GACHA,EAAQE,EAASD,CAAS,EAG3B,MAAM,KAAK,MAAMK,CAAK,CACvB,MACC,KAAK,QAAQ,gBACbF,EAAO,MAAM,cAAcL,CAAa,kBAAkB,KAAK,YAAY,WAAW,YAAa,CAAE,MAAOE,EAAU,QAAS,CAEjI,CAGD,MAAMA,GAAa,IAAI,MAAM,cAAcF,CAAa,mCAAmC,CAC5F,CAGA,MAAM,oBAAoBQ,EAAkCC,EAAyE,CACpI,GAAI,KAAK,eACR,OAAAJ,EAAO,MAAM,+CAA+C,EACrD,GAGR,KAAK,eAAiB,GACtB,KAAK,QAAQ,qBAEb,MAAMK,EAAY,KAAK,MACjBC,EAAgB,CACrB,UAAWD,EACX,MAAO,kBACP,UAAW,GACX,aAAc,QAGf,GAAI,CACHE,EAAoB,WAAY,eAAgB,qCAAqC,EAErF,MAAM,KAAK,iBAAiBJ,EAAa,wBAAyB,CAACL,EAASG,IAAU,CACrFM,EAAoB,WAAY,YAAa,wBAAwBT,CAAO,IAAI,KAAK,YAAY,WAAW,YAAYG,EAAM,OAAO,EAAE,CACxI,CAAC,EAED,MAAMO,EAAe,KAAK,MAAQH,EAClC,OAAAC,EAAc,UAAY,GAC1BA,EAAc,aAAeE,EAE7B,KAAK,QAAQ,0BACb,KAAK,QAAQ,iBAAmB,KAAK,MACrC,KAAK,0BAA0BA,CAAY,EAC3C,KAAK,wBAA0B,KAAK,MAEpCD,EAAoB,WAAY,UAAW,mCAAmC,EAC9EP,EAAO,KAAK,0CAA0CQ,CAAY,IAAI,EAE/D,EACR,OAASP,EAAO,CACf,MAAMQ,EAAyB,CAC9B,KAAM,sBACN,QAASR,aAAiB,MAAQA,EAAM,QAAU,gBAClD,QAAS,CAAE,SAAU,KAAK,YAAY,YAAY,EAGnD,YAAK,QAAQ,gBAAkB,KAAK,MACpCM,EAAoB,WAAY,YAAa,+BAAgCE,EAAQ,OAAO,EAG5F,MAAML,EAAaK,CAAO,EAE1BT,EAAO,MAAM,kDAAmD,CAAE,MAAOS,EAAS,EAE3E,EACR,SACC,KAAK,QAAQ,eAAe,KAAKH,CAAa,EAE1C,KAAK,QAAQ,eAAe,OAAS,KACxC,KAAK,QAAQ,eAAiB,KAAK,QAAQ,eAAe,MAAM,GAAG,GAEpE,KAAK,eAAiB,EACvB,CACD,CAMA,MAAM,oBAAyD,CAC9D,GAAI,CAEH,MAAMI,EAAW,MAAAC,EAAA,IAAM,OAAO,UAAU,sBAGlCC,EAAY,MAAM,KAAK,qBAAqBF,EAAS,OAAO,EAE5DG,EAAkBD,EAAU,MAAQ,EAAKA,EAAU,OAASA,EAAU,MAAS,IAAM,EACrFE,EAAe,KAAK,oBAAoBD,EAAiBD,EAAU,OAAO,EAC1EG,EAAkB,KAAK,4BAA4BH,EAAWC,CAAe,EAEnF,MAAO,CACN,iBAAkBD,EAAU,MAC5B,kBAAmBA,EAAU,OAC7B,gBAAiBA,EAAU,KAC3B,gBAAiBA,EAAU,QAC3B,gBAAAC,EACA,kBAAmBD,EAAU,kBAC7B,aAAAE,EACA,gBAAAC,CAAA,CAEF,OAASd,EAAO,CACf,OAAAD,EAAO,MAAM,iCAAkC,CAAE,MAAAC,CAAA,CAAO,EAGjD,CACN,iBAAkB,EAClB,kBAAmB,EACnB,gBAAiB,EACjB,gBAAiB,EACjB,gBAAiB,EACjB,kBAAmB,EACnB,aAAc,WACd,gBAAiB,CAAC,mEAAmE,EAEvF,CACD,CAGA,MAAc,qBAAqBS,EAMhC,CAEF,OAAIA,EAAS,WAAW,aAAe,EAC/B,CACN,MAAO,EACP,OAAQ,EACR,KAAM,EACN,QAAS,EACT,kBAAmB,GAUH,CACjB,MAAO,GACP,OAAQ,EACR,KAAM,EACN,QAAS,EACT,kBAAmB,EAkCrB,CAGA,YAAgC,CAC/B,MAAMM,EAAS,KAAK,wBAA0B,KAAK,MAAQ,KAAK,wBAA0B,EAE1F,MAAO,CACN,GAAG,KAAK,QACR,iBAAkBA,CAAA,CAEpB,CAGA,MAAM,YAAYC,EAIf,CACF,GAAI,CACH,MAAMC,EAAU,MAAMD,EAAA,EAEhBE,EAAUD,EAAU,IACpBE,EAAUD,EAAU,8BAA8BD,CAAO,MAAQ,+BAA+BA,CAAO,MAE7G,MAAO,CAAE,QAAAC,EAAS,QAAAD,EAAS,QAAAE,CAAA,CAC5B,OAASnB,EAAO,CACf,MAAO,CACN,QAAS,GACT,QAAS,GACT,QAASA,aAAiB,MAAQA,EAAM,QAAU,sBAEpD,CACD,CAGQ,uBAA8B,CAErC,KAAK,mBAAqB,YAAY,IAAM,CAC3C,KAAK,wBACN,EAAG,GAAK,CACT,CAGA,MAAa,CACR,KAAK,qBACR,cAAc,KAAK,kBAAkB,EACrC,KAAK,mBAAqB,OAE5B,CAGQ,sBAAsBH,EAAyB,CACtD,MAAMuB,EAAmB,KAAK,IAC7B,KAAK,YAAY,eAAiB,KAAK,IAAI,KAAK,YAAY,kBAAmBvB,EAAU,CAAC,EAC1F,KAAK,YAAY,YAIZwB,EAAS,KAAK,SAAW,KAAK,YAAY,SAEhD,OAAO,KAAK,MAAMD,EAAmBC,CAAM,CAC5C,CAGQ,MAAMC,EAA2B,CACxC,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACxD,CAGQ,0BAA0BE,EAA+B,CAC5D,KAAK,QAAQ,sBAAwB,EACxC,KAAK,QAAQ,oBAAsBA,EAGnC,KAAK,QAAQ,oBAAsB,GAAMA,EAAkB,GAAM,KAAK,QAAQ,mBAEhF,CAGQ,wBAA+B,CAClC,KAAK,0BACR,KAAK,QAAQ,iBAAmB,KAAK,MAAQ,KAAK,wBAEpD,CAGQ,oBAAoBC,EAAqBC,EAAsD,CACtG,OAAIA,EAAU,IAAMD,EAAc,GAC1B,WAEJC,EAAU,GAAKD,EAAc,GACzB,WAED,SACR,CAGQ,4BAA4BE,EAAyEF,EAA+B,CAC3I,MAAMX,EAA4B,GAElC,OAAIW,EAAc,IACjBX,EAAgB,KAAK,wEAAwE,EAG1Fa,EAAM,QAAU,IACnBb,EAAgB,KAAK,GAAGa,EAAM,OAAO,gFAAgF,EAGlHA,EAAM,KAAOA,EAAM,MAAQ,IAC9Bb,EAAgB,KAAK,kFAAkF,EAGpGa,EAAM,MAAQ,IACjBb,EAAgB,KAAK,sEAAsE,EAGxFA,EAAgB,SAAW,GAC9BA,EAAgB,KAAK,iDAAiD,EAGhEA,CACR,CACD,CAgFA,IAAIc,EAAgD,KAE7C,SAASC,EAAsBrC,EAAmD,CACxF,OAAKoC,IACJA,EAAqB,IAAIrC,EAAmBC,CAAM,GAE5CoC,CACR","names":["DEFAULT_RETRY_CONFIG","DatabaseResilience","config","operation","operationName","onRetry","lastError","attempt","result","logger","error","delay","reconnectFn","notifyAdmins","startTime","failureRecord","updateServiceHealth","recoveryTime","dbError","mongoose","__vitePreload","poolStats","poolUtilization","healthStatus","recommendations","uptime","pingFn","latency","healthy","message","exponentialDelay","jitter","ms","resolve","newRecoveryTime","utilization","waiting","stats","resilienceInstance","getDatabaseResilience"],"ignoreList":[],"sources":["../../../../../../../../shared/database/src/DatabaseResilience.ts"],"sourcesContent":["/**\n * @file src/databases/DatabaseResilience.ts\n * @description Database resilience and self-healing system\n *\n * Features:\n * - Automatic retry with exponential backoff\n * - Self-healing database reconnection\n * - Connection pool diagnostics\n * - Admin notifications on failures\n * - Comprehensive error tracking\n */\n\nimport { logger } from '@shared/utils/logger';\nimport { updateServiceHealth, getSystemState } from '@shared/stores/system';\nimport type { DatabaseError } from './dbInterface';\n\n// Type definitions\nexport interface RetryConfig {\n\tmaxAttempts: number;\n\tinitialDelayMs: number;\n\tmaxDelayMs: number;\n\tbackoffMultiplier: number;\n\tjitterMs: number;\n}\n\nexport interface ConnectionPoolDiagnostics {\n\ttotalConnections: number;\n\tactiveConnections: number;\n\tidleConnections: number;\n\twaitingRequests: number;\n\tpoolUtilization: number;\n\tavgConnectionTime: number;\n\thealthStatus: 'healthy' | 'degraded' | 'critical';\n\trecommendations: string[];\n}\n\nexport interface ResilienceMetrics {\n\ttotalRetries: number;\n\tsuccessfulRetries: number;\n\tfailedRetries: number;\n\ttotalReconnections: number;\n\tsuccessfulReconnections: number;\n\tlastFailureTime?: number;\n\tlastRecoveryTime?: number;\n\taverageRecoveryTime: number;\n\tconnectionUptime: number;\n\tfailureHistory: Array<{\n\t\ttimestamp: number;\n\t\terror: string;\n\t\trecovered: boolean;\n\t\trecoveryTime?: number;\n\t}>;\n}\n\n// Default retry configuration\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n\tmaxAttempts: 5,\n\tinitialDelayMs: 1000, // 1 second\n\tmaxDelayMs: 32000, // 32 seconds\n\tbackoffMultiplier: 2,\n\tjitterMs: 500\n};\n\n/**\n * Database Resilience Manager\n * Handles automatic retries, reconnection, and health monitoring\n */\nexport class DatabaseResilience {\n\tprivate metrics: ResilienceMetrics = {\n\t\ttotalRetries: 0,\n\t\tsuccessfulRetries: 0,\n\t\tfailedRetries: 0,\n\t\ttotalReconnections: 0,\n\t\tsuccessfulReconnections: 0,\n\t\taverageRecoveryTime: 0,\n\t\tconnectionUptime: 0,\n\t\tfailureHistory: []\n\t};\n\n\tprivate retryConfig: RetryConfig;\n\tprivate isReconnecting = false;\n\tprivate connectionEstablishedAt?: number;\n\tprivate monitoringInterval?: NodeJS.Timeout;\n\n\tconstructor(config?: Partial<RetryConfig>) {\n\t\tthis.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...config };\n\t\tthis.startHealthMonitoring();\n\t}\n\n\t// Execute operation with automatic retry and exponential backoff\n\tasync executeWithRetry<T>(operation: () => Promise<T>, operationName: string, onRetry?: (attempt: number, error: Error) => void): Promise<T> {\n\t\tlet lastError: Error | undefined;\n\n\t\tfor (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {\n\t\t\ttry {\n\t\t\t\tconst result = await operation();\n\n\t\t\t\tif (attempt > 1) {\n\t\t\t\t\t// Operation succeeded after retry\n\t\t\t\t\tthis.metrics.successfulRetries++;\n\t\t\t\t\tlogger.info(`âœ“ Operation '${operationName}' succeeded after ${attempt} attempt(s)`);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error as Error;\n\t\t\t\tthis.metrics.totalRetries++;\n\n\t\t\t\tif (attempt < this.retryConfig.maxAttempts) {\n\t\t\t\t\tconst delay = this.calculateBackoffDelay(attempt);\n\n\t\t\t\t\tlogger.warn(`Operation '${operationName}' failed (attempt ${attempt}/${this.retryConfig.maxAttempts}), retrying in ${delay}ms...`, {\n\t\t\t\t\t\terror: lastError.message\n\t\t\t\t\t});\n\n\t\t\t\t\t// Call retry callback if provided\n\t\t\t\t\tif (onRetry) {\n\t\t\t\t\t\tonRetry(attempt, lastError);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this.sleep(delay);\n\t\t\t\t} else {\n\t\t\t\t\tthis.metrics.failedRetries++;\n\t\t\t\t\tlogger.error(`Operation '${operationName}' failed after ${this.retryConfig.maxAttempts} attempts`, { error: lastError.message });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow lastError || new Error(`Operation '${operationName}' failed after all retry attempts`);\n\t}\n\n\t// Attempt to reconnect to database with self-healing\n\tasync attemptReconnection(reconnectFn: () => Promise<void>, notifyAdmins: (error: DatabaseError) => Promise<void>): Promise<boolean> {\n\t\tif (this.isReconnecting) {\n\t\t\tlogger.debug('Reconnection already in progress, skipping...');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.isReconnecting = true;\n\t\tthis.metrics.totalReconnections++;\n\n\t\tconst startTime = Date.now();\n\t\tconst failureRecord = {\n\t\t\ttimestamp: startTime,\n\t\t\terror: 'Connection lost',\n\t\t\trecovered: false,\n\t\t\trecoveryTime: undefined as number | undefined\n\t\t};\n\n\t\ttry {\n\t\t\tupdateServiceHealth('database', 'initializing', 'Attempting database reconnection...');\n\n\t\t\tawait this.executeWithRetry(reconnectFn, 'Database Reconnection', (attempt, error) => {\n\t\t\t\tupdateServiceHealth('database', 'unhealthy', `Reconnection attempt ${attempt}/${this.retryConfig.maxAttempts} failed: ${error.message}`);\n\t\t\t});\n\n\t\t\tconst recoveryTime = Date.now() - startTime;\n\t\t\tfailureRecord.recovered = true;\n\t\t\tfailureRecord.recoveryTime = recoveryTime;\n\n\t\t\tthis.metrics.successfulReconnections++;\n\t\t\tthis.metrics.lastRecoveryTime = Date.now();\n\t\t\tthis.updateAverageRecoveryTime(recoveryTime);\n\t\t\tthis.connectionEstablishedAt = Date.now();\n\n\t\t\tupdateServiceHealth('database', 'healthy', 'Database reconnected successfully');\n\t\t\tlogger.info(`âœ“ Database reconnected successfully in ${recoveryTime}ms`);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconst dbError: DatabaseError = {\n\t\t\t\tcode: 'RECONNECTION_FAILED',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error',\n\t\t\t\tdetails: { attempts: this.retryConfig.maxAttempts }\n\t\t\t};\n\n\t\t\tthis.metrics.lastFailureTime = Date.now();\n\t\t\tupdateServiceHealth('database', 'unhealthy', 'Database reconnection failed', dbError.message);\n\n\t\t\t// Notify admins of persistent failure\n\t\t\tawait notifyAdmins(dbError);\n\n\t\t\tlogger.fatal('Database reconnection failed after all attempts', { error: dbError });\n\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tthis.metrics.failureHistory.push(failureRecord);\n\t\t\t// Keep only last 50 failure records\n\t\t\tif (this.metrics.failureHistory.length > 50) {\n\t\t\t\tthis.metrics.failureHistory = this.metrics.failureHistory.slice(-50);\n\t\t\t}\n\t\t\tthis.isReconnecting = false;\n\t\t}\n\t}\n\n\t/**\n\t * Get connection pool diagnostics\n\t * Fetches real-time statistics from MongoDB connection pool\n\t */\n\tasync getPoolDiagnostics(): Promise<ConnectionPoolDiagnostics> {\n\t\ttry {\n\t\t\t// Import mongoose dynamically to get pool stats\n\t\t\tconst mongoose = await import('mongoose');\n\n\t\t\t// Get connection pool stats from mongoose\n\t\t\tconst poolStats = await this.getMongoosePoolStats(mongoose.default);\n\n\t\t\tconst poolUtilization = poolStats.total > 0 ? (poolStats.active / poolStats.total) * 100 : 0;\n\t\t\tconst healthStatus = this.determinePoolHealth(poolUtilization, poolStats.waiting);\n\t\t\tconst recommendations = this.generatePoolRecommendations(poolStats, poolUtilization);\n\n\t\t\treturn {\n\t\t\t\ttotalConnections: poolStats.total,\n\t\t\t\tactiveConnections: poolStats.active,\n\t\t\t\tidleConnections: poolStats.idle,\n\t\t\t\twaitingRequests: poolStats.waiting,\n\t\t\t\tpoolUtilization,\n\t\t\t\tavgConnectionTime: poolStats.avgConnectionTime,\n\t\t\t\thealthStatus,\n\t\t\t\trecommendations\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to get pool diagnostics', { error });\n\n\t\t\t// Return default diagnostics on error\n\t\t\treturn {\n\t\t\t\ttotalConnections: 0,\n\t\t\t\tactiveConnections: 0,\n\t\t\t\tidleConnections: 0,\n\t\t\t\twaitingRequests: 0,\n\t\t\t\tpoolUtilization: 0,\n\t\t\t\tavgConnectionTime: 0,\n\t\t\t\thealthStatus: 'critical',\n\t\t\t\trecommendations: ['Unable to retrieve pool statistics - database may be disconnected']\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get MongoDB-specific pool statistics from mongoose connection\n\tprivate async getMongoosePoolStats(mongoose: typeof import('mongoose')): Promise<{\n\t\ttotal: number;\n\t\tactive: number;\n\t\tidle: number;\n\t\twaiting: number;\n\t\tavgConnectionTime: number;\n\t}> {\n\t\t// Check if connected\n\t\tif (mongoose.connection.readyState !== 1) {\n\t\t\treturn {\n\t\t\t\ttotal: 0,\n\t\t\t\tactive: 0,\n\t\t\t\tidle: 0,\n\t\t\t\twaiting: 0,\n\t\t\t\tavgConnectionTime: 0\n\t\t\t};\n\t\t}\n\n\t\t// Get pool stats from connection\n\t\t// Note: mongoose doesn't expose detailed pool stats directly\n\t\t// We'll use the connection config and infer from connection state\n\t\t// const client = mongoose.connection.getClient();\n\n\t\t// Try to get pool stats from MongoDB driver\n\t\tconst poolStats = {\n\t\t\ttotal: 50, // Default maxPoolSize from config\n\t\t\tactive: 0,\n\t\t\tidle: 0,\n\t\t\twaiting: 0,\n\t\t\tavgConnectionTime: 0\n\t\t};\n\n\t\ttry {\n\t\t\t// TODO: Revisit this code to get pool stats without accessing internal properties\n\t\t\t// // Access internal pool stats if available (MongoDB Node.js driver specific)\n\t\t\t// const topology = client?.topology;\n\t\t\t// if (topology && typeof topology.s === 'object') {\n\t\t\t// \tconst servers = topology.s.servers;\n\t\t\t// \tif (servers && servers.size > 0) {\n\t\t\t// \t\tconst serverArray = Array.from(servers.values());\n\t\t\t// \t\tconst firstServer = serverArray[0];\n\t\t\t// \t\tif (firstServer?.s?.pool) {\n\t\t\t// \t\t\tconst pool = firstServer.s.pool;\n\t\t\t// \t\t\t// Try to get current connections count\n\t\t\t// \t\t\tconst totalConnections = pool.totalConnectionCount || pool.s?.options?.maxPoolSize || 50;\n\t\t\t// \t\t\tconst availableConnections = pool.availableConnectionCount || 0;\n\t\t\t// \t\t\tconst pendingConnections = pool.pendingConnectionCount || 0;\n\t\t\t// \t\t\tpoolStats = {\n\t\t\t// \t\t\t\ttotal: totalConnections,\n\t\t\t// \t\t\t\tactive: totalConnections - availableConnections,\n\t\t\t// \t\t\t\tidle: availableConnections,\n\t\t\t// \t\t\t\twaiting: pendingConnections,\n\t\t\t// \t\t\t\tavgConnectionTime: 0 // Not available from pool\n\t\t\t// \t\t\t};\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t} catch (err) {\n\t\t\t// If we can't access internal stats, return defaults\n\t\t\tlogger.debug('Unable to access detailed MongoDB pool stats, using defaults', { error: err });\n\t\t}\n\n\t\treturn poolStats;\n\t}\n\n\t// Get resilience metrics\n\tgetMetrics(): ResilienceMetrics {\n\t\tconst uptime = this.connectionEstablishedAt ? Date.now() - this.connectionEstablishedAt : 0;\n\n\t\treturn {\n\t\t\t...this.metrics,\n\t\t\tconnectionUptime: uptime\n\t\t};\n\t}\n\n\t// Check if database connection is healthy\n\tasync healthCheck(pingFn: () => Promise<number>): Promise<{\n\t\thealthy: boolean;\n\t\tlatency: number;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst latency = await pingFn();\n\n\t\t\tconst healthy = latency < 1000; // Consider healthy if latency < 1s\n\t\t\tconst message = healthy ? `Database healthy (latency: ${latency}ms)` : `Database degraded (latency: ${latency}ms)`;\n\n\t\t\treturn { healthy, latency, message };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\thealthy: false,\n\t\t\t\tlatency: -1,\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Health check failed'\n\t\t\t};\n\t\t}\n\t}\n\n\t// Start continuous health monitoring\n\tprivate startHealthMonitoring(): void {\n\t\t// Monitor every 30 seconds\n\t\tthis.monitoringInterval = setInterval(() => {\n\t\t\tthis.updateConnectionUptime();\n\t\t}, 30000);\n\t}\n\n\t// Stop health monitoring (cleanup)\n\tstop(): void {\n\t\tif (this.monitoringInterval) {\n\t\t\tclearInterval(this.monitoringInterval);\n\t\t\tthis.monitoringInterval = undefined;\n\t\t}\n\t}\n\n\t// Calculate exponential backoff delay with jitter\n\tprivate calculateBackoffDelay(attempt: number): number {\n\t\tconst exponentialDelay = Math.min(\n\t\t\tthis.retryConfig.initialDelayMs * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1),\n\t\t\tthis.retryConfig.maxDelayMs\n\t\t);\n\n\t\t// Add random jitter to prevent thundering herd\n\t\tconst jitter = Math.random() * this.retryConfig.jitterMs;\n\n\t\treturn Math.floor(exponentialDelay + jitter);\n\t}\n\n\t// Sleep utility\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n\n\t// Update average recovery time with exponential moving average\n\tprivate updateAverageRecoveryTime(newRecoveryTime: number): void {\n\t\tif (this.metrics.averageRecoveryTime === 0) {\n\t\t\tthis.metrics.averageRecoveryTime = newRecoveryTime;\n\t\t} else {\n\t\t\t// EMA with alpha = 0.3\n\t\t\tthis.metrics.averageRecoveryTime = 0.3 * newRecoveryTime + 0.7 * this.metrics.averageRecoveryTime;\n\t\t}\n\t}\n\n\t// Update connection uptime\n\tprivate updateConnectionUptime(): void {\n\t\tif (this.connectionEstablishedAt) {\n\t\t\tthis.metrics.connectionUptime = Date.now() - this.connectionEstablishedAt;\n\t\t}\n\t}\n\n\t// Determine pool health status based on metrics\n\tprivate determinePoolHealth(utilization: number, waiting: number): 'healthy' | 'degraded' | 'critical' {\n\t\tif (waiting > 10 || utilization > 90) {\n\t\t\treturn 'critical';\n\t\t}\n\t\tif (waiting > 5 || utilization > 75) {\n\t\t\treturn 'degraded';\n\t\t}\n\t\treturn 'healthy';\n\t}\n\n\t// Generate recommendations based on pool stats\n\tprivate generatePoolRecommendations(stats: { total: number; active: number; idle: number; waiting: number }, utilization: number): string[] {\n\t\tconst recommendations: string[] = [];\n\n\t\tif (utilization > 90) {\n\t\t\trecommendations.push('Pool utilization is very high (>90%). Consider increasing maxPoolSize.');\n\t\t}\n\n\t\tif (stats.waiting > 10) {\n\t\t\trecommendations.push(`${stats.waiting} requests are waiting for connections. Increase pool size or optimize queries.`);\n\t\t}\n\n\t\tif (stats.idle > stats.total * 0.8) {\n\t\t\trecommendations.push('Pool has many idle connections. Consider reducing minPoolSize to save resources.');\n\t\t}\n\n\t\tif (stats.total < 10) {\n\t\t\trecommendations.push('Pool size is very small. Consider increasing for better concurrency.');\n\t\t}\n\n\t\tif (recommendations.length === 0) {\n\t\t\trecommendations.push('Connection pool is healthy and well-configured.');\n\t\t}\n\n\t\treturn recommendations;\n\t}\n}\n\n// Send email notification to administrators\nexport async function notifyAdminsOfDatabaseFailure(error: DatabaseError, metrics: ResilienceMetrics): Promise<void> {\n\ttry {\n\t\t// Check if SMTP is configured\n\t\tconst { getPrivateSetting } = await import(/* @vite-ignore */ '@shared/services/settingsService');\n\t\tconst smtpHost = await getPrivateSetting('SMTP_HOST');\n\n\t\tif (!smtpHost) {\n\t\t\tlogger.debug('SMTP not configured, skipping admin notification email');\n\t\t\treturn;\n\t\t}\n\n\t\t// Get admin users\n\t\t// Use relative path to avoid alias resolution issues\n\t\tconst { auth } = await import(/* @vite-ignore */ './db');\n\t\tif (!auth) {\n\t\t\tlogger.warn('Auth service not available, cannot fetch admin users for notification');\n\t\t\treturn;\n\t\t}\n\n\t\tconst allUsers = await auth.getAllUsers();\n\t\tconst adminUsers = allUsers.filter((user) => user.role === 'admin');\n\t\tif (!adminUsers || adminUsers.length === 0) {\n\t\t\tlogger.warn('No admin users found to notify');\n\t\t\treturn;\n\t\t}\n\n\t\t// Prepare email data\n\t\tconst { publicEnv } = await import(/* @vite-ignore */ '@shared/stores/globalSettings.svelte');\n\t\tconst systemState = getSystemState();\n\n\t\tconst emailData = {\n\t\t\tsubject: `ðŸš¨ Critical: Database Connection Failure - ${publicEnv.SITE_NAME || 'SveltyCMS'}`,\n\t\t\trecipientEmail: adminUsers.map((u) => u.email).filter(Boolean),\n\t\t\ttemplateName: 'databaseFailure',\n\t\t\tprops: {\n\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS',\n\t\t\t\terror: {\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tmessage: error.message,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t},\n\t\t\t\tmetrics: {\n\t\t\t\t\ttotalReconnections: metrics.totalReconnections,\n\t\t\t\t\tsuccessfulReconnections: metrics.successfulReconnections,\n\t\t\t\t\tfailedRetries: metrics.failedRetries,\n\t\t\t\t\taverageRecoveryTime: Math.round(metrics.averageRecoveryTime),\n\t\t\t\t\tlastFailureTime: metrics.lastFailureTime ? new Date(metrics.lastFailureTime).toISOString() : 'Unknown'\n\t\t\t\t},\n\t\t\t\tsystemState: {\n\t\t\t\t\toverall: systemState.overallState,\n\t\t\t\t\tdatabaseStatus: systemState.services.database.status,\n\t\t\t\t\tdatabaseMessage: systemState.services.database.message\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\thostLink: publicEnv.HOST_PROD || `http://localhost:5173`\n\t\t\t}\n\t\t};\n\n\t\t// Send email via API (server-side fetch)\n\t\tconst response = await fetch('/api/sendMail', {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\tbody: JSON.stringify(emailData)\n\t\t});\n\n\t\tif (response.ok) {\n\t\t\tlogger.info(`Database failure notification sent to ${adminUsers.length} admin(s)`);\n\t\t} else {\n\t\t\tlogger.error(`Failed to send database failure notification: ${response.status}`);\n\t\t}\n\t} catch (notificationError) {\n\t\tlogger.error('Error sending admin notification', { error: notificationError });\n\t\t// Don't throw - notification failure shouldn't block other operations\n\t}\n}\n\n// Global resilience instance (singleton)\nlet resilienceInstance: DatabaseResilience | null = null;\n\nexport function getDatabaseResilience(config?: Partial<RetryConfig>): DatabaseResilience {\n\tif (!resilienceInstance) {\n\t\tresilienceInstance = new DatabaseResilience(config);\n\t}\n\treturn resilienceInstance;\n}\n\nexport function resetDatabaseResilience(): void {\n\tif (resilienceInstance) {\n\t\tresilienceInstance.stop();\n\t\tresilienceInstance = null;\n\t}\n}\n"],"file":"CkjI6CfY.js"}