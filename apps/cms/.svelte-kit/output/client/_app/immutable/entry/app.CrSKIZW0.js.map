{"version":3,"mappings":"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","names":["asClassComponent","component","Svelte4Component","options","#events","#instance","sources","add_source","key","value","s","mutable_source","props","target","prop","get","LEGACY_PROPS","set","hydrate","mount","flushSync","define_property","next","unmount","event","callback","cb","args","fn","privateConfigSchema","object","union","literal","pipe","string","minLength","number","minValue","optional","boolean","array","publicConfigSchema","maxValue","INFRASTRUCTURE_KEYS","cache","getPrivateSettingSync","corePermissions","PermissionAction","PermissionType","permissionRegistry","permission","getAllPermissions","argon2","crypto","__vitePreload","n","error","logger","CacheCategory","browser","CACHE_CONFIG","getCacheConfig","USE_REDIS","REDIS_HOST","REDIS_PORT","REDIS_PASSWORD","InMemoryStore","now","item","ttlSeconds","expiresAt","k","pattern","regex","RedisStore","config","getDatabaseResilience","createClient","err","cursor","result","CacheService","baseKey","tenantId","accesses","keysToFetch","keys","fetcher","category","missingKeys","fullKey","dataMap","ttl","getCategoryTTL","REDIS_TTL_S","_category","finalTTL","keyPattern","data","count","lastAccess","totalInterval","i","avgInterval","analytics","cacheService","SESSION_CACHE_TTL_MS","DEFAULT_CATEGORY_TTLS","configKey","configuredTTL","dateToISODateString","IS_BROWSER","getEnv","fallback","v","publicEnv","LOG_LEVELS","DISABLED","LEVELS","RESET","maxPrio","l","ICONS","patterns","colorMessage","msg","out","re","color","formatValue","val","SENSITIVE","EMAILS","mask","depth","masked","low","e","local","domain","stream","modules","getMods","ensureStream","path","fs","dir","file","rotate","promises","zlib","sp","ts","rotated","src","dst","queue","timeout","flush","lines","icon","a","enqueue","level","argsStr","pretty","m","MetricsCounters","MetricsService","timeMs","hookName","current","uptime","safeRate","numerator","denominator","avgResponseTime","avgHookTime","bottlenecks","b","name","report","metricsService","cleanupMetrics","defaultHashFunction","subtleSha256","str","digest","nanoid","size","id","byte","CookieRateLimiter","currentId","userId","cookie","secretHash","IPRateLimiter","rate","IPUserAgentRateLimiter","ua","perf","isPosInt","isPosIntOrInf","TTLCache","max","updateAgeOnGet","checkAgeOnGet","noUpdateTTL","dispose","noDisposeOnSet","expiration","t","exp","entries","oldValue","_","__","ttlcache","TTLStore","maxTTL","maxItems","hash","currentRate","TTLTime","unit","RateLimiter","extraData","limited","plugin","index","mapPluginRates","limiter","IPRates","IPUARates","cookieRates","diff","acc","sessionCache","sessionId","strongRefs","lastRefreshAttempt","lastRotationAttempt","SESSION_ROTATION_INTERVAL_MS","timestamp","distributedStore","expires","newCount","matchers","components","$.prop","$$props","data_0","data_1","$.user_pre_effect","$.user_effect","mounted","$.state","navigated","title","onMount","unsubscribe","$.get","$.set","tick","Pyramid_1","Pyramid_0","Pyramid_0_1","$$anchor","Pyramid_1_1","$$value","Pyramid_0_2","$$render","consequent","alternate","div","root_4","consequent_1","consequent_2","root","Root","nodes","server_loads","dictionary","hooks","decoders","encoders","decode","type"],"ignoreList":[0,13,14,15,16,17,18,19,20,21],"sources":["../../../../../../../../node_modules/svelte/src/legacy/legacy-client.js","../../../../../../../../shared/database/src/schemas.ts","../../../../../../../../shared/services/src/settingsService.ts","../../../../../../../../shared/database/src/auth/corePermissions.ts","../../../../../../../../shared/database/src/auth/permissions.ts","../../../../../../../../shared/utils/src/crypto.ts","../../../../../../../../shared/database/src/CacheCategory.ts","../../../../../../../../shared/database/src/CacheService.ts","../../../../../../../../shared/database/src/themeManager.ts","../../../../../../../../shared/database/src/db.ts","../../../../../../../../shared/utils/src/logger.server.ts","../../../../../../../../shared/database/src/seed.ts","../../../../../../../../shared/services/src/MetricsService.ts","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/hashFunction.js","../../../../../../../../node_modules/.bun/nanoid@3.3.11/node_modules/nanoid/index.browser.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/limiters/cookieRateLimiter.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/limiters/ipRateLimiter.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/limiters/ipUaRateLimiter.js","../../../../../../../../node_modules/.bun/@isaacs+ttlcache@1.4.1/node_modules/@isaacs/ttlcache/index.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/stores/ttlStore.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/rate.js","../../../../../../../../node_modules/.bun/sveltekit-rate-limiter@0.7.0+fe0513b84f156ec4/node_modules/sveltekit-rate-limiter/dist/server/rateLimiter.js","../../../../../../src/hooks/handleAuthentication.ts","../../../../../../src/hooks/handleRateLimit.ts","../../../../../generated/client-optimized/matchers.js","../../../../../generated/root.svelte","../../../../../generated/root.js","../../../../../generated/client-optimized/app.js"],"sourcesContent":["/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { active_effect, get } from '../internal/client/runtime.js';\nimport { flushSync } from '../internal/client/reactivity/batch.js';\nimport { define_property, is_array } from '../internal/shared/utils.js';\nimport * as e from '../internal/client/errors.js';\nimport * as w from '../internal/client/warnings.js';\nimport { DEV } from 'esm-env';\nimport { FILENAME } from '../constants.js';\nimport { component_context, dev_current_component_function } from '../internal/client/context.js';\nimport { async_mode_flag } from '../internal/flags/index.js';\nimport { set_signal_status } from '../internal/client/reactivity/status.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Support using the component as both a class and function during the transition period\n * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType\n */\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value, false, false);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is incremented on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\t// Necessary to not throw \"invalid binding\" validation errors on the component side\n\t\t\t\t\tif (prop === LEGACY_PROPS) return true;\n\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tanchor: options.anchor,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\t// We don't flushSync for custom element wrappers or if the user doesn't want it,\n\t\t// or if we're in async mode since `flushSync()` will fail\n\t\tif (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {\n\t\t\tflushSync();\n\t\t}\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(() => {\n\t\tfn();\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\n\t\tif ((effect.f & DIRTY) !== 0) {\n\t\t\tlet filename = \"a file (we can't know which one)\";\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfilename = dev_current_component_function?.[FILENAME] ?? filename;\n\t\t\t}\n\t\t\tw.legacy_recursive_reactive_block(filename);\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t});\n}\n\n/**\n * Function to mimic the multiple listeners available in svelte 4\n * @deprecated\n * @param {EventListener[]} handlers\n * @returns {EventListener}\n */\nexport function handlers(...handlers) {\n\treturn function (event) {\n\t\tconst { stopImmediatePropagation } = event;\n\t\tlet stopped = false;\n\n\t\tevent.stopImmediatePropagation = () => {\n\t\t\tstopped = true;\n\t\t\tstopImmediatePropagation.call(event);\n\t\t};\n\n\t\tconst errors = [];\n\n\t\tfor (const handler of handlers) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error `this` is not typed\n\t\t\t\thandler?.call(this, event);\n\t\t\t} catch (e) {\n\t\t\t\terrors.push(e);\n\t\t\t}\n\n\t\t\tif (stopped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let error of errors) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\n */\nexport function createBubbler() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\te.lifecycle_outside_component('createBubbler');\n\t}\n\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\nexport {\n\tonce,\n\tpreventDefault,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted,\n\tpassive,\n\tnonpassive\n} from '../internal/client/dom/legacy/event-modifiers.js';\n","/**\n * @file src/databases/schemas.ts\n * @description Defines validation schemas for application configuration and base database structures.\n */\n\nimport type { BaseIssue, BaseSchema, InferOutput } from 'valibot';\nimport type { DatabaseId, ISODateString } from './dbInterface';\nimport { array, boolean, literal, maxValue, minLength, minValue, number, object, optional, pipe, safeParse, string, transform, union } from 'valibot';\nimport { logger } from '@shared/utils/logger';\n\n// ----------------- CONFIGURATION SCHEMAS -----------------\n\n// The PRIVATE configuration for the application.\nexport const privateConfigSchema = object({\n\t// --- Database configuration (Essential for startup) ---\n\tDB_TYPE: union([literal('mongodb'), literal('mongodb+srv'), literal('mariadb'), literal('')]),\n\tDB_HOST: pipe(string(), minLength(1, 'Database host is required.')),\n\tDB_PORT: pipe(number(), minValue(1)),\n\tDB_NAME: pipe(string(), minLength(1, 'Database name is required.')),\n\tDB_USER: string(),\n\tDB_PASSWORD: string(),\n\tDB_RETRY_ATTEMPTS: optional(pipe(number(), minValue(1))),\n\tDB_RETRY_DELAY: optional(pipe(number(), minValue(1))),\n\tDB_POOL_SIZE: optional(pipe(number(), minValue(1))),\n\n\t// --- JWT Secret (Essential for startup) ---\n\tJWT_SECRET_KEY: pipe(string(), minLength(32, 'JWT Secret Key must be at least 32 characters long for security.')),\n\n\t// --- Encryption Key (Essential for startup) ---\n\tENCRYPTION_KEY: pipe(string(), minLength(32, 'Encryption Key must be at least 32 characters long for security.')),\n\n\t// --- Multi-tenancy (Essential for startup) ---\n\tMULTI_TENANT: optional(boolean()),\n\tDEMO: optional(boolean()),\n\n\t// --- Licensing & Telemetry (BSL 1.1 Support) ---\n\tLICENSE_KEY: optional(string()), // For Enterprise users to disable nags/tracking\n\tSVELTYCMS_TELEMETRY: optional(boolean()), // Usage tracking (default: true)\n\n\t// --- Optional service toggles (populated dynamically post-startup) ---\n\tUSE_REDIS: optional(boolean()),\n\tREDIS_HOST: optional(pipe(string(), minLength(1))),\n\tREDIS_PORT: optional(pipe(number(), minValue(1))),\n\tREDIS_PASSWORD: optional(string()),\n\n\t// --- Cache TTL Configuration (in seconds) ---\n\tCACHE_TTL_SCHEMA: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_WIDGET: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_THEME: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_CONTENT: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_MEDIA: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_SESSION: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_USER: optional(pipe(number(), minValue(1))),\n\tCACHE_TTL_API: optional(pipe(number(), minValue(1))),\n\n\tGOOGLE_CLIENT_ID: optional(pipe(string(), minLength(1))),\n\tGOOGLE_CLIENT_SECRET: optional(pipe(string(), minLength(1))),\n\tGOOGLE_API_KEY: optional(pipe(string(), minLength(1))),\n\tSMTP_HOST: optional(pipe(string(), minLength(1))),\n\tSMTP_PORT: optional(pipe(number(), minValue(1))),\n\tSMTP_USER: optional(string()),\n\tSMTP_PASS: optional(string()),\n\tSMTP_MAIL_FROM: optional(string()),\n\tSMTP_EMAIL: optional(string()),\n\n\t// Roles schema\n\tROLES: optional(\n\t\tarray(\n\t\t\tobject({\n\t\t\t\t_id: pipe(string(), minLength(1)),\n\t\t\t\tname: pipe(string(), minLength(1)),\n\t\t\t\tdescription: optional(string()),\n\t\t\t\tpermissions: array(pipe(string(), minLength(1))),\n\t\t\t\tisAdmin: optional(boolean()),\n\t\t\t\ticon: optional(string()),\n\t\t\t\tcolor: optional(string())\n\t\t\t})\n\t\t)\n\t),\n\tMEDIA_FOLDER: optional(pipe(string(), minLength(1))),\n\n\t// --- Cloud Storage Credentials ---\n\tMEDIA_CLOUD_ACCESS_KEY: optional(pipe(string(), minLength(1))),\n\tMEDIA_CLOUD_SECRET_KEY: optional(pipe(string(), minLength(1))),\n\tMEDIA_CLOUDINARY_CLOUD_NAME: optional(pipe(string(), minLength(1))),\n\tMEDIA_CLOUDINARY_API_KEY: optional(pipe(string(), minLength(1))),\n\tMEDIA_CLOUDINARY_API_SECRET: optional(pipe(string(), minLength(1))),\n\n\tTWITCH_CLIENT_ID: optional(pipe(string(), minLength(1))),\n\tTWITCH_TOKEN: optional(pipe(string(), minLength(1))),\n\tTIKTOK_TOKEN: optional(pipe(string(), minLength(1))),\n\n\t// --- Firewall Configuration ---\n\tFIREWALL_ENABLED: optional(boolean()),\n\tFIREWALL_ALLOWED_BOTS: optional(array(string())),\n\tFIREWALL_BLOCKED_BOTS: optional(array(string()))\n});\n\n// The PUBLIC configuration for the application.\nexport const publicConfigSchema = object({\n\t// --- Host configuration ---\n\tHOST_DEV: pipe(string(), minLength(1)),\n\tHOST_PROD: pipe(string(), minLength(1)),\n\n\t// --- Site configuration ---\n\tSITE_NAME: pipe(string(), minLength(1)),\n\tPASSWORD_LENGTH: pipe(number(), minValue(8)),\n\n\t// --- Language Configuration ---\n\tDEFAULT_CONTENT_LANGUAGE: pipe(string(), minLength(1)),\n\tAVAILABLE_CONTENT_LANGUAGES: pipe(array(pipe(string(), minLength(1))), minLength(1)),\n\tBASE_LOCALE: pipe(string(), minLength(1)),\n\tLOCALES: pipe(array(pipe(string(), minLength(1))), minLength(1)),\n\n\t// --- Media configuration ---\n\tMEDIA_STORAGE_TYPE: union([literal('local'), literal('s3'), literal('r2'), literal('cloudinary')]),\n\tMEDIA_FOLDER: pipe(string(), minLength(1)),\n\tMEDIA_OUTPUT_FORMAT_QUALITY: object({\n\t\tformat: union([literal('original'), literal('jpg'), literal('webp'), literal('avif')]),\n\t\tquality: pipe(number(), minValue(1), maxValue(100))\n\t}),\n\tMEDIASERVER_URL: optional(string()),\n\tMEDIA_BUCKET_NAME: optional(pipe(string(), minLength(1))),\n\n\t// --- Cloud Storage Configuration ---\n\tMEDIA_CLOUD_REGION: optional(string()),\n\tMEDIA_CLOUD_ENDPOINT: optional(string()),\n\tMEDIA_CLOUD_PUBLIC_URL: optional(string()),\n\tIMAGE_SIZES: object({}),\n\tMAX_FILE_SIZE: optional(pipe(number(), minValue(1))),\n\tBODY_SIZE_LIMIT: optional(pipe(number(), minValue(1))),\n\tEXTRACT_DATA_PATH: optional(string()),\n\tUSE_ARCHIVE_ON_DELETE: optional(boolean()),\n\n\t// --- Seasons Icons ---\n\tSEASONS: optional(boolean()),\n\tSEASON_REGION: optional(union([literal('Western_Europe'), literal('South_Asia'), literal('East_Asia'), literal('Global')])),\n\n\t// --- Versioning ---\n\tPKG_VERSION: optional(string()),\n\n\t// --- Logging ---\n\tLOG_LEVELS: pipe(\n\t\tarray(union([literal('none'), literal('error'), literal('info'), literal('warn'), literal('debug'), literal('fatal'), literal('trace')])),\n\t\tminLength(1)\n\t),\n\tLOG_RETENTION_DAYS: optional(pipe(number(), minValue(1))),\n\tLOG_ROTATION_SIZE: optional(pipe(number(), minValue(1))),\n\n\t// --- Demo Mode ---\n\tUSE_GOOGLE_OAUTH: optional(boolean()),\n\tDEMO: optional(boolean())\n});\n\nexport const websiteTokenSchema = object({\n\t_id: pipe(\n\t\tstring(),\n\t\ttransform((input) => input as DatabaseId)\n\t) as BaseSchema<string, DatabaseId, BaseIssue<string>>,\n\tname: pipe(string(), minLength(1, 'Token name is required.')),\n\ttoken: pipe(string(), minLength(32)),\n\tcreatedAt: pipe(\n\t\tstring(),\n\t\ttransform((input) => input as ISODateString)\n\t) as BaseSchema<string, ISODateString, BaseIssue<string>>,\n\tupdatedAt: pipe(\n\t\tstring(),\n\t\ttransform((input) => input as ISODateString)\n\t) as BaseSchema<string, ISODateString, BaseIssue<string>>,\n\tcreatedBy: string()\n});\n\nexport const databaseConfigSchema = object({\n\ttype: union([literal('mongodb'), literal('mongodb+srv'), literal('mariadb')]),\n\thost: pipe(string(), minLength(1)),\n\tport: optional(pipe(number(), minValue(0))),\n\tname: pipe(string(), minLength(1)),\n\tuser: string(),\n\tpassword: string()\n});\n\n// ----------------- TYPES & HELPERS -----------------\nexport type DatabaseConfig = InferOutput<typeof databaseConfigSchema>;\nexport type PrivateConfig = InferOutput<typeof privateConfigSchema>;\nexport type WebsiteToken = InferOutput<typeof websiteTokenSchema>;\nexport type PublicConfig = InferOutput<typeof publicConfigSchema>;\n\n// --- DYNAMIC COLLECTION SCHEMAS ---\nexport const collectionSchemas = {\n\tNames: { name: 'Names', label: 'Names', fields: [] },\n\tRelation: { name: 'Relation', label: 'Relation', fields: [] },\n\tWidgetTest: { name: 'WidgetTest', label: 'WidgetTest', fields: [] }\n};\n\nexport const createPrivateConfig = (arg: PrivateConfig): PrivateConfig => arg;\nexport const createPublicConfig = (arg: PublicConfig): PublicConfig => arg;\n\n// ----------------- ENHANCED VALIDATION & LOGGING -----------------\nlet validationLogPrinted = false;\n\nconst colors = {\n\treset: '',\n\tred: '',\n\tgreen: '',\n\tyellow: '',\n\tblue: '',\n\tmagenta: '',\n\tcyan: '',\n\twhite: '',\n\tgray: ''\n};\n\nfunction formatPath(path: BaseIssue<unknown>['path']): string {\n\tif (!path || path.length === 0) return 'root';\n\treturn path.map((p) => String(p.key)).join('.');\n}\n\nfunction logValidationErrors(issues: BaseIssue<unknown>[], configFile: string): void {\n\tlogger.error(`\\n${colors.yellow} Invalid configuration in ${colors.cyan}${configFile}${colors.reset}`);\n\tissues.forEach((issue) => {\n\t\tconst fieldPath = formatPath(issue.path) || 'Configuration object';\n\t\tlogger.error(`\\n   - ${colors.white}Location:${colors.cyan} ${fieldPath}`);\n\t\tlogger.error(`     ${colors.red}Error: ${issue.message}${colors.reset}`);\n\t\tif (issue.input !== undefined) {\n\t\t\tlogger.error(`     ${colors.magenta}Received: ${colors.red}${JSON.stringify(issue.input)}${colors.reset}`);\n\t\t}\n\t});\n}\n\ninterface Config {\n\tUSE_2FA?: boolean;\n\tTWO_FACTOR_AUTH_BACKUP_CODES_COUNT?: number;\n\tUSE_GOOGLE_OAUTH?: boolean;\n\tGOOGLE_CLIENT_ID?: string;\n\tGOOGLE_CLIENT_SECRET?: string;\n\tUSE_REDIS?: boolean;\n\tREDIS_HOST?: string;\n\tREDIS_PORT?: number;\n\tUSE_MAPBOX?: boolean;\n\tMAPBOX_API_TOKEN?: string;\n\tUSE_TIKTOK?: boolean;\n\tTIKTOK_TOKEN?: string;\n\tSEASONS?: string[];\n\tSEASON_REGION?: string;\n\tAVAILABLE_CONTENT_LANGUAGES?: string[];\n\tDEFAULT_CONTENT_LANGUAGE?: string;\n\tLOCALES?: string[];\n\tBASE_LOCALE?: string;\n}\n\nfunction performConditionalValidation(config: Config): string[] {\n\tconst errors: string[] = [];\n\n\tif (config.USE_GOOGLE_OAUTH && (!config.GOOGLE_CLIENT_ID || !config.GOOGLE_CLIENT_SECRET)) {\n\t\terrors.push(`When USE_GOOGLE_OAUTH is true, both GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET are required.`);\n\t}\n\tif (config.USE_REDIS && (!config.REDIS_HOST || !config.REDIS_PORT)) {\n\t\terrors.push(`When USE_REDIS is true, both REDIS_HOST and REDIS_PORT are required.`);\n\t}\n\tif (config.USE_MAPBOX && !config.MAPBOX_API_TOKEN) {\n\t\terrors.push(`When USE_MAPBOX is true, a MAPBOX_API_TOKEN is required.`);\n\t}\n\tif (config.USE_TIKTOK && !config.TIKTOK_TOKEN) {\n\t\terrors.push(`When USE_TIKTOK is true, a TIKTOK_TOKEN is required.`);\n\t}\n\tif (\n\t\tconfig.USE_2FA &&\n\t\tconfig.TWO_FACTOR_AUTH_BACKUP_CODES_COUNT &&\n\t\t(config.TWO_FACTOR_AUTH_BACKUP_CODES_COUNT < 1 || config.TWO_FACTOR_AUTH_BACKUP_CODES_COUNT > 50)\n\t) {\n\t\terrors.push(`When USE_2FA is enabled, TWO_FACTOR_AUTH_BACKUP_CODES_COUNT must be between 1 and 50.`);\n\t}\n\tif (config.SEASONS && !config.SEASON_REGION) {\n\t\terrors.push(`When SEASONS is true, a SEASON_REGION must be selected.`);\n\t}\n\tif (\n\t\tconfig.DEFAULT_CONTENT_LANGUAGE &&\n\t\tconfig.AVAILABLE_CONTENT_LANGUAGES &&\n\t\t!config.AVAILABLE_CONTENT_LANGUAGES.includes(config.DEFAULT_CONTENT_LANGUAGE)\n\t) {\n\t\terrors.push(`The DEFAULT_CONTENT_LANGUAGE must be included in the AVAILABLE_CONTENT_LANGUAGES array.`);\n\t}\n\tif (config.BASE_LOCALE && config.LOCALES && Array.isArray(config.LOCALES) && config.LOCALES.includes(config.BASE_LOCALE)) {\n\t\terrors.push(`The BASE_LOCALE must be included in the LOCALES array.`);\n\t}\n\n\treturn errors;\n}\n\nexport function validateConfig(schema: BaseSchema<unknown, unknown, BaseIssue<unknown>>, config: unknown, configName: string): unknown {\n\tif (!validationLogPrinted) {\n\t\tlogger.info('Validating CMS configuration...');\n\t\tvalidationLogPrinted = true;\n\t}\n\n\tconst result = safeParse(schema, config, { abortEarly: false });\n\tconst configFile = configName.includes('Private') ? 'config/private.ts' : 'config/public.ts';\n\n\tif (result.success) {\n\t\tconst conditionalErrors = performConditionalValidation(result.output as Config);\n\t\tif (conditionalErrors.length > 0) {\n\t\t\tlogger.error(`${configName} validation failed with logical errors:`);\n\t\t\tconditionalErrors.forEach((error) => logger.error(`   - ${error}`));\n\t\t\tprocess.exit(1);\n\t\t}\n\t\treturn result.output;\n\t} else {\n\t\tlogger.error(`${configName} validation failed. Please check your configuration.`);\n\t\tlogValidationErrors(result.issues, configFile);\n\t\tprocess.exit(1);\n\t}\n}\n","/**\n * @file shared/services/src/settingsService.ts\n * @description Server-only settings cache and management\n *\n *  SECURITY: This file should NEVER be imported in client-side components\n * It handles both public AND private settings on the server only.\n *\n * ### Features\n * - Server-side cache for fast access\n * - Type-safe getters for public and private settings\n * - Database synchronization\n * - Settings import/export for admin operations\n */\n\nimport { privateConfigSchema, publicConfigSchema } from '@shared/database/schemas';\nimport { type InferOutput } from 'valibot';\nimport { logger } from '@shared/utils/logger';\n\ntype PrivateEnv = InferOutput<typeof privateConfigSchema>;\ntype PublicEnv = InferOutput<typeof publicConfigSchema> & { PKG_VERSION?: string };\n\n// Extract setting keys from schemas (single source of truth)\nconst KNOWN_PUBLIC_KEYS = Object.keys(publicConfigSchema.entries);\n\n// Infrastructure keys that come from config file, not database\nconst INFRASTRUCTURE_KEYS = new Set([\n\t'DB_TYPE',\n\t'DB_HOST',\n\t'DB_PORT',\n\t'DB_NAME',\n\t'DB_USER',\n\t'DB_PASSWORD',\n\t'DB_RETRY_ATTEMPTS',\n\t'DB_RETRY_DELAY',\n\t'DB_POOL_SIZE',\n\t'JWT_SECRET_KEY',\n\t'ENCRYPTION_KEY',\n\t'MULTI_TENANT'\n]);\n\nconst KNOWN_PRIVATE_KEYS = Object.keys(privateConfigSchema.entries).filter((key) => !INFRASTRUCTURE_KEYS.has(key));\n\n// Internal server-side cache (not reactive, plain objects)\nconst cache = {\n\tloaded: false,\n\tloadedAt: 0, // Timestamp for TTL\n\tprivate: {} as PrivateEnv,\n\tpublic: {} as PublicEnv,\n\tTTL: 5 * 60 * 1000 // 5 minutes TTL\n};\n\n// Memoized version loader\nlet pkgVersionPromise: Promise<string> | null = null;\nasync function loadPkgVersion(): Promise<string> {\n\tif (!pkgVersionPromise) {\n\t\tpkgVersionPromise = import('@root/package.json').then((pkg) => pkg.version || '0.0.0').catch(() => '0.0.0');\n\t}\n\treturn pkgVersionPromise;\n}\n\n/**\n * Loads settings from the database into the server-side cache if not already loaded.\n * Cache automatically invalidates after TTL (5 minutes) to prevent stale data.\n * This is the single source of truth on the server.\n */\nexport async function loadSettingsCache(): Promise<typeof cache> {\n\tconst now = Date.now();\n\n\t// Invalidate cache after TTL\n\tif (cache.loaded && now - cache.loadedAt > cache.TTL) {\n\t\tcache.loaded = false;\n\t\tlogger.debug('Settings cache invalidated (TTL expired)');\n\t}\n\n\tif (cache.loaded) {\n\t\treturn cache;\n\t}\n\n\ttry {\n\t\tconst { dbAdapter, getPrivateEnv } = await import('@shared/database/db');\n\n\t\t// Check if database adapter is available (might not be during setup)\n\t\tif (!dbAdapter?.systemPreferences) {\n\t\t\tlogger.warn('Database adapter not yet initialized, using empty settings cache');\n\t\t\t// Return an empty cache but mark it as loaded to prevent repeated warnings\n\t\t\tcache.loaded = true;\n\t\t\tcache.loadedAt = Date.now();\n\t\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\t\treturn cache;\n\t\t}\n\n\t\t// Load both public and private settings in parallel\n\t\tconst [publicResult, privateResult] = await Promise.all([\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PUBLIC_KEYS, 'system'),\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PRIVATE_KEYS, 'system')\n\t\t]);\n\n\t\tif (!publicResult.success) {\n\t\t\tthrow new Error(`Failed to load public settings: ${publicResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\t// Get public settings from database\n\t\tconst publicSettings = publicResult.data || {};\n\n\t\t// Get private settings from database (may be empty)\n\t\tconst privateDynamic = privateResult.success ? privateResult.data || {} : {};\n\n\t\t// Get private config settings (infrastructure settings)\n\t\t// Prefer in-memory config (set by initializeWithConfig) over filesystem import\n\t\t// This eliminates unnecessary file I/O and Vite cache dependency\n\t\tconst inMemoryConfig = getPrivateEnv();\n\n\t\tlet privateConfig: PrivateEnv;\n\t\tif (inMemoryConfig) {\n\t\t\t// Use in-memory config when available (post-setup, zero-restart mode)\n\t\t\tprivateConfig = inMemoryConfig;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t// Fall back to filesystem import (normal startup or first load)\n\t\t\t\tconst configModule = '@config/private';\n\t\t\t\tconst { privateEnv } = await import(/* @vite-ignore */ configModule);\n\t\t\t\tprivateConfig = privateEnv;\n\t\t\t} catch (error) {\n\t\t\t\t// Private config doesn't exist during setup - this is expected\n\t\t\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t});\n\t\t\t\t// During setup, allow private env to be empty but correctly typed\n\t\t\t\tprivateConfig = {} as PrivateEnv;\n\t\t\t}\n\t\t}\n\n\t\t// Merge: infrastructure settings from config + dynamic settings from DB\n\t\tconst mergedPrivate = {\n\t\t\t...privateConfig,\n\t\t\t...privateDynamic\n\t\t};\n\n\t\t// Update cache with merged data\n\t\tcache.private = mergedPrivate as PrivateEnv;\n\t\tcache.public = publicSettings as PublicEnv;\n\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\tcache.loaded = true;\n\t\tcache.loadedAt = Date.now(); // Track when cache was loaded\n\n\t\treturn cache;\n\t} catch (error) {\n\t\t// Log error but don't throw during initial load to prevent blocking server startup\n\t\tconst { logger } = await import('@shared/utils/logger');\n\t\tlogger.error('Failed to load settings cache:', error);\n\n\t\t// Return empty cache with PKG_VERSION to allow server to continue\n\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\tthrow error; // Re-throw for caller to handle\n\t}\n}\n\n/**\n * Invalidates the server-side cache, forcing a reload on the next request.\n * Call this after any database update to the settings.\n * Note: PKG_VERSION is preserved as it's read from package.json, not database.\n */\nexport async function invalidateSettingsCache(): Promise<void> {\n\tconst pkgVersion = await loadPkgVersion();\n\tcache.loaded = false;\n\tcache.loadedAt = 0; // Reset timestamp\n\tcache.private = {} as PrivateEnv;\n\tcache.public = { PKG_VERSION: pkgVersion } as PublicEnv;\n\tlogger.debug('Settings cache manually invalidated');\n}\n\n/**\n * Populates the settings cache with new values.\n * Used by loadSettingsFromDB in db.ts\n */\nexport async function setSettingsCache(newPrivate: PrivateEnv, newPublic: PublicEnv): Promise<void> {\n\tcache.private = newPrivate;\n\tcache.public = { ...newPublic, PKG_VERSION: await loadPkgVersion() };\n\tcache.loaded = true;\n}\n\n/**\n * Check if cache is loaded\n */\nexport function isCacheLoaded(): boolean {\n\treturn cache.loaded;\n}\n\n/**\n * Type-safe getter for a private setting (SERVER ONLY)\n */\nexport async function getPrivateSetting<K extends keyof PrivateEnv>(key: K): Promise<PrivateEnv[K]> {\n\tconst { private: privateEnv } = await loadSettingsCache();\n\treturn privateEnv[key];\n}\n\n/**\n * Type-safe getter for a public setting (SERVER ONLY)\n */\nexport async function getPublicSetting<K extends keyof PublicEnv>(key: K): Promise<PublicEnv[K]> {\n\tconst { public: publicEnv } = await loadSettingsCache();\n\treturn publicEnv[key];\n}\n\n/**\n * Gets a setting that is NOT defined in the schema (SERVER ONLY)\n * Use this as an escape hatch only when necessary. It's not type-safe.\n */\nexport async function getUntypedSetting<T = unknown>(key: string, scope?: 'public' | 'private'): Promise<T | undefined> {\n\tconst { public: publicEnv, private: privateEnv } = await loadSettingsCache();\n\n\tif (!scope || scope === 'public') {\n\t\tif ((publicEnv as Record<string, unknown>)[key] !== undefined) {\n\t\t\treturn (publicEnv as unknown as Record<string, T>)[key];\n\t\t}\n\t}\n\tif (!scope || scope === 'private') {\n\t\tif ((privateEnv as Record<string, unknown>)[key] !== undefined) {\n\t\t\treturn (privateEnv as unknown as Record<string, T>)[key];\n\t\t}\n\t}\n\treturn undefined;\n}\n\n/**\n * SYNCHRONOUS cache accessors for legacy compatibility.\n *  WARNING: These bypass the async loading pattern and can return empty values!\n *\n * These exist ONLY for:\n * - Module-level initialization (CacheService, googleAuth, etc.)\n * - Synchronous hooks that can't await\n *\n * In all other cases, prefer the async getters:\n * - Use getPublicSetting() for public settings\n * - Use getPrivateSetting() for private settings\n *\n * The cache must be pre-loaded via hooks.server.ts or these will return undefined!\n */\nexport function getPublicSettingSync<K extends keyof PublicEnv>(key: K): PublicEnv[K] {\n\treturn cache.public[key];\n}\n\nexport function getPrivateSettingSync<K extends keyof PrivateEnv>(key: K): PrivateEnv[K] {\n\treturn cache.private[key];\n}\n\n/**\n * Returns a merged view of all current settings for export.\n *\n *  SECURITY WARNING: This function exposes PRIVATE settings!\n * Only use this for:\n * - Server-side admin operations\n * - Authenticated admin export functionality\n * - System backup/restore operations\n */\nexport async function getAllSettings(): Promise<Record<string, unknown>> {\n\tconst { public: publicEnv, private: privateEnv } = await loadSettingsCache();\n\treturn {\n\t\tpublic: { ...publicEnv },\n\t\tprivate: { ...privateEnv }\n\t} as Record<string, unknown>;\n}\n\n/**\n * Applies a snapshot to the database via systemPreferences adapter.\n * Invalidates cache after successful update.\n */\nexport async function updateSettingsFromSnapshot(snapshot: Record<string, unknown>): Promise<{ updated: number }> {\n\tconst { dbAdapter } = await import('@shared/database/db');\n\tif (!dbAdapter?.systemPreferences) {\n\t\tthrow new Error('Database adapter not available');\n\t}\n\n\ttype SnapshotRecord = Record<string, unknown>;\n\ttype Snapshot = { settings?: SnapshotRecord } | SnapshotRecord;\n\tconst snap = snapshot as Snapshot;\n\tconst settings: SnapshotRecord = (snap as { settings?: SnapshotRecord }).settings ?? (snap as SnapshotRecord);\n\n\tconst ops: Array<{ key: string; value: unknown; scope: 'user' | 'system' }> = [];\n\n\tfunction isValueWrapper(v: unknown): v is { value: unknown } {\n\t\treturn typeof v === 'object' && v !== null && 'value' in (v as Record<string, unknown>);\n\t}\n\n\tfor (const [key, value] of Object.entries(settings)) {\n\t\tconst v = isValueWrapper(value) ? value.value : value;\n\t\tops.push({ key, value: v, scope: 'system' });\n\t}\n\n\tconst res = await dbAdapter.systemPreferences.setMany(ops);\n\tif (!res.success) {\n\t\tthrow new Error(res.error?.message || 'Failed to update settings');\n\t}\n\n\t// Invalidate cache so next access fetches fresh data\n\tinvalidateSettingsCache();\n\n\treturn { updated: ops.length };\n}\n","/**\n * @file src/databases/auth/corePermissions.ts\n * @description Core permissions configuration for the authentication system\n *\n * This file contains the core permission definitions that can be easily modified\n * without affecting the core authentication logic.\n *\n * Features:\n * - Defines a set of core permissions used throughout the system.\n * - Each permission has an ID, name, action, type, and optional context.\n * - Permissions cover system access, dashboard, user management, collections, API access, and more.\n *\n * This modular approach allows for easy extension and customization of permissions\n * as the application evolves.\n */\n\nimport { PermissionAction, PermissionType, type Permission } from './types';\n\n// Core permissions that are always available\nexport const corePermissions: Permission[] = [\n\t// System permissions\n\t{ _id: 'system:dashboard', name: 'Dashboard Access', action: PermissionAction.ACCESS, type: PermissionType.SYSTEM },\n\t{ _id: 'system:admin', name: 'Admin Access', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM },\n\t{ _id: 'system:settings', name: 'Settings Management', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM },\n\n\t// Dashboard resource permissions\n\t{ _id: 'dashboard:read', name: 'Dashboard Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'dashboard' },\n\t{ _id: 'dashboard:write', name: 'Dashboard Write Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'dashboard' },\n\t{ _id: 'dashboard:update', name: 'Dashboard Update Access', action: PermissionAction.UPDATE, type: PermissionType.SYSTEM, contextId: 'dashboard' },\n\n\t// SendMail resource permissions\n\t{ _id: 'sendMail:write', name: 'Send Mail Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'sendMail' },\n\n\t// Permissions management resource permissions\n\t{ _id: 'permissions:update', name: 'Update Permissions', action: PermissionAction.UPDATE, type: PermissionType.SYSTEM, contextId: 'permissions' },\n\n\t// System preferences resource permissions\n\t{\n\t\t_id: 'systemPreferences:read',\n\t\tname: 'Read System Preferences',\n\t\taction: PermissionAction.READ,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'systemPreferences'\n\t},\n\t{\n\t\t_id: 'systemPreferences:write',\n\t\tname: 'Write System Preferences',\n\t\taction: PermissionAction.WRITE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'systemPreferences'\n\t},\n\n\t// Search resource permissions\n\t{ _id: 'search:read', name: 'Search Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'search' },\n\n\t// GraphQL resource permissions\n\t{ _id: 'graphql:read', name: 'GraphQL API Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'graphql' },\n\n\t// Media resource permissions\n\t{ _id: 'media:read', name: 'Media Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'media' },\n\t{ _id: 'media:write', name: 'Media Write Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'media' },\n\t{ _id: 'media:delete', name: 'Media Delete Access', action: PermissionAction.DELETE, type: PermissionType.SYSTEM, contextId: 'media' },\n\n\t// User management permissions\n\t{ _id: 'user:create', name: 'User Create Access', action: PermissionAction.CREATE, type: PermissionType.SYSTEM, contextId: 'user' },\n\t{ _id: 'user:read', name: 'User Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'user' },\n\t{ _id: 'user:update', name: 'User Update Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'user' },\n\t{ _id: 'user:delete', name: 'User Delete Access', action: PermissionAction.DELETE, type: PermissionType.SYSTEM, contextId: 'user' },\n\n\t// --- NEW: Tenant management permissions (for multi-tenant mode) ---\n\t{ _id: 'tenant:create', name: 'Create Tenants', action: PermissionAction.CREATE, type: PermissionType.SYSTEM, contextId: 'tenant' },\n\t{ _id: 'tenant:read', name: 'Read Tenants', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'tenant' },\n\t{ _id: 'tenant:update', name: 'Update Tenants', action: PermissionAction.UPDATE, type: PermissionType.SYSTEM, contextId: 'tenant' },\n\t{ _id: 'tenant:delete', name: 'Delete Tenants', action: PermissionAction.DELETE, type: PermissionType.SYSTEM, contextId: 'tenant' },\n\t{ _id: 'tenant:manage', name: 'Manage Tenants', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM, contextId: 'tenant' }, // System resource permissions (used by tokens, themes, content-structure, etc.)\n\n\t{ _id: 'system:read', name: 'System Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'system' },\n\t{ _id: 'system:write', name: 'System Write Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'system' },\n\t{ _id: 'system:delete', name: 'System Delete Access', action: PermissionAction.DELETE, type: PermissionType.SYSTEM, contextId: 'system' },\n\n\t// Users resource permissions (used by avatar management, user listing, etc.)\n\t{ _id: 'users:read', name: 'Users Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'users' },\n\t{ _id: 'users:write', name: 'Users Write Access', action: PermissionAction.WRITE, type: PermissionType.SYSTEM, contextId: 'users' },\n\t{ _id: 'users:delete', name: 'Users Delete Access', action: PermissionAction.DELETE, type: PermissionType.SYSTEM, contextId: 'users' },\n\n\t// Collections management permissions\n\t{ _id: 'collections:read', name: 'Collections Read Access', action: PermissionAction.READ, type: PermissionType.SYSTEM, contextId: 'collections' },\n\t{\n\t\t_id: 'collections:write',\n\t\tname: 'Collections Write Access',\n\t\taction: PermissionAction.WRITE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'collections'\n\t},\n\t{\n\t\t_id: 'collections:create',\n\t\tname: 'Collections Create Access',\n\t\taction: PermissionAction.CREATE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'collections'\n\t},\n\t{\n\t\t_id: 'collections:update',\n\t\tname: 'Collections Update Access',\n\t\taction: PermissionAction.UPDATE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'collections'\n\t},\n\t{\n\t\t_id: 'collections:delete',\n\t\tname: 'Collections Delete Access',\n\t\taction: PermissionAction.DELETE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'collections'\n\t},\n\n\t// API permissions\n\t{ _id: 'api:graphql', name: 'GraphQL API Access', action: PermissionAction.ACCESS, type: PermissionType.SYSTEM },\n\t{ _id: 'api:collections', name: 'Collections API Access', action: PermissionAction.ACCESS, type: PermissionType.SYSTEM },\n\t{ _id: 'api:export', name: 'Export API Access', action: PermissionAction.EXECUTE, type: PermissionType.SYSTEM },\n\t{\n\t\t_id: 'api:user',\n\t\tname: 'User API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to all API endpoints under /api/user/.'\n\t},\n\t{\n\t\t_id: 'api:sendMail',\n\t\tname: 'Send Mail API Access',\n\t\taction: PermissionAction.EXECUTE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to send emails via the API.'\n\t},\n\t{ _id: 'api:exportData', name: 'Export Api Data', action: PermissionAction.EXECUTE, type: PermissionType.SYSTEM, contextId: 'api/exportData' },\n\t{\n\t\t_id: 'api:query',\n\t\tname: 'Query API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the query API endpoint.'\n\t},\n\t{\n\t\t_id: 'api:systemPreferences',\n\t\tname: 'System Preferences API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the system preferences API endpoints.'\n\t},\n\t{\n\t\t_id: 'api:systemInfo',\n\t\tname: 'System Info API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the system information API endpoints.'\n\t},\n\t{\n\t\t_id: 'api:userActivity',\n\t\tname: 'User Activity API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the user activity API endpoint for dashboard widgets.'\n\t},\n\t{\n\t\t_id: 'api:media',\n\t\tname: 'Media API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the media API endpoints.'\n\t},\n\t{\n\t\t_id: 'api:widgets',\n\t\tname: 'Widget API Access',\n\t\taction: PermissionAction.ACCESS,\n\t\ttype: PermissionType.SYSTEM,\n\t\tdescription: 'Grants access to the widget management API endpoints.'\n\t},\n\n\t// Collection permissions\n\t{ _id: 'collection:create', name: 'Create Collection Entries', action: PermissionAction.CREATE, type: PermissionType.COLLECTION },\n\t{ _id: 'collection:read', name: 'Read Collection Entries', action: PermissionAction.READ, type: PermissionType.COLLECTION },\n\t{ _id: 'collection:update', name: 'Update Collection Entries', action: PermissionAction.UPDATE, type: PermissionType.COLLECTION },\n\t{ _id: 'collection:delete', name: 'Delete Collection Entries', action: PermissionAction.DELETE, type: PermissionType.COLLECTION },\n\n\t// Content permissions\n\t{ _id: 'content:editor', name: 'Content Editor', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM },\n\t{ _id: 'content:builder', name: 'Content Builder', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM },\n\t{ _id: 'content:images', name: 'Image Management', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM },\n\n\t// User management permissions (consolidated)\n\t{ _id: 'user:manage', name: 'Manage Users', action: PermissionAction.MANAGE, type: PermissionType.USER },\n\t{\n\t\t_id: 'user.create',\n\t\tname: 'Create User Tokens',\n\t\taction: PermissionAction.CREATE,\n\t\ttype: PermissionType.USER,\n\t\tcontextId: 'user.create',\n\t\tdescription: 'Allows creating new user registration tokens.'\n\t},\n\n\t// Configuration permissions - matching your original permissionConfigs\n\t{\n\t\t_id: 'config:collectionManagement',\n\t\tname: 'Collection Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.CONFIGURATION,\n\t\tcontextId: 'config/collectionManagement'\n\t},\n\t{\n\t\t_id: 'config:collectionbuilder',\n\t\tname: 'Collection Builder Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'config/collectionbuilder'\n\t},\n\t{ _id: 'config:graphql', name: 'GraphQL Management', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM, contextId: 'config/graphql' },\n\t{\n\t\t_id: 'config:imageeditor',\n\t\tname: 'ImageEditor Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'config/imageeditor'\n\t},\n\t{\n\t\t_id: 'config:dashboard',\n\t\tname: 'Dashboard Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'config/dashboard'\n\t},\n\t{\n\t\t_id: 'config:widgetManagement',\n\t\tname: 'Widget Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.CONFIGURATION,\n\t\tcontextId: 'config/widgetManagement'\n\t},\n\t{\n\t\t_id: 'config:themeManagement',\n\t\tname: 'Theme Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.CONFIGURATION,\n\t\tcontextId: 'config/themeManagement'\n\t},\n\t{ _id: 'config:settings', name: 'Settings Management', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM, contextId: 'config/settings' },\n\t{\n\t\t_id: 'config:accessManagement',\n\t\tname: 'Access Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.CONFIGURATION,\n\t\tcontextId: 'config/accessManagement'\n\t},\n\t{\n\t\t_id: 'config:emailPreviews',\n\t\tname: 'Email Previews',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'config/emailPreviews'\n\t},\n\t{\n\t\t_id: 'config:adminArea',\n\t\tname: 'Admin Area Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.SYSTEM,\n\t\tcontextId: 'config/adminArea'\n\t},\n\n\t// Admin permissions\n\t{ _id: 'admin:access', name: 'Admin Access', action: PermissionAction.MANAGE, type: PermissionType.SYSTEM, contextId: 'admin/access' },\n\t{\n\t\t_id: 'config:importexport',\n\t\tname: 'Import/Export Management',\n\t\taction: PermissionAction.MANAGE,\n\t\ttype: PermissionType.CONFIGURATION,\n\t\tcontextId: 'config/import-export'\n\t}\n];\n","/**\n * @file src/databases/auth/permissions.ts\n * @description Permission utilities and checking functions\n *\n * This file contains utility functions for permission checking and management\n * that work with the simplified authentication system.\n */\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Auth\nimport type { User, Permission, Role } from './types';\nimport { corePermissions } from './corePermissions';\n\nexport interface PermissionConfig {\n\tcontextId: string;\n\tname: string;\n\taction: string;\n\tcontextType: string;\n\tdescription: string;\n}\n\n// Permission registry for dynamic permissions\nconst permissionRegistry = new Map<string, Permission>();\n\n// Initialize with core permissions\ncorePermissions.forEach((permission) => {\n\tpermissionRegistry.set(permission._id, permission);\n});\n\n// Register a new permission\nexport function registerPermission(permission: Permission): void {\n\tpermissionRegistry.set(permission._id, permission);\n\tlogger.trace(`Permission registered: ${permission._id}`);\n}\n\n// Get all registered permissions\nexport function getAllPermissions(): Permission[] {\n\treturn Array.from(permissionRegistry.values());\n}\n\n// Get a permission by ID\nexport function getPermissionById(permissionId: string): Permission | undefined {\n\treturn permissionRegistry.get(permissionId);\n}\n\n// Check if a user has a specific permission (with roles parameter to avoid circular dependency)\nexport function hasPermissionWithRoles(user: User, permissionId: string, roles: Role[]): boolean {\n\tconst userRole = roles.find((role) => role._id === user.role);\n\tif (!userRole) {\n\t\tlogger.warn('Role not found for user', { email: user.email, userRoleId: user.role, rolesAvailable: roles.map((r) => r._id) });\n\t\treturn false;\n\t}\n\n\t// ADMIN OVERRIDE: Admins automatically have ALL permissions\n\tif (userRole.isAdmin) {\n\t\tlogger.trace('Admin user granted permission', { email: user.email, permissionId, userRole });\n\t\treturn true;\n\t}\n\n\t// Check if user's role has the specific permission\n\tconst hasPermission = userRole.permissions.includes(permissionId);\n\tif (!hasPermission) {\n\t\tlogger.warn('Permission denied for user', {\n\t\t\temail: user.email,\n\t\t\tuserId: user._id,\n\t\t\tuserRoleId: user.role,\n\t\t\tuserRole,\n\t\t\tpermissionId,\n\t\t\tuserPermissions: userRole.permissions,\n\t\t\trolesAvailable: roles.map((r) => ({ id: r._id, isAdmin: r.isAdmin }))\n\t\t});\n\t}\n\tlogger.trace('Permission check for user', { permissionId, granted: hasPermission, email: user.email });\n\treturn hasPermission;\n}\n\n// Check if a user has permission by action and type\nexport function hasPermissionByAction(user: User, action: string, type: string, contextId?: string, userRoles?: Role[]): boolean {\n\t// If user is null, they don't have any permissions\n\tif (!user) {\n\t\treturn false;\n\t}\n\n\tlet roles: Role[] = userRoles || []; // If no roles provided, try to get them from a global location\n\tif (!userRoles) {\n\t\ttry {\n\t\t\t// Try to access roles from a different location\n\t\t\tif (typeof globalThis !== 'undefined' && (globalThis as unknown as { __ROLES_CACHE__?: Role[] }).__ROLES_CACHE__) {\n\t\t\t\troles = (globalThis as unknown as { __ROLES_CACHE__: Role[] }).__ROLES_CACHE__;\n\t\t\t} else {\n\t\t\t\t// Last resort - empty array\n\t\t\t\tlogger.warn('No roles available for permission check - defaulting to deny');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error: unknown) {\n\t\t\tlogger.error('Failed to load roles for hasPermissionByAction:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tconst userRole = roles.find((role) => role._id === user.role);\n\tif (!userRole) return false;\n\n\t// ADMIN OVERRIDE: Admins automatically have ALL permissions\n\tif (userRole.isAdmin) {\n\t\tlogger.trace('Admin user granted permission for action', { email: user.email, action, type });\n\t\treturn true;\n\t}\n\n\t// Find matching permission\n\tconst permission = Array.from(permissionRegistry.values()).find(\n\t\t(p) => p.action === action && p.type === type && (!contextId || p.contextId === contextId)\n\t);\n\n\tif (!permission) return false;\n\n\treturn userRole.permissions.includes(permission._id);\n}\n\n// Get permissions for a specific role (with roles parameter)\nexport function getRolePermissionsWithRoles(roleId: string, roles: Role[]): string[] {\n\tconst role = roles.find((r) => r._id === roleId);\n\treturn role?.permissions || [];\n}\n\n// Check if a role is admin (with roles parameter)\nexport function isAdminRoleWithRoles(roleId: string, roles: Role[]): boolean {\n\tconst role = roles.find((r) => r._id === roleId);\n\treturn role?.isAdmin === true;\n}\n\n// Legacy permission config compatibility - maps old config keys to new permission IDs\nexport function getPermissionConfig(configKey: string): PermissionConfig | null {\n\tconst configMap: Record<string, string> = {\n\t\tcollectionManagement: 'config:collectionManagement',\n\t\tcollectionbuilder: 'config:collectionbuilder',\n\t\tgraphql: 'config:graphql',\n\t\timageeditor: 'config:imageeditor',\n\t\tdashboard: 'config:dashboard',\n\t\twidgetManagement: 'config:widgetManagement',\n\t\tthemeManagement: 'config:themeManagement',\n\t\tsettings: 'config:settings',\n\t\taccessManagement: 'config:accessManagement',\n\t\tadminAccess: 'admin:access',\n\t\temailPreviews: 'config:emailPreviews',\n\t\tadminAreaPermissionConfig: 'config:adminArea',\n\t\texportData: 'api:exportData',\n\t\tapiUser: 'api:user',\n\t\tuserCreateToken: 'user.create'\n\t};\n\n\tconst permissionId = configMap[configKey];\n\tif (!permissionId) {\n\t\tlogger.warn('Unknown permission config key', { configKey });\n\t\treturn null;\n\t}\n\n\tconst permission = getPermissionById(permissionId);\n\tif (!permission) {\n\t\tlogger.warn('Permission not found for ID', { permissionId });\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tcontextId: permission.contextId || permissionId,\n\t\tname: permission.name,\n\t\taction: permission.action,\n\t\tcontextType: permission.type || '',\n\t\tdescription: permission.description ?? ''\n\t};\n}\n\n// Validate user permission from locals.permissions array\nexport function validateUserPermission(userPermissions: string[] | undefined, requiredPermission: string): boolean {\n\tif (!userPermissions) {\n\t\tlogger.warn('No user permissions provided for validation', { requiredPermission });\n\t\treturn false;\n\t}\n\n\tconst hasPermission = userPermissions.includes(requiredPermission);\n\tlogger.trace('User permission validation', { requiredPermission, granted: hasPermission });\n\treturn hasPermission;\n}\n\n// Legacy config map for compatibility\nexport const permissionConfigs: Record<string, { contextId: string; action: string; type: string; name: string; description: string }> = {\n\tcollectionManagement: {\n\t\tcontextId: 'config:collectionManagement',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Collection Management',\n\t\tdescription: 'Access to collection management'\n\t},\n\tcollectionbuilder: {\n\t\tcontextId: 'config:collectionbuilder',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Collection Builder',\n\t\tdescription: 'Access to collection builder'\n\t},\n\tgraphql: { contextId: 'config:graphql', action: 'read', type: 'config', name: 'GraphQL', description: 'Access to GraphQL interface' },\n\timageeditor: { contextId: 'config:imageeditor', action: 'read', type: 'config', name: 'Image Editor', description: 'Access to image editor' },\n\tdashboard: { contextId: 'config:dashboard', action: 'read', type: 'config', name: 'Dashboard', description: 'Access to dashboard' },\n\twidgetManagement: {\n\t\tcontextId: 'config:widgetManagement',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Widget Management',\n\t\tdescription: 'Access to widget management'\n\t},\n\tthemeManagement: {\n\t\tcontextId: 'config:themeManagement',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Theme Management',\n\t\tdescription: 'Access to theme management'\n\t},\n\tsettings: { contextId: 'config:settings', action: 'read', type: 'config', name: 'Settings', description: 'Access to settings' },\n\n\t// Fine-grained System Settings permissions (13 groups)\n\tsettingsCache: {\n\t\tcontextId: 'config:settings:cache',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Cache & Performance Settings',\n\t\tdescription: 'Manage cache TTLs and performance settings'\n\t},\n\tsettingsDatabase: {\n\t\tcontextId: 'config:settings:database',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Database Settings',\n\t\tdescription: 'Manage database and MongoDB settings'\n\t},\n\tsettingsRedis: {\n\t\tcontextId: 'config:settings:redis',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Redis Cache Settings',\n\t\tdescription: 'Manage Redis configuration and connection'\n\t},\n\tsettingsEmail: {\n\t\tcontextId: 'config:settings:email',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Email/SMTP Settings',\n\t\tdescription: 'Manage email server and SMTP configuration'\n\t},\n\tsettingsSecurity: {\n\t\tcontextId: 'config:settings:security',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Security Settings',\n\t\tdescription: 'Manage 2FA, session, and security settings'\n\t},\n\tsettingsOAuth: {\n\t\tcontextId: 'config:settings:oauth',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'OAuth & Social Login',\n\t\tdescription: 'Manage Google OAuth and social login'\n\t},\n\tsettingsMedia: {\n\t\tcontextId: 'config:settings:media',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Media Storage Settings',\n\t\tdescription: 'Manage media folder, sizes, and formats'\n\t},\n\tsettingsLanguages: {\n\t\tcontextId: 'config:settings:languages',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Languages & Localization',\n\t\tdescription: 'Manage content languages and locales'\n\t},\n\tsettingsIntegrations: {\n\t\tcontextId: 'config:settings:integrations',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Third-Party Integrations',\n\t\tdescription: 'Manage MapBox, TikTok, Twitch integrations'\n\t},\n\tsettingsSite: {\n\t\tcontextId: 'config:settings:site',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Site Configuration',\n\t\tdescription: 'Manage site name, URLs, and basic config'\n\t},\n\tsettingsAppearance: {\n\t\tcontextId: 'config:settings:appearance',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Appearance Settings',\n\t\tdescription: 'Manage default theme and appearance'\n\t},\n\tsettingsLogging: {\n\t\tcontextId: 'config:settings:logging',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Logging Settings',\n\t\tdescription: 'Manage log levels, retention, and rotation'\n\t},\n\tsettingsAdvanced: {\n\t\tcontextId: 'config:settings:advanced',\n\t\taction: 'manage',\n\t\ttype: 'config',\n\t\tname: 'Advanced Settings',\n\t\tdescription: 'Manage server port, roles, permissions, and demo mode'\n\t},\n\n\taccessManagement: {\n\t\tcontextId: 'config:accessManagement',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Access Management',\n\t\tdescription: 'Access to user management'\n\t},\n\tadminAccess: { contextId: 'admin:access', action: 'read', type: 'admin', name: 'Admin Access', description: 'Administrative access' },\n\temailPreviews: {\n\t\tcontextId: 'config:emailPreviews',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Email Previews',\n\t\tdescription: 'Access to email previews'\n\t},\n\tadminAreaPermissionConfig: {\n\t\tcontextId: 'config:adminArea',\n\t\taction: 'read',\n\t\ttype: 'config',\n\t\tname: 'Admin Area',\n\t\tdescription: 'Access to admin area'\n\t},\n\texportData: { contextId: 'api:exportData', action: 'export', type: 'api', name: 'Export Data', description: 'Export system data' },\n\tapiUser: { contextId: 'api:user', action: 'read', type: 'api', name: 'User API', description: 'Access to user API' },\n\tuserCreateToken: {\n\t\tcontextId: 'user.create',\n\t\taction: 'create',\n\t\ttype: 'user',\n\t\tname: 'Create User Token',\n\t\tdescription: 'Create user registration tokens'\n\t},\n\tuserManage: {\n\t\tcontextId: 'user:manage',\n\t\taction: 'manage',\n\t\ttype: 'user',\n\t\tname: 'User Management',\n\t\tdescription: 'Manage user accounts and roles'\n\t}\n};\n\n// Export permissions array for compatibility\nexport const permissions = getAllPermissions();\n\n// Convenience functions for common operations\nexport function checkPermissions(user: User, permissionIds: string[], roles: Role[]): boolean {\n\treturn permissionIds.every((permissionId) => hasPermissionWithRoles(user, permissionId, roles));\n}\n\nexport function getUserRole(user: User, roles: Role[]): Role | undefined {\n\treturn roles.find((role) => role._id === user.role);\n}\n\nexport function getUserRoles(user: User, roles: Role[]): Role[] {\n\tconst userRole = getUserRole(user, roles);\n\treturn userRole ? [userRole] : [];\n}\n","/**\n * @file src/utils/crypto.ts\n * @description Enterprise-grade cryptography utilities using Argon2 for key derivation\n *\n * QUANTUM COMPUTING SECURITY NOTICE:\n * ==================================\n * This module is designed with quantum resistance in mind:\n *\n * - Argon2id: Memory-hard algorithm that resists quantum speedup (quantum computers\n *   don't have memory advantages over classical computers)\n * - AES-256-GCM: Even with Grover's algorithm reducing it to 128-bit quantum security,\n *   2^128 operations remain computationally infeasible\n * - No RSA/ECC: We don't use public-key cryptography vulnerable to Shor's algorithm\n *\n * Current Status: SECURE against quantum threats for next 15-30+ years\n * Migration Path: Plan to add CRYSTALS-Kyber/Dilithium (NIST PQC standards) around 2030\n *\n * This module provides:\n * - Password hashing with Argon2id (winner of Password Hashing Competition)\n * - Key derivation from passwords using Argon2 (more secure than PBKDF2)\n * - AES-256-GCM encryption/decryption with Argon2-derived keys\n * - Secure random token generation\n * - SHA256 checksum generation for data integrity\n *\n * @see https://csrc.nist.gov/projects/post-quantum-cryptography for PQC updates\n */\n\nimport { logger } from '@shared/utils/logger';\n\n// Import argon2 and crypto (server-side only)\nlet argon2: typeof import('argon2') | null = null;\nlet crypto: typeof import('crypto') | null = null;\n\nif (typeof window === 'undefined') {\n\ttry {\n\t\targon2 = await import('argon2');\n\t\tcrypto = await import('crypto');\n\t} catch (error) {\n\t\tlogger.error('Failed to load cryptographic modules', { error });\n\t}\n}\n\n/**\n * Argon2 configuration for enterprise security\n *\n * QUANTUM RESISTANCE NOTES:\n * - Argon2 is inherently quantum-resistant due to its memory-hard property\n * - Grover's algorithm doesn't provide significant speedup for memory-bound operations\n * - The 64 MB memory requirement per hash limits quantum computer advantages\n * - Quantum computers excel at computation, not memory access patterns\n *\n * These settings provide a good balance between security and performance\n * while maintaining strong resistance against both classical and quantum attacks.\n */\nexport const argon2Config = {\n\t// Memory cost in KiB (64 MB) - Makes attacks expensive even with quantum computers\n\tmemory: 65536,\n\t// Time cost (number of iterations) - Adds computational complexity\n\ttime: 3,\n\t// Parallelism factor (number of threads) - Optimizes for modern CPUs\n\tparallelism: 4,\n\t// Use Argon2id (hybrid version - best for most use cases)\n\ttype: 2 as const, // argon2id\n\t// Output hash length in bytes\n\thashLength: 32\n};\n\n// AES-256-GCM encryption configuration\n// QUANTUM RESISTANCE: AES-256 provides 128-bit quantum security (Grover's algorithm)\n// which is still computationally infeasible (2^128 operations = billions of years)\nexport const encryptionConfig = {\n\talgorithm: 'aes-256-gcm' as const,\n\tkeyLength: 32, // 256 bits (128-bit quantum security)\n\tivLength: 16, // 128 bits\n\tsaltLength: 32, // 256 bits (128-bit quantum security)\n\tauthTagLength: 16 // 128 bits (provides data integrity)\n};\n\n/**\n * Hash a password using Argon2id\n *\n * @param password - Plain text password to hash\n * @returns Promise resolving to hashed password\n * @throws Error if argon2 is not available\n */\nexport async function hashPassword(password: string): Promise<string> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\treturn argon2.hash(password, {\n\t\t...argon2Config,\n\t\ttype: argon2.argon2id\n\t});\n}\n\n/**\n * Verify a password against its hash using Argon2\n *\n * @param password - Plain text password to verify\n * @param hash - Hashed password to compare against\n * @returns Promise resolving to true if password matches\n * @throws Error if argon2 is not available\n */\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\treturn argon2.verify(hash, password);\n}\n\n/**\n * Derive a cryptographic key from a password using Argon2\n * This is more secure than PBKDF2 for key derivation\n *\n * QUANTUM RESISTANCE:\n * Argon2's memory-hard property makes it quantum-resistant because:\n * 1. Quantum computers don't have memory advantages (limited qubits)\n * 2. Memory access patterns can't be parallelized effectively by quantum algorithms\n * 3. Grover's algorithm doesn't help with memory-bound operations\n *\n * This makes Argon2 an excellent choice for long-term key derivation security.\n *\n * @param password - Password to derive key from\n * @param salt - Salt for key derivation (should be unique per encryption)\n * @returns Promise resolving to derived key buffer\n * @throws Error if argon2 is not available\n */\nexport async function deriveKey(password: string, salt: Buffer): Promise<Buffer> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\t// Use Argon2 to derive a raw key (not encoded)\n\tconst hash = await argon2.hash(password, {\n\t\t...argon2Config,\n\t\ttype: argon2.argon2id,\n\t\tsalt,\n\t\traw: true\n\t});\n\n\t// Ensure key is exactly 32 bytes for AES-256\n\treturn Buffer.from(hash).subarray(0, encryptionConfig.keyLength);\n}\n\n/**\n * Encrypt data using AES-256-GCM with Argon2-derived key\n *\n * QUANTUM RESISTANCE:\n * - AES-256: Even with Grover's algorithm, maintains 128-bit quantum security\n * - GCM mode: Provides authenticated encryption (integrity + confidentiality)\n * - Argon2 key derivation: Quantum-resistant due to memory-hard property\n *\n * This combination provides strong security against both classical and quantum attacks.\n * For ultra-long-term storage (20+ years), consider adding post-quantum key encapsulation\n * (CRYSTALS-Kyber) in hybrid mode once NIST standards are widely implemented.\n *\n * @param data - Data object to encrypt\n * @param password - Password to derive encryption key from\n * @returns Base64-encoded encrypted data (salt + iv + authTag + ciphertext)\n * @throws Error if crypto modules are not available\n */\nexport async function encryptData(data: Record<string, unknown>, password: string): Promise<string> {\n\tif (!crypto || !argon2) {\n\t\tthrow new Error('Crypto modules not available - server-side only');\n\t}\n\n\t// Generate random salt and IV\n\tconst salt = crypto.randomBytes(encryptionConfig.saltLength);\n\tconst iv = crypto.randomBytes(encryptionConfig.ivLength);\n\n\t// Derive key using Argon2 (more secure than PBKDF2)\n\tconst key = await deriveKey(password, salt);\n\n\t// Create cipher\n\tconst cipher = crypto.createCipheriv(encryptionConfig.algorithm, key, iv);\n\n\t// Encrypt data\n\tconst plaintext = JSON.stringify(data);\n\tconst encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);\n\n\t// Get authentication tag\n\tconst authTag = cipher.getAuthTag();\n\n\t// Combine: salt + iv + authTag + encrypted data\n\tconst combined = Buffer.concat([salt, iv, authTag, encrypted]);\n\n\tlogger.debug('Data encrypted successfully', {\n\t\tsaltLength: salt.length,\n\t\tivLength: iv.length,\n\t\tauthTagLength: authTag.length,\n\t\tencryptedLength: encrypted.length\n\t});\n\n\treturn combined.toString('base64');\n}\n\n/**\n * Decrypt data using AES-256-GCM with Argon2-derived key\n *\n * @param encryptedData - Base64-encoded encrypted data\n * @param password - Password to derive decryption key from\n * @returns Decrypted data object\n * @throws Error if decryption fails or password is incorrect\n */\nexport async function decryptData(encryptedData: string, password: string): Promise<Record<string, unknown>> {\n\tif (!crypto || !argon2) {\n\t\tthrow new Error('Crypto modules not available - server-side only');\n\t}\n\n\ttry {\n\t\t// Decode base64\n\t\tconst combined = Buffer.from(encryptedData, 'base64');\n\n\t\t// Extract components\n\t\tlet offset = 0;\n\t\tconst salt = combined.subarray(offset, offset + encryptionConfig.saltLength);\n\t\toffset += encryptionConfig.saltLength;\n\n\t\tconst iv = combined.subarray(offset, offset + encryptionConfig.ivLength);\n\t\toffset += encryptionConfig.ivLength;\n\n\t\tconst authTag = combined.subarray(offset, offset + encryptionConfig.authTagLength);\n\t\toffset += encryptionConfig.authTagLength;\n\n\t\tconst encrypted = combined.subarray(offset);\n\n\t\t// Derive key using same password and salt\n\t\tconst key = await deriveKey(password, salt);\n\n\t\t// Create decipher\n\t\tconst decipher = crypto.createDecipheriv(encryptionConfig.algorithm, key, iv);\n\t\tdecipher.setAuthTag(authTag);\n\n\t\t// Decrypt data\n\t\tconst decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);\n\n\t\tlogger.debug('Data decrypted successfully', {\n\t\t\tdecryptedLength: decrypted.length\n\t\t});\n\n\t\treturn JSON.parse(decrypted.toString('utf8'));\n\t} catch (error) {\n\t\tlogger.error('Decryption failed', { error });\n\t\tthrow new Error('Failed to decrypt data. Password may be incorrect or data corrupted.');\n\t}\n}\n\n/**\n * Creates a SHA256 checksum for any given data object.\n * Useful for data integrity checks and detecting changes.\n *\n * @param data - The data to hash (will be stringified).\n * @returns A hex-encoded SHA256 hash.\n * @throws Error if crypto is not available.\n */\nexport function createChecksum(data: unknown): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\tconst str = JSON.stringify(data);\n\treturn crypto.createHash('sha256').update(str).digest('hex');\n}\n\n/**\n * Generate a secure random token\n *\n * @param length - Length of token in bytes (default: 32)\n * @returns Hex-encoded random token\n * @throws Error if crypto is not available\n */\nexport function generateRandomToken(length: number = 32): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\n\treturn crypto.randomBytes(length).toString('hex');\n}\n\n/**\n * Generate a secure random UUID\n *\n * @returns UUID string\n * @throws Error if crypto is not available\n */\nexport function generateUUID(): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\n\treturn crypto.randomUUID();\n}\n\n/**\n * Check if cryptographic modules are available\n *\n * @returns True if crypto and argon2 are available\n */\nexport function isCryptoAvailable(): boolean {\n\treturn crypto !== null && argon2 !== null;\n}\n","/**\n * @file src/databases/CacheCategory.ts\n * @description Cache category enum - isomorphic (safe for both client and server)\n * Extracted from CacheService.ts to prevent Redis imports in client code\n */\n\nexport enum CacheCategory {\n\tSCHEMA = 'schema',\n\tWIDGET = 'widget',\n\tTHEME = 'theme',\n\tCONTENT = 'content',\n\tMEDIA = 'media',\n\tSESSION = 'session',\n\tUSER = 'user',\n\tAPI = 'api'\n}\n","/**\n * @file src/databases/CacheService.ts\n * @description Unified caching service for the CMS (in-memory or Redis), with optional tenant-aware keys.\n *\n * Features:\n * - Dynamic cache store selection based on environment configuration\n * - In-memory caching for development and testing\n * - Redis caching for production\n * - Tenant-aware keys for multi-tenant environments\n */\n\n// Safe import for test environment\nlet browser = false;\ntry {\n\tconst appEnv = await import('$app/environment');\n\tbrowser = appEnv.browser;\n} catch {\n\t// Running in test environment or outside SvelteKit context\n\tbrowser = false;\n}\n\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport type { RedisClientType } from 'redis';\n// System Logger - use universal logger for client/server compatibility\nimport { logger } from '@shared/utils/logger';\nimport { CacheCategory } from './CacheCategory';\n\n// Cache config will be loaded lazily when cache is initialized\nlet CACHE_CONFIG: {\n\tUSE_REDIS: boolean;\n\tURL: string;\n\tPASSWORD?: string;\n\tRETRY_ATTEMPTS: number;\n\tRETRY_DELAY: number;\n} | null = null;\n\nfunction getCacheConfig() {\n\tif (!CACHE_CONFIG) {\n\t\tconst USE_REDIS = getPrivateSettingSync('USE_REDIS');\n\t\tconst REDIS_HOST = getPrivateSettingSync('REDIS_HOST');\n\t\tconst REDIS_PORT = getPrivateSettingSync('REDIS_PORT');\n\t\tconst REDIS_PASSWORD = getPrivateSettingSync('REDIS_PASSWORD');\n\n\t\tCACHE_CONFIG = {\n\t\t\tUSE_REDIS: USE_REDIS === true, // Ensure boolean type\n\t\t\tURL: `redis://${REDIS_HOST}:${REDIS_PORT}`,\n\t\t\tPASSWORD: REDIS_PASSWORD || undefined,\n\t\t\tRETRY_ATTEMPTS: 3,\n\t\t\tRETRY_DELAY: 2000\n\t\t};\n\t}\n\treturn CACHE_CONFIG;\n}\n\ninterface ICacheStore {\n\tinitialize(): Promise<void>;\n\tget<T>(key: string): Promise<T | null>;\n\tset<T>(key: string, value: T, ttlSeconds: number): Promise<void>;\n\tdelete(key: string | string[]): Promise<void>;\n\tclearByPattern(pattern: string): Promise<void>;\n\tdisconnect(): Promise<void>;\n\tgetClient(): RedisClientType | null;\n}\n\nclass InMemoryStore implements ICacheStore {\n\tprivate cache = new Map<string, { value: string; expiresAt: number }>();\n\tprivate isInitialized = false;\n\tprivate interval: ReturnType<typeof setInterval> | null = null;\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.isInitialized) return;\n\t\tthis.interval = setInterval(() => this.cleanup(), 60_000);\n\t\tthis.isInitialized = true;\n\t\tlogger.info('In-memory cache initialized.');\n\t}\n\n\tprivate cleanup() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, item] of this.cache.entries()) {\n\t\t\tif (item.expiresAt < now) this.cache.delete(key);\n\t\t}\n\t}\n\n\tasync get<T>(key: string): Promise<T | null> {\n\t\tconst item = this.cache.get(key);\n\t\tif (!item) return null;\n\t\tif (item.expiresAt < Date.now()) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn null;\n\t\t}\n\t\treturn JSON.parse(item.value) as T;\n\t}\n\n\tasync set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {\n\t\tconst expiresAt = Date.now() + ttlSeconds * 1000;\n\t\tthis.cache.set(key, { value: JSON.stringify(value), expiresAt });\n\t}\n\n\tasync delete(key: string | string[]): Promise<void> {\n\t\tconst keys = Array.isArray(key) ? key : [key];\n\t\tkeys.forEach((k) => this.cache.delete(k));\n\t}\n\n\tasync clearByPattern(pattern: string): Promise<void> {\n\t\tconst regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n\t\tfor (const key of this.cache.keys()) {\n\t\t\tif (regex.test(key)) this.cache.delete(key);\n\t\t}\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tthis.cache.clear();\n\t\tif (this.interval) clearInterval(this.interval);\n\t\tlogger.info('In-memory cache cleared.');\n\t}\n\n\tgetClient(): RedisClientType | null {\n\t\treturn null;\n\t}\n}\n\nclass RedisStore implements ICacheStore {\n\tprivate client: RedisClientType | null = null;\n\tprivate isInitialized = false;\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.isInitialized || browser) return;\n\t\tconst config = getCacheConfig();\n\t\tif (!config) {\n\t\t\tthrow new Error('Cache configuration is not available');\n\t\t}\n\n\t\t// Use DatabaseResilience for automatic retry with exponential backoff\n\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\tconst resilience = getDatabaseResilience({\n\t\t\tmaxAttempts: config.RETRY_ATTEMPTS,\n\t\t\tinitialDelayMs: config.RETRY_DELAY,\n\t\t\tbackoffMultiplier: 2,\n\t\t\tmaxDelayMs: 30000, // Max 30s delay\n\t\t\tjitterMs: 500\n\t\t});\n\n\t\tawait resilience.executeWithRetry(async () => {\n\t\t\tconst { createClient } = await import('redis');\n\t\t\tthis.client = createClient({ url: config.URL, password: config.PASSWORD });\n\t\t\tthis.client.on('error', (err) => logger.error('Redis Client Error', err));\n\t\t\tthis.client.on('reconnecting', () => logger.warn('Reconnecting to Redis...'));\n\t\t\tawait this.client.connect();\n\t\t\tthis.isInitialized = true;\n\t\t\tlogger.info('Redis client connected successfully.');\n\t\t}, 'Redis Connection');\n\t}\n\n\tprivate async ensureReady(): Promise<void> {\n\t\tif (!this.client || !this.isInitialized) {\n\t\t\tthrow new Error('Redis client is not initialized. Call initialize() first.');\n\t\t}\n\t\tif (!this.client.isOpen) {\n\t\t\tawait this.client.connect();\n\t\t}\n\t}\n\n\tasync get<T>(key: string): Promise<T | null> {\n\t\tawait this.ensureReady();\n\t\tconst value = await this.client!.get(key);\n\t\treturn value ? (JSON.parse(value) as T) : null;\n\t}\n\n\tasync set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tawait this.client!.set(key, JSON.stringify(value), { EX: ttlSeconds });\n\t}\n\n\tasync delete(key: string | string[]): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tif (Array.isArray(key)) await this.client!.del(key);\n\t\telse await this.client!.del(key);\n\t}\n\n\tasync clearByPattern(pattern: string): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tlet cursor: string = '0';\n\t\tdo {\n\t\t\tconst result = await this.client!.scan(cursor, { MATCH: pattern, COUNT: 100 });\n\t\t\tcursor = result.cursor; // Redis returns cursor as string\n\t\t\tif (result.keys.length > 0) await this.client!.del(result.keys);\n\t\t} while (cursor !== '0');\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tif (this.client?.isOpen) await this.client.quit();\n\t\tthis.isInitialized = false;\n\t\tlogger.info('Redis connection closed.');\n\t}\n\n\tgetClient(): RedisClientType | null {\n\t\treturn this.client;\n\t}\n}\n\nclass CacheService {\n\tprivate static instance: CacheService;\n\tprivate store: ICacheStore;\n\tprivate initialized = false;\n\tprivate initPromise: Promise<void> | null = null;\n\tprivate prefetchPatterns: PrefetchPattern[] = [];\n\tprivate accessLog: Map<string, number[]> = new Map(); // Track access times for analytics\n\n\tprivate constructor() {\n\t\tconst config = getCacheConfig();\n\t\tthis.store = !browser && config.USE_REDIS ? new RedisStore() : new InMemoryStore();\n\t}\n\n\tstatic getInstance(): CacheService {\n\t\tif (!CacheService.instance) CacheService.instance = new CacheService();\n\t\treturn CacheService.instance;\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.initialized) return;\n\t\tif (!this.initPromise) {\n\t\t\tthis.initPromise = this.store.initialize().then(() => {\n\t\t\t\tthis.initialized = true;\n\t\t\t});\n\t\t}\n\t\tawait this.initPromise;\n\t}\n\n\tprivate async ensureInitialized() {\n\t\tif (!this.initialized) {\n\t\t\tawait this.initialize();\n\t\t}\n\t}\n\n\tprivate generateKey(baseKey: string, tenantId?: string): string {\n\t\t// If the caller already supplied a fully-qualified tenant-prefixed key, respect it\n\t\tif (baseKey.startsWith('tenant:')) return baseKey;\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tconst tenant = tenantId || 'default';\n\t\t\treturn `tenant:${tenant}:${baseKey}`;\n\t\t}\n\t\treturn baseKey;\n\t}\n\n\t// Track cache access for analytics and predictive prefetching\n\tprivate trackAccess(key: string): void {\n\t\tconst now = Date.now();\n\t\tconst accesses = this.accessLog.get(key) || [];\n\t\taccesses.push(now);\n\n\t\t// Keep only last 100 accesses per key\n\t\tif (accesses.length > 100) {\n\t\t\taccesses.shift();\n\t\t}\n\n\t\tthis.accessLog.set(key, accesses);\n\t}\n\n\t// Check if a key should be predictively prefetched based on patterns\n\tprivate async checkPrefetch(key: string, tenantId?: string): Promise<void> {\n\t\tfor (const pattern of this.prefetchPatterns) {\n\t\t\tif (pattern.pattern.test(key)) {\n\t\t\t\tconst keysToFetch = pattern.prefetchKeys(key);\n\t\t\t\tif (keysToFetch.length > 0 && pattern.fetcher) {\n\t\t\t\t\t// Execute prefetch in background\n\t\t\t\t\tvoid this.executePrefetch(keysToFetch, pattern.fetcher, pattern.category, tenantId);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async executePrefetch(\n\t\tkeys: string[],\n\t\tfetcher: (keys: string[]) => Promise<Record<string, unknown>>,\n\t\tcategory?: CacheCategory,\n\t\ttenantId?: string\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// 1. Filter out keys that are already cached\n\t\t\tconst missingKeys: string[] = [];\n\t\t\tfor (const key of keys) {\n\t\t\t\t// const cached = await this.get(key, tenantId); // This tracks access, might skew analytics?\n\t\t\t\t// Actually, we should check existence without tracking access if possible, or just accept it.\n\t\t\t\t// For now, let's just fetch everything to be safe and ensure freshness,\n\t\t\t\t// or assume the fetcher is efficient.\n\t\t\t\t// Optimization: Check cache existence first.\n\t\t\t\tconst fullKey = this.generateKey(key, tenantId);\n\t\t\t\tconst exists = await this.store.get(fullKey); // Direct store access to avoid recursion/tracking\n\t\t\t\tif (!exists) {\n\t\t\t\t\tmissingKeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (missingKeys.length === 0) return;\n\n\t\t\tlogger.debug(`Prefetching ${missingKeys.length} missing keys`);\n\n\t\t\t// 2. Fetch data\n\t\t\tconst dataMap = await fetcher(missingKeys);\n\n\t\t\t// 3. Cache data\n\t\t\tconst ttl = category ? getCategoryTTL(category) : REDIS_TTL_S;\n\t\t\tfor (const [key, value] of Object.entries(dataMap)) {\n\t\t\t\tawait this.set(key, value, ttl, tenantId, category);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.warn('Predictive prefetch failed:', error);\n\t\t}\n\t}\n\n\tasync get<T>(baseKey: string, tenantId?: string, _category?: CacheCategory): Promise<T | null> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\n\t\t// Track access\n\t\tthis.trackAccess(key);\n\n\t\t// Check for predictive prefetch opportunities\n\t\tvoid this.checkPrefetch(key, tenantId);\n\n\t\treturn this.store.get<T>(key);\n\t}\n\n\tasync set<T>(baseKey: string, value: T, ttlSeconds: number, tenantId?: string, category?: CacheCategory): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\n\t\t// Use category-specific TTL if category provided and no explicit TTL\n\t\tconst finalTTL = category && ttlSeconds === 0 ? getCategoryTTL(category) : ttlSeconds;\n\n\t\tawait this.store.set<T>(key, value, finalTTL);\n\t}\n\n\t// Set with automatic category-based TTL\n\tasync setWithCategory<T>(baseKey: string, value: T, category: CacheCategory, tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\t\tconst ttl = getCategoryTTL(category);\n\t\tawait this.store.set<T>(key, value, ttl);\n\t}\n\n\tasync delete(baseKey: string | string[], tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst keys = Array.isArray(baseKey) ? baseKey.map((k) => this.generateKey(k, tenantId)) : this.generateKey(baseKey, tenantId);\n\t\tawait this.store.delete(keys);\n\t}\n\n\tasync clearByPattern(pattern: string, tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst keyPattern = this.generateKey(pattern, tenantId);\n\t\tawait this.store.clearByPattern(keyPattern);\n\t}\n\n\t/**\n\t * Warm cache with critical data\n\t * Useful for preloading frequently accessed data on startup\n\t */\n\tasync warmCache(config: WarmCacheConfig): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tlogger.info(`Warming cache for ${config.keys.length} keys in category ${config.category || 'default'}`);\n\n\t\ttry {\n\t\t\tconst data = await config.fetcher();\n\t\t\tconst ttl = config.category ? getCategoryTTL(config.category) : REDIS_TTL_S;\n\n\t\t\tfor (const key of config.keys) {\n\t\t\t\tawait this.set(key, data, ttl, config.tenantId, config.category);\n\t\t\t}\n\n\t\t\tlogger.info(`Cache warmed successfully for ${config.keys.length} keys`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Cache warming failed:', error);\n\t\t}\n\t}\n\n\t/**\n\t * Register a predictive prefetch pattern\n\t * When a key matching the pattern is accessed, related keys will be prefetched\n\t */\n\tregisterPrefetchPattern(pattern: PrefetchPattern): void {\n\t\tthis.prefetchPatterns.push(pattern);\n\t\tlogger.info(`Registered prefetch pattern: ${pattern.pattern.source}`);\n\t}\n\n\t// Get cache access analytics\n\tgetAccessAnalytics(key: string): { count: number; avgInterval: number; lastAccess: number } | null {\n\t\tconst accesses = this.accessLog.get(key);\n\t\tif (!accesses || accesses.length === 0) return null;\n\n\t\tconst count = accesses.length;\n\t\tconst lastAccess = accesses[accesses.length - 1];\n\n\t\t// Calculate average interval between accesses\n\t\tlet totalInterval = 0;\n\t\tfor (let i = 1; i < accesses.length; i++) {\n\t\t\ttotalInterval += accesses[i] - accesses[i - 1];\n\t\t}\n\t\tconst avgInterval = accesses.length > 1 ? totalInterval / (accesses.length - 1) : 0;\n\n\t\treturn { count, avgInterval, lastAccess };\n\t}\n\n\t/**\n\t * Get recommended TTL based on access patterns\n\t * Returns recommended TTL in seconds\n\t */\n\tgetRecommendedTTL(key: string): number | null {\n\t\tconst analytics = this.getAccessAnalytics(key);\n\t\tif (!analytics) return null;\n\n\t\t// If accessed frequently (avgInterval < 1 minute), use longer TTL\n\t\tif (analytics.avgInterval < 60000) {\n\t\t\treturn 600; // 10 minutes\n\t\t}\n\n\t\t// If accessed moderately (1-5 minutes), use medium TTL\n\t\tif (analytics.avgInterval < 300000) {\n\t\t\treturn 300; // 5 minutes\n\t\t}\n\n\t\t// Otherwise use short TTL\n\t\treturn 180; // 3 minutes\n\t}\n\n\t/**\n\t * Invalidate all cached data to force refresh\n\t * Useful when TTL settings are changed via the settings UI\n\t */\n\tasync invalidateAll(): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tlogger.info(' Invalidating all cache entries due to configuration change');\n\n\t\t// For in-memory cache, we can just clear everything\n\t\tif (this.store instanceof InMemoryStore) {\n\t\t\tawait this.store.disconnect();\n\t\t\tawait this.store.initialize();\n\t\t} else if (this.store instanceof RedisStore) {\n\t\t\t// For Redis, clear by pattern (all keys)\n\t\t\tawait this.store.clearByPattern('*');\n\t\t}\n\n\t\tlogger.info(' Cache invalidated successfully');\n\t}\n\n\t/**\n\t * Get current TTL configuration for all categories\n\t * Useful for displaying in admin UI\n\t */\n\tgetCurrentTTLConfig(): Record<string, number> {\n\t\treturn {\n\t\t\tschema: getCategoryTTL(CacheCategory.SCHEMA),\n\t\t\twidget: getCategoryTTL(CacheCategory.WIDGET),\n\t\t\ttheme: getCategoryTTL(CacheCategory.THEME),\n\t\t\tcontent: getCategoryTTL(CacheCategory.CONTENT),\n\t\t\tmedia: getCategoryTTL(CacheCategory.MEDIA),\n\t\t\tsession: getCategoryTTL(CacheCategory.SESSION),\n\t\t\tuser: getCategoryTTL(CacheCategory.USER),\n\t\t\tapi: getCategoryTTL(CacheCategory.API)\n\t\t};\n\t}\n\n\tgetRedisClient(): RedisClientType | null {\n\t\treturn this.store.getClient();\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tawait this.store.disconnect();\n\t}\n}\n\nexport const cacheService = CacheService.getInstance();\n\n// Helper functions to get dynamic TTLs from database settings\n// These allow runtime changes without server restart\n\n/**\n * Get SESSION cache TTL from database settings\n * @returns TTL in seconds (default: 86400 = 24 hours)\n */\nexport function getSessionCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.SESSION);\n}\n\n/**\n * Get USER permissions cache TTL from database settings\n * @returns TTL in seconds (default: 60 = 1 minute)\n */\nexport function getUserPermCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.USER);\n}\n\n/**\n * Get API response cache TTL from database settings\n * @returns TTL in seconds (default: 300 = 5 minutes)\n */\nexport function getApiCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.API);\n}\n\n// Legacy exports for backward compatibility - now use dynamic values\n// Millisecond versions\nexport const SESSION_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // Default: 24 hours\nexport const USER_PERM_CACHE_TTL_MS = 60 * 1000; // Default: 1 minute\nexport const USER_COUNT_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes (not dynamically configured yet)\nexport const API_CACHE_TTL_MS = 5 * 60 * 1000; // Default: 5 minutes\n// Second versions - use getter functions for dynamic values\nexport const SESSION_CACHE_TTL_S = Math.ceil(SESSION_CACHE_TTL_MS / 1000);\nexport const USER_PERM_CACHE_TTL_S = Math.ceil(USER_PERM_CACHE_TTL_MS / 1000);\nexport const USER_COUNT_CACHE_TTL_S = Math.ceil(USER_COUNT_CACHE_TTL_MS / 1000);\nexport const API_CACHE_TTL_S = Math.ceil(API_CACHE_TTL_MS / 1000);\n// Generic Redis TTL\nexport const REDIS_TTL_S = 300; // 5 minutes in seconds for Redis\n\n/**\n * Cache category TTLs - Configurable via database settings\n * Defaults are used if not configured in the database\n */\n// CacheCategory enum now imported from ./CacheCategory.ts\n\n// Default TTLs (in seconds) if not configured in database\nconst DEFAULT_CATEGORY_TTLS: Record<CacheCategory, number> = {\n\t[CacheCategory.SCHEMA]: 600, // 10 minutes - schemas change rarely\n\t[CacheCategory.WIDGET]: 600, // 10 minutes - widget configs are relatively stable\n\t[CacheCategory.THEME]: 300, // 5 minutes - themes may update occasionally\n\t[CacheCategory.CONTENT]: 180, // 3 minutes - content updates frequently\n\t[CacheCategory.MEDIA]: 300, // 5 minutes - media metadata is fairly stable\n\t[CacheCategory.SESSION]: 86400, // 24 hours - user sessions\n\t[CacheCategory.USER]: 60, // 1 minute - user permissions (frequently checked)\n\t[CacheCategory.API]: 300 // 5 minutes - API responses\n};\n\n/**\n * Gets the TTL for a specific cache category\n * Checks database settings first (dynamically), falls back to defaults\n * This allows users to change TTLs via the settings UI without restarting\n */\nfunction getCategoryTTL(category: CacheCategory): number {\n\t// Map category to config key\n\tconst configKey = `CACHE_TTL_${category.toUpperCase()}` as\n\t\t| 'CACHE_TTL_SCHEMA'\n\t\t| 'CACHE_TTL_WIDGET'\n\t\t| 'CACHE_TTL_THEME'\n\t\t| 'CACHE_TTL_CONTENT'\n\t\t| 'CACHE_TTL_MEDIA'\n\t\t| 'CACHE_TTL_SESSION'\n\t\t| 'CACHE_TTL_USER'\n\t\t| 'CACHE_TTL_API';\n\n\ttry {\n\t\t// Try to get from dynamic settings (allows runtime changes)\n\t\tconst configuredTTL = getPrivateSettingSync(configKey);\n\n\t\tif (typeof configuredTTL === 'number' && configuredTTL > 0) {\n\t\t\treturn configuredTTL;\n\t\t}\n\t} catch (error) {\n\t\t// If settings not loaded yet, fall through to defaults\n\t\tlogger.debug(`Failed to get TTL for ${category}, using default:`, error);\n\t}\n\n\t// Fall back to default TTL\n\treturn DEFAULT_CATEGORY_TTLS[category];\n}\n\n// Interface for cache warming configuration\ninterface WarmCacheConfig {\n\tkeys: string[];\n\tfetcher: () => Promise<unknown>;\n\tcategory?: CacheCategory;\n\ttenantId?: string;\n}\n\n// Interface for predictive prefetch configuration\ninterface PrefetchPattern {\n\tpattern: RegExp;\n\tprefetchKeys: (matchedKey: string) => string[];\n\tfetcher?: (keys: string[]) => Promise<Record<string, unknown>>; // Function to fetch data for keys\n\tcategory?: CacheCategory;\n}\n","/**\n * @file src/databases/themeManager.ts\n * @description Theme manager for the CMS, utilizing a database-agnostic interface and now multi-tenant aware.\n *\n * ### Features\n * - Singleton pattern for global access\n * - Database-agnostic via IDBAdapter interface\n * - Caches themes in-memory for performance\n * - Supports multi-tenant theme management\n * - Fallback to default theme if database is unavailable\n */\nimport { error } from '@sveltejs/kit';\nimport type { DatabaseId } from '@cms-types/content';\nimport type { IDBAdapter, Theme } from './dbInterface';\nimport { dateToISODateString } from '@shared/utils/dateUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n/**\n * Fallback theme for when database is not available\n * This should match the theme that gets seeded during setup\n */\nexport const DEFAULT_THEME: Theme = {\n\t_id: '670e8b8c4d123456789abcde' as DatabaseId, // Matches the seeded theme ID\n\tpath: '', // Default path\n\tname: 'SveltyCMSTheme',\n\n\tisActive: false,\n\tisDefault: true,\n\tconfig: {\n\t\ttailwindConfigPath: '',\n\t\tassetsPath: ''\n\t},\n\tcreatedAt: dateToISODateString(new Date()),\n\tupdatedAt: dateToISODateString(new Date())\n};\n\nexport class ThemeManager {\n\tprivate static instance: ThemeManager;\n\tprivate themeCache: Map<string, Theme> = new Map(); // Single cache for all themes\n\tprivate db: IDBAdapter | null = null;\n\tprivate initialized: boolean = false;\n\n\tprivate constructor() {}\n\n\tpublic static getInstance(): ThemeManager {\n\t\tif (!ThemeManager.instance) {\n\t\t\tThemeManager.instance = new ThemeManager();\n\t\t}\n\t\treturn ThemeManager.instance;\n\t}\n\n\tpublic isInitialized(): boolean {\n\t\treturn this.initialized;\n\t}\n\n\tpublic async initialize(db: IDBAdapter): Promise<void> {\n\t\tif (this.initialized) {\n\t\t\tlogger.debug('ThemeManager already initialized, skipping.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.db = db;\n\n\t\t\t// Load and cache the default theme\n\t\t\tawait this.loadAndCacheDefaultTheme();\n\n\t\t\tthis.initialized = true;\n\t\t\t// Removed logger.info here - will be combined with timing in system init\n\t\t} catch (err) {\n\t\t\tconst message = `Error in ThemeManager.initialize: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t/**\n\t * Load the default theme from database and cache it\n\t */\n\tprivate async loadAndCacheDefaultTheme(): Promise<void> {\n\t\tif (!this.db) throw new Error('Database adapter not initialized.');\n\n\t\ttry {\n\t\t\t// Single optimized database call - get all themes at once\n\t\t\tconst allThemes = await this.db.themes.getAllThemes();\n\n\t\t\tif (!Array.isArray(allThemes) || allThemes.length === 0) {\n\t\t\t\tlogger.warn('No themes found in database. Using DEFAULT_THEME fallback.');\n\t\t\t\tthis.themeCache.set('global', DEFAULT_THEME);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find active theme, or default theme, or first theme\n\t\t\tconst defaultTheme = allThemes.find((t) => t.isActive) || allThemes.find((t) => t.isDefault) || allThemes[0];\n\n\t\t\t// Cache it as the global default\n\t\t\tthis.themeCache.set('global', defaultTheme);\n\t\t\tlogger.debug(`Default theme cached: ${defaultTheme.name}`);\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to load themes from database:', err);\n\t\t\t// Fallback to DEFAULT_THEME on error\n\t\t\tthis.themeCache.set('global', DEFAULT_THEME);\n\t\t}\n\t}\n\n\tpublic async getTheme(tenantId?: string): Promise<Theme> {\n\t\tif (!this.initialized || !this.db) {\n\t\t\tthrow new Error('ThemeManager is not initialized.');\n\t\t}\n\n\t\tconst cacheKey = tenantId || 'global';\n\n\t\t// Return from cache if available\n\t\tif (this.themeCache.has(cacheKey)) {\n\t\t\treturn this.themeCache.get(cacheKey)!;\n\t\t}\n\n\t\t// For tenant-specific themes, fetch from database\n\t\t// For now, fall back to global theme since tenant-specific themes\n\t\t// require additional schema implementation\n\t\tif (tenantId) {\n\t\t\tlogger.debug(`No tenant-specific theme for ${tenantId}, using global theme`);\n\t\t\tconst globalTheme = this.themeCache.get('global');\n\t\t\tif (globalTheme) {\n\t\t\t\treturn globalTheme;\n\t\t\t}\n\t\t}\n\n\t\t// Final fallback - should rarely reach here\n\t\tlogger.warn('No cached theme found, using DEFAULT_THEME fallback.');\n\t\treturn DEFAULT_THEME;\n\t}\n\n\tpublic async setTheme(theme: Theme, tenantId?: string): Promise<void> {\n\t\tif (!this.initialized || !this.db) {\n\t\t\tthrow new Error('ThemeManager is not initialized.');\n\t\t}\n\n\t\ttry {\n\t\t\t// Update database to set this theme as default\n\t\t\tconst setDefaultResult = await this.db.themes.setDefault(theme._id);\n\n\t\t\tif (!setDefaultResult.success) {\n\t\t\t\tthrow new Error(setDefaultResult.error?.message || 'Failed to set theme as default');\n\t\t\t}\n\n\t\t\t// Update cache\n\t\t\tconst cacheKey = tenantId || 'global';\n\t\t\tthis.themeCache.set(cacheKey, theme);\n\n\t\t\tlogger.info(`Theme updated to: ${theme.name}`, { tenantId: tenantId || 'global' });\n\t\t} catch (err) {\n\t\t\tconst message = `Error in ThemeManager.setTheme: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { tenantId });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t/**\n\t * Clear cache and reload themes from database\n\t */\n\tpublic async refresh(): Promise<void> {\n\t\tif (!this.initialized || !this.db) {\n\t\t\tthrow new Error('ThemeManager is not initialized.');\n\t\t}\n\n\t\tthis.themeCache.clear();\n\t\tawait this.loadAndCacheDefaultTheme();\n\t\tlogger.debug('ThemeManager cache refreshed.');\n\t}\n}\n","/**\n * @file src/databases/db.ts\n * @description\n * Database and authentication initialization and management module.\n *\n * This module is responsible for:\n * - Loading and initializing database and authentication adapters based on the configured DB_TYPE\n * - Establishing database connections with a retry mechanism\n * - Managing initialization of authentication models, media models, and collection models\n * - Setting up default roles and permissions\n * Multi-Tenancy Note:\n * This file handles the one-time global startup of the server. Tenant-specific\n * data scoping is handled by the API endpoints and server hooks that use the\n * initialized services from this module.\n */\n\nimport { building, browser } from '$app/environment';\n\n// Handle private config that might not exist during setup\nlet privateEnv: InferOutput<typeof privateConfigSchema> | null = null;\n\n// Function to load private config when needed (SERVER-ONLY)\nasync function loadPrivateConfig(forceReload = false) {\n\t// CRITICAL: Never run in browser - this function uses Node.js APIs\n\tif (browser) {\n\t\treturn null;\n\t}\n\n\tif (privateEnv && !forceReload) return privateEnv;\n\n\ttry {\n\t\tlogger.debug('Loading @config/private configuration...');\n\t\tlet module;\n\n\t\t// Check if running in test mode via environment variable\n\t\tconst isTestMode = typeof process !== 'undefined' && process.env?.TEST_MODE;\n\n\t\tif (isTestMode) {\n\t\t\tconst pathUtil = await import('path');\n\t\t\tlet workspaceRoot = process.cwd();\n\t\t\tif (\n\t\t\t\tworkspaceRoot.endsWith('apps/setup') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/setup/') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/cms') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/cms/')\n\t\t\t) {\n\t\t\t\tworkspaceRoot = pathUtil.resolve(workspaceRoot, '../../');\n\t\t\t}\n\t\t\tconst configPath = pathUtil.resolve(workspaceRoot, 'config/private.test.ts');\n\t\t\tmodule = await import(/* @vite-ignore */ configPath);\n\t\t} else {\n\t\t\tmodule = await import('@config/private');\n\t\t}\n\n\t\tprivateEnv = module.privateEnv;\n\t\tlogger.debug('Private config loaded successfully', {\n\t\t\thasConfig: !!privateEnv,\n\t\t\tdbType: privateEnv?.DB_TYPE,\n\t\t\tdbHost: privateEnv?.DB_HOST ? '***' : 'missing'\n\t\t});\n\t\treturn privateEnv;\n\t} catch (error) {\n\t\t// Private config doesn't exist during setup - this is expected\n\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t});\n\t\treturn null;\n\t}\n}\n// Function to clear private config cache (used after setup completion)\nexport function clearPrivateConfigCache(keepPrivateEnv = false) {\n\tlogger.debug('Clearing private config cache and initialization promises', {\n\t\tkeepPrivateEnv,\n\t\thadPrivateEnv: !!privateEnv\n\t});\n\tif (!keepPrivateEnv) {\n\t\tprivateEnv = null;\n\t}\n\tadaptersLoaded = false;\n\t_dbInitPromise = null;\n\tinitializationPromise = null;\n\tlogger.debug('Private config cache and initialization promises cleared', {\n\t\tprivateEnvCleared: !keepPrivateEnv\n\t});\n}\n\n// Auth\nimport { Auth } from '@shared/database/auth';\nimport { getDefaultSessionStore } from '@shared/database/auth/sessionManager';\n// Adapters Interfaces\nimport type { DatabaseAdapter } from './dbInterface';\n\n// Settings loader\nimport { privateConfigSchema, publicConfigSchema } from '@shared/database/schemas';\nimport { invalidateSettingsCache, setSettingsCache, getPublicSetting } from '@shared/services/settingsService';\nimport { safeParse, type InferOutput } from 'valibot';\n\n// Type definition for private config schema\n\n// Theme\nimport { DEFAULT_THEME, ThemeManager } from '@shared/database/themeManager';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// System State Management\n// Using dynamic imports to break circular dependency while still updating actual system state\nlet _systemStateModule: typeof import('@shared/stores/system') | null = null;\n\nasync function loadSystemStateModule() {\n\tif (!_systemStateModule) {\n\t\t_systemStateModule = await import('@shared/stores/system');\n\t}\n\treturn _systemStateModule;\n}\n\nconst setSystemState = async (status: string, message: string) => {\n\tlogger.debug(`[SystemState] ${status}: ${message}`);\n\ttry {\n\t\tconst mod = await loadSystemStateModule();\n\t\tmod.setSystemState(status as any, message);\n\t} catch (err) {\n\t\tlogger.warn('Failed to update system state:', err);\n\t}\n};\n\nconst updateServiceHealth = async (service: string, status: string, message?: string, error?: string) => {\n\tlogger.debug(`[ServiceHealth] ${service} ${status}: ${message}`);\n\ttry {\n\t\tconst mod = await loadSystemStateModule();\n\t\tmod.updateServiceHealth(service as any, status as any, message || '', error);\n\t} catch (err) {\n\t\tlogger.warn('Failed to update service health:', err);\n\t}\n};\n\nconst waitForServiceHealthy = async () => true;\n\n// Widget Store - Dynamic import to avoid circular dependency\n// import { widgetStoreActions } from '@shared/stores/widgetStore.svelte';\n\n// State Variables\nexport let dbAdapter: DatabaseAdapter | null = null; // Database adapter\n\nexport let auth: Auth | null = null; // Authentication instance\nexport let isConnected = false; // Database connection state (primarily for external checks if needed)\nlet isInitialized = false; // Initialization state\nlet initializationPromise: Promise<void> | null = null; // Initialization promise\n\n/**\n * Get the in-memory private config if available.\n * Returns null if config hasn't been loaded yet (e.g., during setup).\n * Used by settingsService to avoid filesystem imports when config is already in memory.\n */\nexport function getPrivateEnv(): InferOutput<typeof privateConfigSchema> | null {\n\treturn privateEnv;\n}\n\n// Create a proper Promise for lazy initialization\nlet _dbInitPromise: Promise<void> | null = null;\nexport function getDbInitPromise(forceInit = false): Promise<void> {\n\tif (!_dbInitPromise || forceInit) {\n\t\t_dbInitPromise = initializeOnRequest(forceInit);\n\t}\n\treturn _dbInitPromise;\n}\n// Export a lazy Promise that will be initialized on first access (prevents browser execution)\nexport const dbInitPromise = browser ? Promise.resolve() : getDbInitPromise();\nlet adaptersLoaded = false; // Internal flag\n\n/**\n * Loads all settings from the database and populates the in-memory cache.\n * This function should only be called from a server-side context.\n */\n// Extract setting keys directly from schemas (single source of truth)\n// These are cached to avoid rebuilding arrays on every call\n\n// Infrastructure keys that come from config file, not database\nconst INFRASTRUCTURE_KEYS = new Set([\n\t'DB_TYPE',\n\t'DB_HOST',\n\t'DB_PORT',\n\t'DB_NAME',\n\t'DB_USER',\n\t'DB_PASSWORD',\n\t'DB_RETRY_ATTEMPTS',\n\t'DB_RETRY_DELAY',\n\t'DB_POOL_SIZE',\n\t'JWT_SECRET_KEY',\n\t'ENCRYPTION_KEY',\n\t'MULTI_TENANT'\n]);\n\nconst KNOWN_PUBLIC_KEYS = Object.keys(publicConfigSchema.entries);\nconst KNOWN_PRIVATE_KEYS = Object.keys(privateConfigSchema.entries).filter((key) => !INFRASTRUCTURE_KEYS.has(key));\n\nexport async function loadSettingsFromDB() {\n\ttry {\n\t\t// logger.debug('Loading settings from database...');\n\n\t\t// Check if database adapter is available\n\t\tif (!dbAdapter || !dbAdapter.systemPreferences) {\n\t\t\tlogger.warn('Database adapter not available during settings load. Using empty cache.');\n\t\t\tawait invalidateSettingsCache();\n\t\t\treturn;\n\t\t}\n\n\t\t// Load both public and private settings in parallel (not sequential)\n\t\tconst [settingsResult, privateDynResult] = await Promise.all([\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PUBLIC_KEYS, 'system'),\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PRIVATE_KEYS, 'system')\n\t\t]);\n\n\t\tif (!settingsResult.success) {\n\t\t\tlogger.error('Failed to load settings from database:', settingsResult.error);\n\t\t\tlogger.error('Settings keys attempted:', KNOWN_PUBLIC_KEYS);\n\t\t\tlogger.error('Database adapter status:', {\n\t\t\t\thasAdapter: !!dbAdapter,\n\t\t\t\thasSystemPrefs: !!dbAdapter?.systemPreferences,\n\t\t\t\thasGetMany: !!dbAdapter?.systemPreferences?.getMany\n\t\t\t});\n\t\t\tthrow new Error(`Could not load settings from DB: ${settingsResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\tconst settings = settingsResult.data || {};\n\t\tconst privateDynamic = privateDynResult.success ? privateDynResult.data || {} : {};\n\n\t\t// If no settings exist (initial setup), use empty objects and skip validation\n\t\tif (Object.keys(settings).length === 0) {\n\t\t\tlogger.info('No settings found in database (initial setup). Using empty cache.');\n\t\t\t// During initial setup, bypass validation by calling invalidateSettingsCache\n\t\t\t// which sets empty cache without validation\n\t\t\tawait invalidateSettingsCache();\n\t\t\treturn;\n\t\t}\n\n\t\t// All system settings are public in the current implementation\n\t\tconst publicSettings: Record<string, unknown> = settings;\n\t\tconst databasePrivateSettings: Record<string, unknown> = {};\n\n\t\t// Get private config settings (infrastructure settings)\n\t\t// Prefer in-memory config (set by initializeWithConfig) over filesystem import\n\t\t// This eliminates unnecessary file I/O and Vite cache dependency\n\t\tlet privateConfig: InferOutput<typeof privateConfigSchema>;\n\t\tif (privateEnv) {\n\t\t\t// Use in-memory config when available (post-setup, zero-restart mode)\n\t\t\tlogger.debug('Using in-memory private config (bypassing filesystem)');\n\t\t\tprivateConfig = privateEnv;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t// Fall back to filesystem import (normal startup)\n\t\t\t\tlogger.debug('Loading private config from filesystem');\n\t\t\t\tlet imported;\n\t\t\t\tconst isTestMode = typeof process !== 'undefined' && process.env?.TEST_MODE;\n\t\t\t\tif (isTestMode) {\n\t\t\t\t\tconst path = '@config/private.test';\n\t\t\t\t\timported = await import(/* @vite-ignore */ path);\n\t\t\t\t} else {\n\t\t\t\t\timported = await import('@config/private');\n\t\t\t\t}\n\t\t\t\tprivateConfig = imported.privateEnv;\n\t\t\t} catch (error) {\n\t\t\t\t// Private config doesn't exist during setup - this is expected\n\t\t\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge private config file settings with database private settings\n\t\t// Private config contains infrastructure settings (DB_*, JWT_*, ENCRYPTION_*)\n\t\t// Database contains application private settings (SMTP_*, GOOGLE_*, etc.)\n\t\tconst privateSettings = {\n\t\t\t...privateConfig, // Infrastructure settings from config (in-memory or file)\n\t\t\t...databasePrivateSettings // Application settings from database\n\t\t};\n\n\t\t// Validate and parse the settings against the schemas\n\t\tconst parsedPublic = safeParse(publicConfigSchema, publicSettings);\n\t\tconst parsedPrivate = safeParse(privateConfigSchema, privateSettings);\n\n\t\t// If validation fails, it might be during setup with incomplete settings\n\t\t// In this case, just use empty cache to allow setup to continue\n\t\tif (!parsedPublic.success || !parsedPrivate.success) {\n\t\t\tlogger.debug('Settings validation failed during startup - likely first run or setup mode');\n\t\t\tif (!parsedPublic.success) {\n\t\t\t\tlogger.debug('Public settings validation issues:', parsedPublic.issues);\n\t\t\t}\n\t\t\tif (!parsedPrivate.success) {\n\t\t\t\tlogger.debug('Private settings validation issues:', parsedPrivate.issues);\n\t\t\t}\n\n\t\t\t// Clear invalid settings from database (silent cleanup)\n\t\t\ttry {\n\t\t\t\tlogger.debug('Clearing invalid settings from database...');\n\t\t\t\tif (dbAdapter && dbAdapter.systemPreferences && typeof dbAdapter.systemPreferences.deleteMany === 'function') {\n\t\t\t\t\tawait dbAdapter.systemPreferences.deleteMany([]);\n\t\t\t\t\tlogger.debug('Invalid settings cleared successfully');\n\t\t\t\t}\n\t\t\t} catch (clearError) {\n\t\t\t\tlogger.debug('Failed to clear invalid settings:', clearError);\n\t\t\t}\n\n\t\t\tawait invalidateSettingsCache();\n\t\t\tlogger.info('Settings validation failed - system will run with defaults until settings are configured');\n\t\t\treturn; // Return without throwing - allow system to continue in setup mode\n\t\t}\n\n\t\t// Populate the cache with validated settings, merging dynamic private flags into unified cache\n\t\tconst mergedPrivate = { ...(parsedPrivate.output as Record<string, unknown>), ...privateDynamic } as InferOutput<typeof privateConfigSchema>;\n\t\tawait setSettingsCache(mergedPrivate, parsedPublic.output);\n\n\t\tlogger.info(' System settings loaded and cached from database.');\n\t} catch (error) {\n\t\tlogger.error('Failed to load settings from database:', error);\n\t\t// Don't throw - invalidate cache and continue with defaults\n\t\tawait invalidateSettingsCache();\n\t\tlogger.warn('Settings load failed - system will continue with default configuration');\n\t}\n}\n\n// Load database and authentication adapters with resilience\nasync function loadAdapters() {\n\tif (adaptersLoaded && dbAdapter) {\n\t\tlogger.debug('Adapters already loaded, skipping');\n\t\treturn;\n\t}\n\n\t// Use privateEnv if already set (from initializeWithConfig), otherwise load from Vite\n\tlogger.debug('Loading adapters - checking privateEnv', {\n\t\thasPrivateEnv: !!privateEnv,\n\t\tdbType: privateEnv?.DB_TYPE\n\t});\n\n\tconst config = privateEnv || (await loadPrivateConfig(false));\n\n\t// If no DB_TYPE is provided in the config (even if it's the temporary setup config),\n\t// log a warning and return, but don't prematurely exit if DB_TYPE *is* defined.\n\tif (!config?.DB_TYPE) {\n\t\tlogger.debug('No DB_TYPE in config; cannot load adapters. Skipping adapter loading during setup.', { config });\n\t\t// Set health to unhealthy and return without throwing to allow setup flow\n\t\tupdateServiceHealth('database', 'unhealthy', 'No DB_TYPE in config', 'Missing database configuration');\n\t\treturn;\n\t}\n\n\tlogger.debug(` Loading ${config.DB_TYPE} adapters...`);\n\n\t// Use DatabaseResilience for adapter loading (handles transient import failures)\n\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\tconst resilience = getDatabaseResilience({\n\t\tmaxAttempts: 3, // Retry adapter loading up to 3 times\n\t\tinitialDelayMs: 500,\n\t\tbackoffMultiplier: 2,\n\t\tmaxDelayMs: 5000,\n\t\tjitterMs: 200\n\t});\n\n\ttry {\n\t\tawait resilience.executeWithRetry(async () => {\n\t\t\tswitch (config.DB_TYPE) {\n\t\t\t\tcase 'mongodb':\n\t\t\t\tcase 'mongodb+srv': {\n\t\t\t\t\tlogger.debug('Importing MongoDB adapter...');\n\t\t\t\t\tconst mongoAdapterModule = await import('./mongodb/mongoDBAdapter');\n\t\t\t\t\tif (!mongoAdapterModule || !mongoAdapterModule.MongoDBAdapter) {\n\t\t\t\t\t\tthrow new Error('MongoDBAdapter is not exported correctly from mongoDBAdapter.ts');\n\t\t\t\t\t}\n\t\t\t\t\tconst { MongoDBAdapter } = mongoAdapterModule;\n\t\t\t\t\tdbAdapter = new MongoDBAdapter() as unknown as DatabaseAdapter;\n\n\t\t\t\t\tlogger.debug('MongoDB adapter created');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'mariadb': {\n\t\t\t\t\tlogger.debug('Importing MariaDB adapter...');\n\t\t\t\t\tconst mariadbAdapterModule = await import('./mariadb/mariadbAdapter');\n\t\t\t\t\tif (!mariadbAdapterModule || !mariadbAdapterModule.MariaDBAdapter) {\n\t\t\t\t\t\tthrow new Error('MariaDBAdapter is not exported correctly from mariadbAdapter.ts');\n\t\t\t\t\t}\n\t\t\t\t\tconst { MariaDBAdapter } = mariadbAdapterModule;\n\t\t\t\t\tdbAdapter = new MariaDBAdapter() as unknown as DatabaseAdapter;\n\n\t\t\t\t\tlogger.debug('MariaDB adapter created');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.error(`Unsupported DB_TYPE: ${config.DB_TYPE}. Supported types: mongodb, mongodb+srv, mariadb`);\n\t\t\t\t\tthrow new Error(`Unsupported DB_TYPE: ${config.DB_TYPE}. Supported types: mongodb, mongodb+srv, mariadb`);\n\t\t\t}\n\t\t}, 'Database Adapter Loading');\n\n\t\tadaptersLoaded = true;\n\t\tlogger.debug('All adapters loaded successfully');\n\t} catch (err) {\n\t\tconst message = `Error loading adapters: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message);\n\t\tadaptersLoaded = false; // Ensure flag is reset on error\n\t\t// Re-throwing here will cause the initializationPromise to reject\n\t\tthrow new Error(message);\n\t}\n}\n\n// Initialize default theme\nasync function initializeDefaultTheme(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize themes: dbAdapter is not available.');\n\ttry {\n\t\t// Check if theme exists before writing (avoid unnecessary DB operation)\n\t\tconst existingThemes = await dbAdapter.themes.getAllThemes();\n\t\tconst themeExists = existingThemes.some((t) => t.name === DEFAULT_THEME.name && t.isDefault);\n\n\t\tif (!themeExists) {\n\t\t\tawait dbAdapter.themes.storeThemes([DEFAULT_THEME]);\n\t\t\tlogger.debug('Default SveltyCMS theme initialized');\n\t\t}\n\t\t// Skip logging if theme already exists (save 1-2ms)\n\t} catch (err) {\n\t\t// Log but don't fail - theme initialization is not critical for system startup\n\t\tlogger.warn(`Theme initialization issue: ${err instanceof Error ? err.message : String(err)}`);\n\t}\n}\n\n// Initialize ThemeManager\nasync function initializeThemeManager(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize ThemeManager: dbAdapter is not available.');\n\ttry {\n\t\tlogger.debug('Initializing ThemeManager...');\n\t\tconst themeManager = ThemeManager.getInstance();\n\t\tawait themeManager.initialize(dbAdapter);\n\t} catch (err) {\n\t\tconst message = `Error initializing ThemeManager: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n\n// Initialize the media folder\nasync function initializeMediaFolder(): Promise<void> {\n\t// During setup, MEDIA_FOLDER might not be loaded yet, so use fallback\n\tconst mediaFolderPath = (await getPublicSetting('MEDIA_FOLDER')) || './mediaFolder';\n\tif (building) return;\n\tconst fs = await import('node:fs/promises');\n\ttry {\n\t\t// Fast stat() check, skip debug logging overhead\n\t\tawait fs.stat(mediaFolderPath);\n\t\t// Folder exists, skip logging for speed\n\t} catch {\n\t\t// If the folder does not exist, create it\n\t\tlogger.info(`Creating media folder: ${mediaFolderPath}`);\n\t\tawait fs.mkdir(mediaFolderPath, { recursive: true });\n\t}\n}\n\n// Initialize virtual folders using DatabaseResilience\nasync function initializeVirtualFolders(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize virtual folders: dbAdapter is not available.');\n\tif (!dbAdapter.systemVirtualFolder) {\n\t\tlogger.warn('systemVirtualFolder adapter not available, skipping initialization.');\n\t\treturn;\n\t}\n\n\t// Use DatabaseResilience for automatic retry with exponential backoff\n\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\tconst resilience = getDatabaseResilience();\n\n\tawait resilience.executeWithRetry(async () => {\n\t\tif (!dbAdapter) throw new Error('dbAdapter is null');\n\t\t// Verify the connection is still active before querying\n\t\tif (dbAdapter.isConnected && !dbAdapter.isConnected()) {\n\t\t\tthrow new Error('Database connection lost - reconnection required');\n\t\t}\n\n\t\tconst systemVirtualFoldersResult = await dbAdapter.systemVirtualFolder.getAll();\n\n\t\tif (!systemVirtualFoldersResult.success) {\n\t\t\tconst error = systemVirtualFoldersResult.error;\n\t\t\tlet errorMessage = 'Unknown error';\n\n\t\t\tif (error instanceof Error) {\n\t\t\t\terrorMessage = error.message;\n\t\t\t} else if (error && typeof error === 'object' && 'message' in error) {\n\t\t\t\terrorMessage = String((error as { message: unknown }).message);\n\t\t\t} else if (error) {\n\t\t\t\terrorMessage = String(error);\n\t\t\t}\n\n\t\t\tthrow new Error(`Failed to get virtual folders: ${errorMessage}`);\n\t\t}\n\n\t\tconst systemVirtualFolders = systemVirtualFoldersResult.data;\n\n\t\tif (systemVirtualFolders.length === 0) {\n\t\t\t// Create default virtual folder\n\t\t\tconst defaultMediaFolder = (await getPublicSetting('MEDIA_FOLDER')) || 'mediaFolder';\n\t\t\tconst creationResult = await dbAdapter.systemVirtualFolder.create({\n\t\t\t\tname: defaultMediaFolder,\n\t\t\t\tpath: defaultMediaFolder,\n\t\t\t\torder: 0,\n\t\t\t\ttype: 'folder' as const\n\t\t\t});\n\n\t\t\tif (!creationResult.success) {\n\t\t\t\tconst error = creationResult.error;\n\t\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\t\tthrow new Error(`Failed to create root virtual folder: ${errorMessage}`);\n\t\t\t}\n\t\t}\n\t}, 'Virtual Folders Initialization');\n}\n\n// Initialize adapters (instant validation only)\nasync function initializeRevisions(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize revisions: dbAdapter is not available.');\n\t// Instant no-op validation (revisions are lazy-loaded on first use)\n}\n\n// Core Initialization Logic\nasync function initializeSystem(forceReload = false, skipSetupCheck = false): Promise<void> {\n\t// Prevent re-initialization\n\tif (isInitialized) {\n\t\tlogger.debug('System already initialized. Skipping.');\n\t\treturn;\n\t}\n\n\tconst systemStartTime = performance.now();\n\tlogger.info('Starting SvelteCMS System Initialization...');\n\n\t// Set system state to INITIALIZING\n\tawait setSystemState('INITIALIZING', 'Starting system initialization');\n\n\ttry {\n\t\t// Step 1: Check for setup mode (skip if called from initializeWithConfig)\n\t\tlet privateConfig: InferOutput<typeof privateConfigSchema> | null;\n\t\tif (skipSetupCheck) {\n\t\t\t// When called from initializeWithConfig, privateEnv is already set - don't reload\n\t\t\tlogger.debug('Skipping private config load - using pre-set configuration');\n\t\t\tprivateConfig = privateEnv;\n\t\t} else {\n\t\t\t// Normal initialization flow - load from Vite\n\t\t\tprivateConfig = await loadPrivateConfig(forceReload);\n\t\t}\n\n\t\t// Ensure we have valid config before proceeding\n\t\tif (!privateConfig || !privateConfig.DB_TYPE) {\n\t\t\tlogger.info('Private config not available  running in setup mode (skipping full initialization).');\n\t\t\tawait setSystemState('IDLE', 'Running in setup mode');\n\t\t\treturn;\n\t\t}\n\n\t\t// Step 2: Load Adapters & Connect to DB\n\t\tupdateServiceHealth('database', 'initializing', 'Loading database adapter...');\n\t\tawait loadAdapters();\n\t\tif (!dbAdapter) {\n\t\t\tupdateServiceHealth('database', 'unhealthy', 'Database adapter failed to load');\n\t\t\tthrow new Error('Database adapter failed to load.');\n\t\t}\n\n\t\tlet connectionString: string;\n\t\tif (privateConfig.DB_TYPE === 'mongodb') {\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mongodb://${authPart}${privateConfig.DB_HOST}:${privateConfig.DB_PORT}/${privateConfig.DB_NAME}${hasAuth ? '?authSource=admin' : ''}`;\n\t\t\tlogger.debug(`Connecting to MongoDB...`);\n\t\t} else if (privateConfig.DB_TYPE === 'mongodb+srv') {\n\t\t\t// MongoDB Atlas connection string\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mongodb+srv://${authPart}${privateConfig.DB_HOST}/${privateConfig.DB_NAME}?retryWrites=true&w=majority`;\n\t\t\tlogger.debug(`Connecting to MongoDB Atlas (SRV)...`);\n\t\t} else if (privateConfig.DB_TYPE === 'mariadb') {\n\t\t\t// MariaDB connection string\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mysql://${authPart}${privateConfig.DB_HOST}:${privateConfig.DB_PORT}/${privateConfig.DB_NAME}`;\n\t\t\tlogger.debug(`Connecting to MariaDB...`);\n\t\t} else {\n\t\t\tconnectionString = '';\n\t\t}\n\n\t\t//  Run connection + model setup in parallel (overlapping I/O)\n\t\tconst step2And3StartTime = performance.now();\n\t\tconst [connectionResult] = await Promise.all([\n\t\t\tdbAdapter.connect(connectionString),\n\t\t\t// Step 3: Setup Core Database Models (runs in parallel with connection)\n\t\t\t// Models can be set up while connection is establishing\n\t\t\t(async () => {\n\t\t\t\t// Small delay to ensure connection is in progress before model setup\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 10));\n\t\t\t\treturn Promise.all([dbAdapter.media?.setupMediaModels(), dbAdapter.widgets?.setupWidgetModels(), dbAdapter.themes?.setupThemeModels()]);\n\t\t\t})()\n\t\t]);\n\n\t\tif (!connectionResult.success) {\n\t\t\tupdateServiceHealth(\n\t\t\t\t'database',\n\t\t\t\t'unhealthy',\n\t\t\t\t`Connection failed: ${connectionResult.error?.message || 'Unknown error'}`,\n\t\t\t\tconnectionResult.error?.message\n\t\t\t);\n\t\t\tthrow new Error(`Database connection failed: ${connectionResult.error?.message || 'Unknown error'}`);\n\t\t}\n\t\tisConnected = true;\n\t\tupdateServiceHealth('database', 'healthy', 'Database connected successfully');\n\n\t\tconst step2And3Time = performance.now() - step2And3StartTime;\n\t\tlogger.info(`Steps 1-2: DB connected & adapters loaded in ${step2And3Time.toFixed(2)}ms`);\n\t\tlogger.info(`Step 3: Database models setup in ${step2And3Time.toFixed(2)}ms ( parallelized with connection)`);\n\n\t\t// Step 4: Pre-load Server-Side Services\n\t\t// WidgetRegistryService and ContentManager are moved to AFTER Step 5 to ensure dependencies (Settings, Widgets) are ready.\n\t\tlogger.info('Step 4: Skipping eager ContentManager init (moved to Step 6)');\n\n\t\t// Step 5: Initialize Critical Components (optimized for speed)\n\t\tlogger.debug('Starting Step 5: Critical components initialization...');\n\t\tconst step5StartTime = performance.now();\n\n\t\t// Auth (fast, required immediately)\n\t\tlogger.debug('Initializing Auth service...');\n\t\tupdateServiceHealth('auth', 'initializing', 'Initializing authentication service...');\n\t\tif (!dbAdapter) {\n\t\t\tlogger.error('Cannot initialize Auth: dbAdapter is null');\n\t\t\tthrow new Error('Database adapter not initialized');\n\t\t}\n\t\tauth = new Auth(dbAdapter, getDefaultSessionStore());\n\t\tif (!auth) {\n\t\t\tlogger.error('Auth constructor returned null/undefined');\n\t\t\tupdateServiceHealth('auth', 'unhealthy', 'Auth initialization failed');\n\t\t\tthrow new Error('Auth initialization failed');\n\t\t}\n\t\tlogger.debug('Auth service initialized successfully');\n\t\tupdateServiceHealth('auth', 'healthy', 'Authentication service ready');\n\n\t\t// Settings (required for app configuration)\n\t\tlogger.debug('Loading settings from database...');\n\t\tconst settingsStartTime = performance.now();\n\t\tawait loadSettingsFromDB();\n\t\tconst settingsTime = performance.now() - settingsStartTime;\n\t\tlogger.debug(`Settings loaded in ${settingsTime.toFixed(2)}ms`);\n\n\t\tconst authTime = performance.now() - step5StartTime;\n\n\t\t// Run slow I/O operations in parallel\n\t\tlogger.debug('Starting parallel I/O operations...');\n\t\tconst parallelStartTime = performance.now();\n\t\tupdateServiceHealth('cache', 'initializing', 'Initializing media, revisions, and themes...');\n\t\tupdateServiceHealth('themeManager', 'initializing', 'Initializing theme manager...');\n\n\t\t// Collect timings for all parallel operations\n\t\tlet mediaTime = 0,\n\t\t\trevisionsTime = 0,\n\t\t\tvirtualFoldersTime = 0,\n\t\t\tthemesTime = 0,\n\t\t\twidgetsTime = 0;\n\n\t\tawait Promise.all([\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeMediaFolder();\n\t\t\t\tmediaTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeRevisions();\n\t\t\t\trevisionsTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeVirtualFolders();\n\t\t\t\tvirtualFoldersTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeDefaultTheme();\n\t\t\t\tawait initializeThemeManager();\n\t\t\t\tupdateServiceHealth('themeManager', 'healthy', 'Theme manager initialized');\n\t\t\t\tthemesTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tupdateServiceHealth('widgets', 'initializing', 'Initializing widget store...');\n\t\t\t\t// Dynamic import to avoid circular dependency with client bundle\n\t\t\t\tconst { widgets } = await import('@shared/stores/widgetStore.svelte');\n\t\t\t\tawait widgets.initialize(undefined, dbAdapter);\n\t\t\t\tupdateServiceHealth('widgets', 'healthy', 'Widget store initialized');\n\t\t\t\twidgetsTime = performance.now() - t;\n\t\t\t})()\n\t\t]);\n\n\t\tupdateServiceHealth('cache', 'healthy', 'Media, revisions, and virtual folders initialized');\n\n\t\tconst parallelTime = performance.now() - parallelStartTime;\n\t\tlogger.info(\n\t\t\t`Parallel I/O completed in ${parallelTime.toFixed(2)}ms (Media: ${mediaTime.toFixed(2)}ms, Revisions: ${revisionsTime.toFixed(2)}ms, Virtual Folders: ${virtualFoldersTime.toFixed(2)}ms, Themes: ${themesTime.toFixed(2)}ms, Widgets: ${widgetsTime.toFixed(2)}ms)`\n\t\t);\n\n\t\tconst step5Time = performance.now() - step5StartTime;\n\t\tlogger.info(\n\t\t\t`Step 5: Critical components initialized in ${step5Time.toFixed(2)}ms (Auth: ${authTime.toFixed(2)}ms, Settings: ${settingsTime.toFixed(2)}ms)`\n\t\t);\n\n\t\t// Step 6: Application-level services (like ContentManager) are now initialized\n\t\t// in the application hooks (apps/cms/src/hooks.server.ts) after DB is ready.\n\t\tlogger.info('Step 5: Database and core components initialized.');\n\n\t\t// --- Demo Mode Cleanup Service ---\n\t\tif (privateConfig?.DEMO) {\n\t\t\timport('@shared/utils/demoCleanup').then(({ cleanupExpiredDemoTenants }) => {\n\t\t\t\tlogger.info(' Demo Cleanup Service initialized (Interval: 5m, TTL: 60m)');\n\t\t\t\t// Run immediately on startup\n\t\t\t\tcleanupExpiredDemoTenants();\n\t\t\t\t// Run every 5 minutes\n\t\t\t\tsetInterval(cleanupExpiredDemoTenants, 5 * 60 * 1000);\n\t\t\t});\n\t\t}\n\n\t\tisInitialized = true;\n\n\t\t// Explicitly set system state to READY after all services are initialized\n\t\tawait setSystemState('READY', 'All critical services initialized successfully');\n\n\t\tconst totalTime = performance.now() - systemStartTime;\n\t\tlogger.info(` System initialization completed successfully in ${totalTime.toFixed(2)}ms!`);\n\t} catch (err) {\n\t\tconst message = `CRITICAL: System initialization failed: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message, err);\n\t\tisInitialized = false; // Reset initialization flag on error\n\t\tisConnected = false; // Reset connection flag on error\n\t\tauth = null; // Reset auth on error\n\t\tawait setSystemState('FAILED', message);\n\t\tthrow new Error(message);\n\t}\n}\n\n// --- Status & Reinitialization Helpers ---\n\n/**\n * Minimal initialization for setup mode - ONLY connects to database\n * Does NOT initialize any services (auth, themes, content, etc.)\n * Used by setup wizard to perform database operations\n */\nexport async function initializeForSetup(dbConfig: {\n\ttype: string;\n\thost: string;\n\tport: number;\n\tname: string;\n\tuser?: string;\n\tpassword?: string;\n}): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tlogger.info('Initializing minimal database connection for setup mode...');\n\n\t\t// Load the appropriate adapter\n\t\tif (!adaptersLoaded) {\n\t\t\tawait loadAdapters();\n\t\t}\n\n\t\tif (!dbAdapter) {\n\t\t\treturn { success: false, error: 'Failed to load database adapter' };\n\t\t}\n\n\t\t// Build connection string\n\t\tlet connectionString: string;\n\t\tif (dbConfig.type === 'mongodb') {\n\t\t\tconst hasAuth = dbConfig.user && dbConfig.password;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(dbConfig.user!)}:${encodeURIComponent(dbConfig.password!)}@` : '';\n\t\t\tconnectionString = `mongodb://${authPart}${dbConfig.host}:${dbConfig.port}/${dbConfig.name}${hasAuth ? '?authSource=admin' : ''}`;\n\t\t} else if (dbConfig.type === 'mariadb') {\n\t\t\tconst hasAuth = dbConfig.user && dbConfig.password;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(dbConfig.user!)}:${encodeURIComponent(dbConfig.password!)}@` : '';\n\t\t\tconnectionString = `mysql://${authPart}${dbConfig.host}:${dbConfig.port}/${dbConfig.name}`;\n\t\t} else {\n\t\t\treturn { success: false, error: `Database type '${dbConfig.type}' not supported yet` };\n\t\t}\n\n\t\t// Connect to database\n\t\tconst connectionResult = await dbAdapter.connect(connectionString);\n\t\tif (!connectionResult.success) {\n\t\t\treturn { success: false, error: connectionResult.error?.message || 'Connection failed' };\n\t\t}\n\n\t\tisConnected = true;\n\t\tlogger.info(' Minimal database connection established for setup');\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\tlogger.error('Failed to initialize database for setup:', message);\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Initializes the system on the first non-setup request.\n * This prevents the server from trying to connect to the DB during setup.\n */\nexport function initializeOnRequest(forceInit = false): Promise<void> {\n\t// CRITICAL: Never run in browser - this is server-only initialization\n\tif (browser) {\n\t\treturn Promise.resolve();\n\t}\n\n\tconst isBuildProcess = typeof process !== 'undefined' && process.argv?.some((arg) => ['build', 'check'].includes(arg));\n\n\tif (!building && !isBuildProcess) {\n\t\tif (!initializationPromise || forceInit) {\n\t\t\tlogger.debug('Creating system initialization promise...');\n\n\t\t\tinitializationPromise = (async () => {\n\t\t\t\t// Check if private config exists and is valid\n\t\t\t\tconst privateConfig = await loadPrivateConfig(forceInit);\n\t\t\t\tif (!privateConfig || !privateConfig.DB_TYPE || !privateConfig.DB_HOST) {\n\t\t\t\t\tlogger.info('Private config not available  skipping initialization (setup mode)');\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\t// Private config exists - run full initialization\n\t\t\t\tlogger.info('Private config found, starting full system initialization');\n\t\t\t\treturn initializeSystem(forceInit);\n\t\t\t})();\n\n\t\t\tinitializationPromise.catch((err) => {\n\t\t\t\tlogger.error(`Initialization failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\t\tlogger.error('Clearing initialization promise to allow retry');\n\t\t\t\tinitializationPromise = null;\n\t\t\t\t_dbInitPromise = null;\n\t\t\t});\n\t\t}\n\t} else if (!initializationPromise) {\n\t\tlogger.debug('Skipping system initialization during build process.');\n\t\tinitializationPromise = Promise.resolve();\n\t}\n\treturn initializationPromise;\n}\n\nexport async function getSystemStatus() {\n\tconst basicStatus = {\n\t\tinitialized: isInitialized,\n\t\tconnected: isConnected,\n\t\tauthReady: !!auth,\n\t\tinitializing: !!initializationPromise && !isInitialized\n\t};\n\n\t// If not connected, return basic status without health check\n\tif (!isConnected || !dbAdapter) {\n\t\treturn basicStatus;\n\t}\n\n\ttry {\n\t\t// Get database health metrics using DatabaseResilience\n\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\tconst resilience = getDatabaseResilience();\n\n\t\t// Perform health check with database ping\n\t\tconst healthResult = await resilience.healthCheck(async () => {\n\t\t\tif (!dbAdapter) throw new Error('dbAdapter is null');\n\t\t\tconst start = Date.now();\n\t\t\t// Ping the database by running a lightweight query\n\t\t\tif (dbAdapter.isConnected && dbAdapter.isConnected()) {\n\t\t\t\treturn Date.now() - start;\n\t\t\t}\n\t\t\tthrow new Error('Database not connected');\n\t\t});\n\n\t\t// Get resilience metrics for additional insights\n\t\tconst metrics = resilience.getMetrics();\n\n\t\treturn {\n\t\t\t...basicStatus,\n\t\t\thealth: {\n\t\t\t\thealthy: healthResult.healthy,\n\t\t\t\tlatency: healthResult.latency,\n\t\t\t\tmessage: healthResult.message\n\t\t\t},\n\t\t\tmetrics: {\n\t\t\t\ttotalRetries: metrics.totalRetries,\n\t\t\t\tsuccessfulRetries: metrics.successfulRetries,\n\t\t\t\tfailedRetries: metrics.failedRetries,\n\t\t\t\ttotalReconnections: metrics.totalReconnections,\n\t\t\t\tsuccessfulReconnections: metrics.successfulReconnections,\n\t\t\t\tconnectionUptime: metrics.connectionUptime,\n\t\t\t\taverageRecoveryTime: Math.round(metrics.averageRecoveryTime)\n\t\t\t}\n\t\t};\n\t} catch (error) {\n\t\t// If health check fails, return basic status with error\n\t\treturn {\n\t\t\t...basicStatus,\n\t\t\thealth: {\n\t\t\t\thealthy: false,\n\t\t\t\tlatency: -1,\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Health check failed'\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport function getAuth() {\n\treturn auth;\n}\n\nexport async function reinitializeSystem(force = false, waitForAuth = true): Promise<{ status: string; error?: string }> {\n\tif (isInitialized && !force) {\n\t\treturn { status: 'already-initialized' };\n\t}\n\n\t// If force is true, clear any existing initialization promise and reload config\n\tif (force) {\n\t\tlogger.info('Force reinitialization requested - clearing existing initialization promise and reloading config');\n\t\tinitializationPromise = null;\n\t\tisInitialized = false;\n\t\tisConnected = false;\n\t\tauth = null;\n\t\t// Force reload private config\n\t\tawait loadPrivateConfig(true);\n\t\t// Reset system state\n\t\tawait setSystemState('IDLE', 'Preparing for reinitialization');\n\t}\n\n\tif (initializationPromise) {\n\t\treturn { status: 'initialization-in-progress' };\n\t}\n\n\ttry {\n\t\tlogger.info(`Manual reinitialization requested${force ? ' (force)' : ''}${!waitForAuth ? ' (skip auth wait)' : ''}`);\n\t\tinitializationPromise = initializeSystem(force);\n\t\tawait initializationPromise;\n\n\t\t// Optionally wait for auth service to be ready (skip during setup to avoid blocking)\n\t\tif (waitForAuth) {\n\t\t\tlogger.info('Waiting for auth service to become available after reinitialization...');\n\t\t\tconst authReady = await waitForServiceHealthy('auth', { timeoutMs: 3000 }); // Reduced from 10s to 3s\n\t\t\tif (!authReady) {\n\t\t\t\tlogger.warn('Auth service not ready after timeout, but will continue');\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.info('Skipping auth readiness wait (setup mode)');\n\t\t}\n\n\t\treturn { status: 'initialized' };\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\t// Clear the failed promise so retries are possible\n\t\tinitializationPromise = null;\n\t\treturn { status: 'failed', error: message };\n\t}\n}\n\n/**\n * Initialize system with provided configuration (in-memory) - MOST EFFICIENT\n * This is the recommended method for zero-restart setup completion.\n * Bypasses filesystem completely by accepting configuration in memory.\n *\n * Use this during setup completion to avoid:\n * - Vite module cache issues\n * - Filesystem read operations\n * - Double initialization\n *\n * @param config - Complete private environment configuration\n * @returns Promise with initialization status\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function initializeWithConfig(config: any): Promise<{ status: string; error?: string }> {\n\ttry {\n\t\tlogger.info(' Initializing system with provided configuration (bypassing Vite cache & filesystem)...');\n\n\t\t// CRITICAL: Set config in memory BEFORE initialization\n\t\tprivateEnv = config;\n\n\t\t// Clear any existing initialization state\n\t\tinitializationPromise = null;\n\t\tisInitialized = false;\n\t\tisConnected = false;\n\t\tauth = null;\n\t\tawait setSystemState('IDLE', 'Preparing for initialization with in-memory config');\n\n\t\tlogger.debug('In-memory config set successfully', {\n\t\t\tDB_TYPE: config.DB_TYPE,\n\t\t\tDB_HOST: config.DB_HOST ? '***' : 'missing',\n\t\t\thasJWT: !!config.JWT_SECRET_KEY,\n\t\t\thasEncryption: !!config.ENCRYPTION_KEY\n\t\t});\n\n\t\t// Initialize system with in-memory config\n\t\t// skipSetupCheck = true tells initializeSystem to use privateEnv instead of importing\n\t\tinitializationPromise = initializeSystem(false, true);\n\t\tawait initializationPromise;\n\n\t\tlogger.info(' System initialized successfully with in-memory config (zero-restart)');\n\t\treturn { status: 'success' };\n\t} catch (error) {\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\tlogger.error('Failed to initialize with in-memory config:', errorMessage);\n\t\tinitializationPromise = null;\n\t\tprivateEnv = null; // Clear failed config\n\t\tawait setSystemState('FAILED', `Initialization failed: ${errorMessage}`);\n\t\treturn { status: 'failed', error: errorMessage };\n\t}\n}\n\n/**\n * Initialize system by loading private.ts from filesystem (bypasses Vite cache).\n * LEGACY METHOD - Use initializeWithConfig() for better performance when config is already in memory.\n *\n * Use this during setup when private.ts was just created on filesystem but hasn't been\n * loaded by Vite yet due to module caching.\n *\n * @returns Promise with initialization status\n */\nexport async function initializeWithFreshConfig(): Promise<{ status: string; error?: string }> {\n\t// Clear any existing initialization\n\tlogger.info('Initializing system with fresh config from filesystem (bypassing Vite cache)...');\n\tinitializationPromise = null;\n\tisInitialized = false;\n\tisConnected = false;\n\tauth = null;\n\tprivateEnv = null; // Clear cache to force reload\n\tawait setSystemState('IDLE', 'Preparing for initialization with fresh config');\n\n\ttry {\n\t\t// Force reload private.ts from filesystem (bypasses Vite's module cache)\n\t\tconst freshConfig = await loadPrivateConfig(true);\n\n\t\tif (!freshConfig || !freshConfig.DB_TYPE) {\n\t\t\tthrow new Error('Failed to load private config from filesystem');\n\t\t}\n\n\t\tlogger.debug('Fresh config loaded from filesystem', {\n\t\t\tDB_TYPE: freshConfig.DB_TYPE,\n\t\t\tDB_HOST: freshConfig.DB_HOST ? '***' : 'missing',\n\t\t\thasJWT: !!freshConfig.JWT_SECRET_KEY,\n\t\t\thasEncryption: !!freshConfig.ENCRYPTION_KEY\n\t\t});\n\n\t\t// Now call initializeSystem - it will use the freshly loaded config\n\t\tinitializationPromise = initializeSystem(false, true); // skipSetupCheck = true\n\t\tawait initializationPromise;\n\n\t\tlogger.info(' System initialized successfully with fresh config');\n\t\treturn { status: 'initialized' };\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tlogger.error('Failed to initialize with fresh config:', message);\n\t\tinitializationPromise = null;\n\t\tprivateEnv = null; // Clear failed config\n\t\treturn { status: 'failed', error: message };\n\t}\n}\n\n/**\n * Get the current database adapter instance\n * @returns The database adapter or null if not initialized\n */\nexport function getDb(): DatabaseAdapter | null {\n\treturn dbAdapter;\n}\n\n/**\n * Initialize a database connection for seeding purposes\n * @param dbConfig Database configuration\n */\nexport async function initConnection(dbConfig: {\n\ttype: string;\n\thost: string;\n\tport: string;\n\tname: string;\n\tuser?: string;\n\tpassword?: string;\n}): Promise<void> {\n\t// For seeding, we need to create a temporary adapter instance\n\t// This is a simplified version that works with the existing MongoDB setup\n\n\tif (!dbConfig || !dbConfig.type) {\n\t\tthrow new Error('Database configuration is required');\n\t}\n\n\tif (dbConfig.type !== 'mongodb') {\n\t\tthrow new Error(`Database type '${dbConfig.type}' is not supported for seeding yet`);\n\t}\n\n\ttry {\n\t\t// Import MongoDB adapter\n\t\tconst { MongoDBAdapter } = await import('./mongodb/mongoDBAdapter');\n\n\t\t// Create a new adapter instance for seeding\n\t\tconst tempAdapter = new MongoDBAdapter();\n\n\t\t// Build connection string like the test endpoint does\n\t\tconst { buildDatabaseConnectionString } = await import('@shared/utils/database');\n\t\tconst connectionString = buildDatabaseConnectionString({\n\t\t\ttype: dbConfig.type as 'mongodb' | 'mongodb+srv',\n\t\t\thost: dbConfig.host,\n\t\t\tport: Number(dbConfig.port),\n\t\t\tname: dbConfig.name,\n\t\t\tuser: dbConfig.user ?? '',\n\t\t\tpassword: dbConfig.password ?? ''\n\t\t});\n\t\tconst isAtlas = connectionString.startsWith('mongodb+srv://');\n\n\t\tconst options = {\n\t\t\tuser: dbConfig.user || undefined,\n\t\t\tpass: dbConfig.password || undefined,\n\t\t\tdbName: dbConfig.name,\n\t\t\tauthSource: isAtlas ? undefined : 'admin',\n\t\t\tretryWrites: true,\n\t\t\tserverSelectionTimeoutMS: 15000,\n\t\t\tmaxPoolSize: 1 // Use a minimal pool for seeding\n\t\t};\n\n\t\t// Connect using the custom connection string and options\n\t\tconst connectResult = await tempAdapter.connect(connectionString, options);\n\t\tif (!connectResult.success) {\n\t\t\tthrow new Error(`Database connection failed: ${connectResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\t// Set this as the global adapter for seeding\n\t\tdbAdapter = tempAdapter as unknown as DatabaseAdapter;\n\n\t\tlogger.info('Database connection initialized for seeding');\n\t} catch (error) {\n\t\tlogger.error('Failed to initialize database connection for seeding:', error);\n\t\tthrow error;\n\t}\n}\n","/**\n * @file src/utils/logger.server.ts\n * @description Server-only logger with formatting, batching, rotation & masking\n *\n * Features:\n * - Level-based logging (fatal  trace)\n * - Smart terminal formatting & token highlighting\n * - Sensitive data masking\n * - Batched file writes with rotation & optional compression\n * - Configurable via env/public settings\n * - Graceful degradation & cleanup\n */\n\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\n\n// Browser detection - if imported in browser, export noop logger to prevent crashes\nconst IS_BROWSER = typeof window !== 'undefined';\n\nif (IS_BROWSER) {\n\t// Log a warning in development mode only (don't throw, just gracefully degrade)\n\tconsole.warn('[logger.server.ts] Server logger imported in browser - using noop fallback');\n}\n\n// Env helpers\nconst getEnv = <T>(key: keyof typeof publicEnv, fallback: T): T => {\n\ttry {\n\t\tconst v = publicEnv[key];\n\t\treturn v !== undefined ? (v as T) : fallback;\n\t} catch {\n\t\treturn fallback;\n\t}\n};\n\nconst LOG_LEVELS = getEnv('LOG_LEVELS', ['fatal', 'error', 'warn', 'info']);\nconst DISABLED = LOG_LEVELS.includes('none');\n\n// Log levels\ntype LogLevel = 'none' | 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace';\nconst LEVELS: Record<LogLevel, { prio: number; color: string }> = {\n\tnone: { prio: 0, color: '' },\n\tfatal: { prio: 1, color: '\\x1b[35m' }, // magenta\n\terror: { prio: 2, color: '\\x1b[31m' }, // red\n\twarn: { prio: 3, color: '\\x1b[33m' }, // yellow\n\tinfo: { prio: 4, color: '\\x1b[32m' }, // green\n\tdebug: { prio: 5, color: '\\x1b[34m' }, // blue\n\ttrace: { prio: 6, color: '\\x1b[36m' } // cyan\n};\n\nconst RESET = '\\x1b[0m';\nexport type LoggableValue = string | number | boolean | null | undefined | object | Date | Error;\n\nconst maxPrio = DISABLED ? 0 : Math.max(...LOG_LEVELS.map((l) => LEVELS[l as LogLevel]?.prio ?? 0));\n\n// Icons\nconst ICONS: Record<string, string> = {\n\tFATAL: '',\n\tERROR: '',\n\tWARN: '',\n\tINFO: '',\n\tDEBUG: '',\n\tTRACE: ''\n};\n\n// Message token highlighting\nconst patterns = [\n\t{ re: /\\b\\d+(\\.\\d+)?(ms|s)\\b/g, color: '\\x1b[32m' }, // durations\n\t{\n\t\tre: /([a-f0-9]{24}|[a-f0-9]{32}|[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/gi,\n\t\tcolor: '\\x1b[33m'\n\t}, // IDs/UUIDs\n\t{ re: /\\/api\\/[^\\s]+/g, color: '\\x1b[36m' }, // API paths\n\t{ re: /\\b(true)\\b/g, color: '\\x1b[32m' },\n\t{ re: /\\b(false)\\b/g, color: '\\x1b[31m' },\n\t{ re: /\\b-?\\d+\\.?\\d*\\b/g, color: '\\x1b[34m' }\n];\n\nfunction colorMessage(msg: string): string {\n\tlet out = msg;\n\tfor (const { re, color } of patterns) {\n\t\tout = out.replace(re, `${color}$1${RESET}`);\n\t}\n\treturn out;\n}\n\n// Value formatting\nfunction formatValue(v: unknown): string {\n\tif (v === null) return '\\x1b[35mnull\\x1b[0m';\n\tif (v === undefined) return '\\x1b[90mundefined\\x1b[0m';\n\tif (typeof v === 'boolean') return v ? '\\x1b[32mtrue\\x1b[0m' : '\\x1b[31mfalse\\x1b[0m';\n\tif (typeof v === 'number') return `\\x1b[34m${v}\\x1b[0m`;\n\tif (typeof v === 'string') return colorMessage(v);\n\tif (v instanceof Date) return `\\x1b[36m${v.toISOString()}\\x1b[0m`;\n\tif (Array.isArray(v)) return `\\x1b[33m[${v.map(formatValue).join(', ')}]\\x1b[0m`;\n\tif (typeof v === 'object') {\n\t\tconst entries = Object.entries(v)\n\t\t\t.map(([k, val]) => `${k}: ${formatValue(val)}`)\n\t\t\t.join(', ');\n\t\treturn `\\x1b[33m{${entries}}\\x1b[0m`;\n\t}\n\treturn String(v);\n}\n\n// Sensitive data masking\nconst SENSITIVE = ['password', 'token', 'secret', 'key', 'authorization'];\nconst EMAILS = ['email', 'mail'];\n\nfunction mask(v: unknown, depth = 0): unknown {\n\tif (depth > 10) return '[Depth]';\n\tif (v === null || typeof v !== 'object') return v;\n\tif (v instanceof Date || v instanceof RegExp) return v;\n\tif (Array.isArray(v)) return v.map((item) => mask(item, depth + 1));\n\n\tconst masked: Record<string, unknown> = {};\n\tfor (const [k, val] of Object.entries(v)) {\n\t\tconst low = k.toLowerCase();\n\t\tif (SENSITIVE.some((s) => low.includes(s))) masked[k] = '[REDACTED]';\n\t\telse if (EMAILS.some((e) => low.includes(e)) && typeof val === 'string') {\n\t\t\tconst [local, domain] = val.split('@');\n\t\t\tmasked[k] = domain ? `${local.slice(0, 2)}***@${domain}` : '***';\n\t\t} else {\n\t\t\tmasked[k] = mask(val, depth + 1);\n\t\t}\n\t}\n\treturn masked;\n}\n\n// File ops (lazy loaded)\nlet stream: import('node:fs').WriteStream | null = null;\nlet modules: any = null;\n\nasync function getMods() {\n\tif (modules) return modules;\n\tmodules = {\n\t\tfs: await import('node:fs'),\n\t\tpath: await import('node:path'),\n\t\tzlib: await import('node:zlib'),\n\t\tstream: await import('node:stream/promises'),\n\t\tpromises: await import('node:fs/promises')\n\t};\n\treturn modules;\n}\n\nasync function ensureStream() {\n\tconst { path, fs } = await getMods();\n\tconst dir = 'logs';\n\tconst file = path.join(dir, 'app.log');\n\n\tif (!stream || stream.destroyed) {\n\t\tawait (await getMods()).promises.mkdir(dir, { recursive: true });\n\t\tstream = fs.createWriteStream(file, { flags: 'a' });\n\t}\n\treturn stream;\n}\n\nasync function rotate() {\n\tconst { path, promises, zlib, stream: sp } = await getMods();\n\tconst file = path.join('logs', 'app.log');\n\ttry {\n\t\tconst stat = await promises.stat(file);\n\t\tif (stat.size < 5 * 1024 * 1024) return; // 5MB\n\n\t\tif (stream) stream.end();\n\t\tconst ts = new Date().toISOString().replace(/[:.]/g, '-');\n\t\tconst rotated = `${file}.${ts}`;\n\t\tawait promises.rename(file, rotated);\n\t\tawait promises.writeFile(file, '');\n\n\t\tif (true) {\n\t\t\t// compression enabled\n\t\t\tconst src = (await getMods()).fs.createReadStream(rotated);\n\t\t\tconst dst = (await getMods()).fs.createWriteStream(`${rotated}.gz`);\n\t\t\tawait sp.pipeline(src, zlib.createGzip(), dst);\n\t\t\tawait promises.unlink(rotated);\n\t\t}\n\t} catch (e: any) {\n\t\tif (e.code !== 'ENOENT') console.error('Rotation failed:', e);\n\t}\n}\n\n// Batch queue\nconst queue: { level: LogLevel; msg: string; args: unknown[] }[] = [];\nlet timeout: NodeJS.Timeout | null = null;\n\nfunction flush() {\n\tif (!queue.length) return;\n\tconst batch = queue.splice(0, queue.length);\n\tconst lines = batch\n\t\t.map((e) => {\n\t\t\tconst ts = new Date().toISOString().slice(0, 19).replace('T', ' ');\n\t\t\tconst icon = ICONS[e.level.toUpperCase()] ?? '';\n\t\t\tconst color = LEVELS[e.level].color;\n\t\t\tconst masked = e.args.map((a) => mask(a));\n\t\t\tconst args = masked.map(formatValue).join(' ');\n\t\t\tconst msg = colorMessage(e.msg);\n\t\t\treturn `${ts} ${color}${icon} [${e.level.toUpperCase().padEnd(5)}]${RESET} ${msg} ${args}`;\n\t\t})\n\t\t.join('\\n');\n\tensureStream()\n\t\t.then((s) => {\n\t\t\tif (s) rotate().finally(() => s.write(lines + '\\n'));\n\t\t})\n\t\t.catch((err) => console.error('Log write failed:', err));\n}\n\nfunction enqueue(level: LogLevel, msg: string, args: unknown[]) {\n\tif (DISABLED || LEVELS[level].prio > maxPrio) return;\n\n\tconst masked = args.map(mask);\n\tconst color = LEVELS[level].color;\n\tconst icon = ICONS[level.toUpperCase()] ?? '';\n\tconst argsStr = masked.map(formatValue).join(' ');\n\tconst pretty = colorMessage(msg);\n\n\tconst ts = new Date().toISOString().slice(0, 19).replace('T', ' ');\n\tprocess.stdout.write(`${ts} ${color}${icon} [${level.toUpperCase().padEnd(5)}]${RESET} ${pretty} ${argsStr}\\n`);\n\n\tqueue.push({ level, msg, args: masked });\n\tif (queue.length >= 100) flush();\n\telse if (!timeout)\n\t\ttimeout = setTimeout(() => {\n\t\t\ttimeout = null;\n\t\t\tflush();\n\t\t}, 5000);\n}\n\n// Public logger - returns noop in browser or when disabled\nexport const logger =\n\tIS_BROWSER || DISABLED\n\t\t? {\n\t\t\t\tfatal: () => {},\n\t\t\t\terror: () => {},\n\t\t\t\twarn: () => {},\n\t\t\t\tinfo: () => {},\n\t\t\t\tdebug: () => {},\n\t\t\t\ttrace: () => {}\n\t\t\t}\n\t\t: {\n\t\t\t\tfatal: (m: string, ...a: unknown[]) => enqueue('fatal', m, a),\n\t\t\t\terror: (m: string, ...a: unknown[]) => enqueue('error', m, a),\n\t\t\t\twarn: (m: string, ...a: unknown[]) => enqueue('warn', m, a),\n\t\t\t\tinfo: (m: string, ...a: unknown[]) => enqueue('info', m, a),\n\t\t\t\tdebug: (m: string, ...a: unknown[]) => enqueue('debug', m, a),\n\t\t\t\ttrace: (m: string, ...a: unknown[]) => enqueue('trace', m, a)\n\t\t\t};\n","/**\n * @file src/routes/api/setup/seed.ts\n * @description Seeds the database with default system settings\n *\n * This replaces the static configuration files with database settings.\n * Uses database-agnostic interfaces for compatibility across different database engines.\n *\n * Collection Seeding Strategy:\n * - seedCollectionsForSetup(): Lightweight version for setup that directly reads compiled\n *   collections from filesystem and creates models. Bypasses ContentManager to avoid\n *   global dbAdapter dependency issues during setup mode.\n * - This allows ContentManager to have collections pre-cached when system fully initializes,\n *   resulting in faster redirects and better UX after setup completion.\n */\n\nimport { publicConfigSchema } from '@shared/database/schemas';\nimport type { DatabaseId } from '@cms-types';\nimport type { DatabaseAdapter, Theme } from '@shared/database/dbInterface';\nimport { invalidateSettingsCache } from '@shared/services/settingsService';\nimport { logger } from '@shared/utils/logger.server';\nimport { dateToISODateString } from '@shared/utils/dateUtils';\nimport { safeParse } from 'valibot';\nimport { getAllPermissions } from '@shared/database/auth';\nimport { defaultRoles as importedDefaultRoles } from '@shared/database/auth/defaultRoles';\n\n// Import inlang settings directly (TypeScript/SvelteKit handles JSON imports)\nimport inlangSettings from '@root/project.inlang/settings.json';\nimport { setupManager } from '@shared/utils/setupManager';\n\n// ============================================================================\n// EXPORTED DEFAULTS - Loaded from project.inlang/settings.json\n// ============================================================================\n\nexport const DEFAULT_SYSTEM_LANGUAGES = inlangSettings.locales || ['en', 'de'];\nexport const DEFAULT_BASE_LOCALE = inlangSettings.baseLocale || 'en';\nexport const DEFAULT_CONTENT_LANGUAGES = DEFAULT_SYSTEM_LANGUAGES;\nexport const DEFAULT_CONTENT_LANGUAGE = DEFAULT_BASE_LOCALE;\n\n// ============================================================================\n\n// Type for setting data in snapshots\ninterface SettingData {\n\tvalue: unknown;\n\tvisibility?: 'public' | 'private';\n\tcategory?: 'public' | 'private';\n\tdescription?: string;\n}\n\n// Default theme that matches the ThemeManager's DEFAULT_THEME\nconst defaultTheme: Theme = {\n\t_id: '670e8b8c4d123456789abcde' as DatabaseId, // MongoDB ObjectId-style string\n\tpath: '', // Default path\n\tname: 'SveltyCMSTheme',\n\n\tisActive: false,\n\tisDefault: true,\n\tconfig: {\n\t\ttailwindConfigPath: '',\n\t\tassetsPath: ''\n\t},\n\tcreatedAt: dateToISODateString(new Date()),\n\tupdatedAt: dateToISODateString(new Date())\n};\n\n// Re-export defaultRoles from shared module for backward compatibility\nexport const defaultRoles = importedDefaultRoles;\n\n// Seeds the default theme into the database\nexport async function seedDefaultTheme(dbAdapter: DatabaseAdapter, tenantId?: string): Promise<void> {\n\tlogger.info(` Checking if default theme needs seeding${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\n\tif (!dbAdapter || !dbAdapter.themes) {\n\t\tthrow new Error('Database adapter or themes interface not available');\n\t}\n\n\ttry {\n\t\t// Check if themes already exist\n\t\tconst existingThemes = await dbAdapter.themes.getAllThemes();\n\t\tif (Array.isArray(existingThemes) && existingThemes.length > 0) {\n\t\t\tlogger.info(` Themes already exist${tenantId ? ` for tenant ${tenantId}` : ''}, skipping theme seeding`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Seed the default theme\n\t\tlogger.info(` Seeding default theme${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\t\tconst themeToStore = {\n\t\t\t...defaultTheme,\n\t\t\t...(tenantId && { tenantId })\n\t\t};\n\t\tawait dbAdapter.themes.storeThemes([themeToStore]);\n\t\tlogger.info(` Default theme seeded successfully${tenantId ? ` for tenant ${tenantId}` : ''}`);\n\t} catch (error) {\n\t\tlogger.error(`Failed to seed default theme${tenantId ? ` for tenant ${tenantId}` : ''}:`, error);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Seeds default roles into the database\n * Roles are now stored in database for dynamic management via UI\n * Admin role gets all available permissions automatically\n */\nexport async function seedRoles(dbAdapter: DatabaseAdapter, tenantId?: string): Promise<void> {\n\tlogger.info(` Seeding default roles${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\n\tif (!dbAdapter || !dbAdapter.auth) {\n\t\tthrow new Error('Database adapter or auth interface not available');\n\t}\n\n\ttry {\n\t\t// Get all available permissions for admin role\n\t\tconst allPermissions = getAllPermissions();\n\t\tconst adminPermissions = allPermissions.map((p) => p._id);\n\n\t\t// Seed each default role\n\t\tfor (const role of defaultRoles) {\n\t\t\ttry {\n\t\t\t\t// Admin role gets all permissions\n\t\t\t\tconst roleToCreate = {\n\t\t\t\t\t...role,\n\t\t\t\t\tpermissions: role._id === 'admin' ? adminPermissions : role.permissions,\n\t\t\t\t\t...(tenantId && { tenantId })\n\t\t\t\t};\n\n\t\t\t\tawait dbAdapter.auth.createRole(roleToCreate);\n\t\t\t\tlogger.debug(` Role \"${role.name}\" seeded successfully${tenantId ? ` for tenant ${tenantId}` : ''}`);\n\t\t\t} catch (error) {\n\t\t\t\t// Skip if role already exists (duplicate key error)\n\t\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\t\tif (errorMessage.includes('duplicate') || errorMessage.includes('E11000')) {\n\t\t\t\t\tlogger.debug(`  Role \"${role.name}\" already exists${tenantId ? ` for tenant ${tenantId}` : ''}, skipping`);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.error(`Failed to seed role \"${role.name}\"${tenantId ? ` for tenant ${tenantId}` : ''}:`, error);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.info(` Default roles seeded successfully${tenantId ? ` for tenant ${tenantId}` : ''}`);\n\t} catch (error) {\n\t\tlogger.error(`Failed to seed roles${tenantId ? ` for tenant ${tenantId}` : ''}:`, error);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Seeds collections from filesystem into database\n * This bypasses ContentManager to avoid global dbAdapter dependency during setup\n *\n * @returns Information about the first collection (for faster redirects)\n */\nexport async function seedCollectionsForSetup(\n\tdbAdapter: DatabaseAdapter,\n\ttenantId?: string\n): Promise<{ firstCollection: { name: string; path: string } | null }> {\n\tconst overallStart = performance.now();\n\tlogger.info(` Seeding collections from filesystem${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\n\tif (!dbAdapter || !dbAdapter.collection) {\n\t\tthrow new Error('Database adapter or collection interface not available');\n\t}\n\n\tlet firstCollection: { name: string; path: string } | null = null;\n\n\ttry {\n\t\t// Import the collection scanner directly from shared\n\t\tconst { scanCompiledCollections } = await import('@shared/utils/content/scanner');\n\n\t\tconst scanStart = performance.now();\n\t\tconst collections = await scanCompiledCollections();\n\t\tconst scanTime = performance.now() - scanStart;\n\t\tlogger.debug(`  Collection scan: ${scanTime.toFixed(2)}ms (found ${collections.length})`);\n\n\t\tif (collections.length === 0) {\n\t\t\tlogger.info('  No collections found in filesystem, skipping collection seeding');\n\t\t\treturn { firstCollection: null };\n\t\t}\n\n\t\tlogger.info(`Found ${collections.length} collections to seed`);\n\n\t\tlet successCount = 0;\n\t\tlet skipCount = 0;\n\t\tconst totalCollections = collections.length;\n\t\tconst modelCreationStart = performance.now();\n\n\t\t// Delay between collection registrations to prevent Mongoose race conditions\n\t\t// Use shorter delay in CI/test mode for faster builds\n\t\tconst isTestMode = process.env.TEST_MODE === 'true';\n\t\tconst registrationDelay = isTestMode ? 10 : 50; // 10ms in CI, 50ms in production\n\n\t\tlogger.debug(` Seeding ${totalCollections} collections (delay: ${registrationDelay}ms, testMode: ${isTestMode})`);\n\n\t\t// Register each collection SEQUENTIALLY to prevent Mongoose registry race conditions\n\t\tfor (let i = 0; i < totalCollections; i++) {\n\t\t\tconst schema = collections[i];\n\t\t\tsetupManager.updateProgress(i, totalCollections);\n\t\t\ttry {\n\t\t\t\tconst createStart = performance.now();\n\t\t\t\t// Try to create the collection model in database\n\t\t\t\tawait dbAdapter.collection.createModel(schema);\n\n\t\t\t\t// Small delay to ensure model registration completes before next one\n\t\t\t\t// Reduced from 100ms: 10ms in CI, 50ms in production\n\t\t\t\tif (i < totalCollections - 1) {\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, registrationDelay));\n\t\t\t\t}\n\n\t\t\t\tconst createTime = performance.now() - createStart;\n\t\t\t\tlogger.info(` Created collection model: ${schema.name || 'unknown'} (${createTime.toFixed(0)}ms)`);\n\t\t\t\tsuccessCount++;\n\n\t\t\t\t// Capture the first collection for redirect\n\t\t\t\tif (!firstCollection && schema.path && schema.name) {\n\t\t\t\t\tconst collectionName = schema.name; // Narrow the type\n\t\t\t\t\tconst collectionPath = schema.path; // Narrow the type\n\t\t\t\t\tfirstCollection = {\n\t\t\t\t\t\tname: collectionName,\n\t\t\t\t\t\tpath: collectionPath\n\t\t\t\t\t};\n\t\t\t\t\tlogger.debug(`First collection identified: ${collectionName} at ${collectionPath}`);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Collection might already exist or have schema issues\n\t\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\t\tif (errorMessage.includes('already exists') || errorMessage.includes('duplicate')) {\n\t\t\t\t\tlogger.debug(`Collection '${schema.name || 'unknown'}' already exists, skipping`);\n\t\t\t\t\tskipCount++;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.error(` Failed to create collection '${schema.name || 'unknown'}'${tenantId ? ` for tenant ${tenantId}` : ''}: ${errorMessage}`);\n\t\t\t\t\tif (error instanceof Error && error.stack) {\n\t\t\t\t\t\tlogger.debug('Stack trace:', error.stack);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetupManager.updateProgress(totalCollections, totalCollections);\n\n\t\tconst modelCreationTime = performance.now() - modelCreationStart;\n\t\tconst overallTime = performance.now() - overallStart;\n\n\t\tlogger.info(` Collections seeding completed: ${successCount} created, ${skipCount} skipped`);\n\t\tlogger.info(`  Model creation time: ${modelCreationTime.toFixed(2)}ms`);\n\t\tlogger.info(`  Total seed time: ${overallTime.toFixed(2)}ms`);\n\n\t\treturn { firstCollection };\n\t} catch (error) {\n\t\tconst overallTime = performance.now() - overallStart;\n\t\tif (error instanceof Error) {\n\t\t\tlogger.error(`Failed to seed collections after ${overallTime.toFixed(2)}ms: ${error.message}`);\n\t\t\tif (error.stack) {\n\t\t\t\tlogger.debug('Stack trace:', error.stack);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.error(`Failed to seed collections after ${overallTime.toFixed(2)}ms:`, error);\n\t\t}\n\t\t// Don't throw - collections can be created later through the UI\n\t\tlogger.warn('Continuing setup without collection seeding...');\n\t\treturn { firstCollection: null };\n\t}\n}\n\n// Initialize system from setup using database-agnostic interface\nexport async function initSystemFromSetup(\n\tadapter: DatabaseAdapter,\n\ttenantId?: string,\n\tisDemoSeed = false\n): Promise<{ firstCollection: { name: string; path: string } | null }> {\n\tlogger.info(` Starting system initialization from setup${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\n\tif (!adapter) {\n\t\tthrow new Error('Database adapter not available. Database must be initialized first.');\n\t}\n\n\t// Seed the database with default settings using database-agnostic interface\n\tawait seedSettings(adapter, tenantId, isDemoSeed);\n\n\t// Seed the default theme\n\tawait seedDefaultTheme(adapter, tenantId);\n\n\t// Seed default roles into database (from shared defaultRoles module)\n\tawait seedRoles(adapter, tenantId);\n\n\t// Seed collections from filesystem\n\t// This creates collection models in MongoDB so ContentManager can access them quickly\n\t// Uses seedCollectionsForSetup() which bypasses ContentManager to avoid global dbAdapter dependency\n\tconst { firstCollection } = await seedCollectionsForSetup(adapter, tenantId);\n\n\t// Invalidate the settings cache and reload from database\n\tinvalidateSettingsCache();\n\tconst { loadSettingsFromDB } = await import('@shared/database/db');\n\tawait loadSettingsFromDB();\n\n\tlogger.info(` System initialization completed${tenantId ? ` for tenant ${tenantId}` : ''}`);\n\n\treturn { firstCollection };\n}\n\n// Default public settings that were previously in config/public.ts\nexport const defaultPublicSettings: Array<{ key: string; value: unknown; description?: string }> = [\n\t// Host configuration\n\t{ key: 'HOST_DEV', value: 'http://localhost:5173', description: 'Development server URL' },\n\t{ key: 'HOST_PROD', value: 'https://yourdomain.com', description: 'Production server URL' },\n\n\t// Site configuration\n\t{ key: 'SITE_NAME', value: 'SveltyCMS', description: 'The public name of the website' },\n\t{ key: 'PASSWORD_LENGTH', value: 8, description: 'Minimum required length for user passwords' },\n\n\t// Language Configuration\n\t{ key: 'DEFAULT_CONTENT_LANGUAGE', value: DEFAULT_CONTENT_LANGUAGE, description: 'Default language for content' },\n\t{ key: 'AVAILABLE_CONTENT_LANGUAGES', value: DEFAULT_CONTENT_LANGUAGES, description: 'List of available content languages' },\n\t{ key: 'BASE_LOCALE', value: DEFAULT_BASE_LOCALE, description: 'Default/base locale for the CMS interface' },\n\t{ key: 'LOCALES', value: DEFAULT_SYSTEM_LANGUAGES, description: 'List of available interface locales' },\n\n\t// Media configuration\n\t{ key: 'MEDIA_STORAGE_TYPE', value: 'local', description: 'Type of media storage (local, s3, r2, cloudinary)' },\n\t{ key: 'MEDIA_FOLDER', value: './mediaFolder', description: 'Server path where media files are stored' },\n\t{ key: 'MEDIA_OUTPUT_FORMAT_QUALITY', value: { format: 'webp', quality: 80 }, description: 'Image format and quality settings' },\n\t{ key: 'IMAGE_SIZES', value: { sm: 600, md: 900, lg: 1200 }, description: 'Image sizes for automatic resizing' },\n\t{ key: 'MAX_FILE_SIZE', value: 10485760, description: 'Maximum file size for uploads in bytes (10MB)' },\n\t{ key: 'BODY_SIZE_LIMIT', value: 10485760, description: 'Body size limit for server requests in bytes (10MB)' },\n\t{ key: 'USE_ARCHIVE_ON_DELETE', value: true, description: 'Enable archiving instead of permanent deletion' },\n\n\t// Seasons Icons for login page\n\t{ key: 'SEASONS', value: true, description: 'Enable seasonal themes on the login page' },\n\t{ key: 'SEASON_REGION', value: 'Western_Europe', description: 'Region for determining seasonal themes' },\n\n\t// Default Theme Configuration\n\t// The ID will be generated by the database adapter and set after insertion\n\t{ key: 'DEFAULT_THEME_ID', value: '', description: 'ID of the default theme (set by adapter)' },\n\t{ key: 'DEFAULT_THEME_NAME', value: 'SveltyCMSTheme', description: 'Name of the default theme' },\n\t{ key: 'DEFAULT_THEME_PATH', value: '', description: 'Path to the default theme CSS file' },\n\t{ key: 'DEFAULT_THEME_IS_DEFAULT', value: true, description: 'Whether the default theme is the default theme' },\n\n\t// Advanced Settings\n\t{ key: 'EXTRACT_DATA_PATH', value: './exports/data.json', description: 'File path for exported collection data' },\n\t{ key: 'PKG_VERSION', value: '1.0.0', description: 'Application version (can be overridden, but usually read from package.json)' },\n\n\t// NOTE: PKG_VERSION is read dynamically from package.json at runtime, not stored in DB\n\t// This ensures version always reflects the installed package and helps detect outdated installations\n\n\t// Logging\n\t{\n\t\tkey: 'LOG_LEVELS',\n\t\tvalue: ['info', 'warn', 'error', 'debug'],\n\t\tdescription: 'Active logging levels (none, info, warn, error, debug, fatal, trace)'\n\t},\n\t{ key: 'LOG_RETENTION_DAYS', value: 30, description: 'Number of days to keep log files' },\n\t{ key: 'LOG_ROTATION_SIZE', value: 10485760, description: 'Maximum size of a log file in bytes before rotation (10MB)' },\n\n\t// Demo Mode\n\t{ key: 'DEMO', value: false, description: 'Enable demo mode (restricts certain features)' }\n];\n\n/**\n * Default private settings that were previously in config/private.ts\n * Note: Sensitive settings like API keys should be set via GUI or CLI\n * Database config, JWT keys, and encryption keys are handled separately in private config files\n */\nexport const defaultPrivateSettings: Array<{ key: string; value: unknown; description?: string }> = [\n\t// Security / 2FA\n\t{ key: 'USE_2FA', value: false, description: 'Enable Two-Factor Authentication globally' },\n\t{ key: 'TWO_FACTOR_AUTH_BACKUP_CODES_COUNT', value: 10, description: 'Backup codes count for 2FA (1-50)' },\n\n\t// Telemetry (Privacy)\n\t{ key: 'SVELTYCMS_TELEMETRY', value: true, description: 'Enable SveltyCMS telemetry tracking' },\n\n\t// SMTP config\n\t{ key: 'SMTP_HOST', value: '', description: 'SMTP server host for sending emails' },\n\t{ key: 'SMTP_PORT', value: 587, description: 'SMTP server port' },\n\t{ key: 'SMTP_EMAIL', value: '', description: 'Email address to send from' },\n\t{ key: 'SMTP_PASSWORD', value: '', description: 'Password for the SMTP email account' },\n\n\t// Google OAuth\n\t{ key: 'USE_GOOGLE_OAUTH', value: false, description: 'Enable Google OAuth for login' },\n\t{ key: 'GOOGLE_CLIENT_ID', value: '', description: 'Google OAuth Client ID' },\n\t{ key: 'GOOGLE_CLIENT_SECRET', value: '', description: 'Google OAuth Client Secret' },\n\n\t// Redis config\n\t{ key: 'USE_REDIS', value: false, description: 'Enable Redis for caching' },\n\t{ key: 'REDIS_HOST', value: 'localhost', description: 'Redis server host address' },\n\t{ key: 'REDIS_PORT', value: 6379, description: 'Redis server port number' },\n\t{ key: 'REDIS_PASSWORD', value: '', description: 'Password for Redis server' },\n\n\t// Cache TTL Configuration (in seconds)\n\t{ key: 'CACHE_TTL_SCHEMA', value: 600, description: 'TTL for schema/collection definitions (10 minutes)' },\n\t{ key: 'CACHE_TTL_WIDGET', value: 600, description: 'TTL for widget data (10 minutes)' },\n\t{ key: 'CACHE_TTL_THEME', value: 300, description: 'TTL for theme configurations (5 minutes)' },\n\t{ key: 'CACHE_TTL_CONTENT', value: 180, description: 'TTL for content data (3 minutes)' },\n\t{ key: 'CACHE_TTL_MEDIA', value: 300, description: 'TTL for media metadata (5 minutes)' },\n\t{ key: 'CACHE_TTL_SESSION', value: 86400, description: 'TTL for user session data (24 hours)' },\n\t{ key: 'CACHE_TTL_USER', value: 60, description: 'TTL for user permissions (1 minute)' },\n\t{ key: 'CACHE_TTL_API', value: 300, description: 'TTL for API responses (5 minutes)' },\n\n\t// Session configuration\n\t{ key: 'SESSION_CLEANUP_INTERVAL', value: 300000, description: 'Interval in ms to clean up expired sessions (5 minutes)' },\n\t{ key: 'MAX_IN_MEMORY_SESSIONS', value: 1000, description: 'Maximum number of sessions to hold in memory' },\n\t{ key: 'DB_VALIDATION_PROBABILITY', value: 0.1, description: 'Probability (0-1) of validating a session against the DB' },\n\t{ key: 'SESSION_EXPIRATION_SECONDS', value: 86400, description: 'Duration in seconds until a session expires (24 hours)' },\n\n\t// Mapbox config\n\t{ key: 'USE_MAPBOX', value: false, description: 'Enable Mapbox integration' },\n\t{ key: 'MAPBOX_API_TOKEN', value: '', description: 'Public Mapbox API token (for client-side use)' },\n\t{ key: 'SECRET_MAPBOX_API_TOKEN', value: '', description: 'Secret Mapbox API token (for server-side use)' },\n\n\t// Other APIs\n\t{ key: 'GOOGLE_API_KEY', value: '', description: 'Google API Key for services like Maps and YouTube' },\n\t{ key: 'TWITCH_TOKEN', value: '', description: 'API token for Twitch integration' },\n\t{ key: 'USE_TIKTOK', value: false, description: 'Enable TikTok integration' },\n\t{ key: 'TIKTOK_TOKEN', value: '', description: 'API token for TikTok integration' },\n\n\t// Server configuration\n\t{ key: 'SERVER_PORT', value: 5173, description: 'Port for the application server' },\n\n\t// Roles and Permissions (previously required in private config)\n\t{ key: 'ROLES', value: ['admin', 'editor', 'viewer'], description: 'List of user roles available in the system' },\n\t{ key: 'PERMISSIONS', value: ['read', 'write', 'delete', 'admin'], description: 'List of permissions available in the system' }\n];\n\n/**\n * Seeds the database with default settings using database-agnostic interface.\n * This should be called during initial setup or when resetting to defaults.\n * Note: Database config and security keys are handled in private config files, not in DB\n * Only seeds settings that don't already exist (smart seeding).\n * @param dbAdapter Database adapter to use for operations\n */\nexport async function seedSettings(dbAdapter: DatabaseAdapter, tenantId?: string, isDemoSeed = false): Promise<void> {\n\tlogger.info(` Checking which settings need seeding${tenantId ? ` for tenant ${tenantId}` : ''}...`);\n\n\tif (!dbAdapter || !dbAdapter.systemPreferences) {\n\t\tthrow new Error('Database adapter or systemPreferences interface not available');\n\t}\n\n\t// Test database accessibility\n\ttry {\n\t\t// Try a simple getMany operation to test connectivity\n\t\tawait dbAdapter.systemPreferences.getMany(['HOST_DEV'], 'system');\n\t\tlogger.debug('Database adapter is accessible');\n\t} catch (error) {\n\t\tlogger.error('Database adapter is not accessible:', error);\n\t\tthrow new Error(`Cannot access database adapter: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n\n\tconst allSettings = [...defaultPublicSettings, ...defaultPrivateSettings];\n\n\t// Create a Set of private setting keys for efficient lookup\n\tconst privateSettingKeys = new Set(defaultPrivateSettings.map((s) => s.key));\n\n\t// Check which settings already exist\n\tconst allKeys = allSettings.map((s) => s.key);\n\tlet existingSettings: Record<string, unknown> = {};\n\n\ttry {\n\t\tconst result = await dbAdapter.systemPreferences.getMany(allKeys, 'system');\n\t\tif (result.success && result.data) {\n\t\t\texistingSettings = result.data;\n\t\t}\n\t} catch (error) {\n\t\tlogger.debug(`Could not check existing settings for tenant ${tenantId}, will seed all:`, error);\n\t}\n\n\t// Filter out settings that already exist\n\tconst settingsToSeed = allSettings.filter((setting) => !(setting.key in existingSettings));\n\n\tif (settingsToSeed.length === 0) {\n\t\tlogger.info(` All settings already exist${tenantId ? ` for tenant ${tenantId}` : ''}, skipping settings seeding`);\n\t\treturn;\n\t}\n\n\tlogger.info(\n\t\t` Seeding ${settingsToSeed.length} missing settings${tenantId ? ` for tenant ${tenantId}` : ''} (${Object.keys(existingSettings).length} already exist)...`\n\t);\n\n\t// Prepare settings for batch operation with category\n\tconst settingsToSet: Array<{\n\t\tkey: string;\n\t\tvalue: unknown;\n\t\tcategory: 'public' | 'private';\n\t\tscope: 'user' | 'system';\n\t\tuserId?: DatabaseId;\n\t\ttenantId?: string;\n\t}> = [];\n\n\tfor (const setting of settingsToSeed) {\n\t\t// Determine category based on whether the setting is in the private list\n\t\tconst category = privateSettingKeys.has(setting.key) ? 'private' : 'public';\n\n\t\tlet value = setting.value;\n\n\t\t// Override DEMO, SEASONS, SEASON_REGION if isDemoSeed\n\t\tif (isDemoSeed) {\n\t\t\tif (setting.key === 'DEMO') value = true;\n\t\t\tif (setting.key === 'SEASONS') value = true;\n\t\t\tif (setting.key === 'SEASON_REGION') value = 'Western_Europe';\n\t\t}\n\n\t\tsettingsToSet.push({\n\t\t\tkey: setting.key,\n\t\t\tvalue: value, // Store the actual value directly\n\t\t\tcategory, // Add category field for proper classification\n\t\t\tscope: 'system',\n\t\t\t...(tenantId && { tenantId })\n\t\t});\n\t}\n\n\t// Use batch operation for better performance\n\ttry {\n\t\tconst result = await dbAdapter.systemPreferences.setMany(settingsToSet);\n\n\t\tif (!result.success) {\n\t\t\tthrow new Error(result.error?.message || 'Failed to seed settings');\n\t\t}\n\n\t\tlogger.info(` Seeded ${settingsToSeed.length} missing settings`);\n\t} catch (error) {\n\t\tlogger.error(`Failed to seed settings${tenantId ? ` for tenant ${tenantId}` : ''}:`, error);\n\t\tthrow error;\n\t}\n\n\t// Populate public settings cache immediately after seeding\n\t// Private settings will be loaded later when the app starts and reads the private config file\n\ttry {\n\t\tlogger.info(' Populating public settings cache...');\n\n\t\t// Only organize public settings for immediate cache population\n\t\tconst publicSettings: Record<string, unknown> = {};\n\n\t\t// Add existing public settings first\n\t\tfor (const [key, value] of Object.entries(existingSettings)) {\n\t\t\tconst isPublic = defaultPublicSettings.some((s) => s.key === key);\n\t\t\tif (isPublic) {\n\t\t\t\tpublicSettings[key] = (value as any).value ?? value;\n\t\t\t}\n\t\t}\n\n\t\t// Add/overwrite with new seeded settings\n\t\tfor (const setting of settingsToSeed) {\n\t\t\tconst isPublic = defaultPublicSettings.some((s) => s.key === setting.key);\n\t\t\tif (isPublic) {\n\t\t\t\tpublicSettings[setting.key] = setting.value;\n\t\t\t}\n\t\t}\n\n\t\t// Validate public settings\n\t\tconst parsedPublic = safeParse(publicConfigSchema, publicSettings);\n\n\t\tif (parsedPublic.success) {\n\t\t\t// Private settings will be loaded when the app starts normally\n\t\t\tlogger.info(' Public settings validated successfully');\n\t\t} else {\n\t\t\tlogger.warn('Public settings validation failed');\n\t\t\t// Filter out expected undefined errors for cleaner logs if needed, or just log issues\n\t\t\tlogger.debug('Public settings validation issues:', parsedPublic.issues);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Failed to populate settings cache:', error);\n\t\t// Don't throw here - seeding was successful, cache population is just an optimization\n\t}\n}\n\n/**\n * Exports all current settings to a JSON file using database-agnostic interface.\n * This creates a settings snapshot for project templates.\n */\ntype SettingsSnapshot = {\n\tversion: string;\n\texportedAt: string;\n\tsettings: Record<string, { value: unknown; category: string; description: string }>;\n};\n\nexport async function exportSettingsSnapshot(dbAdapter: DatabaseAdapter): Promise<SettingsSnapshot> {\n\tif (!dbAdapter || !dbAdapter.systemPreferences) {\n\t\tthrow new Error('Database adapter or systemPreferences interface not available');\n\t}\n\n\t// Get all system settings - we'll need to implement a method to get all settings\n\t// For now, we'll get the known settings keys\n\tconst allSettingKeys = [...defaultPublicSettings, ...defaultPrivateSettings].map((s) => s.key);\n\n\tconst settingsResult = await dbAdapter.systemPreferences.getMany(allSettingKeys, 'system');\n\n\tif (!settingsResult.success) {\n\t\tthrow new Error(`Failed to export settings: ${settingsResult.error?.message}`);\n\t}\n\n\tconst snapshot: SettingsSnapshot = {\n\t\tversion: '1.0.0',\n\t\texportedAt: new Date().toISOString(),\n\t\tsettings: {}\n\t};\n\n\t// Transform the settings data\n\tfor (const [key, settingData] of Object.entries(settingsResult.data)) {\n\t\tif (settingData && typeof settingData === 'object' && 'data' in settingData) {\n\t\t\tconst data = settingData as { data: SettingData };\n\t\t\tsnapshot.settings[key] = {\n\t\t\t\tvalue: data.data.value,\n\t\t\t\tcategory: data.data.category || 'public',\n\t\t\t\tdescription: data.data.description || ''\n\t\t\t};\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n/**\n * Imports settings from a snapshot file using database-agnostic interface.\n * This allows restoring settings from a project template.\n */\nexport async function importSettingsSnapshot(snapshot: Record<string, unknown>, dbAdapter: DatabaseAdapter): Promise<void> {\n\tif (!dbAdapter || !dbAdapter.systemPreferences) {\n\t\tthrow new Error('Database adapter or systemPreferences interface not available');\n\t}\n\n\tif (!snapshot.settings) {\n\t\tthrow new Error('Invalid settings snapshot format');\n\t}\n\n\tlogger.info(' Importing settings snapshot...');\n\n\tconst settingsToSet: Array<{\n\t\tkey: string;\n\t\tvalue: unknown;\n\t\tscope: 'user' | 'system';\n\t\tuserId?: DatabaseId;\n\t}> = [];\n\n\tfor (const [key, settingData] of Object.entries(snapshot.settings)) {\n\t\tconst data = settingData as SettingData;\n\t\tsettingsToSet.push({\n\t\t\tkey,\n\t\t\tvalue: {\n\t\t\t\tdata: data.value,\n\t\t\t\tcategory: data.category || 'public',\n\t\t\t\tdescription: data.description || '',\n\t\t\t\tisGlobal: true,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t},\n\t\t\tscope: 'system'\n\t\t});\n\t}\n\n\tconst result = await dbAdapter.systemPreferences.setMany(settingsToSet);\n\n\tif (!result.success) {\n\t\tthrow new Error(`Failed to import settings: ${result.error?.message}`);\n\t}\n\n\tlogger.info(' Settings snapshot imported successfully');\n}\n\n/**\n * Seeds a demo tenant with default settings, theme, roles, and a user.\n */\nexport async function seedDemoTenant(dbAdapter: DatabaseAdapter, tenantId: string): Promise<void> {\n\tlogger.info(` Seeding demo tenant ${tenantId}...`);\n\n\t// 1. Seed Settings (Force Demo Mode)\n\tawait seedSettings(dbAdapter, tenantId, true);\n\n\t// 2. Seed Default Theme\n\tawait seedDefaultTheme(dbAdapter, tenantId);\n\n\t// 3. Seed Roles\n\tawait seedRoles(dbAdapter, tenantId);\n\n\t// 4. Create Admin User\n\t// We need to import auth service or use dbAdapter.auth directly\n\tif (dbAdapter.auth) {\n\t\tconst result = await dbAdapter.auth.getRoleById('admin', tenantId);\n\t\tconst adminRole = result.success ? result.data : null;\n\t\tif (adminRole) {\n\t\t\tconst email = `demo-${tenantId.substring(0, 8)}@sveltycms.com`;\n\t\t\tconst password = 'demo'; // Simple password for demo\n\t\t\ttry {\n\t\t\t\tawait dbAdapter.auth.createUser({\n\t\t\t\t\temail,\n\t\t\t\t\tpassword,\n\t\t\t\t\trole: adminRole._id,\n\t\t\t\t\tusername: 'Demo Admin',\n\t\t\t\t\ttenantId\n\t\t\t\t});\n\t\t\t\tlogger.info(` Demo admin user created: ${email}`);\n\t\t\t} catch (e) {\n\t\t\t\tlogger.warn(`Demo user creation failed (might exist): ${e instanceof Error ? e.message : String(e)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.info(` Demo tenant ${tenantId} seeded successfully.`);\n}\n","/**\n * @file shared/services/src/MetricsService.ts\n * @description Unified metrics service for all middleware hooks\n *\n * ### Features\n * - Centralized metrics collection for all hooks\n * - High-performance counters with minimal overhead\n * - Automatic metric aggregation and reporting\n * - Thread-safe operations with atomic updates\n * - Memory-efficient with automatic cleanup\n * - Prometheus-style metrics export\n *\n * ### Categories\n * - **Requests**: Total requests, errors, response times\n * - **Auth**: Session validations, failures, cache hits/misses\n * - **API**: API requests, cache performance, rate limiting\n * - **Performance**: Hook execution times, bottlenecks\n * - **Security**: CSP violations, rate limit violations, auth failures\n *\n * @enterprise Optimized for high-throughput production environments\n */\n\nimport { logger } from '@shared/utils/logger';\nimport { building } from '$app/environment';\n\n// --- TYPES ---\n\nexport interface MetricSnapshot {\n\tname: string;\n\tvalue: number;\n\ttimestamp: number;\n\tcategory: string;\n\tlabels?: Record<string, string>;\n}\n\nexport interface MetricsReport {\n\ttimestamp: number;\n\tuptime: number;\n\trequests: {\n\t\ttotal: number;\n\t\terrors: number;\n\t\terrorRate: number;\n\t\tavgResponseTime: number;\n\t};\n\tauthentication: {\n\t\tvalidations: number;\n\t\tfailures: number;\n\t\tsuccessRate: number;\n\t\tcacheHits: number;\n\t\tcacheMisses: number;\n\t\tcacheHitRate: number;\n\t};\n\tapi: {\n\t\trequests: number;\n\t\terrors: number;\n\t\tcacheHits: number;\n\t\tcacheMisses: number;\n\t\tcacheHitRate: number;\n\t};\n\tsecurity: {\n\t\trateLimitViolations: number;\n\t\tcspViolations: number;\n\t\tauthFailures: number;\n\t};\n\tperformance: {\n\t\tslowRequests: number;\n\t\tavgHookExecutionTime: number;\n\t\tbottlenecks: string[];\n\t};\n}\n\n// --- METRICS COUNTERS ---\n\n/**\n * High-performance atomic counters for metrics collection.\n * Using simple objects for maximum performance in V8.\n */\nclass MetricsCounters {\n\t// Request metrics\n\trequests = { total: 0, errors: 0, totalResponseTime: 0 };\n\n\t// Authentication metrics\n\tauth = {\n\t\tvalidations: 0,\n\t\tfailures: 0,\n\t\tcacheHits: 0,\n\t\tcacheMisses: 0\n\t};\n\n\t// API metrics\n\tapi = {\n\t\trequests: 0,\n\t\terrors: 0,\n\t\tcacheHits: 0,\n\t\tcacheMisses: 0\n\t};\n\n\t// Security metrics\n\tsecurity = {\n\t\trateLimitViolations: 0,\n\t\tcspViolations: 0,\n\t\tauthFailures: 0\n\t};\n\n\t// Performance metrics\n\tperformance = {\n\t\tslowRequests: 0,\n\t\ttotalHookTime: 0,\n\t\thookExecutions: 0,\n\t\tbottlenecks: new Map<string, number>()\n\t};\n\n\t// Metadata\n\tlastReset = Date.now();\n\tstartTime = Date.now();\n}\n\n// --- METRICS SERVICE ---\n\n/**\n * Singleton metrics service for enterprise-grade performance monitoring.\n * Thread-safe and optimized for minimal overhead.\n */\nclass MetricsService {\n\tprivate counters = new MetricsCounters();\n\tprivate resetInterval: NodeJS.Timeout | null = null;\n\n\tconstructor() {\n\t\t// Auto-reset metrics every hour to prevent memory growth\n\t\tif (!building) {\n\t\t\tthis.resetInterval = setInterval(\n\t\t\t\t() => {\n\t\t\t\t\tthis.reset();\n\t\t\t\t},\n\t\t\t\t60 * 60 * 1000\n\t\t\t);\n\t\t}\n\t}\n\n\t// --- REQUEST METRICS ---\n\n\t/**\n\t * Increment total request counter.\n\t * Call this at the start of request processing.\n\t */\n\tincrementRequests(): void {\n\t\tthis.counters.requests.total++;\n\t}\n\n\t/**\n\t * Increment error counter.\n\t * Call this when a request results in an error.\n\t */\n\tincrementErrors(): void {\n\t\tthis.counters.requests.errors++;\n\t}\n\n\t/**\n\t * Record response time for performance analysis.\n\t * @param timeMs - Response time in milliseconds\n\t */\n\trecordResponseTime(timeMs: number): void {\n\t\tthis.counters.requests.totalResponseTime += timeMs;\n\n\t\t// Track slow requests (>2 seconds)\n\t\tif (timeMs > 2000) {\n\t\t\tthis.counters.performance.slowRequests++;\n\t\t}\n\t}\n\n\t// --- AUTHENTICATION METRICS ---\n\n\t/**\n\t * Increment authentication validation counter.\n\t * Call this for each session validation attempt.\n\t */\n\tincrementAuthValidations(): void {\n\t\tthis.counters.auth.validations++;\n\t}\n\n\t/**\n\t * Increment authentication failure counter.\n\t * Call this when session validation fails.\n\t */\n\tincrementAuthFailures(): void {\n\t\tthis.counters.auth.failures++;\n\t\tthis.counters.security.authFailures++;\n\t}\n\n\t/**\n\t * Record authentication cache hit.\n\t * Call this when session is found in cache.\n\t */\n\trecordAuthCacheHit(): void {\n\t\tthis.counters.auth.cacheHits++;\n\t}\n\n\t/**\n\t * Record authentication cache miss.\n\t * Call this when session must be fetched from database.\n\t */\n\trecordAuthCacheMiss(): void {\n\t\tthis.counters.auth.cacheMisses++;\n\t}\n\n\t// --- API METRICS ---\n\n\t/**\n\t * Increment API request counter.\n\t * Call this for each API request processed.\n\t */\n\tincrementApiRequests(): void {\n\t\tthis.counters.api.requests++;\n\t}\n\n\t/**\n\t * Increment API error counter.\n\t * Call this when an API request fails.\n\t */\n\tincrementApiErrors(): void {\n\t\tthis.counters.api.errors++;\n\t}\n\n\t/**\n\t * Record API cache hit.\n\t * Call this when API response is served from cache.\n\t */\n\trecordApiCacheHit(): void {\n\t\tthis.counters.api.cacheHits++;\n\t}\n\n\t/**\n\t * Record API cache miss.\n\t * Call this when API response must be generated.\n\t */\n\trecordApiCacheMiss(): void {\n\t\tthis.counters.api.cacheMisses++;\n\t}\n\n\t// --- SECURITY METRICS ---\n\n\t/**\n\t * Increment rate limit violation counter.\n\t * Call this when a request is rate limited.\n\t */\n\tincrementRateLimitViolations(): void {\n\t\tthis.counters.security.rateLimitViolations++;\n\t}\n\n\t/**\n\t * Increment CSP violation counter.\n\t * Call this when a CSP violation is detected.\n\t */\n\tincrementCSPViolations(): void {\n\t\tthis.counters.security.cspViolations++;\n\t}\n\n\t/**\n\t * Increment security violations counter.\n\t */\n\tincrementSecurityViolations(): void {\n\t\tthis.counters.security.cspViolations++; // Using CSP counter for now, can be extended\n\t}\n\n\t// --- PERFORMANCE METRICS ---\n\n\t/**\n\t * Record hook execution time for performance analysis.\n\t * @param hookName - Name of the hook\n\t * @param timeMs - Execution time in milliseconds\n\t */\n\trecordHookExecutionTime(hookName: string, timeMs: number): void {\n\t\tthis.counters.performance.totalHookTime += timeMs;\n\t\tthis.counters.performance.hookExecutions++;\n\n\t\t// Track potential bottlenecks (hooks taking >100ms)\n\t\tif (timeMs > 100) {\n\t\t\tconst current = this.counters.performance.bottlenecks.get(hookName) || 0;\n\t\t\tthis.counters.performance.bottlenecks.set(hookName, current + 1);\n\t\t}\n\t}\n\n\t// --- REPORTING ---\n\n\t// Generate a comprehensive metrics report\n\tgetReport(): MetricsReport {\n\t\tconst now = Date.now();\n\t\tconst uptime = now - this.counters.startTime;\n\n\t\t// Calculate rates with safe division\n\t\tconst safeRate = (numerator: number, denominator: number): number => (denominator > 0 ? (numerator / denominator) * 100 : 0);\n\n\t\tconst avgResponseTime = this.counters.requests.total > 0 ? this.counters.requests.totalResponseTime / this.counters.requests.total : 0;\n\n\t\tconst avgHookTime =\n\t\t\tthis.counters.performance.hookExecutions > 0 ? this.counters.performance.totalHookTime / this.counters.performance.hookExecutions : 0;\n\n\t\t// Get top bottlenecks\n\t\tconst bottlenecks = Array.from(this.counters.performance.bottlenecks.entries())\n\t\t\t.sort(([, a], [, b]) => b - a)\n\t\t\t.slice(0, 5)\n\t\t\t.map(([name]) => name);\n\n\t\treturn {\n\t\t\ttimestamp: now,\n\t\t\tuptime,\n\t\t\trequests: {\n\t\t\t\ttotal: this.counters.requests.total,\n\t\t\t\terrors: this.counters.requests.errors,\n\t\t\t\terrorRate: safeRate(this.counters.requests.errors, this.counters.requests.total),\n\t\t\t\tavgResponseTime\n\t\t\t},\n\t\t\tauthentication: {\n\t\t\t\tvalidations: this.counters.auth.validations,\n\t\t\t\tfailures: this.counters.auth.failures,\n\t\t\t\tsuccessRate: safeRate(this.counters.auth.validations - this.counters.auth.failures, this.counters.auth.validations),\n\t\t\t\tcacheHits: this.counters.auth.cacheHits,\n\t\t\t\tcacheMisses: this.counters.auth.cacheMisses,\n\t\t\t\tcacheHitRate: safeRate(this.counters.auth.cacheHits, this.counters.auth.cacheHits + this.counters.auth.cacheMisses)\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\trequests: this.counters.api.requests,\n\t\t\t\terrors: this.counters.api.errors,\n\t\t\t\tcacheHits: this.counters.api.cacheHits,\n\t\t\t\tcacheMisses: this.counters.api.cacheMisses,\n\t\t\t\tcacheHitRate: safeRate(this.counters.api.cacheHits, this.counters.api.cacheHits + this.counters.api.cacheMisses)\n\t\t\t},\n\t\t\tsecurity: {\n\t\t\t\trateLimitViolations: this.counters.security.rateLimitViolations,\n\t\t\t\tcspViolations: this.counters.security.cspViolations,\n\t\t\t\tauthFailures: this.counters.security.authFailures\n\t\t\t},\n\t\t\tperformance: {\n\t\t\t\tslowRequests: this.counters.performance.slowRequests,\n\t\t\t\tavgHookExecutionTime: avgHookTime,\n\t\t\t\tbottlenecks\n\t\t\t}\n\t\t};\n\t}\n\n\t// Reset all metrics counters periodically to prevent memory growth\n\treset(): void {\n\t\tthis.counters = new MetricsCounters();\n\t\tlogger.trace('Unified metrics reset');\n\t}\n\n\t// Export metrics in Prometheus format for monitoring systems\n\texportPrometheus(): string {\n\t\tconst report = this.getReport();\n\t\tconst lines: string[] = [];\n\n\t\t// Request metrics\n\t\tlines.push(`# HELP svelty_requests_total Total number of requests`);\n\t\tlines.push(`# TYPE svelty_requests_total counter`);\n\t\tlines.push(`svelty_requests_total ${report.requests.total}`);\n\n\t\tlines.push(`# HELP svelty_requests_errors_total Total number of request errors`);\n\t\tlines.push(`# TYPE svelty_requests_errors_total counter`);\n\t\tlines.push(`svelty_requests_errors_total ${report.requests.errors}`);\n\n\t\t// Authentication metrics\n\t\tlines.push(`# HELP svelty_auth_cache_hit_rate Authentication cache hit rate`);\n\t\tlines.push(`# TYPE svelty_auth_cache_hit_rate gauge`);\n\t\tlines.push(`svelty_auth_cache_hit_rate ${report.authentication.cacheHitRate / 100}`);\n\n\t\t// API metrics\n\t\tlines.push(`# HELP svelty_api_cache_hit_rate API cache hit rate`);\n\t\tlines.push(`# TYPE svelty_api_cache_hit_rate gauge`);\n\t\tlines.push(`svelty_api_cache_hit_rate ${report.api.cacheHitRate / 100}`);\n\n\t\t// Security metrics\n\t\tlines.push(`# HELP svelty_security_violations_total Total security violations`);\n\t\tlines.push(`# TYPE svelty_security_violations_total counter`);\n\t\tlines.push(`svelty_security_violations_total{type=\"rate_limit\"} ${report.security.rateLimitViolations}`);\n\t\tlines.push(`svelty_security_violations_total{type=\"csp\"} ${report.security.cspViolations}`);\n\n\t\treturn lines.join('\\n') + '\\n';\n\t}\n\n\t// Cleanup resources when shutting down\n\tdestroy(): void {\n\t\tif (this.resetInterval) {\n\t\t\tclearInterval(this.resetInterval);\n\t\t\tthis.resetInterval = null;\n\t\t}\n\t}\n}\n\n// --- SINGLETON INSTANCE ---\n\n/**\n * Global metrics service instance.\n * Use this throughout the application for consistent metrics collection.\n */\nexport const metricsService = new MetricsService();\n\n/**\n * Cleanup function for graceful shutdown.\n * Call this when the application is shutting down.\n */\nexport const cleanupMetrics = (): void => {\n\tmetricsService.destroy();\n};\n\n// Cleanup on process exit (server-only)\nif (!building && typeof process !== 'undefined' && typeof window === 'undefined') {\n\tprocess.on('SIGTERM', cleanupMetrics);\n\tprocess.on('SIGINT', cleanupMetrics);\n}\n","export let defaultHashFunction;\nif (globalThis?.crypto?.subtle) {\n    defaultHashFunction = subtleSha256;\n}\nasync function subtleSha256(str) {\n    const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));\n    return [...new Uint8Array(digest)]\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n","import { urlAlphabet } from './url-alphabet/index.js'\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import { defaultHashFunction } from '../hashFunction.js';\nimport { nanoid } from 'nanoid';\nexport class CookieRateLimiter {\n    rate;\n    cookieOptions;\n    secret;\n    requirePreflight;\n    cookieId;\n    hashFunction;\n    constructor(options) {\n        this.cookieId = options.name;\n        this.secret = options.secret;\n        this.rate = options.rate;\n        this.requirePreflight = options.preflight;\n        this.hashFunction = options.hashFunction ?? defaultHashFunction;\n        this.cookieOptions = {\n            path: '/',\n            httpOnly: true,\n            maxAge: 60 * 60 * 24 * 7,\n            sameSite: 'strict',\n            ...options.serializeOptions\n        };\n    }\n    async hash(event) {\n        const currentId = await this.userIdFromCookie(event.cookies.get(this.cookieId), event);\n        return currentId ? currentId : false;\n    }\n    async preflight(event) {\n        const data = event.cookies.get(this.cookieId);\n        if (data) {\n            const userId = await this.userIdFromCookie(data, event);\n            if (userId)\n                return userId;\n        }\n        return this.setPreflightCookie(event);\n    }\n    async setPreflightCookie(event) {\n        const userId = nanoid();\n        event.cookies.set(this.cookieId, userId + ';' + (await this.hashFunction(this.secret + userId)), this.cookieOptions);\n        return userId;\n    }\n    async userIdFromCookie(cookie, event) {\n        if (!cookie)\n            return this.requirePreflight ? null : this.preflight(event);\n        const [userId, secretHash] = cookie.split(';');\n        if (!userId || !secretHash) {\n            return this.setPreflightCookie(event);\n        }\n        if ((await this.hashFunction(this.secret + userId)) != secretHash) {\n            return this.setPreflightCookie(event);\n        }\n        return userId;\n    }\n}\n","export class IPRateLimiter {\n    rate;\n    constructor(rate) {\n        this.rate = rate;\n    }\n    async hash(event) {\n        return event.getClientAddress();\n    }\n}\n","export class IPUserAgentRateLimiter {\n    rate;\n    constructor(rate) {\n        this.rate = rate;\n    }\n    async hash(event) {\n        const ua = event.request.headers.get('user-agent');\n        if (!ua)\n            return false;\n        return event.getClientAddress() + ua;\n    }\n}\n","// A simple TTL cache with max capacity option, ms resolution,\n// autopurge, and reasonably optimized performance\n// Relies on the fact that integer Object keys are kept sorted,\n// and managed very efficiently by V8.\n\n/* istanbul ignore next */\nconst perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst now = () => perf.now()\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\nconst isPosIntOrInf = n => n === Infinity || isPosInt(n)\n\nclass TTLCache {\n  constructor({\n    max = Infinity,\n    ttl,\n    updateAgeOnGet = false,\n    checkAgeOnGet = false,\n    noUpdateTTL = false,\n    dispose,\n    noDisposeOnSet = false,\n  } = {}) {\n    // {[expirationTime]: [keys]}\n    this.expirations = Object.create(null)\n    // {key=>val}\n    this.data = new Map()\n    // {key=>expiration}\n    this.expirationMap = new Map()\n    if (ttl !== undefined && !isPosIntOrInf(ttl)) {\n      throw new TypeError(\n        'ttl must be positive integer or Infinity if set'\n      )\n    }\n    if (!isPosIntOrInf(max)) {\n      throw new TypeError('max must be positive integer or Infinity')\n    }\n    this.ttl = ttl\n    this.max = max\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.checkAgeOnGet = !!checkAgeOnGet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDisposeOnSet = !!noDisposeOnSet\n    if (dispose !== undefined) {\n      if (typeof dispose !== 'function') {\n        throw new TypeError('dispose must be function if set')\n      }\n      this.dispose = dispose\n    }\n\n    this.timer = undefined\n    this.timerExpiration = undefined\n  }\n\n  setTimer(expiration, ttl) {\n    if (this.timerExpiration < expiration) {\n      return\n    }\n\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n\n    const t = setTimeout(() => {\n      this.timer = undefined\n      this.timerExpiration = undefined\n      this.purgeStale()\n      for (const exp in this.expirations) {\n        this.setTimer(exp, exp - now())\n        break\n      }\n    }, ttl)\n\n    /* istanbul ignore else - affordance for non-node envs */\n    if (t.unref) t.unref()\n\n    this.timerExpiration = expiration\n    this.timer = t\n  }\n\n  // hang onto the timer so we can clearTimeout if all items\n  // are deleted.  Deno doesn't have Timer.unref(), so it\n  // hangs otherwise.\n  cancelTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timerExpiration = undefined\n      this.timer = undefined\n    }\n  }\n\n  /* istanbul ignore next */\n  cancelTimers() {\n    process.emitWarning(\n      'TTLCache.cancelTimers has been renamed to ' +\n        'TTLCache.cancelTimer (no \"s\"), and will be removed in the next ' +\n        'major version update'\n    )\n    return this.cancelTimer()\n  }\n\n  clear() {\n    const entries =\n      this.dispose !== TTLCache.prototype.dispose ? [...this] : []\n    this.data.clear()\n    this.expirationMap.clear()\n    // no need for any purging now\n    this.cancelTimer()\n    this.expirations = Object.create(null)\n    for (const [key, val] of entries) {\n      this.dispose(val, key, 'delete')\n    }\n  }\n\n  setTTL(key, ttl = this.ttl) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      // remove from the expirations list, so it isn't purged\n      const exp = this.expirations[current]\n      if (!exp || exp.length <= 1) {\n        delete this.expirations[current]\n      } else {\n        this.expirations[current] = exp.filter(k => k !== key)\n      }\n    }\n\n    if (ttl !== Infinity) {\n      const expiration = Math.floor(now() + ttl)\n      this.expirationMap.set(key, expiration)\n      if (!this.expirations[expiration]) {\n        this.expirations[expiration] = []\n        this.setTimer(expiration, ttl)\n      }\n      this.expirations[expiration].push(key)\n    } else {\n      this.expirationMap.set(key, Infinity)\n    }\n  }\n\n  set(\n    key,\n    val,\n    {\n      ttl = this.ttl,\n      noUpdateTTL = this.noUpdateTTL,\n      noDisposeOnSet = this.noDisposeOnSet,\n    } = {}\n  ) {\n    if (!isPosIntOrInf(ttl)) {\n      throw new TypeError('ttl must be positive integer or Infinity')\n    }\n    if (this.expirationMap.has(key)) {\n      if (!noUpdateTTL) {\n        this.setTTL(key, ttl)\n      }\n      // has old value\n      const oldValue = this.data.get(key)\n      if (oldValue !== val) {\n        this.data.set(key, val)\n        if (!noDisposeOnSet) {\n          this.dispose(oldValue, key, 'set')\n        }\n      }\n    } else {\n      this.setTTL(key, ttl)\n      this.data.set(key, val)\n    }\n\n    while (this.size > this.max) {\n      this.purgeToCapacity()\n    }\n\n    return this\n  }\n\n  has(key) {\n    return this.data.has(key)\n  }\n\n  getRemainingTTL(key) {\n    const expiration = this.expirationMap.get(key)\n    return expiration === Infinity\n      ? expiration\n      : expiration !== undefined\n      ? Math.max(0, Math.ceil(expiration - now()))\n      : 0\n  }\n\n  get(\n    key,\n    {\n      updateAgeOnGet = this.updateAgeOnGet,\n      ttl = this.ttl,\n      checkAgeOnGet = this.checkAgeOnGet,\n    } = {}\n  ) {\n    const val = this.data.get(key)\n    if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {\n      this.delete(key)\n      return undefined\n    }\n    if (updateAgeOnGet) {\n      this.setTTL(key, ttl)\n    }\n    return val\n  }\n\n  dispose(_, __) {}\n\n  delete(key) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      const value = this.data.get(key)\n      this.data.delete(key)\n      this.expirationMap.delete(key)\n      const exp = this.expirations[current]\n      if (exp) {\n        if (exp.length <= 1) {\n          delete this.expirations[current]\n        } else {\n          this.expirations[current] = exp.filter(k => k !== key)\n        }\n      }\n      this.dispose(value, key, 'delete')\n      if (this.size === 0) {\n        this.cancelTimer()\n      }\n      return true\n    }\n    return false\n  }\n\n  purgeToCapacity() {\n    for (const exp in this.expirations) {\n      const keys = this.expirations[exp]\n      if (this.size - keys.length >= this.max) {\n        delete this.expirations[exp]\n        const entries = []\n        for (const key of keys) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n      } else {\n        const s = this.size - this.max\n        const entries = []\n        for (const key of keys.splice(0, s)) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n        return\n      }\n    }\n  }\n\n  get size() {\n    return this.data.size\n  }\n\n  purgeStale() {\n    const n = Math.ceil(now())\n    for (const exp in this.expirations) {\n      if (exp === 'Infinity' || exp > n) {\n        return\n      }\n\n      /* istanbul ignore next\n       * mysterious need for a guard here?\n       * https://github.com/isaacs/ttlcache/issues/26 */\n      const keys = [...(this.expirations[exp] || [])]\n      const entries = []\n      delete this.expirations[exp]\n      for (const key of keys) {\n        entries.push([key, this.data.get(key)])\n        this.data.delete(key)\n        this.expirationMap.delete(key)\n      }\n      for (const [key, val] of entries) {\n        this.dispose(val, key, 'stale')\n      }\n    }\n    if (this.size === 0) {\n      this.cancelTimer()\n    }\n  }\n\n  *entries() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield [key, this.data.get(key)]\n      }\n    }\n  }\n  *keys() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield key\n      }\n    }\n  }\n  *values() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield this.data.get(key)\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n}\n\nmodule.exports = TTLCache\n","import TTLCache from '@isaacs/ttlcache';\nexport class TTLStore {\n    cache;\n    constructor(maxTTL, maxItems = Infinity) {\n        this.cache = new TTLCache({\n            ttl: maxTTL,\n            max: maxItems,\n            noUpdateTTL: true\n        });\n    }\n    async clear() {\n        return this.cache.clear();\n    }\n    async add(hash, ttl) {\n        const currentRate = this.cache.get(hash) ?? 0;\n        return this.set(hash, currentRate + 1, ttl);\n    }\n    set(hash, rate, ttl) {\n        this.cache.set(hash, rate, { ttl });\n        return rate;\n    }\n}\n","export function TTLTime(unit) {\n    switch (unit) {\n        case 's':\n            return 1000;\n        case 'm':\n            return 60000;\n        case 'h':\n            return 60 * 60000;\n        case '2s':\n            return 2000;\n        case '5s':\n            return 5000;\n        case '10s':\n            return 10000;\n        case '15s':\n            return 15000;\n        case '30s':\n            return 30000;\n        case '45s':\n            return 45000;\n        case '2m':\n            return 2 * 60000;\n        case '5m':\n            return 5 * 60000;\n        case '10m':\n            return 10 * 60000;\n        case '15m':\n            return 15 * 60000;\n        case '30m':\n            return 30 * 60000;\n        case '45m':\n            return 45 * 60000;\n        case '100ms':\n            return 100;\n        case '250ms':\n            return 250;\n        case '500ms':\n            return 500;\n        case '2h':\n            return 2 * 60 * 60000;\n        case '6h':\n            return 6 * 60 * 60000;\n        case '12h':\n            return 12 * 60 * 60000;\n        case 'd':\n            return 24 * 60 * 60000;\n        case 'ms':\n            return 1;\n    }\n    throw new Error('Invalid unit for TTLTime: ' + unit);\n}\n","import { CookieRateLimiter } from './limiters/cookieRateLimiter.js';\nimport { IPRateLimiter } from './limiters/ipRateLimiter.js';\nimport { IPUserAgentRateLimiter } from './limiters/ipUaRateLimiter.js';\nimport { defaultHashFunction } from './hashFunction.js';\nimport { TTLStore } from './stores/ttlStore.js';\nimport {} from './limiters/rateLimiterPlugin.js';\nimport { TTLTime } from './rate.js';\nexport class RateLimiter {\n    store;\n    plugins;\n    onLimited;\n    hashFunction;\n    cookieLimiter;\n    async isLimited(event, extraData) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (await this._isLimited(event, extraData))\n            .limited;\n    }\n    /**\n     * Clear all rate limits.\n     */\n    async clear() {\n        return await this.store.clear();\n    }\n    /**\n     * Check if a request event is rate limited.\n     * @param {RequestEvent} event\n     * @returns {Promise<limited: boolean, reason: 'IP' | 'IPUA' | 'cookie' | number>} Rate limit status for the event.\n     */\n    async check(event, extraData) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result = await this._isLimited(event, extraData);\n        if (!result.limited)\n            return { limited: false };\n        return { limited: true, reason: result.reason };\n    }\n    /**\n     * Check if a request event is rate limited.\n     * @param {RequestEvent} event\n     * @returns {Promise<boolean>} true if request is limited, false otherwise\n     */\n    async _isLimited(event, extraData) {\n        let limited = undefined;\n        for (let i = 0; i < this.plugins.length; i++) {\n            const plugin = this.plugins[i];\n            const rate = plugin.rate;\n            const id = await plugin.limiter.hash(event, extraData);\n            if (id === false) {\n                if (this.onLimited) {\n                    const status = await this.onLimited(event, 'rejected');\n                    if (status === true)\n                        return { limited: false, hash: null, ttl: rate[1] };\n                }\n                return {\n                    limited: true,\n                    hash: null,\n                    ttl: rate[1],\n                    reason: this.limitReason(plugin.limiter, i)\n                };\n            }\n            else if (id === null) {\n                if (limited === undefined)\n                    limited = true;\n                continue;\n            }\n            else {\n                limited = false;\n            }\n            if (!id) {\n                throw new Error('Empty hash returned from rate limiter ' + plugin.constructor.name);\n            }\n            if (id === true) {\n                return { limited: false, hash: null, ttl: rate[1] };\n            }\n            // Add the plugin index to the hash, so it differs between limiters with multiple rates\n            const hash = i.toString() + (await this.hashFunction(id));\n            const currentRate = await this.store.add(hash, rate[1]);\n            if (currentRate > rate[0]) {\n                if (this.onLimited) {\n                    const status = await this.onLimited(event, 'rate');\n                    if (status === true)\n                        return { limited: false, hash, ttl: rate[1] };\n                }\n                return {\n                    limited: true,\n                    hash,\n                    ttl: rate[1],\n                    reason: this.limitReason(plugin.limiter, i)\n                };\n            }\n        }\n        if (limited) {\n            return {\n                limited: true,\n                hash: null,\n                ttl: this.plugins[this.plugins.length - 1].rate[1],\n                reason: this.limitReason(this.plugins[this.plugins.length - 1].limiter, this.plugins.length - 1)\n            };\n        }\n        return {\n            limited: false,\n            hash: null,\n            ttl: this.plugins[this.plugins.length - 1].rate[1]\n        };\n    }\n    limitReason(plugin, index) {\n        if (plugin instanceof IPRateLimiter)\n            return 'IP';\n        if (plugin instanceof IPUserAgentRateLimiter)\n            return 'IPUA';\n        if (plugin instanceof CookieRateLimiter)\n            return 'cookie';\n        return index;\n    }\n    constructor(options = {}) {\n        this.onLimited = options.onLimited;\n        this.hashFunction = options.hashFunction ?? defaultHashFunction;\n        if (!this.hashFunction) {\n            throw new Error('No RateLimiter hash function found. Please set one with the hashFunction option.');\n        }\n        //#region Plugin setup\n        function mapPluginRates(limiter) {\n            if (!limiter.rate.length)\n                throw new Error(`Empty rate for limiter ${limiter.constructor.name}`);\n            const pluginRates = (Array.isArray(limiter.rate[0]) ? limiter.rate : [limiter.rate]);\n            return pluginRates.map((rate) => ({\n                rate: [rate[0], TTLTime(rate[1])],\n                limiter\n            }));\n        }\n        this.plugins = (options.plugins ?? []).flatMap(mapPluginRates);\n        const IPRates = options.IP ?? options.rates?.IP;\n        if (IPRates) {\n            this.plugins = this.plugins.concat(mapPluginRates(new IPRateLimiter(IPRates)));\n        }\n        const IPUARates = options.IPUA ?? options.rates?.IPUA;\n        if (IPUARates) {\n            this.plugins = this.plugins.concat(mapPluginRates(new IPUserAgentRateLimiter(IPUARates)));\n        }\n        const cookieRates = options.cookie ?? options.rates?.cookie;\n        if (cookieRates) {\n            this.plugins = this.plugins.concat(mapPluginRates((this.cookieLimiter = new CookieRateLimiter({\n                hashFunction: this.hashFunction,\n                ...cookieRates\n            }))));\n        }\n        if (!this.plugins.length) {\n            throw new Error('No plugins set for RateLimiter!');\n        }\n        // Sort plugins by rate, if early cancelling\n        this.plugins.sort((a, b) => {\n            const diff = a.rate[1] - b.rate[1];\n            return diff == 0 ? a.rate[0] - b.rate[0] : diff;\n        });\n        //#endregion\n        const maxTTL = this.plugins.reduce((acc, plugin) => {\n            const rate = plugin.rate[1];\n            if (rate == 1) {\n                console.warn('RateLimiter: The \"ms\" unit is not reliable due to OS timing issues.');\n            }\n            return Math.max(rate, acc);\n        }, 0);\n        this.store = options.store ?? new TTLStore(maxTTL, options.maxItems);\n    }\n}\n","/**\n * @file src/hooks/handleAuthentication.ts\n * @description Enterprise-grade authentication middleware with session validation, rotation, and multi-tenancy.\n *\n * @summary This hook runs after handleSystemState and handleSetup confirm the system is ready. It provides:\n * - **Session Management**: Validates session cookies with 3-layer caching (in-memory  Redis  database)\n * - **Security Token Rotation**: Automatic token rotation for active sessions (prevents session hijacking)\n * - **Multi-tenancy**: Hostname-based tenant identification with strict isolation\n * - **Memory Optimization**: WeakRef-based cache with automatic garbage collection\n * - **Rate Limiting**: Session rotation rate limits to prevent abuse\n * - **Metrics Integration**: Comprehensive tracking via MetricsService\n *\n * ### Features\n * - Session rotation every 15 minutes for active users\n * - WeakRef cache with LRU eviction (top 100 hot sessions)\n * - Tenant isolation enforcement (prevents cross-tenant access)\n * - Rate-limited refresh attempts (100/min per IP)\n * - Automatic cleanup of expired sessions\n * - Zero-downtime session validation\n *\n * @prerequisite handleSystemState and handleSetup have already confirmed readiness\n */\n\nimport type { Handle, RequestEvent } from '@sveltejs/kit';\nimport { error } from '@sveltejs/kit';\nimport { dev } from '$app/environment';\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { SESSION_COOKIE_NAME } from '@shared/database/auth/constants';\nimport type { User } from '@shared/database/auth/types';\nimport type { ISODateString } from '@shared/database/dbInterface';\nimport { auth, dbAdapter } from '@shared/database/db';\nimport { getSystemState } from '@shared/stores/system';\nimport { seedDemoTenant } from '@shared/database/seed';\nimport { cacheService, SESSION_CACHE_TTL_MS } from '@shared/database/CacheService';\nimport { logger } from '@shared/utils/logger.server';\nimport { metricsService } from '@shared/services/MetricsService';\nimport { RateLimiter } from 'sveltekit-rate-limiter/server';\n\n// --- IN-MEMORY SESSION CACHE WITH WEAKREF-BASED CLEANUP ---\n\n/**\n * WeakRef-based session cache for automatic garbage collection.\n * This approach allows the JavaScript engine to clean up unused sessions\n * without requiring full iteration through the cache.\n *\n * Benefits:\n * - Lower memory overhead in high-traffic scenarios\n * - Automatic cleanup of unused sessions\n * - Better for clustered/edge environments\n * - No periodic setInterval cleanup needed\n */\n\ninterface SessionCacheEntry {\n\tuser: User;\n\ttimestamp: number;\n}\n\n/**\n * Main session cache using WeakRef for automatic GC.\n * Each entry can be garbage collected when no longer referenced.\n */\nconst sessionCache = new Map<string, WeakRef<SessionCacheEntry>>();\n\n/**\n * FinalizationRegistry to track when cache entries are garbage collected.\n * This allows us to clean up the Map keys when values are GC'd.\n */\nconst sessionCacheRegistry = new FinalizationRegistry<string>((sessionId) => {\n\tsessionCache.delete(sessionId);\n\tlogger.trace(`Session cache entry GC'd: ${sessionId.substring(0, 8)}...`);\n});\n\n/**\n * Strong references to prevent immediate GC of recently accessed sessions.\n * This LRU-style cache keeps the most recent N sessions in memory.\n */\nconst MAX_STRONG_REFS = 100;\nconst strongRefs = new Map<string, SessionCacheEntry>();\n\n/**\n * Prevents frequent DB lookups for invalid sessions.\n */\nconst lastRefreshAttempt = new Map<string, number>();\n\n/**\n * Tracks last session rotation time to prevent excessive rotation.\n * Key: sessionId, Value: timestamp of last rotation\n */\nconst lastRotationAttempt = new Map<string, number>();\n\n/**\n * Session rotation interval: 15 minutes\n * Balances security (regular token refresh) with performance (reduced DB writes)\n */\nconst SESSION_ROTATION_INTERVAL_MS = 15 * 60 * 1000;\n\n/**\n * Rate limiter for session rotation to prevent abuse.\n * Limits: 100 rotation attempts per minute per IP\n */\nconst rotationRateLimiter = new RateLimiter({\n\tIP: [100, 'm'],\n\tcookie: {\n\t\tname: 'session_rotation_limit',\n\t\tsecret: getPrivateSettingSync('JWT_SECRET_KEY') || 'fallback-dev-secret',\n\t\trate: [100, 'm'],\n\t\tpreflight: true\n\t}\n});\n\n/**\n * Gets a session from the cache, handling WeakRef dereferencing.\n */\nfunction getSessionFromCache(sessionId: string): SessionCacheEntry | null {\n\tconst now = Date.now();\n\n\t// Check strong references first (most recent)\n\tconst strongRef = strongRefs.get(sessionId);\n\tif (strongRef && now - strongRef.timestamp < SESSION_CACHE_TTL_MS) {\n\t\treturn strongRef;\n\t}\n\n\t// Check weak references\n\tconst weakRef = sessionCache.get(sessionId);\n\tif (weakRef) {\n\t\tconst entry = weakRef.deref();\n\t\tif (entry && now - entry.timestamp < SESSION_CACHE_TTL_MS) {\n\t\t\t// Promote to strong reference\n\t\t\taddToStrongRefs(sessionId, entry);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Sets a session in the cache with WeakRef.\n */\nfunction setSessionInCache(sessionId: string, entry: SessionCacheEntry): void {\n\t// Add to strong refs (LRU)\n\taddToStrongRefs(sessionId, entry);\n\n\t// Add to weak refs with GC tracking\n\tconst weakRef = new WeakRef(entry);\n\tsessionCache.set(sessionId, weakRef);\n\tsessionCacheRegistry.register(entry, sessionId);\n}\n\n/**\n * Adds/updates a session in the strong reference LRU cache.\n */\nfunction addToStrongRefs(sessionId: string, entry: SessionCacheEntry): void {\n\t// Remove if exists (for LRU re-insertion)\n\tif (strongRefs.has(sessionId)) {\n\t\tstrongRefs.delete(sessionId);\n\t}\n\n\t// Add to end (most recent)\n\tstrongRefs.set(sessionId, entry);\n\n\t// Evict oldest if over limit\n\tif (strongRefs.size > MAX_STRONG_REFS) {\n\t\tconst firstKey = strongRefs.keys().next().value;\n\t\tif (firstKey) {\n\t\t\tstrongRefs.delete(firstKey);\n\t\t}\n\t}\n}\n\n// Periodic cleanup of expired strong references and lastRefreshAttempt\nif (typeof setInterval !== 'undefined') {\n\tsetInterval(\n\t\t() => {\n\t\t\tconst now = Date.now();\n\n\t\t\t// Clean expired strong refs\n\t\t\tfor (const [sessionId, data] of strongRefs.entries()) {\n\t\t\t\tif (now - data.timestamp > SESSION_CACHE_TTL_MS) {\n\t\t\t\t\tstrongRefs.delete(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clean old refresh attempts\n\t\t\tfor (const [sessionId, timestamp] of lastRefreshAttempt.entries()) {\n\t\t\t\tif (now - timestamp > 300000) {\n\t\t\t\t\t// 5 minutes\n\t\t\t\t\tlastRefreshAttempt.delete(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clean old rotation attempts\n\t\t\tfor (const [sessionId, timestamp] of lastRotationAttempt.entries()) {\n\t\t\t\tif (now - timestamp > SESSION_ROTATION_INTERVAL_MS * 2) {\n\t\t\t\t\tlastRotationAttempt.delete(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.trace(`Session cache cleanup: ${strongRefs.size} strong refs, ${sessionCache.size} weak refs`);\n\t\t},\n\t\t5 * 60 * 1000\n\t);\n}\n\n// --- UTILITY FUNCTIONS ---\n\n/** Derives tenant ID from hostname */\nfunction getTenantIdFromHostname(hostname: string): string | null {\n\tif (!getPrivateSettingSync('MULTI_TENANT')) return null;\n\n\tif (hostname === 'localhost' || hostname.startsWith('127.0.0.1') || hostname.startsWith('192.168.')) {\n\t\treturn 'default';\n\t}\n\n\tconst parts = hostname.split('.');\n\tif (parts.length > 2 && !['www', 'app', 'api', 'cdn', 'static'].includes(parts[0])) {\n\t\treturn parts[0];\n\t}\n\n\treturn null;\n}\n\n/** Multi-layer user session retrieval (in-memory  distributed  DB) */\nasync function getUserFromSession(sessionId: string, tenantId?: string): Promise<User | null> {\n\tconst now = Date.now();\n\n\t// Layer 1: In-memory cache with WeakRef (fastest)\n\tconst memCached = getSessionFromCache(sessionId);\n\tif (memCached) {\n\t\tlogger.trace(`Session cache hit (memory): ${sessionId.substring(0, 8)}...`);\n\t\treturn memCached.user;\n\t}\n\n\t// Layer 2: Distributed cache (Redis)\n\ttry {\n\t\tconst cacheKey = tenantId ? `session:${tenantId}:${sessionId}` : `session:${sessionId}`;\n\t\tconst redisCached = await cacheService.get<SessionCacheEntry>(cacheKey, tenantId);\n\t\tif (redisCached && now - redisCached.timestamp < SESSION_CACHE_TTL_MS) {\n\t\t\tsetSessionInCache(sessionId, redisCached);\n\t\t\tlogger.trace(`Session cache hit (redis): ${sessionId.substring(0, 8)}...`);\n\t\t\treturn redisCached.user;\n\t\t}\n\t} catch (err) {\n\t\tlogger.warn(`Redis session read failed: ${err instanceof Error ? err.message : String(err)}`);\n\t}\n\n\t// Layer 3: Database (source of truth)\n\tconst lastAttempt = lastRefreshAttempt.get(sessionId);\n\tif (lastAttempt && now - lastAttempt < 60000) return null; // 1-minute cooldown\n\tlastRefreshAttempt.set(sessionId, now);\n\n\tif (!auth) {\n\t\t// Only log as error if system is ready, otherwise suppress or log as debug\n\t\tconst sysState = getSystemState();\n\t\tif (sysState.overallState === 'READY' || sysState.overallState === 'DEGRADED') {\n\t\t\tlogger.error('Auth service unavailable, skipping session validation.');\n\t\t} else {\n\t\t\tlogger.debug('Auth service not ready, skipping session validation.');\n\t\t}\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst user = await auth.validateSession(sessionId);\n\t\tif (user) {\n\t\t\tconst sessionData: SessionCacheEntry = { user, timestamp: now };\n\t\t\tsetSessionInCache(sessionId, sessionData);\n\t\t\tconst cacheKey = tenantId ? `session:${tenantId}:${sessionId}` : `session:${sessionId}`;\n\t\t\tawait cacheService\n\t\t\t\t.set(cacheKey, sessionData, Math.ceil(SESSION_CACHE_TTL_MS / 1000), tenantId)\n\t\t\t\t.catch((err) => logger.warn(`Session cache set failed: ${err.message}`));\n\t\t\tlogger.trace(`Session validated from DB: ${sessionId.substring(0, 8)}...`);\n\t\t\treturn user;\n\t\t}\n\t} catch (err) {\n\t\tlogger.error(`Session validation failed for ${sessionId.substring(0, 8)}: ${err instanceof Error ? err.message : String(err)}`);\n\t}\n\n\treturn null;\n}\n\n/**\n * Handles automatic session rotation for security.\n * Rotates session tokens every 15 minutes for active users to prevent session hijacking.\n *\n * @param event - SvelteKit request event\n * @param user - Authenticated user object\n * @param oldSessionId - Current session ID\n * @returns Promise<void>\n */\nasync function handleSessionRotation(event: RequestEvent, user: User, oldSessionId: string): Promise<void> {\n\tconst now = Date.now();\n\n\t// Check if rotation is needed (15-minute interval)\n\tconst lastRotation = lastRotationAttempt.get(oldSessionId);\n\tif (lastRotation && now - lastRotation < SESSION_ROTATION_INTERVAL_MS) {\n\t\treturn; // Too soon for rotation\n\t}\n\n\t// Rate limit check\n\tif (await rotationRateLimiter.isLimited(event)) {\n\t\tlogger.debug(`Session rotation rate limited for session ${oldSessionId.substring(0, 8)}...`);\n\t\treturn;\n\t}\n\n\t// Attempt rotation\n\ttry {\n\t\tif (!auth?.createSession || !auth?.destroySession) {\n\t\t\tlogger.warn('Session rotation not supported by auth adapter');\n\t\t\treturn;\n\t\t}\n\n\t\t// Create new session with same user\n\t\tconst newSession = await auth.createSession({\n\t\t\tuser_id: user._id,\n\t\t\texpires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() as ISODateString, // 30 days\n\t\t\ttenantId: event.locals.tenantId\n\t\t});\n\n\t\tif (newSession && newSession._id !== oldSessionId) {\n\t\t\tconst newSessionId = newSession._id;\n\n\t\t\t// Update cookie with new session ID\n\t\t\tevent.cookies.set(SESSION_COOKIE_NAME, newSessionId, {\n\t\t\t\tpath: '/',\n\t\t\t\thttpOnly: true,\n\t\t\t\tsecure: event.url.protocol === 'https:' || (event.url.hostname !== 'localhost' && !dev),\n\t\t\t\tsameSite: 'lax',\n\t\t\t\tmaxAge: 60 * 60 * 24 * 30 // 30 days\n\t\t\t});\n\n\t\t\t// Destroy old session\n\t\t\tawait auth\n\t\t\t\t.destroySession(oldSessionId)\n\t\t\t\t.catch((err) => logger.warn(`Failed to destroy old session ${oldSessionId.substring(0, 8)}: ${err.message}`));\n\n\t\t\t// Invalidate old session from all caches\n\t\t\tinvalidateSessionCache(oldSessionId, event.locals.tenantId);\n\n\t\t\t// Cache new session\n\t\t\tconst sessionData: SessionCacheEntry = { user, timestamp: now };\n\t\t\tsetSessionInCache(newSessionId, sessionData);\n\n\t\t\tconst cacheKey = event.locals.tenantId ? `session:${event.locals.tenantId}:${newSessionId}` : `session:${newSessionId}`;\n\t\t\tawait cacheService\n\t\t\t\t.set(cacheKey, sessionData, Math.ceil(SESSION_CACHE_TTL_MS / 1000), event.locals.tenantId)\n\t\t\t\t.catch((err) => logger.warn(`Failed to cache rotated session: ${err.message}`));\n\n\t\t\t// Update locals with new session ID\n\t\t\tevent.locals.session_id = newSessionId;\n\n\t\t\t// Track rotation\n\t\t\tlastRotationAttempt.set(newSessionId, now);\n\n\t\t\tmetricsService.incrementAuthValidations();\n\t\t\tlogger.info(`Session rotated for user ${user._id}: ${oldSessionId.substring(0, 8)}...  ${newSessionId.substring(0, 8)}...`);\n\t\t}\n\t} catch (err) {\n\t\t// Non-fatal error - log but don't break the session\n\t\tlogger.error(`Session rotation failed for ${oldSessionId.substring(0, 8)}: ${err instanceof Error ? err.message : String(err)}`);\n\n\t\t// If rotation fails due to invalid session, this is critical\n\t\tif (err instanceof Error && err.message.includes('invalid')) {\n\t\t\tevent.cookies.delete(SESSION_COOKIE_NAME, { path: '/' });\n\t\t\tevent.locals.user = null;\n\t\t\tevent.locals.session_id = undefined;\n\t\t\tinvalidateSessionCache(oldSessionId, event.locals.tenantId);\n\t\t\tthrow error(401, 'Session expired. Please log in again.');\n\t\t}\n\t}\n}\n\n// --- MAIN HOOK ---\n\nexport const handleAuthentication: Handle = async ({ event, resolve }) => {\n\tconst { locals, url, cookies } = event;\n\n\t// Skip internal or special requests\n\tconst ASSET_REGEX =\n\t\t/^\\/(?:@vite\\/client|@fs\\/|src\\/|node_modules\\/|vite\\/|_app|static|favicon\\.ico|\\.svelte-kit\\/generated\\/client\\/nodes|.*\\.(svg|png|jpg|jpeg|gif|css|js|woff|woff2|ttf|eot|map|json))/;\n\tif (url.pathname.startsWith('/.well-known/') || url.pathname.startsWith('/_') || ASSET_REGEX.test(url.pathname)) {\n\t\treturn resolve(event);\n\t}\n\n\t// Skip public routes\n\tconst publicRoutes = ['/login', '/register', '/forgot-password', '/setup', '/api/setup'];\n\tconst isLocalizedPublic = /^\\/[a-z]{2,5}(-[a-zA-Z]+)?\\/(setup|login|register|forgot-password)/.test(url.pathname);\n\n\tif (publicRoutes.some((r) => url.pathname.startsWith(r)) || isLocalizedPublic) {\n\t\treturn resolve(event);\n\t}\n\n\t// --- Setup Guard Removed ---\n\t// handleSetup already handles unconfigured states, saving import overhead.\n\n\t// Attach database adapter\n\tlocals.dbAdapter = dbAdapter;\n\tif (!dbAdapter) {\n\t\tlogger.warn('Database adapter unavailable; system initializing.');\n\t\t// During setup/initialization, skip authentication entirely\n\t\t// handleSetup will enforce proper access control for setup routes\n\t\treturn resolve(event);\n\t}\n\n\t// Step 1: Multi-tenancy (synchronous check)\n\tconst multiTenant = getPrivateSettingSync('MULTI_TENANT');\n\tconst isDemoMode = getPrivateSettingSync('DEMO');\n\n\tif (multiTenant) {\n\t\tlet tenantId: string | null = null;\n\n\t\tif (isDemoMode) {\n\t\t\t// For demo mode, try to get tenantId from cookie first\n\t\t\ttenantId = cookies.get('demo_tenant_id') || null;\n\n\t\t\tif (!tenantId) {\n\t\t\t\t// If no demo_tenant_id cookie, generate a new one\n\t\t\t\ttenantId = crypto.randomUUID();\n\t\t\t\t// Set the cookie for future requests in this session\n\t\t\t\tcookies.set('demo_tenant_id', tenantId, {\n\t\t\t\t\tpath: '/',\n\t\t\t\t\thttpOnly: true,\n\t\t\t\t\tsecure: url.protocol === 'https:' || (url.hostname !== 'localhost' && !dev),\n\t\t\t\t\tsameSite: 'lax',\n\t\t\t\t\tmaxAge: 60 * 20 // 20 minutes for a demo session\n\t\t\t\t});\n\t\t\t\tlogger.info(`New demo tenant generated: ${tenantId}`);\n\n\t\t\t\t// --- Trigger Tenant Seeding Here ---\n\t\t\t\ttry {\n\t\t\t\t\tawait seedDemoTenant(dbAdapter, tenantId);\n\t\t\t\t\tlogger.info(` New demo tenant ${tenantId} seeded successfully.`);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.error(`Failed to seed demo tenant ${tenantId}:`, e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.trace(`Existing demo tenant from cookie: ${tenantId}`);\n\t\t\t}\n\t\t} else {\n\t\t\t// Standard multi-tenancy: resolve tenantId from hostname\n\t\t\ttenantId = getTenantIdFromHostname(url.hostname);\n\t\t}\n\n\t\tif (!tenantId) {\n\t\t\tlogger.error(`Tenant not found for hostname: ${url.hostname}`);\n\t\t\tthrow error(404, `Tenant not found for hostname: ${url.hostname}`);\n\t\t}\n\t\tlocals.tenantId = tenantId;\n\t\tlogger.trace(`Tenant identified: ${tenantId}`);\n\t}\n\n\t// Step 2: Session validation\n\tconst sessionId = cookies.get(SESSION_COOKIE_NAME);\n\tif (sessionId) {\n\t\tmetricsService.incrementAuthValidations();\n\n\t\t// Check if auth service is ready before attempting validation\n\t\tif (!auth) {\n\t\t\tlogger.debug('Auth service not ready during session validation - skipping validation but preserving cookie');\n\t\t\t// Do NOT delete cookie here - allow retry on next request\n\t\t\treturn resolve(event);\n\t\t}\n\n\t\tconst user = await getUserFromSession(sessionId, locals.tenantId);\n\t\tif (user) {\n\t\t\t// Tenant isolation check\n\t\t\tif (locals.tenantId && user.tenantId && user.tenantId !== locals.tenantId) {\n\t\t\t\tlogger.warn(`Tenant isolation violation: User ${user._id} (tenant: ${user.tenantId}) tried ${locals.tenantId}`);\n\t\t\t\tmetricsService.incrementAuthFailures();\n\t\t\t\tcookies.delete(SESSION_COOKIE_NAME, { path: '/' });\n\t\t\t\tthrow error(403, 'Access denied: Tenant isolation violation');\n\t\t\t}\n\n\t\t\t// Set user in locals\n\t\t\tlocals.user = user;\n\t\t\tlocals.session_id = sessionId;\n\t\t\tlocals.permissions = user.permissions || [];\n\t\t\tlogger.trace(`User authenticated: ${user._id}`);\n\n\t\t\t// Step 3: Automatic session rotation (security enhancement)\n\t\t\t// Rotates session token every 15 minutes for active users\n\t\t\ttry {\n\t\t\t\tawait handleSessionRotation(event, user, sessionId);\n\t\t\t} catch (rotationError) {\n\t\t\t\t// Rotation errors are already handled in handleSessionRotation\n\t\t\t\t// Just log additional context here if needed\n\t\t\t\tif (rotationError instanceof Error && !rotationError.message.includes('Session expired')) {\n\t\t\t\t\tlogger.debug(`Non-critical rotation issue: ${rotationError.message}`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Only delete cookie if auth was ready but session was invalid\n\t\t\t// getUserFromSession returns null if session not found/expired OR if auth not ready\n\t\t\t// But we checked !auth above, so here it means session is truly invalid\n\t\t\tmetricsService.incrementAuthFailures();\n\t\t\tcookies.delete(SESSION_COOKIE_NAME, { path: '/' });\n\t\t\tlogger.trace(`Invalid session removed: ${sessionId.substring(0, 8)}...`);\n\t\t}\n\t}\n\n\treturn resolve(event);\n};\n\n// --- UTILITY EXPORTS ---\n\n/**\n * Invalidate a single session from all cache layers.\n * Use when logging out a user or detecting compromised sessions.\n *\n * @param sessionId - The session ID to invalidate\n * @param tenantId - Optional tenant ID for multi-tenant setups\n */\nexport function invalidateSessionCache(sessionId: string, tenantId?: string): void {\n\tsessionCache.delete(sessionId);\n\tstrongRefs.delete(sessionId);\n\tlastRefreshAttempt.delete(sessionId);\n\tlastRotationAttempt.delete(sessionId);\n\n\tconst cacheKey = tenantId ? `session:${tenantId}:${sessionId}` : `session:${sessionId}`;\n\tcacheService.delete(cacheKey, tenantId).catch((err) => logger.warn(`Failed to delete session from Redis: ${err.message}`));\n\n\tlogger.debug(`Session cache invalidated: ${sessionId.substring(0, 8)}...`);\n}\n\n/**\n * Clear session refresh cooldown to allow immediate validation.\n * Useful for testing or forced session validation.\n *\n * @param sessionId - The session ID to clear cooldown for\n */\nexport function clearSessionRefreshAttempt(sessionId: string): void {\n\tlastRefreshAttempt.delete(sessionId);\n}\n\n/**\n * Force session rotation for a specific session.\n * Useful for security responses or administrative actions.\n *\n * @param sessionId - The session ID to force rotation for\n */\nexport function forceSessionRotation(sessionId: string): void {\n\tlastRotationAttempt.delete(sessionId);\n\tlogger.info(`Forced rotation flag set for session ${sessionId.substring(0, 8)}...`);\n}\n\n/**\n * Clears all session caches (maintenance only).\n * WARNING: This will force all users to re-authenticate on next request.\n * Only use during maintenance windows or security incidents.\n */\nexport function clearAllSessionCaches(): void {\n\tsessionCache.clear();\n\tstrongRefs.clear();\n\tlastRefreshAttempt.clear();\n\tlastRotationAttempt.clear();\n\tlogger.warn('  All session caches cleared - users will need to re-authenticate');\n}\n\n/**\n * Get session cache statistics for monitoring.\n * @returns Object containing cache sizes and metrics\n */\nexport function getSessionCacheStats() {\n\treturn {\n\t\tweakRefs: sessionCache.size,\n\t\tstrongRefs: strongRefs.size,\n\t\tpendingRefreshes: lastRefreshAttempt.size,\n\t\tpendingRotations: lastRotationAttempt.size,\n\t\tmaxStrongRefs: MAX_STRONG_REFS\n\t};\n}\n","/**\n * @file src/hooks/handleRateLimit.ts\n * @description Middleware for rate limiting to prevent abuse and DoS attacks with clustered deployment support\n *\n * ### Rate Limiting Strategy\n * - **General Routes**: 500 requests/minute per IP, IP+UA, and cookie\n * - **API Routes**: 500 requests/minute per IP, 200 requests/minute per IP+UA (stricter)\n * - **Exemptions**: Localhost, build process, static assets\n *\n * ### Multi-Layer Protection\n * 1. **IP-based**: Prevents basic abuse from single source\n * 2. **IP + User-Agent**: Prevents abuse from same IP with multiple UAs\n * 3. **Cookie-based**: Signed cookie tracking for additional security\n * 4. **Distributed Store**: Redis/Database backend for clustered deployments\n *\n * ### Clustered Deployment Support\n * - Automatically uses Redis if available via CacheService\n * - Falls back to in-memory for single-instance deployments\n * - Shared rate limiting across all instances in load-balanced environments\n *\n * ### Behavior\n * - Returns 429 \"Too Many Requests\" when limits exceeded\n * - Logs violations with IP and endpoint for monitoring\n * - Exempt routes bypass all checks for performance\n *\n * ### Prerequisites\n * - handleSystemState confirmed system is READY\n * - JWT_SECRET_KEY is configured for cookie signing\n * - CacheService configured with Redis for distributed rate limiting\n *\n * @prerequisite System state is READY and JWT secret is available\n */\n\nimport { building } from '$app/environment';\nimport { error, type Handle, type RequestEvent } from '@sveltejs/kit';\nimport { RateLimiter } from 'sveltekit-rate-limiter/server';\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { metricsService } from '@shared/services/MetricsService';\nimport { cacheService } from '@shared/database/CacheService';\nimport { logger } from '@shared/utils/logger.server';\n\n// --- RATE LIMITER CONFIGURATION ---\n\n/**\n * Custom store plugin for distributed rate limiting using Redis/Database.\n * Enables shared rate limiting across clustered deployments.\n */\nconst distributedStore = {\n\t/**\n\t * Gets the current count for a rate limit key\n\t */\n\tasync get(key: string): Promise<number | undefined> {\n\t\ttry {\n\t\t\tconst data = await cacheService.get<{ count: number; expires: number }>(`ratelimit:${key}`);\n\t\t\tif (data && data.expires > Date.now()) {\n\t\t\t\treturn data.count;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Distributed rate limit store GET failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn undefined;\n\t\t}\n\t},\n\n\tasync has(key: string): Promise<boolean> {\n\t\treturn (await this.get(key)) !== undefined;\n\t},\n\n\t/**\n\t * Adds/sets a value in the store (required by sveltekit-rate-limiter)\n\t */\n\tasync add(key: string, ttlSeconds: number): Promise<number> {\n\t\ttry {\n\t\t\tif (await this.has(key)) {\n\t\t\t\treturn this.increment(key, ttlSeconds);\n\t\t\t}\n\t\t\tconst expires = Date.now() + ttlSeconds * 1000;\n\t\t\tawait cacheService.set(`ratelimit:${key}`, { count: 1, expires }, ttlSeconds);\n\t\t\treturn 1;\n\t\t} catch (err) {\n\t\t\tlogger.error(`Distributed rate limit store ADD failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\t/**\n\t * Increments the counter for a rate limit key\n\t */\n\tasync increment(key: string, ttlSeconds: number): Promise<number> {\n\t\ttry {\n\t\t\tconst existing = await this.get(key);\n\t\t\tconst newCount = (existing || 0) + 1;\n\t\t\tconst expires = Date.now() + ttlSeconds * 1000;\n\n\t\t\tawait cacheService.set(`ratelimit:${key}`, { count: newCount, expires }, ttlSeconds);\n\t\t\tconsole.log(`[RateLimit] INC ${key}: ${newCount}`);\n\t\t\treturn newCount;\n\t\t} catch (err) {\n\t\t\tlogger.error(`Distributed rate limit store INCREMENT failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn 1; // Fail open to prevent blocking all traffic\n\t\t}\n\t},\n\tasync clear(): Promise<void> {\n\t\ttry {\n\t\t\tawait cacheService.delete(`ratelimit:*`); // Clear all rate limit keys\n\t\t} catch (err) {\n\t\t\tlogger.error(`Distributed rate limit store CLEAR failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t}\n\t}\n};\n\n/** General limiter for all non-API routes with distributed store support */\nconst generalLimiter = new RateLimiter({\n\tIP: [500, 'm'],\n\tIPUA: [500, 'm'],\n\tcookie: {\n\t\tname: 'ratelimit',\n\t\tsecret: getPrivateSettingSync('JWT_SECRET_KEY') || 'fallback-dev-secret',\n\t\trate: [500, 'm'],\n\t\tpreflight: true\n\t},\n\t// Enable distributed store if Redis is available\n\tstore: cacheService ? distributedStore : undefined\n});\n\n/** Stricter limiter for API routes with distributed store support */\nconst apiLimiter = new RateLimiter({\n\tIP: [500, 'm'],\n\tIPUA: [200, 'm'],\n\t// Enable distributed store if Redis is available\n\tstore: cacheService ? distributedStore : undefined\n});\n\n/** Stricter limiter for Auth routes (brute force protection) */\nconst authLimiter = new RateLimiter({\n\tIP: [10, 'm'], // 10 requests per minute per IP\n\tIPUA: [5, 'm'], // 5 requests per minute per IP+UA\n\tstore: cacheService ? distributedStore : undefined\n});\n\n// --- UTILITY FUNCTIONS ---\n\n/** Extracts client IP from request headers or environment */\nfunction getClientIp(event: RequestEvent): string {\n\ttry {\n\t\tconst address = event.getClientAddress();\n\t\tif (address) return address;\n\t} catch {\n\t\t// Fallback to proxy headers\n\t}\n\n\tconst forwarded = event.request.headers.get('x-forwarded-for');\n\tif (forwarded) return forwarded.split(',')[0].trim();\n\n\tconst realIp = event.request.headers.get('x-real-ip');\n\tif (realIp) return realIp;\n\n\treturn '127.0.0.1';\n}\n\n/** Determines if an IP is localhost */\nfunction isLocalhost(ip: string): boolean {\n\treturn ip === '127.0.0.1' || ip === '::1' || ip === '::ffff:127.0.0.1';\n}\n\n/**\n * Checks if a pathname points to a static asset that should bypass rate limiting.\n * Static assets are typically cached by CDNs and don't need rate limiting.\n */\nconst STATIC_EXTENSIONS = /\\.(js|css|map|woff2?|ttf|eot|svg|png|jpg|jpeg|gif|webp|ico)$/;\n\nfunction isStaticAsset(pathname: string): boolean {\n\treturn (\n\t\tpathname.startsWith('/static/') ||\n\t\tpathname.startsWith('/_app/') ||\n\t\tpathname === '/favicon.ico' ||\n\t\tpathname === '/robots.txt' ||\n\t\tpathname === '/sitemap.xml' ||\n\t\tSTATIC_EXTENSIONS.test(pathname)\n\t);\n}\n\n// --- MAIN HOOK ---\n\nexport const handleRateLimit: Handle = async ({ event, resolve }) => {\n\tconst { url } = event;\n\tconst clientIp = getClientIp(event);\n\n\t// --- Exemptions (Skip Rate Limiting) ---\n\n\t// 1. Build process\n\tif (building) return resolve(event);\n\n\t// 2. Localhost during development OR production\n\t// Allow bypassing this check for testing purposes\n\tconst bypassLocalhost = event.request.headers.get('x-test-rate-limit-bypass-localhost') === 'true';\n\t// console.log(`[RateLimit] IP: ${clientIp}, Localhost: ${isLocalhost(clientIp)}, Bypass: ${bypassLocalhost}, Path: ${url.pathname}`);\n\tif (isLocalhost(clientIp) && !bypassLocalhost) {\n\t\treturn resolve(event);\n\t}\n\n\t// 3. Static assets (no need to rate limit CDN-cached content)\n\tif (isStaticAsset(url.pathname)) return resolve(event);\n\n\t// --- Apply Rate Limiting ---\n\tlet limiter = generalLimiter;\n\n\tif (url.pathname.startsWith('/api/auth')) {\n\t\tlimiter = authLimiter;\n\t} else if (url.pathname.startsWith('/api/')) {\n\t\tlimiter = apiLimiter;\n\t}\n\n\tif (await limiter.isLimited(event)) {\n\t\tmetricsService.incrementRateLimitViolations();\n\n\t\tlogger.warn(\n\t\t\t`Rate limit exceeded for IP: ${clientIp}, ` +\n\t\t\t\t`endpoint: ${url.pathname}, ` +\n\t\t\t\t`UA: ${event.request.headers.get('user-agent')?.substring(0, 50) || 'unknown'}`\n\t\t);\n\n\t\tthrow error(429, 'Too Many Requests. Please slow down and try again later.');\n\t}\n\n\treturn resolve(event);\n};\n","export const matchers = {};","<!-- This file is generated by @sveltejs/kit  do not edit it! -->\n<svelte:options runes={true} />\n<script>\n\timport { setContext, onMount, tick } from 'svelte';\n\timport { browser } from '$app/environment';\n\n\t// stores\n\tlet { stores, page, constructors, components = [], form, data_0 = null, data_1 = null } = $props();\n\n\tif (!browser) {\n\t\t// svelte-ignore state_referenced_locally\n\t\tsetContext('__svelte__', stores);\n\t}\n\n\tif (browser) {\n\t\t$effect.pre(() => stores.page.set(page));\n\t} else {\n\t\t// svelte-ignore state_referenced_locally\n\t\tstores.page.set(page);\n\t}\n\t$effect(() => {\n\t\tstores;page;constructors;components;form;data_0;data_1;\n\t\tstores.page.notify();\n\t});\n\n\tlet mounted = $state(false);\n\tlet navigated = $state(false);\n\tlet title = $state(null);\n\n\tonMount(() => {\n\t\tconst unsubscribe = stores.page.subscribe(() => {\n\t\t\tif (mounted) {\n\t\t\t\tnavigated = true;\n\t\t\t\ttick().then(() => {\n\t\t\t\t\ttitle = document.title || 'untitled page';\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tmounted = true;\n\t\treturn unsubscribe;\n\t});\n\n\tconst Pyramid_1=$derived(constructors[1])\n</script>\n\n{#if constructors[1]}\n\t{@const Pyramid_0 = constructors[0]}\n\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t<Pyramid_0 bind:this={components[0]} data={data_0} {form} params={page.params}>\n\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t<Pyramid_1 bind:this={components[1]} data={data_1} {form} params={page.params} />\n\t\t\t\t\t\t\t</Pyramid_0>\n\n{:else}\n\t{@const Pyramid_0 = constructors[0]}\n\t<!-- svelte-ignore binding_property_non_reactive -->\n\t<Pyramid_0 bind:this={components[0]} data={data_0} {form} params={page.params} />\n\n{/if}\n\n{#if mounted}\n\t<div id=\"svelte-announcer\" aria-live=\"assertive\" aria-atomic=\"true\" style=\"position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px\">\n\t\t{#if navigated}\n\t\t\t{title}\n\t\t{/if}\n\t</div>\n{/if}","import { asClassComponent } from 'svelte/legacy';\nimport Root from './root.svelte';\nexport default asClassComponent(Root);","import * as universal_hooks from '../../../src/hooks/index.ts';\n\nexport { matchers } from './matchers.js';\n\nexport const nodes = [\n\t() => import('./nodes/0'),\n\t() => import('./nodes/1'),\n\t() => import('./nodes/2'),\n\t() => import('./nodes/3'),\n\t() => import('./nodes/4'),\n\t() => import('./nodes/5'),\n\t() => import('./nodes/6'),\n\t() => import('./nodes/7'),\n\t() => import('./nodes/8'),\n\t() => import('./nodes/9'),\n\t() => import('./nodes/10'),\n\t() => import('./nodes/11'),\n\t() => import('./nodes/12'),\n\t() => import('./nodes/13'),\n\t() => import('./nodes/14'),\n\t() => import('./nodes/15'),\n\t() => import('./nodes/16'),\n\t() => import('./nodes/17'),\n\t() => import('./nodes/18'),\n\t() => import('./nodes/19'),\n\t() => import('./nodes/20'),\n\t() => import('./nodes/21'),\n\t() => import('./nodes/22'),\n\t() => import('./nodes/23')\n];\n\nexport const server_loads = [0];\n\nexport const dictionary = {\n\t\t\"/\": [~3],\n\t\t\"/config\": [~6],\n\t\t\"/config/accessManagement\": [~7],\n\t\t\"/config/collectionbuilder\": [~8],\n\t\t\"/config/collectionbuilder/[action]/[...contentPath]\": [~9],\n\t\t\"/config/configurationManager\": [~10],\n\t\t\"/config/import-export\": [~11],\n\t\t\"/config/system-health\": [12],\n\t\t\"/config/systemsetting\": [~13],\n\t\t\"/config/themeManagement\": [~14],\n\t\t\"/config/widgetManagement\": [~15],\n\t\t\"/dashboard\": [~16],\n\t\t\"/email-previews\": [~17],\n\t\t\"/graphql-test\": [18],\n\t\t\"/login\": [~19],\n\t\t\"/login/oauth\": [~20],\n\t\t\"/mediagallery\": [~21],\n\t\t\"/mediagallery/uploadMedia\": [22],\n\t\t\"/user\": [~23],\n\t\t\"/[language]\": [~4,[],[2]],\n\t\t\"/[language]/[...collection]\": [~5,[],[2]]\n\t};\n\nexport const hooks = {\n\thandleError: (({ error }) => { console.error(error) }),\n\t\n\treroute: universal_hooks.reroute || (() => {}),\n\ttransport: universal_hooks.transport || {}\n};\n\nexport const decoders = Object.fromEntries(Object.entries(hooks.transport).map(([k, v]) => [k, v.decode]));\nexport const encoders = Object.fromEntries(Object.entries(hooks.transport).map(([k, v]) => [k, v.encode]));\n\nexport const hash = false;\n\nexport const decode = (type, value) => decoders[type](value);\n\nexport { default as root } from '../root.js';"],"file":"app.CrSKIZW0.js"}