{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/routes/api/token/[tokenID]/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/token/[tokenId]/+se\t\t// Authentication is handled by hooks.server.ts - user presence confirms accession API endpoint for updating an existing token.\n *\n * This module is responsible for:\n * - Updating an existing token's data (e.g., email, role, expiration) within the current tenant.\n * - Requires 'update:token' permission.\n * - Adheres to the authDBInterface for database-agnostic operations.\n *\n * @usage\n * PUT /api/token/{tokenId}\n * @body {\n * \"newTokenData\": {\n * \"email\": \"new@example.com\",\n * \"role\": \"admin\"\n * }\n * }\n */\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { error, json, type HttpError } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\n\n// Auth\nimport { auth } from '@shared/database/db';\n\n// Validation\nimport { any, object, parse } from 'valibot';\n\n// Cache invalidation\nimport { cacheService } from '@shared/database/CacheService';\n\n// System logger\nimport { logger } from '@shared/utils/logger.server';\n\n// Minimal shared result type guards (kept local to avoid broad dependencies)\ninterface DatabaseResultLike<T> {\n\tsuccess: boolean;\n\tdata?: T;\n\tdeletedCount?: number;\n}\ninterface TokenLike {\n\t_id?: string;\n\ttoken?: string;\n}\nfunction isDatabaseResult<T>(val: unknown): val is DatabaseResultLike<T> {\n\treturn !!val && typeof val === 'object' && 'success' in val;\n}\n\nconst editTokenSchema = object({\n\tnewTokenData: any() // Keep it flexible, specific validation can be added\n});\n\nexport const PUT: RequestHandler = async ({ request, params, locals }) => {\n\tconst { user, tenantId } = locals;\n\ttry {\n\t\tconst tokenId = params.tokenID;\n\t\tif (!tokenId) {\n\t\t\tthrow error(400, 'Token ID is required in the URL path.');\n\t\t}\n\t\t// Authentication is handled by hooks.server.ts - user presence confirms access\n\n\t\tconst body = await request.json().catch(() => {\n\t\t\tthrow error(400, 'Invalid JSON in request body');\n\t\t});\n\t\tconst { newTokenData } = parse(editTokenSchema, body);\n\n\t\tif (!auth) {\n\t\t\tlogger.error('Database authentication adapter not initialized');\n\t\t\tthrow error(500, 'Database authentication not available');\n\t\t}\n\n\t\t// --- MULTI-TENANCY SECURITY CHECK ---\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tif (!tenantId) {\n\t\t\t\tthrow error(500, 'Tenant could not be identified for this operation.');\n\t\t\t}\n\t\t\tconst tokenToUpdate = await auth.getTokenByValue(tokenId);\n\t\t\tif (!tokenToUpdate || tokenToUpdate.tenantId !== tenantId) {\n\t\t\t\tlogger.warn('Attempt to edit a token belonging to another tenant.', {\n\t\t\t\t\tadminId: user?._id,\n\t\t\t\t\tadminTenantId: tenantId,\n\t\t\t\t\ttargetTokenId: tokenId,\n\t\t\t\t\ttargetTenantId: tokenToUpdate?.tenantId\n\t\t\t\t});\n\t\t\t\tthrow error(403, 'Forbidden: You can only edit tokens within your own tenant.');\n\t\t\t}\n\t\t} // TODO: Use database-agnostic interface once updateToken is implemented\t\t// Use database-agnostic interface if available, with graceful fallback\n\t\tlet updateResult: unknown = null;\n\t\tconst possibleAuth: unknown = auth as unknown;\n\t\tif (\n\t\t\tpossibleAuth &&\n\t\t\ttypeof possibleAuth === 'object' &&\n\t\t\t'updateToken' in possibleAuth &&\n\t\t\ttypeof (possibleAuth as { updateToken: unknown }).updateToken === 'function'\n\t\t) {\n\t\t\tupdateResult = await (possibleAuth as { updateToken: (id: string, data: unknown) => unknown }).updateToken(tokenId, newTokenData);\n\t\t} else {\n\t\t\t// Fallback (should not normally execute once interface is standardized)\n\t\t\tconst { TokenAdapter } = await import('@shared/database/mongodb/models/authToken');\n\t\t\tconst tokenAdapter = new TokenAdapter();\n\t\t\tupdateResult = await tokenAdapter.updateToken(tokenId, newTokenData);\n\t\t}\n\n\t\t// Handle possible return shapes: boolean | Token | DatabaseResult<Token>\n\t\tlet updated = false;\n\t\tif (typeof updateResult === 'boolean') {\n\t\t\tupdated = updateResult;\n\t\t} else if (isDatabaseResult<TokenLike>(updateResult)) {\n\t\t\tupdated = updateResult.success === true;\n\t\t} else if (updateResult && typeof updateResult === 'object') {\n\t\t\tupdated = true; // Assume object implies success (token object returned)\n\t\t}\n\t\tif (!updated) {\n\t\t\tthrow error(404, 'Token not found or not modified');\n\t\t}\n\n\t\tlogger.info('Token updated successfully', { tokenId, updateData: newTokenData, tenantId }); // Invalidate the tokens cache so the UI updates immediately\n\n\t\tcacheService.delete('tokens', tenantId).catch((err) => {\n\t\t\tlogger.warn(`Failed to invalidate tokens cache: ${err.message}`);\n\t\t});\n\n\t\treturn json({ success: true, message: 'Token updated successfully.' });\n\t} catch (err) {\n\t\tif (err instanceof Error && err.name === 'ValiError') {\n\t\t\tconst valiError = err as unknown as { issues: Array<{ message: string }> };\n\t\t\tconst issues = valiError.issues.map((issue: { message: string }) => issue.message).join(', ');\n\t\t\tlogger.warn('Invalid input for edit token API:', { issues });\n\t\t\tthrow error(400, `Invalid input: ${issues}`);\n\t\t}\n\t\tconst httpError = err as HttpError;\n\t\tconst status = httpError.status || 500;\n\t\tconst message = httpError.body?.message || 'An unexpected error occurred.';\n\t\tlogger.error('Error in edit token API:', {\n\t\t\terror: message,\n\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\tuserId: locals.user?._id,\n\t\t\tstatus\n\t\t});\n\t\treturn json({ success: false, message: status === 500 ? 'Internal Server Error' : message }, { status });\n\t}\n};\n\nexport const DELETE: RequestHandler = async ({ params, locals }) => {\n\tconst { user, tenantId } = locals;\n\ttry {\n\t\tconst tokenId = params.tokenID;\n\t\tif (!tokenId) {\n\t\t\tthrow error(400, 'Token ID is required in the URL path.');\n\t\t}\n\t\t// Authentication is handled by hooks.server.ts - user presence confirms access\n\n\t\t// --- MULTI-TENANCY SECURITY CHECK ---\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tif (!tenantId) {\n\t\t\t\tthrow error(500, 'Tenant could not be identified for this operation.');\n\t\t\t}\n\t\t\tif (!auth) {\n\t\t\t\tthrow error(500, 'Auth service is not initialized');\n\t\t\t}\n\t\t\tconst tokenToDelete = await auth.getTokenByValue(tokenId);\n\t\t\tif (!tokenToDelete) {\n\t\t\t\tlogger.warn('Attempt to delete a non-existent token.', {\n\t\t\t\t\tadminId: user?._id,\n\t\t\t\t\tadminTenantId: tenantId,\n\t\t\t\t\ttargetTokenId: tokenId\n\t\t\t\t});\n\t\t\t\tthrow error(404, 'Token not found.');\n\t\t\t}\n\t\t}\n\n\t\t// Use database-agnostic interface if available, fallback to adapter\n\t\tlet deletedCount: number | undefined;\n\t\tconst maybeAuth: unknown = auth as unknown;\n\t\tif (\n\t\t\tmaybeAuth &&\n\t\t\ttypeof maybeAuth === 'object' &&\n\t\t\t'deleteTokens' in maybeAuth &&\n\t\t\ttypeof (maybeAuth as { deleteTokens: unknown }).deleteTokens === 'function'\n\t\t) {\n\t\t\tconst result = await (maybeAuth as { deleteTokens: (ids: string[]) => unknown }).deleteTokens([tokenId]);\n\t\t\tif (typeof result === 'number') {\n\t\t\t\tdeletedCount = result;\n\t\t\t} else if (result && typeof result === 'object' && 'deletedCount' in result) {\n\t\t\t\tdeletedCount = (result as { deletedCount?: number }).deletedCount;\n\t\t\t}\n\t\t} else {\n\t\t\tconst { TokenAdapter } = await import('@shared/database/mongodb/models/authToken');\n\t\t\tconst tokenAdapter = new TokenAdapter();\n\t\t\tconst result = await tokenAdapter.deleteTokens([tokenId]);\n\t\t\tif (result.success && result.data) {\n\t\t\t\tdeletedCount = result.data.deletedCount;\n\t\t\t}\n\t\t}\n\t\tif (!deletedCount) {\n\t\t\tthrow error(404, 'Token not found');\n\t\t} // Invalidate the tokens cache so the deleted token disappears immediately from admin area\n\n\t\tcacheService.delete('tokens', tenantId).catch((err) => {\n\t\t\tlogger.warn(`Failed to invalidate tokens cache: ${err.message}`);\n\t\t});\n\n\t\tlogger.info(`Token ${tokenId} deleted successfully`, { executedBy: user?._id, tenantId });\n\n\t\treturn json({ success: true, message: 'Token deleted successfully.' });\n\t} catch (err) {\n\t\tconst httpError = err as HttpError;\n\t\tconst status = httpError.status || 500;\n\t\tconst message = httpError.body?.message || 'An unexpected error occurred.';\n\t\tlogger.error('Error in delete token API:', {\n\t\t\terror: message,\n\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\tuserId: locals.user?._id,\n\t\t\tstatus\n\t\t});\n\t\treturn json({ success: false, message: status === 500 ? 'Internal Server Error' : message }, { status });\n\t}\n};\n"],"names":[],"mappings":"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"}