{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/routes/api/dashboard/online_user/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/dashboard/online_user/+server.ts\n * @description API endpoint for user activity data for dashboard widgets (online users)\n */\n\nimport { error, json } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { auth } from '@shared/database/db';\nimport { logger } from '@shared/utils/logger.server';\nimport * as v from 'valibot';\n\n// Schema for the outgoing API data\nconst OnlineUserSchema = v.object({\n\tid: v.string(),\n\tname: v.string(),\n\tavatarUrl: v.optional(v.string()),\n\tonlineTime: v.string(), // Human-readable online duration\n\tonlineMinutes: v.number() // Online time in minutes for sorting\n});\n\n// TypeScript type from schema\ntype OnlineUser = v.InferOutput<typeof OnlineUserSchema>;\n\n// Helper function to format online duration\nfunction formatOnlineTime(minutes: number): string {\n\tif (minutes < 1) return '< 1m';\n\tif (minutes < 60) return `${Math.floor(minutes)}m`;\n\tif (minutes < 1440) {\n\t\tconst hours = Math.floor(minutes / 60);\n\t\tconst remainingMinutes = Math.floor(minutes % 60);\n\t\treturn remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;\n\t}\n\tconst days = Math.floor(minutes / 1440);\n\tconst remainingHours = Math.floor((minutes % 1440) / 60);\n\treturn remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days}d`;\n}\n\nexport const GET: RequestHandler = async ({ locals }) => {\n\tconst { user, tenantId } = locals;\n\tif (!user) {\n\t\tlogger.warn('Unauthorized attempt to access online user data');\n\t\tthrow error(401, 'Unauthorized');\n\t}\n\tif (!auth) {\n\t\tlogger.error('Auth service unavailable');\n\t\tthrow error(500, 'Internal Server Error: Auth service unavailable.');\n\t}\n\ttry {\n\t\tif (getPrivateSettingSync('MULTI_TENANT') && !tenantId) {\n\t\t\tthrow error(400, 'Tenant could not be identified for this operation.');\n\t\t}\n\t\t// Fetch active sessions for all users (not just the current user)\n\t\t// We need to get all active sessions, then extract unique user IDs\n\t\tconst sessionsResult = await auth.getAllActiveSessions(tenantId);\n\t\tlogger.debug('Sessions result from auth.getAllActiveSessions:', {\n\t\t\tsuccess: sessionsResult.success,\n\t\t\tdataLength: sessionsResult.data?.length || 0,\n\t\t\trequestedBy: user._id,\n\t\t\ttenantId\n\t\t});\n\t\tif (!sessionsResult.success) {\n\t\t\tlogger.error('Failed to retrieve active sessions', {\n\t\t\t\trequestedBy: user._id,\n\t\t\t\ttenantId,\n\t\t\t\terror: sessionsResult.message\n\t\t\t});\n\t\t\tthrow new Error(`Failed to retrieve active sessions: ${sessionsResult.message || 'Unknown error'}`);\n\t\t}\n\t\tconst uniqueIds = Array.from(new Set(sessionsResult.data.map((s) => s.user_id)));\n\n\t\t// Create a map of user sessions to find the earliest (longest online) session per user\n\t\t// Extract timestamp from MongoDB ObjectId (first 4 bytes represent Unix timestamp)\n\t\tconst userSessionMap = new Map<string, Date>();\n\t\tfor (const session of sessionsResult.data) {\n\t\t\tconst existingStart = userSessionMap.get(session.user_id);\n\t\t\t// Extract timestamp from ObjectId: first 8 hex chars = 4 bytes = Unix timestamp in seconds\n\t\t\tconst timestamp = parseInt(session._id.substring(0, 8), 16) * 1000;\n\t\t\tconst sessionStart = new Date(timestamp);\n\t\t\tif (!existingStart || sessionStart < existingStart) {\n\t\t\t\tuserSessionMap.set(session.user_id, sessionStart);\n\t\t\t}\n\t\t} // Fetch user details\n\t\tconst onlineUsers: OnlineUser[] = [];\n\t\tlogger.debug('Processing unique user IDs:', { uniqueIds, count: uniqueIds.length });\n\n\t\tfor (const uid of uniqueIds) {\n\t\t\tlogger.debug('Fetching user by ID:', { uid, tenantId });\n\t\t\tconst userData = await auth.getUserById(uid, tenantId);\n\t\t\tlogger.debug('User fetch result:', {\n\t\t\t\tuid,\n\t\t\t\thasData: !!userData,\n\t\t\t\tusername: userData?.username,\n\t\t\t\temail: userData?.email\n\t\t\t});\n\n\t\t\tif (userData) {\n\t\t\t\t// Create display name - prefer username, fallback to firstName + lastName, then email\n\t\t\t\tlet displayName = userData.username;\n\t\t\t\tif (!displayName && (userData.firstName || userData.lastName)) {\n\t\t\t\t\tdisplayName = [userData.firstName, userData.lastName].filter(Boolean).join(' ');\n\t\t\t\t}\n\t\t\t\tif (!displayName) {\n\t\t\t\t\tdisplayName = userData.email || 'Unknown User';\n\t\t\t\t}\n\n\t\t\t\t// Calculate online time\n\t\t\t\tconst sessionStart = userSessionMap.get(uid);\n\t\t\t\tconst onlineMinutes = sessionStart ? (Date.now() - sessionStart.getTime()) / (1000 * 60) : 0;\n\t\t\t\tconst onlineTime = formatOnlineTime(onlineMinutes);\n\n\t\t\t\tlogger.debug('Adding online user:', {\n\t\t\t\t\tid: userData._id.toString(),\n\t\t\t\t\tdisplayName,\n\t\t\t\t\thasAvatar: !!userData.avatar,\n\t\t\t\t\tonlineMinutes: Math.floor(onlineMinutes),\n\t\t\t\t\tonlineTime\n\t\t\t\t});\n\n\t\t\t\tonlineUsers.push({\n\t\t\t\t\tid: userData._id.toString(),\n\t\t\t\t\tname: displayName,\n\t\t\t\t\tavatarUrl: userData.avatar || undefined,\n\t\t\t\t\tonlineTime,\n\t\t\t\t\tonlineMinutes: Math.floor(onlineMinutes)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlogger.warn('Failed to fetch user details:', { uid });\n\t\t\t}\n\t\t}\n\n\t\t// Sort users by online time (longest online first)\n\t\tonlineUsers.sort((a, b) => b.onlineMinutes - a.onlineMinutes);\n\t\tconst responseData = { onlineUsers };\n\t\tconst validated = v.parse(v.object({ onlineUsers: v.array(OnlineUserSchema) }), responseData);\n\t\tlogger.info('Online users fetched successfully', { count: validated.onlineUsers.length, requestedBy: user._id });\n\t\treturn json(validated);\n\t} catch (err) {\n\t\tif (err instanceof v.ValiError) {\n\t\t\tlogger.error('Validation error for online_user data', { issues: err.issues });\n\t\t\tthrow error(500, 'Internal Server Error: Failed to validate online user data.');\n\t\t}\n\t\tconst httpErr = err as { status?: number; message?: string };\n\t\tlogger.error('An error occurred fetching online users', { error: httpErr.message, status: httpErr.status });\n\t\tthrow error(httpErr.status || 500, httpErr.message || 'An unexpected error occurred.');\n\t}\n};\n"],"names":[],"mappings":"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"}