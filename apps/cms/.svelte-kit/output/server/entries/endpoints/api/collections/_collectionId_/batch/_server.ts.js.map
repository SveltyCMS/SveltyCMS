{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../../src/routes/api/collections/[collectionId]/batch/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/collections/[collectionId]/batch/+server.ts\n * @description API endpoint for batch operations on collection entries\n *\n * @example: POST /api/collections/posts/batch\n *\n * Features:\n * * Batch delete, status updates, and other bulk operations\n * * Performance optimized for large datasets\n * * Maintains audit trail for batch operations\n * * Permission checking scoped to current tenant\n * * Enhanced error reporting for partial failures\n */\n\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { error, json, type RequestHandler } from '@sveltejs/kit';\n\n// Auth\nimport { modifyRequest } from '@api/collections/modifyRequest';\nimport { contentManager } from '@content/ContentManager';\nimport type { StatusType } from '@cms-types';\nimport type { DatabaseId, BaseEntity, CollectionModel } from '@shared/database/dbInterface';\n\n// Validation\nimport { array, object, optional, parse, picklist, string } from 'valibot';\n\n// System Logger\nimport { logger } from '@shared/utils/logger.server';\n\n// Validation schema for batch operations\nconst batchOperationSchema = object({\n\taction: picklist(['delete', 'status', 'clone'], 'Invalid action specified.'),\n\tentryIds: array(string(), 'Entry IDs must be an array of strings'),\n\t// Optional fields for specific actions\n\tstatus: optional(string()), // Required for status action\n\tcloneCount: optional(string()) // Required for clone action\n});\n\n// Helper function to normalize collection names\nconst normalizeCollectionName = (collectionId: string): string => {\n\tconst cleanId = collectionId.replace(/-/g, '');\n\treturn `collection_${cleanId}`;\n};\n\n// POST: Performs batch operations on collection entries\nexport const POST: RequestHandler = async ({ locals, params, request }) => {\n\tconst start = performance.now();\n\tconst endpoint = `POST /api/collections/${params.collectionId}/batch`;\n\tconst { user, tenantId } = locals;\n\n\tlogger.info(`${endpoint} - Batch operation started`, {\n\t\tuserId: user?._id,\n\t\ttenantId,\n\t\tcollectionId: params.collectionId\n\t});\n\n\ttry {\n\t\tif (!user) {\n\t\t\tthrow error(401, 'Unauthorized');\n\t\t}\n\n\t\tif (getPrivateSettingSync('MULTI_TENANT') && !tenantId) {\n\t\t\tthrow error(400, 'Could not identify the tenant for this request.');\n\t\t}\n\n\t\tconst schema = await contentManager.getCollectionById(params.collectionId, tenantId);\n\t\tif (!schema) {\n\t\t\tthrow error(404, 'Collection not found');\n\t\t}\n\n\t\t// Parse and validate request body\n\t\tlet body;\n\t\ttry {\n\t\t\tbody = await request.json();\n\t\t} catch {\n\t\t\tthrow error(400, 'Invalid JSON in request body');\n\t\t}\n\n\t\tconst { action, entryIds, status, cloneCount } = parse(batchOperationSchema, body);\n\n\t\t// Validate action-specific requirements\n\t\tif (action === 'status' && !status) {\n\t\t\tthrow error(400, 'Status is required for status action');\n\t\t}\n\n\t\tif (action === 'status' && !['publish', 'unpublish', 'draft', 'archived'].includes(status as StatusType)) {\n\t\t\tthrow error(400, `Invalid status. Must be one of: publish, unpublish, draft, archived`);\n\t\t}\n\n\t\tif (action === 'clone' && !cloneCount) {\n\t\t\tthrow error(400, 'Clone count is required for clone action');\n\t\t}\n\n\t\tconst dbAdapter = locals.dbAdapter;\n\t\tif (!dbAdapter) {\n\t\t\tthrow error(503, 'Service Unavailable: Database service is not properly initialized');\n\t\t}\n\n\t\tif (!schema._id) {\n\t\t\tthrow error(500, 'Collection ID is missing');\n\t\t}\n\n\t\tconst normalizedCollectionId = normalizeCollectionName(schema._id); // Build tenant-aware query\n\t\tconst databaseEntryIds = entryIds.map((id) => id as unknown as DatabaseId);\n\t\tconst query: { _id: { $in: DatabaseId[] }; tenantId?: string } = { _id: { $in: databaseEntryIds } };\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tquery.tenantId = tenantId;\n\t\t}\n\n\t\t// Verify all entries exist and belong to current tenant\n\t\tconst verificationResult = await dbAdapter.crud.findMany<BaseEntity>(\n\t\t\tnormalizedCollectionId,\n\t\t\tquery as unknown as import('@shared/database/dbInterface').QueryFilter<BaseEntity>\n\t\t);\n\t\tif (!verificationResult.success || !Array.isArray(verificationResult.data) || verificationResult.data.length !== entryIds.length) {\n\t\t\tlogger.warn(`${endpoint} - Attempted batch operation on entries outside of tenant`, {\n\t\t\t\tuserId: user._id,\n\t\t\t\ttenantId,\n\t\t\t\trequestedEntryIds: entryIds,\n\t\t\t\tfoundEntries: (verificationResult as { success: true; data: BaseEntity[] }).data.length\n\t\t\t});\n\t\t\tthrow error(403, 'One or more entries do not belong to your tenant or do not exist');\n\t\t}\n\n\t\tconst results: Array<{ entryId: string; success: boolean; error?: string; newId?: string }> = [];\n\t\tlet successCount = 0;\n\n\t\t// Perform the batch operation\n\t\tswitch (action) {\n\t\t\tcase 'delete': {\n\t\t\t\t// Apply modifyRequest for each entry before deletion\n\t\t\t\ttry {\n\t\t\t\t\tawait modifyRequest({\n\t\t\t\t\t\tdata: verificationResult.data as unknown as Array<Record<string, unknown>>,\n\t\t\t\t\t\tfields: schema.fields as unknown as import('@cms-types').FieldInstance[],\n\t\t\t\t\t\tcollection: schema as unknown as CollectionModel,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\ttype: 'DELETE'\n\t\t\t\t\t});\n\t\t\t\t} catch (modifyError) {\n\t\t\t\t\tconst errorMsg = modifyError instanceof Error ? modifyError.message : 'Unknown error';\n\t\t\t\t\tlogger.warn(`${endpoint} - ModifyRequest pre-processing failed`, {\n\t\t\t\t\t\terror: errorMsg\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Perform batch delete\n\t\t\t\tconst deleteResult = await dbAdapter.crud.deleteMany(normalizedCollectionId, query as Partial<Record<string, unknown>>);\n\t\t\t\tif (deleteResult.success) {\n\t\t\t\t\tsuccessCount = entryIds.length;\n\t\t\t\t\tresults.push(...entryIds.map((id) => ({ entryId: id, success: true })));\n\t\t\t\t} else {\n\t\t\t\t\tresults.push(\n\t\t\t\t\t\t...entryIds.map((id) => ({\n\t\t\t\t\t\t\tentryId: id,\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: deleteResult.error.message\n\t\t\t\t\t\t}))\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlogger.info(`${endpoint} - Batch delete completed`, {\n\t\t\t\t\ttotalEntries: entryIds.length,\n\t\t\t\t\tsuccessCount,\n\t\t\t\t\tfailedCount: entryIds.length - successCount\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'status': {\n\t\t\t\tconst updateData = { status, updatedBy: user._id } as Partial<Omit<BaseEntity, 'createdAt' | 'updatedAt'>>;\n\n\t\t\t\tconst updateResult = await dbAdapter.crud.updateMany(\n\t\t\t\t\tnormalizedCollectionId,\n\t\t\t\t\tquery as Partial<Record<string, unknown>>,\n\t\t\t\t\tupdateData as Partial<Omit<BaseEntity, 'createdAt' | 'updatedAt'>>\n\t\t\t\t);\n\t\t\t\tif (updateResult.success) {\n\t\t\t\t\tsuccessCount = entryIds.length;\n\t\t\t\t\tresults.push(...entryIds.map((id) => ({ entryId: id, success: true })));\n\t\t\t\t} else {\n\t\t\t\t\tresults.push(\n\t\t\t\t\t\t...entryIds.map((id) => ({\n\t\t\t\t\t\t\tentryId: id,\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\terror: updateResult.error.message\n\t\t\t\t\t\t}))\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlogger.info(`${endpoint} - Batch status update completed`, {\n\t\t\t\t\tnewStatus: status,\n\t\t\t\t\ttotalEntries: entryIds.length,\n\t\t\t\t\tsuccessCount,\n\t\t\t\t\tfailedCount: entryIds.length - successCount\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'clone': {\n\t\t\t\t// Clone entries - create duplicates with modified titles\n\t\t\t\tconst entriesToClone: Array<Omit<BaseEntity, '_id' | 'createdAt' | 'updatedAt'>> = [];\n\t\t\t\tconst originalIds: string[] = [];\n\n\t\t\t\tfor (const entry of verificationResult.data as BaseEntity[]) {\n\t\t\t\t\tconst entryData = entry as unknown as Record<string, unknown>;\n\t\t\t\t\tconst clonedEntry = {\n\t\t\t\t\t\t...entryData,\n\t\t\t\t\t\t_id: undefined, // Remove ID so a new one is generated\n\t\t\t\t\t\ttitle: `${entryData.title || 'Untitled'} (Copy)`,\n\t\t\t\t\t\tcreatedBy: user._id,\n\t\t\t\t\t\tupdatedBy: user._id,\n\t\t\t\t\t\tcreatedAt: new Date().toISOString(),\n\t\t\t\t\t\tupdatedAt: new Date().toISOString()\n\t\t\t\t\t} as unknown as Omit<BaseEntity, '_id' | 'createdAt' | 'updatedAt'>;\n\n\t\t\t\t\tentriesToClone.push(clonedEntry);\n\t\t\t\t\toriginalIds.push(entry._id);\n\t\t\t\t}\n\n\t\t\t\tif (entriesToClone.length > 0) {\n\t\t\t\t\t// Use optimized insertMany\n\t\t\t\t\tconst insertResult = await dbAdapter.crud.insertMany(normalizedCollectionId, entriesToClone);\n\n\t\t\t\t\tif (insertResult.success) {\n\t\t\t\t\t\tsuccessCount = insertResult.data.length;\n\t\t\t\t\t\t// Map new IDs back to results\n\t\t\t\t\t\tinsertResult.data.forEach((newEntry, index) => {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tentryId: originalIds[index],\n\t\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\t\tnewId: newEntry._id\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to individual errors if batch fails completely (though insertMany usually throws or returns all/nothing depending on impl)\n\t\t\t\t\t\t// Assuming all failed if success is false\n\t\t\t\t\t\tresults.push(\n\t\t\t\t\t\t\t...originalIds.map((id) => ({\n\t\t\t\t\t\t\t\tentryId: id,\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\terror: insertResult.error.message\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlogger.info(`${endpoint} - Batch clone completed`, {\n\t\t\t\t\ttotalEntries: entryIds.length,\n\t\t\t\t\tsuccessCount,\n\t\t\t\t\tfailedCount: entryIds.length - successCount\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst duration = performance.now() - start;\n\n\t\t// Invalidate server-side page cache for this collection after batch operation\n\t\tconst cacheService = (await import('@shared/database/CacheService')).cacheService;\n\t\tconst cachePattern = `collection:${schema._id}:*`;\n\t\tawait cacheService.clearByPattern(cachePattern).catch((err) => {\n\t\t\tlogger.warn('Failed to invalidate page cache after batch operation', { pattern: cachePattern, error: err });\n\t\t});\n\n\t\treturn json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\taction,\n\t\t\t\tresults,\n\t\t\t\tsummary: {\n\t\t\t\t\ttotal: entryIds.length,\n\t\t\t\t\tsuccessful: successCount,\n\t\t\t\t\tfailed: entryIds.length - successCount\n\t\t\t\t}\n\t\t\t},\n\t\t\tperformance: { duration }\n\t\t});\n\t} catch (e) {\n\t\tif (typeof e === 'object' && e !== null && 'status' in e) {\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst duration = performance.now() - start;\n\t\tlogger.error(`${endpoint} - Unexpected error`, {\n\t\t\terror: (e as any).message,\n\t\t\tstack: (e as any).stack,\n\t\t\tduration: `${duration.toFixed(2)}ms`\n\t\t});\n\t\tthrow error(500, 'Internal Server Error');\n\t}\n};\n"],"names":[],"mappings":"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"}