{"version":3,"file":"MediaUpload.js","sources":["../../../../../../shared/components/src/system/inputs/FileInput.svelte","../../../../../../shared/components/src/imageEditor/widgets/transformerConfig.ts","../../../../../../shared/components/src/imageEditor/widgets/Annotate/transformer.ts","../../../../../../shared/components/src/imageEditor/widgets/Annotate/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/Annotate/index.ts","../../../../../../shared/components/src/imageEditor/widgets/Blur/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/Blur/index.ts","../../../../../../shared/components/src/imageEditor/widgets/Crop/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/Crop/index.ts","../../../../../../shared/components/src/imageEditor/widgets/FineTune/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/FineTune/index.ts","../../../../../../shared/components/src/imageEditor/widgets/FocalPoint/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/FocalPoint/index.ts","../../../../../../shared/components/src/imageEditor/widgets/Rotate/Controls.svelte","../../../../../../shared/components/src/imageEditor/widgets/Rotate/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/Rotate/index.ts","../../../../../../shared/components/src/imageEditor/widgets/Watermark/Tool.svelte","../../../../../../shared/components/src/imageEditor/widgets/Watermark/index.ts","../../../../../../shared/components/src/imageEditor/widgets/registry.ts","../../../../src/widgets/core/MediaUpload/widgetData.ts","../../../../src/widgets/core/MediaUpload/MediaUpload.svelte"],"sourcesContent":["<!-- \n@file src/components/system/inputs/FileInput.svelte\n@component\n**FileInput component**\n\n### Props\n- `value`: File | MediaImage | undefined - Currently selected file or media image.\n- `multiple`: boolean - Allow multiple file selection.\n- `show`: boolean - Whether to show the file input area.\n- `className`: string - Additional CSS classes for styling.\n\n### Features\n- File input \n- Multiple file input\n- Drag and drop\n-->\n\n<script lang=\"ts\">\n\timport type { MediaImage } from '@shared/utils/media/mediaModels';\n\timport { twMerge } from 'tailwind-merge';\n\t// Component\n\timport Media from '@cms/components/Media.svelte';\n\n\t// ParaglideJS\n\timport * as m from '@shared/paraglide/messages';\n\n\t// Props\n\tlet { value = $bindable(), multiple = $bindable(false), show = $bindable(true), className = '', onChange } = $props();\n\n\t// Declare reactive state with $state\n\tlet input: HTMLInputElement | null = $state(null);\n\tlet showMedia = $state(false);\n\n\t// Handle media selection\n\tfunction handleMediaSelect(data: MediaImage | MediaImage[]) {\n\t\tshow = false;\n\t\tshowMedia = false;\n\t\t// If multiple support is added later, this logic will need update\n\t\tconst selected = Array.isArray(data) ? data[0] : data;\n\t\tif (selected) {\n\t\t\tvalue = selected;\n\t\t\tonChange?.(selected);\n\t\t}\n\t}\n\n\t// Handle file change\n\tfunction handleFileChange() {\n\t\tif (!input?.files || input.files.length === 0) return;\n\t\tconst file = input.files[0];\n\t\tvalue = file;\n\t\tshow = false;\n\t\tonChange?.(file);\n\t}\n\n\t// Handle file drop\n\tfunction handleDrop(e: DragEvent) {\n\t\te.preventDefault();\n\t\tconst file = e?.dataTransfer?.files[0];\n\t\tif (file) {\n\t\t\tvalue = file;\n\t\t\tonChange?.(file);\n\t\t}\n\t}\n\n\t// Handle drag over\n\tfunction handleDragOver(e: DragEvent) {\n\t\te.preventDefault();\n\t\tconst target = e.target as HTMLElement;\n\t\ttarget.style.borderColor = '#6bdfff';\n\t}\n\n\t// Handle drag leave\n\tfunction handleDragLeave(e: DragEvent) {\n\t\te.preventDefault();\n\t\tconst target = e.target as HTMLElement;\n\t\ttarget.style.removeProperty('border-color');\n\t}\n\n\t// Open file input dialog\n\tfunction openFileInput() {\n\t\tinput?.click();\n\t}\n\n\t// Toggle media selection modal\n\tfunction toggleMedia(showMediaValue: boolean) {\n\t\tshowMedia = showMediaValue;\n\t}\n</script>\n\n{#if show}\n\t<!-- Upload Dropzone -->\n\t<div\n\t\tondrop={handleDrop}\n\t\tondragover={handleDragOver}\n\t\tondragleave={handleDragLeave}\n\t\trole=\"cell\"\n\t\ttabindex=\"0\"\n\t\tclass={twMerge(\n\t\t\t'relative mt-2 flex h-[200px] w-full max-w-full select-none flex-col items-center justify-center gap-4 rounded border-2 border-dashed border-surface-600 bg-surface-200 dark:border-surface-500 dark:bg-surface-700',\n\t\t\tclassName\n\t\t)}\n\t>\n\t\t<div class=\"grid grid-cols-6 items-center p-4\">\n\t\t\t<iconify-icon icon=\"fa6-solid:file-arrow-up\" width=\"40\"></iconify-icon>\n\t\t\t<span class=\"text-white\"> test</span>\n\n\t\t\t<div class=\"col-span-5\">\n\t\t\t\t{#if !show}\n\t\t\t\t\t<p class=\"font-bold\">\n\t\t\t\t\t\t<span class=\"text-tertiary-500 dark:text-primary-500\">{m.widget_ImageUpload_Upload()}</span>\n\t\t\t\t\t\t{m.widget_ImageUpload_Drag()}\n\t\t\t\t\t</p>\n\t\t\t\t{:else}\n\t\t\t\t\t<p class=\"font-bold\">\n\t\t\t\t\t\t<span class=\"text-tertiary-500 dark:text-primary-500\">{m.widget_ImageUpload_Replace()}</span>\n\t\t\t\t\t\t{m.widget_ImageUpload_Drag()}\n\t\t\t\t\t</p>\n\t\t\t\t{/if}\n\t\t\t\t<p class=\"text-sm opacity-75\">{m.widget_ImageUpload_Allowed()}.</p>\n\n\t\t\t\t<div class=\"flex w-full justify-center gap-2\">\n\t\t\t\t\t<button\n\t\t\t\t\t\tonclick={openFileInput}\n\t\t\t\t\t\taria-label={m.widget_ImageUpload_BrowseNew()}\n\t\t\t\t\t\tclass=\"preset-filled-tertiary-500 btn mt-3 dark:preset-filled-primary-500\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{m.widget_ImageUpload_BrowseNew()}\n\t\t\t\t\t</button>\n\n\t\t\t\t\t<button\n\t\t\t\t\t\tonclick={() => toggleMedia(true)}\n\t\t\t\t\t\taria-label={m.widget_ImageUpload_SelectMedia()}\n\t\t\t\t\t\tclass=\"preset-filled-tertiary-500 btn mt-3 dark:preset-filled-primary-500\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{m.widget_ImageUpload_SelectMedia()}\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- File Input -->\n\t\t<input bind:this={input} type=\"file\" accept=\"image/*,image/webp,image/avif,image/svg+xml\" hidden {multiple} onchange={handleFileChange} />\n\t</div>\n\n\t<!-- Show existing Media Images -->\n\t{#if showMedia}\n\t\t<div\n\t\t\tclass=\"bg-surface-100-800-token fixed left-[50%] top-[50%] z-999999999 flex h-[90%] w-[95%] translate-x-[-50%] translate-y-[-50%] flex-col rounded border border-surface-400 p-2\"\n\t\t>\n\t\t\t<div class=\"bg-surface-100-800-token flex items-center justify-between border-b p-2\">\n\t\t\t\t<p class=\"ml-auto font-bold text-black dark:text-primary-500\">\n\t\t\t\t\t{m.widget_ImageUpload_SelectImage()}\n\t\t\t\t</p>\n\t\t\t\t<button onclick={() => toggleMedia(false)} aria-label=\"Close\" class=\"preset-outlined-secondary-500 btn-icon ml-auto\">\n\t\t\t\t\t<iconify-icon icon=\"material-symbols:close\" width=\"24\" class=\"text-tertiary-500 dark:text-primary-500\"></iconify-icon>\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t\t<Media onselect={handleMediaSelect} />\n\t\t</div>\n\t{/if}\n{/if}\n","/**\n * @file src/components/imageEditor/widgets/transformerConfig.ts\n * @description Shared transformer configuration for consistent styling\n *\n * All image editor widgets (Crop, Blur, Annotate, Watermark) should use these\n * shared styles for uniform appearance of resize handles and borders.\n */\nimport Konva from 'konva';\n\n/**\n * Unified transformer configuration\n * - Blue circular handles with white border\n * - Solid blue border around selection\n * - Consistent sizing across all widgets\n */\nexport const TRANSFORMER_STYLE_DEFAULT: Partial<Konva.TransformerConfig> = {\n\t// Handle appearance\n\tanchorFill: '#3b82f6', // Tailwind blue-500\n\tanchorStroke: '#ffffff',\n\tanchorStrokeWidth: 2,\n\tanchorSize: 12,\n\tanchorCornerRadius: 6, // Makes handles circular\n\n\t// Border appearance\n\tborderStroke: '#3b82f6',\n\tborderStrokeWidth: 2,\n\tborderDash: [] // Solid line\n};\n\n/**\n * Specialized style for Crop tool\n */\nexport const TRANSFORMER_STYLE_CROP: Partial<Konva.TransformerConfig> = {\n\t...TRANSFORMER_STYLE_DEFAULT,\n\tanchorFill: '#3b82f6',\n\tanchorStroke: '#ffffff',\n\tanchorSize: 14,\n\tanchorCornerRadius: 7, // Circular\n\tborderStroke: '#ffffff',\n\tborderStrokeWidth: 1.5\n};\n\n/**\n * Specialized style for Redact/Blur tool (White thin borders, blue handles)\n */\nexport const TRANSFORMER_STYLE_REDACT: Partial<Konva.TransformerConfig> = {\n\t...TRANSFORMER_STYLE_DEFAULT,\n\tborderStroke: '#ffffff',\n\tborderStrokeWidth: 1.5,\n\tanchorFill: '#3b82f6',\n\tanchorStroke: '#ffffff',\n\tanchorSize: 12,\n\tanchorCornerRadius: 6\n};\n\n/** Legacy alias to keep compatibility while transitioning */\nexport const TRANSFORMER_STYLE = TRANSFORMER_STYLE_DEFAULT;\n\n/**\n * Style for rule-of-thirds grid\n */\nexport const GRID_STYLE = {\n\tstroke: 'rgba(255, 255, 255, 0.4)',\n\tstrokeWidth: 1,\n\tlistening: false\n};\n\n/**\n * Default transformer behavior options\n */\nexport const TRANSFORMER_DEFAULTS: Partial<Konva.TransformerConfig> = {\n\tkeepRatio: true,\n\trotateEnabled: true,\n\trotationSnaps: [0, 90, 180, 270],\n\trotateAnchorOffset: 40,\n\tenabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],\n\tboundBoxFunc: (oldBox, newBox) => {\n\t\t// Minimum size constraint\n\t\tif (newBox.width < 20 || newBox.height < 20) return oldBox;\n\t\treturn newBox;\n\t}\n};\n\n/**\n * Creates a styled transformer with unified appearance.\n *\n * @param layer - Konva layer to add transformer to\n * @param options - Optional overrides for specific widget needs\n * @returns Configured Konva.Transformer\n *\n * @example\n * ```ts\n * const tr = createStyledTransformer(layer);\n * tr.nodes([myShape]);\n * ```\n */\nexport function createStyledTransformer(layer: Konva.Layer, options?: Partial<Konva.TransformerConfig>): Konva.Transformer {\n\tconst tr = new Konva.Transformer({\n\t\t...TRANSFORMER_STYLE,\n\t\t...TRANSFORMER_DEFAULTS,\n\t\t...options\n\t});\n\tlayer.add(tr);\n\ttr.moveToTop();\n\treturn tr;\n}\n\n/**\n * Safely attaches transformer to a node with error handling.\n *\n * @param tr - Konva transformer instance\n * @param node - Node to attach, or null to detach\n */\nexport function attachStyledTransformer(tr: Konva.Transformer, node?: Konva.Node | null): void {\n\ttry {\n\t\tif (!node) {\n\t\t\ttr.nodes([]);\n\t\t\ttr.hide();\n\t\t\treturn;\n\t\t}\n\t\ttr.nodes([node]);\n\t\ttr.show();\n\t\ttr.forceUpdate();\n\t\ttr.moveToTop();\n\t} catch {\n\t\ttry {\n\t\t\ttr.nodes([]);\n\t\t\ttr.hide();\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t}\n}\n","/**\n * @file src/routes/(app)/imageEditor/widgets/Annotate/transformer.ts\n * @description Transformer utilities for Annotate tool\n *\n * Re-exports shared transformer config for consistent styling across widgets.\n */\nimport Konva from 'konva';\nimport { createStyledTransformer, attachStyledTransformer } from '../transformerConfig';\n\n/**\n * Create a transformer for annotations with consistent styling.\n * Uses more anchors than other tools for flexible annotation resizing.\n */\nexport function createTransformer(layer: Konva.Layer): Konva.Transformer {\n\treturn createStyledTransformer(layer, {\n\t\tkeepRatio: false,\n\t\tenabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'middle-left', 'middle-right']\n\t});\n}\n\n/**\n * Re-export attach function for convenience\n */\nexport const attachTransformer = attachStyledTransformer;\n","<!--\n@file: src/routes/(app)/imageEditor/widgets/Annotate/Tool.svelte\n@component\n**Annotate Tool \"Controller\"**\n\nOrchestrates the annotation lifecycle:\n- Manages the $state list of AnnotationItem instances\n- Handles stage drawing events (mousedown, mousemove, mouseup)\n- Manages the active selection and transformer\n- Registers the toolbar UI\n- Implements the critical 'apply' (bake) logic\n-->\n\n<script lang=\"ts\">\n\timport Konva from 'konva';\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport AnnotateControls from './Controls.svelte';\n\timport { AnnotationItem, type AnnotationKind } from './regions';\n\timport * as draw from './draw';\n\timport { createTransformer, attachTransformer } from './transformer';\n\timport { enableTextEdit } from './editText';\n\timport { names } from './events';\n\n\t// --- Svelte 5 State ---\n\tlet transformer = $state<Konva.Transformer | null>(null);\n\tlet annotations = $state<AnnotationItem[]>([]);\n\tlet selected = $state<AnnotationItem | null>(null);\n\tlet currentTool = $state<AnnotationKind | null>(null);\n\tlet strokeColor = $state('#ff0000');\n\tlet fillColor = $state('transparent');\n\tlet strokeWidth = $state(2);\n\tlet fontSize = $state(20);\n\n\t// Drawing state machine\n\tlet isDrawing = $state(false);\n\tlet tempNode = $state<Konva.Node | null>(null);\n\tlet startPos = $state<{ x: number; y: number } | null>(null);\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\n\t// --- Lifecycle $effect ---\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'annotate') {\n\t\t\tbindTool();\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: AnnotateControls,\n\t\t\t\tprops: {\n\t\t\t\t\tcurrentTool,\n\t\t\t\t\tstrokeColor,\n\t\t\t\t\tfillColor,\n\t\t\t\t\tonSetTool: (t: AnnotationKind | null) => {\n\t\t\t\t\t\tcurrentTool = t;\n\t\t\t\t\t\tdeselect(); // Deselect to allow drawing\n\t\t\t\t\t},\n\t\t\t\t\tonStrokeColorChange: (v: string) => {\n\t\t\t\t\t\tstrokeColor = v;\n\t\t\t\t\t\tselected?.node.setAttrs({ stroke: v });\n\t\t\t\t\t},\n\t\t\t\t\tonFillColorChange: (v: string) => {\n\t\t\t\t\t\tfillColor = v;\n\t\t\t\t\t\tselected?.node.setAttrs({ fill: v });\n\t\t\t\t\t},\n\t\t\t\t\tonDelete: () => deleteSelected(),\n\t\t\t\t\tonApply: () => apply()\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindTool();\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === AnnotateControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// --- Event Binding ---\n\tfunction bindTool() {\n\t\tconst { stage, layer } = imageEditorStore.state;\n\t\tif (!stage || !layer || _toolBound) return;\n\t\t_toolBound = true;\n\n\t\tif (!transformer) {\n\t\t\ttransformer = createTransformer(layer);\n\t\t}\n\t\tstage.on(names('mousedown'), onMouseDown);\n\t\tstage.on(names('mousemove'), onMouseMove);\n\t\tstage.on(names('mouseup'), onMouseUp);\n\t\tstage.on(names('click'), onStageClick);\n\t\tstage.on(names('dblclick'), onDblClick);\n\t\tstage.container().style.cursor = 'crosshair';\n\t}\n\n\tfunction unbindTool() {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage || !_toolBound) return;\n\t\t_toolBound = false;\n\n\t\tstage.off(names('mousedown'));\n\t\tstage.off(names('mousemove'));\n\t\tstage.off(names('mouseup'));\n\t\tstage.off(names('click'));\n\t\tstage.off(names('dblclick'));\n\t\tif (stage.container()) stage.container().style.cursor = 'default';\n\t\tdeselect();\n\t\tcurrentTool = null;\n\t\tisDrawing = false;\n\t\ttempNode = null;\n\t}\n\n\t// --- Drawing Handlers ---\n\tfunction onMouseDown(e: Konva.KonvaEventObject<MouseEvent>) {\n\t\t// Don't draw if clicking on existing node\n\t\tif (e.target !== e.target.getStage()) return;\n\n\t\tconst { stage, layer } = imageEditorStore.state;\n\t\tif (!stage || !layer) return;\n\t\tconst pos = stage.getPointerPosition();\n\t\tif (!pos) return;\n\t\tif (!currentTool) return;\n\n\t\tdeselect();\n\t\tisDrawing = true;\n\t\tstartPos = pos;\n\n\t\tswitch (currentTool) {\n\t\t\tcase 'text': {\n\t\t\t\tconst txt = draw.createText(layer, pos.x, pos.y, 'Text', fontSize, strokeColor);\n\t\t\t\tconst item = finalizeNode(txt, 'text');\n\t\t\t\tselect(item);\n\t\t\t\tisDrawing = false; // Text is one-click\n\t\t\t\tcurrentTool = null; // Exit tool\n\t\t\t\tstartTextEdit(item.node as Konva.Text); // Immediately edit\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rect':\n\t\t\t\ttempNode = draw.createRect(layer, pos.x, pos.y, 0, 0, strokeColor, fillColor, strokeWidth);\n\t\t\t\tbreak;\n\t\t\tcase 'circle':\n\t\t\t\ttempNode = draw.createCircle(layer, pos.x, pos.y, 0, strokeColor, fillColor, strokeWidth);\n\t\t\t\tbreak;\n\t\t\tcase 'line':\n\t\t\t\ttempNode = draw.createLine(layer, [pos.x, pos.y, pos.x, pos.y], strokeColor, strokeWidth);\n\t\t\t\tbreak;\n\t\t\tcase 'arrow':\n\t\t\t\ttempNode = draw.createArrow(layer, [pos.x, pos.y, pos.x, pos.y], strokeColor, strokeWidth);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction onMouseMove() {\n\t\tif (!isDrawing || !tempNode || !startPos) return;\n\t\tconst { stage, layer } = imageEditorStore.state;\n\t\tif (!stage || !layer) return;\n\t\tconst pos = stage.getPointerPosition();\n\t\tif (!pos) return;\n\n\t\tif (tempNode instanceof Konva.Rect) {\n\t\t\ttempNode.width(pos.x - startPos.x);\n\t\t\ttempNode.height(pos.y - startPos.y);\n\t\t} else if (tempNode instanceof Konva.Circle) {\n\t\t\tconst r = Math.hypot(pos.x - startPos.x, pos.y - startPos.y);\n\t\t\ttempNode.radius(r);\n\t\t} else if (tempNode instanceof Konva.Line || tempNode instanceof Konva.Arrow) {\n\t\t\t(tempNode as Konva.Line).points([startPos.x, startPos.y, pos.x, pos.y]);\n\t\t}\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction onMouseUp() {\n\t\tif (!isDrawing || !tempNode || !currentTool) return;\n\t\tisDrawing = false;\n\n\t\t// Finalize node\n\t\tconst item = finalizeNode(tempNode, currentTool);\n\t\tselect(item);\n\n\t\ttempNode = null;\n\t\tcurrentTool = null;\n\t\tstartPos = null;\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\n\tfunction onStageClick(e: Konva.KonvaEventObject<MouseEvent>) {\n\t\tif (isDrawing || currentTool) return;\n\t\t// Deselect if clicking on stage background\n\t\tif (e.target === e.target.getStage()) {\n\t\t\tdeselect();\n\t\t}\n\t}\n\n\tfunction onDblClick(e: Konva.KonvaEventObject<MouseEvent>) {\n\t\tconst node = e.target;\n\t\tif (node instanceof Konva.Text) {\n\t\t\tconst item = annotations.find((a) => a.node === node);\n\t\t\tif (item) {\n\t\t\t\tselect(item);\n\t\t\t\tstartTextEdit(item.node as Konva.Text);\n\t\t\t}\n\t\t}\n\t}\n\n\t// --- Helper Functions ---\n\tfunction finalizeNode(node: Konva.Node, kind: AnnotationKind): AnnotationItem {\n\t\tconst { layer } = imageEditorStore.state;\n\t\tif (!layer) throw new Error('No layer');\n\t\tnode.name(`annotation-${kind}`);\n\t\tnode.draggable(true);\n\t\tconst item = new AnnotationItem(crypto.randomUUID(), node, layer, kind);\n\t\titem.onSelect(() => select(item));\n\t\tannotations = [...annotations, item];\n\t\treturn item;\n\t}\n\n\tfunction startTextEdit(textNode: Konva.Text) {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage) return;\n\t\ttextNode.hide();\n\t\ttransformer?.hide();\n\t\tenableTextEdit(stage, textNode, (newValue) => {\n\t\t\ttextNode.text(newValue);\n\t\t\ttextNode.show();\n\t\t\ttransformer?.show();\n\t\t\ttransformer?.forceUpdate();\n\t\t\timageEditorStore.state.layer?.batchDraw();\n\t\t});\n\t}\n\n\tfunction select(item: AnnotationItem) {\n\t\tselected = item;\n\t\tif (!transformer) return;\n\t\tattachTransformer(transformer, item.node);\n\t}\n\n\tfunction deselect() {\n\t\tselected = null;\n\t\tif (!transformer) return;\n\t\tattachTransformer(transformer, null);\n\t}\n\n\tfunction deleteSelected() {\n\t\tif (!selected) return;\n\t\tconst id = selected.id;\n\t\tselected.destroy();\n\t\tannotations = annotations.filter((a) => a.id !== id);\n\t\tselected = null;\n\t\tdeselect(); // Hides transformer\n\t}\n\n\tfunction cleanupAnnotations(destroy = true) {\n\t\tdeselect();\n\t\tisDrawing = false;\n\t\tcurrentTool = null;\n\t\ttempNode = null;\n\t\tif (destroy) {\n\t\t\t[...annotations].forEach((a) => a.destroy());\n\t\t\tannotations = [];\n\t\t} else {\n\t\t\t// Hide UI for baking\n\t\t\tannotations.forEach((a) => a.disableInteraction());\n\t\t}\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\n\t// --- Tool Actions ---\n\tfunction apply() {\n\t\timageEditorStore.takeSnapshot();\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\t// --- Parent Store API ---\n\texport function cleanup() {\n\t\ttry {\n\t\t\tunbindTool();\n\t\t\tcleanupAnnotations(true);\n\t\t\ttransformer?.destroy();\n\t\t\ttransformer = null;\n\t\t} catch (e) {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\texport function saveState() {}\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n<!-- Controls registered to master toolbar; no DOM toolbar here -->\n","/**\n * @file src/routes/(app)/imageEditor/widgets/Annotate/index.ts\n * @description Annotate tool for Konva\n *\n * Features:\n * - Text\n * - Rectangle\n * - Circle\n * - Line\n * - Arrow\n * - Text editing\n * - Namespacing events to avoid conflicts with other tools\n */\nimport type { Component } from 'svelte';\nimport Tool from './Tool.svelte';\n\nexport default {\n\tkey: 'annotate',\n\ttitle: 'Annotate',\n\ticon: 'mdi:draw',\n\ttool: Tool as unknown as Component<Record<string, unknown>>\n};\n","<!--\n@file: src/routes/(app)/imageEditor/widgets/Blur/Tool.svelte\n@component\nController for Blur tool: binds stage, manages BlurRegion instances,\nhandles drawing, applies/bakes effects, and registers toolbar.\n-->\n<script lang=\"ts\">\n\timport Konva from 'konva';\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport Controls from './Controls.svelte';\n\timport { BlurRegion, type RegionInit, type BlurPattern, type BlurShape } from './regions';\n\n\t// reactive tool state (Svelte 5 runes)\n\tlet blurStrength = $state(20);\n\tlet pattern = $state<BlurPattern>('blur');\n\tlet shape = $state<BlurShape>('rectangle');\n\tlet regions = $state<BlurRegion[]>([]);\n\tlet activeId = $state<string | null>(null);\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\n\tlet { onCancel }: { onCancel: () => void } = $props();\n\n\t// debounce timer for strength slider updates\n\tlet strengthDebounceTimer: number | null = null;\n\n\t// bind/unbind the tool when active state changes\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'blur') {\n\t\t\tbindStageEvents();\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: Controls,\n\t\t\t\tprops: {\n\t\t\t\t\tblurStrength,\n\t\t\t\t\tpattern,\n\t\t\t\t\tshape,\n\t\t\t\t\tonAdd: undefined, // Remove duplicates\n\t\t\t\t\tonDelete: undefined, // Remove duplicates\n\t\t\t\t\tonStrengthChange: (v: number) => {\n\t\t\t\t\t\tblurStrength = v;\n\t\t\t\t\t\tif (strengthDebounceTimer) clearTimeout(strengthDebounceTimer);\n\t\t\t\t\t\tstrengthDebounceTimer = window.setTimeout(() => {\n\t\t\t\t\t\t\t// ALWAYS update activeId if exists, or all regions\n\t\t\t\t\t\t\tif (activeId) {\n\t\t\t\t\t\t\t\tregions.find((r) => r.id === activeId)?.setStrength(v);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tregions.forEach((r) => r.setStrength(v));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\timageEditorStore.state.layer?.batchDraw();\n\t\t\t\t\t\t}, 30); // Fast feedback\n\t\t\t\t\t},\n\t\t\t\t\tonPatternChange: (p: BlurPattern) => {\n\t\t\t\t\t\tpattern = p;\n\t\t\t\t\t\tregions.forEach((r) => r.setPattern(p));\n\t\t\t\t\t},\n\t\t\t\t\tonShapeChange: (s: BlurShape) => {\n\t\t\t\t\t\tshape = s;\n\t\t\t\t\t\t// If there's an active region, change its shape\n\t\t\t\t\t\tif (activeId) {\n\t\t\t\t\t\t\tconst r = regions.find((x) => x.id === activeId);\n\t\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\t\t// Remove old region and create new one with same position but new shape\n\t\t\t\t\t\t\t\tconst oldShape = r.shapeNode;\n\t\t\t\t\t\t\t\tconst bounds = oldShape.getClientRect();\n\t\t\t\t\t\t\t\tdeleteRegion(r.id);\n\t\t\t\t\t\t\t\tcreateRegion({\n\t\t\t\t\t\t\t\t\tx: bounds.x,\n\t\t\t\t\t\t\t\t\ty: bounds.y,\n\t\t\t\t\t\t\t\t\twidth: bounds.width,\n\t\t\t\t\t\t\t\t\theight: bounds.height,\n\t\t\t\t\t\t\t\t\tshape: s\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// NEW: Add, Delete, Rotate, Flip handlers\n\t\t\t\t\tonAddRegion: () => {\n\t\t\t\t\t\tconst stage = imageEditorStore.state.stage;\n\t\t\t\t\t\tconst x = stage ? stage.width() / 2 : 100;\n\t\t\t\t\t\tconst y = stage ? stage.height() / 2 : 100;\n\t\t\t\t\t\tcreateRegion({ x, y });\n\t\t\t\t\t},\n\t\t\t\t\tonDeleteRegion: () => {\n\t\t\t\t\t\tif (activeId) deleteRegion(activeId);\n\t\t\t\t\t},\n\t\t\t\t\tonRotateLeft: () => {\n\t\t\t\t\t\tif (activeId) regions.find((x) => x.id === activeId)?.rotate(-90);\n\t\t\t\t\t},\n\t\t\t\t\tonRotateRight: () => {\n\t\t\t\t\t\tif (activeId) regions.find((x) => x.id === activeId)?.rotate(90);\n\t\t\t\t\t},\n\t\t\t\t\tonFlipHorizontal: () => {\n\t\t\t\t\t\tif (activeId) regions.find((x) => x.id === activeId)?.flipX();\n\t\t\t\t\t},\n\t\t\t\t\tonReset: () => reset(),\n\t\t\t\t\tonCancel: () => onCancel(),\n\t\t\t\t\tonApply: apply\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindStageEvents();\n\t\t\t// only clear toolbar if ours\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === Controls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Auto-initialize first region if empty\n\t$effect(() => {\n\t\tif (_toolBound && regions.length === 0) {\n\t\t\tcreateRegion();\n\t\t}\n\t});\n\n\t// add stage event listeners once\n\tfunction bindStageEvents() {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage || _toolBound) return;\n\t\tstage.on('click tap', handleStageClick);\n\t\tif (stage.container()) stage.container().style.cursor = 'crosshair';\n\t\t_toolBound = true;\n\t}\n\n\t// remove stage event listeners once\n\tfunction unbindStageEvents() {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage || !_toolBound) return;\n\t\tstage.off('click tap', handleStageClick);\n\t\tif (stage.container()) stage.container().style.cursor = 'default';\n\t\t_toolBound = false;\n\t}\n\n\t// deselect all regions when clicking outside overlays\n\tfunction handleStageClick(e: Konva.KonvaEventObject<MouseEvent>) {\n\t\tconst { stage, imageNode, imageGroup } = imageEditorStore.state;\n\t\tconst t = e.target;\n\t\tif (!stage) return;\n\t\t// If clicking on stage, base image, or its group - create a new region\n\t\tif (t === stage || t === imageNode || t === imageGroup) {\n\t\t\tconst pos = stage.getPointerPosition();\n\t\t\tif (pos) {\n\t\t\t\t// Create a new region at click position with default size\n\t\t\t\tcreateRegion({\n\t\t\t\t\tx: pos.x - 100,\n\t\t\t\t\ty: pos.y - 75,\n\t\t\t\t\twidth: 200,\n\t\t\t\t\theight: 150,\n\t\t\t\t\tshape\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// create a new region and wire lifecycle hooks\n\tfunction createRegion(init?: Partial<RegionInit>) {\n\t\tconst { stage, layer, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !layer || !imageNode || !imageGroup) return;\n\n\t\tconst newR = new BlurRegion({\n\t\t\tid: crypto.randomUUID(),\n\t\t\tlayer,\n\t\t\timageNode,\n\t\t\timageGroup,\n\t\t\tinit: { shape, pattern, strength: blurStrength, ...init }\n\t\t});\n\n\t\tregions = [...regions, newR];\n\t\tactiveId = newR.id;\n\n\t\tnewR.onSelect(() => selectRegion(newR.id));\n\t\tnewR.onClone(() => {\n\t\t\tconst bounds = newR.shapeNode.getClientRect();\n\t\t\tcreateRegion({\n\t\t\t\tx: bounds.x + 20,\n\t\t\t\ty: bounds.y + 20,\n\t\t\t\twidth: bounds.width,\n\t\t\t\theight: bounds.height,\n\t\t\t\tshape: newR.shapeNode instanceof Konva.Ellipse ? 'ellipse' : 'rectangle',\n\t\t\t\tpattern: pattern,\n\t\t\t\tstrength: blurStrength\n\t\t\t});\n\t\t});\n\t\tnewR.onDestroy(() => {\n\t\t\tregions = regions.filter((x) => x.id !== newR.id);\n\t\t\tif (activeId === newR.id) activeId = null;\n\t\t});\n\n\t\t// Always finalize and apply effects for click-created regions\n\t\tnewR.setPattern(pattern);\n\t\tnewR.setStrength(blurStrength);\n\t\tnewR.finalize();\n\n\t\t// Make the new region active to show handles\n\t\tselectRegion(newR.id);\n\t}\n\n\t// make specified region active and hide others\n\tfunction selectRegion(id: string) {\n\t\tactiveId = id;\n\t\tregions.forEach((r) => r.setActive(r.id === id));\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\n\t// delete a region instance\n\tfunction deleteRegion(id: string) {\n\t\tconst r = regions.find((x) => x.id === id);\n\t\tr?.destroy();\n\t}\n\n\t// hide or destroy all regions (used before bake and during reset)\n\tfunction cleanupBlurElements(destroyRegions = true) {\n\t\tif (destroyRegions) {\n\t\t\t[...regions].forEach((region) => region.destroy());\n\t\t\tregions = [];\n\t\t} else {\n\t\t\tregions.forEach((region) => region.hideUI());\n\t\t}\n\t\tactiveId = null;\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\n\t// reset tool state and remove regions\n\texport function reset() {\n\t\tcleanupBlurElements(true);\n\t}\n\n\t// Apply blur: bake all blur regions into the image\n\texport function apply() {\n\t\t// Hide UI elements before baking\n\t\tcleanupBlurElements(false);\n\n\t\t// Take snapshot with blur regions visible\n\t\timageEditorStore.takeSnapshot();\n\n\t\t// Clean up and exit\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\t// cleanup invoked by parent store\n\texport function cleanup() {\n\t\ttry {\n\t\t\tunbindStageEvents();\n\t\t\tcleanupBlurElements(true);\n\t\t} catch (e) {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\n\texport function saveState() {\n\t\t/* state captured by parent snapshots */\n\t}\n\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n<!-- Controls registered to master toolbar; no DOM toolbar here -->\n","/**\n * @file src/routes/(app)/imageEditor/widgets/Blur/index.ts\n * @description Blur tool for Konva\n *\n * Features:\n * - Blur\n * - Namespacing events to avoid conflicts with other tools\n */\nimport type { Component } from 'svelte';\nimport Tool from './Tool.svelte';\n\nexport default {\n\tkey: 'blur',\n\ttitle: 'Blur',\n\ticon: 'mdi:blur',\n\ttool: Tool as unknown as Component<Record<string, unknown>>\n};\n","<!--\n@file: src/routes/(app)/imageEditor/widgets/Crop/Tool.svelte\n@component\n**Crop Tool \"Controller\"**\n\nOrchestrates the CropRegion, handles rotations/flips,\nand implements the correct 'apply' logic by setting the\nimageNode's 'crop' properties.\n-->\n<script lang=\"ts\">\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport CropControls from './Controls.svelte';\n\timport CropRegion, { type CropShape } from './regions';\n\timport { showToast } from '@shared/utils/toast';\n\n\tlet cropShape = $state<CropShape>('rectangle');\n\tlet aspectRatio = $state('free');\n\n\t// This is the *only* region. We don't use an array for crop.\n\tlet region = $state<CropRegion | null>(null);\n\n\tconst { onCancel }: { onCancel: () => void } = $props();\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\n\t// bind/unbind the tool when active state changes\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'crop') {\n\t\t\tbindTool();\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: CropControls,\n\t\t\t\tprops: {\n\t\t\t\t\tcropShape,\n\t\t\t\t\tonRotateLeft: rotateLeft,\n\t\t\t\t\tonRotateRight: rotateRight,\n\t\t\t\t\tonFlipHorizontal: flipHorizontal,\n\t\t\t\t\tonCropShapeChange: (s: CropShape) => {\n\t\t\t\t\t\tcropShape = s;\n\t\t\t\t\t\tif (s === 'square' || s === 'circular') {\n\t\t\t\t\t\t\taspectRatio = '1:1';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s === 'circular') {\n\t\t\t\t\t\t\tshowToast('Round Crop selected. Image will be saved with transparency.', 'info');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitDefaultRegion();\n\t\t\t\t\t},\n\t\t\t\t\tonAspectRatio: (r: number | null) => {\n\t\t\t\t\t\taspectRatio = r === null ? 'free' : `${r}`;\n\t\t\t\t\t\tif (r === 1) {\n\t\t\t\t\t\t\tcropShape = cropShape === 'circular' ? 'circular' : 'square';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcropShape = 'rectangle';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitDefaultRegion();\n\t\t\t\t\t},\n\t\t\t\t\tonApply: apply,\n\t\t\t\t\tonCancel: () => onCancel()\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindTool();\n\t\t\t// Only clear controls if they are ours\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === CropControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// add stage event listeners once\n\tfunction bindTool() {\n\t\tif (_toolBound) return;\n\t\t_toolBound = true;\n\t\t// Initialize the crop region when tool is activated\n\t\tinitDefaultRegion();\n\t}\n\n\t// remove stage event listeners once\n\tfunction unbindTool() {\n\t\tif (!_toolBound) return;\n\t\t_toolBound = false;\n\t\tcleanup(); // Destroy region when tool is deactivated\n\t}\n\n\t// create a new region and wire lifecycle hooks\n\tfunction initDefaultRegion() {\n\t\tconst { stage, layer, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !layer || !imageNode || !imageGroup) return;\n\n\t\t// Clean up old region first\n\t\tif (region) {\n\t\t\tregion.destroy();\n\t\t\tregion = null;\n\t\t}\n\n\t\tconst newRegion = new CropRegion({\n\t\t\tid: crypto.randomUUID(),\n\t\t\tlayer,\n\t\t\timageNode,\n\t\t\timageGroup,\n\t\t\tinit: { shape: cropShape as CropShape, aspect: aspectRatio }\n\t\t});\n\n\t\t// Wire event to update cutout on drag/transform\n\t\t// ** FIX 1: This is the 'desync' fix **\n\t\tnewRegion.onTransform(() => {\n\t\t\tnewRegion.updateCutout(false); // fast update, no cache\n\t\t});\n\t\tnewRegion.onTransformEnd(() => {\n\t\t\tnewRegion.updateCutout(true); // slow update, with cache\n\t\t});\n\n\t\tnewRegion.attachTransformer();\n\t\tregion = newRegion;\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction rotateLeft() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\t// Get current rotation and add -90\n\t\tconst currentRotation = imageGroup.rotation();\n\t\tconst newRotation = (currentRotation - 90) % 360;\n\t\timageGroup.rotation(newRotation);\n\n\t\t// We must also re-center the crop region\n\t\tif (region) {\n\t\t\tregion.centerIn(imageGroup.getClientRect());\n\t\t\tregion.updateCutout(true);\n\t\t}\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction flipHorizontal() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\timageGroup.scaleX(imageGroup.scaleX() * -1);\n\n\t\t// We must also re-center the crop region\n\t\tif (region) {\n\t\t\tregion.centerIn(imageGroup.getClientRect());\n\t\t\tregion.updateCutout(true);\n\t\t}\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction rotateRight() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\t// Get current rotation and add +90\n\t\tconst currentRotation = imageGroup.rotation();\n\t\tconst newRotation = (currentRotation + 90) % 360;\n\t\timageGroup.rotation(newRotation);\n\n\t\t// We must also re-center the crop region\n\t\tif (region) {\n\t\t\tregion.centerIn(imageGroup.getClientRect());\n\t\t\tregion.updateCutout(true);\n\t\t}\n\t\tlayer.batchDraw();\n\t}\n\n\t// Apply crop: calculate the crop rect and set it on the imageNode\n\tfunction apply() {\n\t\tconst { imageNode, imageGroup, layer, stage } = imageEditorStore.state;\n\t\tif (!imageNode || !imageGroup || !region || !layer || !stage) return;\n\n\t\t// Import the cropMath utility\n\t\timport('./cropMath').then(({ stageRectToImageRect }) => {\n\t\t\t// Get the crop region's bounding box in stage coordinates\n\t\t\tconst cropRect = region!.shape.getClientRect();\n\n\t\t\t// Convert to image-local coordinates\n\t\t\tconst imageCrop = stageRectToImageRect(cropRect, imageNode, imageGroup);\n\n\t\t\t// Apply crop to the image node\n\t\t\timageNode.cropX(imageCrop.x);\n\t\t\timageNode.cropY(imageCrop.y);\n\t\t\timageNode.cropWidth(imageCrop.width);\n\t\t\timageNode.cropHeight(imageCrop.height);\n\n\t\t\t// Update image dimensions to match crop\n\t\t\timageNode.width(imageCrop.width);\n\t\t\timageNode.height(imageCrop.height);\n\n\t\t\t// Reset image position to center within the group\n\t\t\timageNode.x(-imageCrop.width / 2);\n\t\t\timageNode.y(-imageCrop.height / 2);\n\n\t\t\t// Handle round crop transparency\n\t\t\tif (cropShape === 'circular') {\n\t\t\t\timageNode.cornerRadius(Math.max(imageCrop.width, imageCrop.height));\n\t\t\t} else {\n\t\t\t\timageNode.cornerRadius(0);\n\t\t\t}\n\n\t\t\t// Recalculate scale to fit the cropped image in the viewport\n\t\t\tconst containerWidth = stage.width();\n\t\t\tconst containerHeight = stage.height();\n\t\t\tconst scaleX = (containerWidth * 0.8) / imageCrop.width;\n\t\t\tconst scaleY = (containerHeight * 0.8) / imageCrop.height;\n\t\t\tconst newScale = Math.min(scaleX, scaleY);\n\n\t\t\t// Reset imageGroup transform\n\t\t\timageGroup.scaleX(newScale);\n\t\t\timageGroup.scaleY(newScale);\n\t\t\timageGroup.rotation(0); // Reset rotation\n\t\t\timageGroup.x(containerWidth / 2);\n\t\t\timageGroup.y(containerHeight / 2);\n\n\t\t\t// Hide the crop UI\n\t\t\tregion!.hideUI();\n\n\t\t\t// Redraw and take snapshot\n\t\t\tlayer.batchDraw();\n\t\t\timageEditorStore.takeSnapshot();\n\t\t\timageEditorStore.setActiveState('');\n\t\t});\n\t}\n\n\t// cleanup invoked by parent store\n\texport function cleanup() {\n\t\tif (region) {\n\t\t\tregion.destroy();\n\t\t\tregion = null;\n\t\t}\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\texport function saveState() {\n\t\t/* state captured by parent snapshots */\n\t}\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n\n\t// --- Expose functions for Controls ---\n\t// These are now part of the props passed to setToolbarControls\n</script>\n\n<!-- Controls registered to master toolbar; no DOM toolbar here -->\n","/**\n * @file src/routes/(app)/imageEditor/widgets/Crop/index.ts\n * @description Crop tool for Konva\n *\n * Features:\n * - Crop\n * - Namespacing events to avoid conflicts with other tools\n */\nimport type { Component } from 'svelte';\nimport Tool from './Tool.svelte';\n\nexport default {\n\tkey: 'crop',\n\ttitle: 'Crop',\n\ticon: 'mdi:crop',\n\ttool: Tool as unknown as Component<Record<string, unknown>>\n};\n","<!--\n@file: src/routes/(app)/imageEditor/widgets/FineTune/Tool.svelte\n@component\n**Fine-Tune \"Controller\" Component**\n\nOrchestrates the filter modules:\n- Manages $state for all adjustments.\n- Registers the toolbar UI.\n- Applies filters (base + custom) in a debounced $effect.\n- Handles \"Compare\" logic using Konva's cache.\n- Implements the final 'apply' (bake) logic.\n-->\n\n<script lang=\"ts\">\n\timport Konva from 'konva';\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport FineTuneControls from './Controls.svelte';\n\timport { type Adjustments, DEFAULT_ADJUSTMENTS } from './adjustments';\n\timport { applyBaseFilters } from './baseFilters';\n\timport { createCustomFilter } from './customFilters';\n\n\t// --- Svelte 5 State ---\n\tlet adjustments = $state({ ...DEFAULT_ADJUSTMENTS });\n\tlet activeAdjustment = $state<keyof Adjustments>('brightness');\n\n\tconst adjustments_list = [\n\t\t{ key: 'brightness', label: 'Brightness', icon: 'mdi:brightness-6' },\n\t\t{ key: 'contrast', label: 'Contrast', icon: 'mdi:contrast-box' },\n\t\t{ key: 'saturation', label: 'Saturation', icon: 'mdi:palette' },\n\t\t{ key: 'exposure', label: 'Exposure', icon: 'mdi:brightness-7' },\n\t\t{ key: 'highlights', label: 'Highlights', icon: 'mdi:white-balance-sunny' },\n\t\t{ key: 'shadows', label: 'Shadows', icon: 'mdi:weather-night' },\n\t\t{ key: 'temperature', label: 'Temperature', icon: 'mdi:thermometer' },\n\t\t{ key: 'clarity', label: 'Clarity', icon: 'mdi:crystal-ball' },\n\t\t{ key: 'vibrance', label: 'Vibrance', icon: 'mdi:vibrate' }\n\t];\n\tlet { onCancel }: { onCancel: () => void } = $props();\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\n\t// debounce timer for slider updates\n\tlet filterDebounceTimer: number | null = null;\n\n\t// --- Lifecycle $effect ---\n\t// Binds/unbounds the tool and registers the toolbar\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'finetune') {\n\t\t\tbindTool();\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: FineTuneControls,\n\t\t\t\tprops: {\n\t\t\t\t\tactiveAdjustment: activeAdjustment,\n\t\t\t\t\tactiveIcon: adjustments_list.find((a) => a.key === activeAdjustment)?.icon,\n\t\t\t\t\tvalue: adjustments[activeAdjustment],\n\t\t\t\t\tonChange: (value: number) => {\n\t\t\t\t\t\tadjustments[activeAdjustment] = value;\n\t\t\t\t\t},\n\t\t\t\t\tonAdjustmentChange: (key: keyof Adjustments) => {\n\t\t\t\t\t\tactiveAdjustment = key;\n\t\t\t\t\t},\n\t\t\t\t\tonReset: () => resetAdjustment(),\n\t\t\t\t\tonCancel: () => onCancel(),\n\t\t\t\t\tonApply: () => apply()\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindTool();\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === FineTuneControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// --- Core Filter Logic ---\n\t// This $effect watches for adjustment changes,\n\t// debounces them, and applies the Konva filters.\n\t$effect(() => {\n\t\tif (!_toolBound) return;\n\n\t\t// Force dependency tracking by reading adjustments state here\n\t\tconst currentAdjustments = JSON.parse(JSON.stringify(adjustments));\n\n\t\t// Debounce to prevent thrashing on slider drag\n\t\tif (filterDebounceTimer) clearTimeout(filterDebounceTimer);\n\n\t\tfilterDebounceTimer = window.setTimeout(() => {\n\t\t\tconst { imageNode, layer } = imageEditorStore.state;\n\t\t\tif (!imageNode || !layer) return;\n\n\t\t\t// Log for debugging\n\t\t\tconsole.log('Applying FineTune adjustments:', currentAdjustments);\n\n\t\t\t// 1. Prepare filter list\n\t\t\tconst activeFilters = [];\n\n\t\t\t// Base Konva filters (Brighten, Contrast, HSL for saturation/hue)\n\t\t\tactiveFilters.push(Konva.Filters.Brighten);\n\t\t\tactiveFilters.push(Konva.Filters.Contrast);\n\t\t\tactiveFilters.push(Konva.Filters.HSL);\n\n\t\t\t// 2. Check for slow, custom pixel-looping filters\n\t\t\tconst needsCustom =\n\t\t\t\tadjustments.exposure !== 0 ||\n\t\t\t\tadjustments.highlights !== 0 ||\n\t\t\t\tadjustments.shadows !== 0 ||\n\t\t\t\tadjustments.clarity !== 0 ||\n\t\t\t\tadjustments.temperature !== 0;\n\t\t\tif (needsCustom) {\n\t\t\t\tactiveFilters.push(createCustomFilter(currentAdjustments));\n\t\t\t}\n\n\t\t\t// 3. Set filters on node\n\t\t\timageNode.filters(activeFilters);\n\n\t\t\t// 4. Update the actual properties (brightness, contrast, saturation, hue)\n\t\t\tapplyBaseFilters(imageNode, currentAdjustments);\n\n\t\t\t// 5. Re-cache the node to apply all filters\n\t\t\timageNode.clearCache();\n\t\t\timageNode.cache();\n\t\t\tlayer.batchDraw();\n\t\t}, 100); // 100ms debounce\n\t});\n\n\tfunction bindTool() {\n\t\tif (_toolBound) return;\n\t\t_toolBound = true;\n\t\t// Save the current state (which should be 0s) as the 'reset' point\n\t\tadjustments = { ...DEFAULT_ADJUSTMENTS };\n\t}\n\n\tfunction unbindTool() {\n\t\tif (!_toolBound) return;\n\t\t_toolBound = false;\n\t\tif (filterDebounceTimer) clearTimeout(filterDebounceTimer);\n\t}\n\n\t/**\n\t * Toggles comparison view.\n\t * This is the *most efficient* way:\n\t * - clearCache() reverts to the pre-filter image.\n\t * - cache() re-applies the filters.\n\t */\n\tfunction resetAdjustment() {\n\t\tadjustments[activeAdjustment] = 0;\n\t}\n\n\tfunction apply() {\n\t\timageEditorStore.takeSnapshot();\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\t// --- Parent Store API ---\n\texport function cleanup() {\n\t\ttry {\n\t\t\tunbindTool();\n\t\t} catch (e) {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\texport function saveState() {}\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n<!-- Controls registered to master toolbar; no DOM toolbar here -->\n","/**\n * @file src/routes/(app)/imageEditor/widgets/FineTune/index.ts\n * @description Registers the FineTune tool and its controls.\n *\n * Features:\n * - Registers the FineTune tool and its controls.\n */\nimport type { Component } from 'svelte';\nimport Tool from './Tool.svelte';\n\nexport default {\n\tkey: 'finetune',\n\ttitle: 'Fine-Tune',\n\ticon: 'mdi:tune',\n\ttool: Tool as unknown as Component<Record<string, unknown>>\n};\n","<!--\n@file src/components/imageEditor/widgets/FocalPoint/Tool.svelte\n@component\n**FocalPoint Tool**\n\nAllows users to set the focal point of an image with rule of thirds grid overlay.\n- Displays rule of thirds grid\n- Click to set focal point\n- Shows crosshair at focal point\n- Updates toolbar with X/Y coordinates\n-->\n\n<script lang=\"ts\">\n\timport Konva from 'konva';\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport FocalPointControls from './Controls.svelte';\n\n\t// --- Svelte 5 State ---\n\tlet focalPoint = $state<{ x: number; y: number }>({ x: 0.5, y: 0.5 }); // Normalized 0-1\n\tlet gridLayer = $state<Konva.Layer | null>(null);\n\tlet crosshair = $state<Konva.Group | null>(null);\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\tlet { onCancel }: { onCancel: () => void } = $props();\n\n\t// --- Lifecycle $effect ---\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'focalpoint') {\n\t\t\tbindTool();\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: FocalPointControls,\n\t\t\t\tprops: {\n\t\t\t\t\tfocalX: Math.round(focalPoint.x * 100),\n\t\t\t\t\tfocalY: Math.round(focalPoint.y * 100),\n\t\t\t\t\tonReset: () => resetFocalPoint(),\n\t\t\t\t\tonCancel: () => onCancel(),\n\t\t\t\t\tonApply: () => apply()\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindTool();\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === FocalPointControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// --- Event Binding ---\n\tfunction bindTool() {\n\t\tconst { stage, imageNode } = imageEditorStore.state;\n\t\tif (!stage || !imageNode || _toolBound) return;\n\t\t_toolBound = true;\n\n\t\t// Get existing focal point from metadata\n\t\tconst metadata = (imageNode as any).metadata;\n\t\tif (metadata?.focalPoint) {\n\t\t\tfocalPoint = { ...metadata.focalPoint };\n\t\t}\n\n\t\t// Create grid overlay\n\t\tcreateGridOverlay();\n\t\tcreateCrosshair();\n\n\t\t// Bind click event\n\t\tstage.on('click.focalpoint tap.focalpoint', onStageClick);\n\t\tstage.container().style.cursor = 'crosshair';\n\t}\n\n\tfunction unbindTool() {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage || !_toolBound) return;\n\t\t_toolBound = false;\n\n\t\tstage.off('click.focalpoint tap.focalpoint');\n\t\tif (stage.container()) stage.container().style.cursor = 'default';\n\n\t\t// Remove grid overlay\n\t\tgridLayer?.destroy();\n\t\tgridLayer = null;\n\t\tcrosshair = null;\n\t}\n\n\t// --- Grid Overlay ---\n\tfunction createGridOverlay() {\n\t\tconst { stage, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !imageNode || !imageGroup) return;\n\n\t\t// Create a new layer for the grid (on top of everything)\n\t\tgridLayer = new Konva.Layer();\n\t\tstage.add(gridLayer);\n\t\tgridLayer.moveToTop();\n\n\t\tconst imageWidth = imageNode.width() * imageNode.scaleX();\n\t\tconst imageHeight = imageNode.height() * imageNode.scaleY();\n\t\tconst imageX = imageGroup.x();\n\t\tconst imageY = imageGroup.y();\n\n\t\t// Calculate actual top-left of image (accounting for centering in group)\n\t\tconst originX = imageX - imageWidth / 2;\n\t\tconst originY = imageY - imageHeight / 2;\n\n\t\t// Draw rule of thirds grid\n\t\tconst lineColor = '#00ff00';\n\t\tconst lineWidth = 1;\n\t\tconst opacity = 0.7;\n\n\t\t// Vertical lines\n\t\tfor (let i = 1; i <= 2; i++) {\n\t\t\tconst x = originX + (imageWidth / 3) * i;\n\t\t\tconst line = new Konva.Line({\n\t\t\t\tpoints: [x, originY, x, originY + imageHeight],\n\t\t\t\tstroke: lineColor,\n\t\t\t\tstrokeWidth: lineWidth,\n\t\t\t\topacity: opacity,\n\t\t\t\tlistening: false\n\t\t\t});\n\t\t\tgridLayer.add(line);\n\t\t}\n\n\t\t// Horizontal lines\n\t\tfor (let i = 1; i <= 2; i++) {\n\t\t\tconst y = originY + (imageHeight / 3) * i;\n\t\t\tconst line = new Konva.Line({\n\t\t\t\tpoints: [originX, y, originX + imageWidth, y],\n\t\t\t\tstroke: lineColor,\n\t\t\t\tstrokeWidth: lineWidth,\n\t\t\t\topacity: opacity,\n\t\t\t\tlistening: false\n\t\t\t});\n\t\t\tgridLayer.add(line);\n\t\t}\n\n\t\tgridLayer.batchDraw();\n\t}\n\n\tfunction createCrosshair() {\n\t\tconst { imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!gridLayer || !imageNode || !imageGroup) return;\n\n\t\tconst imageWidth = imageNode.width() * imageNode.scaleX();\n\t\tconst imageHeight = imageNode.height() * imageNode.scaleY();\n\t\tconst imageX = imageGroup.x();\n\t\tconst imageY = imageGroup.y();\n\n\t\t// Calculate actual top-left of image (accounting for centering in group)\n\t\tconst originX = imageX - imageWidth / 2;\n\t\tconst originY = imageY - imageHeight / 2;\n\n\t\t// Calculate crosshair position\n\t\tconst x = originX + imageWidth * focalPoint.x;\n\t\tconst y = originY + imageHeight * focalPoint.y;\n\n\t\t// Create crosshair group\n\t\tcrosshair = new Konva.Group({\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\tlistening: false\n\t\t});\n\n\t\t// Crosshair lines\n\t\tconst size = 20;\n\t\tconst color = '#ff0000';\n\t\tconst width = 2;\n\n\t\tconst hLine = new Konva.Line({\n\t\t\tpoints: [-size, 0, size, 0],\n\t\t\tstroke: color,\n\t\t\tstrokeWidth: width\n\t\t});\n\n\t\tconst vLine = new Konva.Line({\n\t\t\tpoints: [0, -size, 0, size],\n\t\t\tstroke: color,\n\t\t\tstrokeWidth: width\n\t\t});\n\n\t\t// Center circle\n\t\tconst circle = new Konva.Circle({\n\t\t\tradius: 4,\n\t\t\tfill: color,\n\t\t\tstroke: '#ffffff',\n\t\t\tstrokeWidth: 2\n\t\t});\n\n\t\tcrosshair.add(hLine, vLine, circle);\n\t\tgridLayer.add(crosshair);\n\t\tgridLayer.batchDraw();\n\t}\n\n\t// --- Event Handlers ---\n\tfunction onStageClick() {\n\t\tconst { stage, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !imageNode || !imageGroup) return;\n\n\t\tconst pos = stage.getPointerPosition();\n\t\tif (!pos) return;\n\n\t\tconst imageWidth = imageNode.width() * imageNode.scaleX();\n\t\tconst imageHeight = imageNode.height() * imageNode.scaleY();\n\t\tconst originX = imageGroup.x() - imageWidth / 2;\n\t\tconst originY = imageGroup.y() - imageHeight / 2;\n\n\t\t// Check if click is within image bounds\n\t\tif (pos.x < originX || pos.x > originX + imageWidth || pos.y < originY || pos.y > originY + imageHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate normalized focal point (0-1)\n\t\tfocalPoint = {\n\t\t\tx: (pos.x - originX) / imageWidth,\n\t\t\ty: (pos.y - originY) / imageHeight\n\t\t};\n\n\t\t// Update crosshair position\n\t\tupdateCrosshair();\n\n\t\t// Update toolbar (reactive)\n\t\timageEditorStore.setToolbarControls({\n\t\t\tcomponent: FocalPointControls,\n\t\t\tprops: {\n\t\t\t\tfocalX: Math.round(focalPoint.x * 100),\n\t\t\t\tfocalY: Math.round(focalPoint.y * 100),\n\t\t\t\tonReset: () => resetFocalPoint(),\n\t\t\t\tonApply: () => apply()\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction updateCrosshair() {\n\t\tconst { imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!crosshair || !imageNode || !imageGroup) return;\n\n\t\tconst imageWidth = imageNode.width() * imageNode.scaleX();\n\t\tconst imageHeight = imageNode.height() * imageNode.scaleY();\n\t\tconst originX = imageGroup.x() - imageWidth / 2;\n\t\tconst originY = imageGroup.y() - imageHeight / 2;\n\n\t\tconst x = originX + imageWidth * focalPoint.x;\n\t\tconst y = originY + imageHeight * focalPoint.y;\n\n\t\tcrosshair.position({ x, y });\n\t\tgridLayer?.batchDraw();\n\t}\n\n\t// --- Tool Actions ---\n\tfunction resetFocalPoint() {\n\t\tfocalPoint = { x: 0.5, y: 0.5 };\n\t\tupdateCrosshair();\n\t}\n\n\tfunction apply() {\n\t\tconst { imageNode } = imageEditorStore.state;\n\t\tif (!imageNode) return;\n\n\t\t// Save focal point to image metadata\n\t\t(imageNode as any).metadata = {\n\t\t\t...(imageNode as any).metadata,\n\t\t\tfocalPoint: { ...focalPoint }\n\t\t};\n\n\t\timageEditorStore.takeSnapshot();\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\t// --- Parent Store API ---\n\texport function cleanup() {\n\t\ttry {\n\t\t\tunbindTool();\n\t\t} catch (e) {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\n\texport function saveState() {}\n\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n<!-- No UI needed, all controls in toolbar and grid overlay -->\n","/**\n * @file src/components/imageEditor/widgets/FocalPoint/index.ts\n * @description FocalPoint widget registration\n */\n\nimport type { EditorWidget } from '../registry';\nimport Tool from './Tool.svelte';\n\nexport const editorWidget: EditorWidget = {\n\tkey: 'focalpoint',\n\ttitle: 'Focal',\n\ticon: 'mdi:target',\n\n\ttool: Tool as unknown as import('svelte').Component<Record<string, unknown>>,\n\tcontrols: null as unknown as import('svelte').Component<Record<string, unknown>>\n};\n","<!--\n@file: src/components/imageEditor/toolbars/RotateControls.svelte\n@component\nControls for the Rotate tool\n-->\n<script lang=\"ts\">\n\tlet {\n\t\trotationAngle,\n\t\tonRotateLeft,\n\t\tonRotateRight,\n\t\tonRotationChange,\n\t\tonFlipHorizontal,\n\t\tonFlipVertical,\n\t\tonReset,\n\t\tonApply\n\t}: {\n\t\trotationAngle: number;\n\t\tonRotateLeft: () => void;\n\t\tonRotateRight: () => void;\n\t\tonRotationChange: (angle: number) => void;\n\t\tonFlipHorizontal: () => void;\n\t\tonFlipVertical: () => void;\n\t\tonReset: () => void;\n\t\tonApply: () => void;\n\t} = $props();\n\n\tfunction handleAngleInput(e: Event) {\n\t\tconst target = e.currentTarget as HTMLInputElement;\n\t\tonRotationChange(parseInt(target.value, 10));\n\t}\n\n\t// Normalize angle to -180 to 180 for display\n\tconst displayAngle = $derived(() => {\n\t\tlet angle = rotationAngle % 360;\n\t\tif (angle > 180) angle -= 360;\n\t\tif (angle < -180) angle += 360;\n\t\treturn Math.round(angle);\n\t});\n</script>\n\n<div class=\"flex w-full items-center gap-4\">\n\t<span class=\"text-sm font-medium\">Rotate & Flip Image</span>\n\n\t<div class=\"h-6 w-px bg-surface-300 dark:bg-surface-600\"></div>\n\n\t<!-- Rotate Controls -->\n\t<div class=\"flex items-center gap-2\">\n\t\t<span class=\"text-sm\">Rotate:</span>\n\t\t<button class=\"btn btn-icon btn-sm preset-outlined-surface-500\" onclick={onRotateLeft} title=\"Rotate Left 90\">\n\t\t\t<iconify-icon icon=\"mdi:rotate-left\"></iconify-icon>\n\t\t</button>\n\t\t<button class=\"btn btn-icon btn-sm preset-outlined-surface-500\" onclick={onRotateRight} title=\"Rotate Right 90\">\n\t\t\t<iconify-icon icon=\"mdi:rotate-right\"></iconify-icon>\n\t\t</button>\n\t</div>\n\n\t<div class=\"h-6 w-px bg-surface-300 dark:bg-surface-600\"></div>\n\n\t<!-- Fine-tune Angle -->\n\t<label class=\"flex items-center gap-2 text-sm\">\n\t\t<span>Angle:</span>\n\t\t<input type=\"range\" min=\"-180\" max=\"180\" step=\"1\" value={rotationAngle} oninput={handleAngleInput} class=\"range range-primary w-32\" />\n\t\t<span class=\"w-12 text-right\">{displayAngle()}</span>\n\t</label>\n\n\t<div class=\"h-6 w-px bg-surface-300 dark:bg-surface-600\"></div>\n\n\t<!-- Flip Controls -->\n\t<div class=\"flex items-center gap-2\">\n\t\t<span class=\"text-sm\">Flip:</span>\n\t\t<button class=\"btn btn-icon btn-sm preset-outlined-surface-500\" onclick={onFlipHorizontal} title=\"Flip Horizontal\">\n\t\t\t<iconify-icon icon=\"mdi:flip-horizontal\"></iconify-icon>\n\t\t</button>\n\t\t<button class=\"btn btn-icon btn-sm preset-outlined-surface-500\" onclick={onFlipVertical} title=\"Flip Vertical\">\n\t\t\t<iconify-icon icon=\"mdi:flip-vertical\"></iconify-icon>\n\t\t</button>\n\t</div>\n\n\t<div class=\"grow\"></div>\n\n\t<!-- Actions -->\n\t<button onclick={onReset} class=\"btn preset-outlined-surface-500\">\n\t\t<iconify-icon icon=\"mdi:restore\"></iconify-icon>\n\t\t<span>Reset</span>\n\t</button>\n\n\t<button class=\"btn preset-filled-success-500\" onclick={onApply}>\n\t\t<iconify-icon icon=\"mdi:check\"></iconify-icon>\n\t\t<span>Apply</span>\n\t</button>\n</div>\n","<script lang=\"ts\">\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport RotateControls from './Controls.svelte';\n\n\tlet rotationAngle = $state(0);\n\n\t// bind/unbind the tool when active state changes\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'rotate') {\n\t\t\t// Get current rotation when tool activates\n\t\t\tconst { imageGroup } = imageEditorStore.state;\n\t\t\tif (imageGroup) {\n\t\t\t\trotationAngle = imageGroup.rotation();\n\t\t\t}\n\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: RotateControls,\n\t\t\t\tprops: {\n\t\t\t\t\trotationAngle,\n\t\t\t\t\tonRotateLeft: rotateLeft,\n\t\t\t\t\tonRotateRight: rotateRight,\n\t\t\t\t\tonRotationChange: setRotation,\n\t\t\t\t\tonFlipHorizontal: flipHorizontal,\n\t\t\t\t\tonFlipVertical: flipVertical,\n\t\t\t\t\tonReset: reset,\n\t\t\t\t\tonApply: apply\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t// Only clear controls if they are ours\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === RotateControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction rotateLeft() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\tconst currentRotation = imageGroup.rotation();\n\t\tconst newRotation = (currentRotation - 90) % 360;\n\t\timageGroup.rotation(newRotation);\n\t\trotationAngle = newRotation;\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction rotateRight() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\tconst currentRotation = imageGroup.rotation();\n\t\tconst newRotation = (currentRotation + 90) % 360;\n\t\timageGroup.rotation(newRotation);\n\t\trotationAngle = newRotation;\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction setRotation(angle: number) {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\timageGroup.rotation(angle);\n\t\trotationAngle = angle;\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction flipHorizontal() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\timageGroup.scaleX(imageGroup.scaleX() * -1);\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction flipVertical() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\timageGroup.scaleY(imageGroup.scaleY() * -1);\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction reset() {\n\t\tconst { imageGroup, layer } = imageEditorStore.state;\n\t\tif (!imageGroup || !layer) return;\n\n\t\timageGroup.rotation(0);\n\t\timageGroup.scaleX(Math.abs(imageGroup.scaleX()));\n\t\timageGroup.scaleY(Math.abs(imageGroup.scaleY()));\n\t\trotationAngle = 0;\n\t\tlayer.batchDraw();\n\t}\n\n\tfunction apply() {\n\t\timageEditorStore.takeSnapshot();\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\texport function cleanup() {\n\t\t/* no cleanup needed */\n\t}\n\n\texport function saveState() {\n\t\t/* state captured by parent snapshots */\n\t}\n\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n// imageEditor/widgets/Rotate/Tool.svelte /** * @file src/components/imageEditor/widgets/Rotate/Tool.svelte * @component * Rotate tool for rotating\nand flipping images */\n<!-- No UI needed, all controls in toolbar -->\n","/**\n * @file src/components/imageEditor/widgets/Rotate/index.ts\n * @description Rotate widget registration\n */\nimport type { EditorWidget } from '../registry';\nimport Tool from './Tool.svelte';\nimport Controls from './Controls.svelte';\n\nconst widget = {\n\tkey: 'rotate',\n\ttitle: 'Rotate',\n\ticon: 'mdi:rotate-right',\n\ttool: Tool,\n\tcontrols: Controls\n};\n\nexport const editorWidget = widget as unknown as EditorWidget;\n\nexport default editorWidget;\n","<!--\n@file: src/routes/(app)/imageEditor/widgets/Watermark/Tool.svelte\n@component\n**Watermark Tool \"Controller\"**\n\nOrchestrates the watermark lifecycle:\n- Manages the $state list of WatermarkItem instances\n- Handles selection and transformer\n- Registers the toolbar UI\n- Implements the 'apply' (bake) logic\n-->\n\n<script lang=\"ts\">\n\timport Konva from 'konva';\n\timport { getContext } from 'svelte';\n\timport { imageEditorStore } from '@shared/stores/imageEditorStore.svelte';\n\timport WatermarkControls from './Controls.svelte';\n\timport { WatermarkItem } from './regions';\n\timport { createStyledTransformer, attachStyledTransformer } from '../transformerConfig';\n\timport type { WatermarkOptions } from '@shared/utils/media/mediaModels';\n\n\t// --- Svelte 5 State ---\n\tlet watermarks: WatermarkItem[] = $state([]);\n\tlet selected: WatermarkItem | null = $state(null);\n\tlet transformer: Konva.Transformer | null = $state(null);\n\tlet opacity = $state(0.8);\n\tlet fileInput: HTMLInputElement;\n\n\t// guard to avoid duplicate event bindings\n\tlet _toolBound = $state(false);\n\t// guard to prevent loading preset multiple times\n\tlet _presetLoaded = $state(false);\n\n\t// Get watermark preset from parent context (set by ImageEditorModal)\n\tconst getWatermarkPreset = getContext<(() => WatermarkOptions | null) | undefined>('watermarkPreset');\n\n\t// --- Lifecycle $effect ---\n\t// Binds/unbounds the tool and registers the toolbar\n\t$effect(() => {\n\t\tconst activeState = imageEditorStore.state.activeState;\n\t\tif (activeState === 'watermark') {\n\t\t\tbindTool();\n\n\t\t\t// Auto-load preset watermark if available and not already loaded\n\t\t\tconst preset = getWatermarkPreset?.();\n\t\t\tif (preset?.url && watermarks.length === 0 && !_presetLoaded) {\n\t\t\t\t_presetLoaded = true;\n\t\t\t\tloadPresetWatermark(preset);\n\t\t\t}\n\n\t\t\timageEditorStore.setToolbarControls({\n\t\t\t\tcomponent: WatermarkControls,\n\t\t\t\tprops: {\n\t\t\t\t\thasSelection: !!selected,\n\t\t\t\t\tonAddWatermark: () => fileInput?.click(),\n\t\t\t\t\tonDeleteWatermark: () => deleteSelected(),\n\t\t\t\t\tonPositionChange: (position: string) => selected?.snapTo(position),\n\t\t\t\t\tonApply: () => apply()\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tunbindTool();\n\t\t\t_presetLoaded = false; // Reset for next activation\n\t\t\tif (imageEditorStore.state.toolbarControls?.component === WatermarkControls) {\n\t\t\t\timageEditorStore.setToolbarControls(null);\n\t\t\t}\n\t\t}\n\t});\n\n\t// --- Event Binding ---\n\tfunction bindTool() {\n\t\tconst { stage, layer } = imageEditorStore.state;\n\t\tif (!stage || !layer || _toolBound) return;\n\t\t_toolBound = true;\n\n\t\tif (!transformer) {\n\t\t\ttransformer = createStyledTransformer(layer);\n\t\t}\n\t\tstage.on('click.watermark tap.watermark', onStageClick);\n\t\tstage.container().style.cursor = 'default';\n\t}\n\n\tfunction unbindTool() {\n\t\tconst { stage } = imageEditorStore.state;\n\t\tif (!stage || !_toolBound) return;\n\t\t_toolBound = false;\n\n\t\tstage.off('click.watermark tap.watermark');\n\t\tif (stage.container()) stage.container().style.cursor = 'default';\n\t\tdeselect();\n\t}\n\n\t// --- Event Handlers ---\n\tfunction onStageClick(e: Konva.KonvaEventObject<MouseEvent>) {\n\t\t// Deselect if clicking on stage background\n\t\tif (e.target === e.target.getStage()) {\n\t\t\tdeselect();\n\t\t}\n\t}\n\n\t// --- Preset Watermark Loading ---\n\tasync function loadPresetWatermark(preset: WatermarkOptions) {\n\t\tconst { stage, layer, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !layer || !imageNode || !imageGroup) return;\n\n\t\ttry {\n\t\t\t// Fetch the watermark image from the preset URL\n\t\t\tconst response = await fetch(preset.url);\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn('Failed to fetch preset watermark:', preset.url);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst blob = await response.blob();\n\t\t\tconst filename = preset.url.split('/').pop() || 'preset-watermark.png';\n\t\t\tconst file = new File([blob], filename, { type: blob.type || 'image/png' });\n\n\t\t\tconst item = new WatermarkItem({\n\t\t\t\tid: crypto.randomUUID(),\n\t\t\t\tlayer,\n\t\t\t\timageGroup\n\t\t\t});\n\n\t\t\titem.onSelect(() => select(item));\n\t\t\titem.onDestroy(() => {\n\t\t\t\twatermarks = watermarks.filter((w) => w.id !== item.id);\n\t\t\t\tif (selected?.id === item.id) deselect();\n\t\t\t});\n\n\t\t\twatermarks = [...watermarks, item];\n\t\t\tselect(item);\n\n\t\t\t// Load with preset opacity (convert percentage scale to 0-1 if needed)\n\t\t\tconst presetOpacity = typeof preset.scale === 'number' && preset.scale > 1 ? preset.scale / 100 : (preset.scale ?? 0.8);\n\n\t\t\tawait item.loadImage(file, {\n\t\t\t\topacity: presetOpacity,\n\t\t\t\tstageWidth: stage.width(),\n\t\t\t\tstageHeight: stage.height()\n\t\t\t});\n\n\t\t\t// Apply preset position if specified\n\t\t\tif (preset.position) {\n\t\t\t\titem.snapTo(preset.position);\n\t\t\t}\n\n\t\t\tattachStyledTransformer(transformer!, item.node);\n\t\t\tlayer.batchDraw();\n\t\t} catch (err) {\n\t\t\tconsole.error('Failed to load preset watermark', err);\n\t\t}\n\t}\n\n\t// --- Watermark Lifecycle ---\n\tasync function addWatermark(file: File) {\n\t\tconst { stage, layer, imageNode, imageGroup } = imageEditorStore.state;\n\t\tif (!stage || !layer || !imageNode || !imageGroup) return;\n\n\t\tconst item = new WatermarkItem({\n\t\t\tid: crypto.randomUUID(),\n\t\t\tlayer,\n\t\t\timageGroup\n\t\t});\n\n\t\titem.onSelect(() => select(item));\n\t\titem.onDestroy(() => {\n\t\t\twatermarks = watermarks.filter((w) => w.id !== item.id);\n\t\t\tif (selected?.id === item.id) deselect();\n\t\t});\n\n\t\twatermarks = [...watermarks, item];\n\t\tselect(item);\n\n\t\ttry {\n\t\t\t// Asynchronously load the image file\n\t\t\tawait item.loadImage(file, {\n\t\t\t\topacity: opacity,\n\t\t\t\tstageWidth: stage.width(),\n\t\t\t\tstageHeight: stage.height()\n\t\t\t});\n\t\t\t// Attach transformer *after* image is loaded and sized\n\t\t\tattachStyledTransformer(transformer!, item.node);\n\t\t\tlayer.batchDraw();\n\t\t} catch (err) {\n\t\t\tconsole.error('Failed to load watermark image', err);\n\t\t\titem.destroy(); // Clean up if load fails\n\t\t}\n\t}\n\n\tfunction select(item: WatermarkItem) {\n\t\tselected = item;\n\t\tif (!transformer) return;\n\t\tattachStyledTransformer(transformer, item.node);\n\t\t// Update controls to match selected item's opacity\n\t\topacity = item.node.opacity();\n\t}\n\n\tfunction deselect() {\n\t\tselected = null;\n\t\tif (!transformer) return;\n\t\tattachStyledTransformer(transformer, null);\n\t}\n\n\tfunction deleteSelected() {\n\t\tif (!selected) return;\n\t\tselected.destroy();\n\t\t// State update is handled by the 'onDestroy' callback\n\t}\n\n\tfunction cleanupWatermarks(destroy = true) {\n\t\tdeselect();\n\t\tif (destroy) {\n\t\t\t[...watermarks].forEach((w) => w.destroy());\n\t\t\twatermarks = [];\n\t\t} else {\n\t\t\t// Hide UI for baking\n\t\t\twatermarks.forEach((w) => w.disableInteraction());\n\t\t}\n\t\timageEditorStore.state.layer?.batchDraw();\n\t}\n\n\t// --- Tool Actions ---\n\tfunction apply() {\n\t\timageEditorStore.takeSnapshot();\n\t\timageEditorStore.setActiveState('');\n\t}\n\n\tfunction handleFileChange(e: Event) {\n\t\tconst target = e.target as HTMLInputElement;\n\t\tif (target.files && target.files.length > 0) {\n\t\t\taddWatermark(target.files[0]);\n\t\t}\n\t\t// Reset input so the same file can be chosen again\n\t\ttarget.value = '';\n\t}\n\n\t// --- Parent Store API ---\n\texport function cleanup() {\n\t\ttry {\n\t\t\tunbindTool();\n\t\t\tcleanupWatermarks(true);\n\t\t\ttransformer?.destroy();\n\t\t\ttransformer = null;\n\t\t} catch (e) {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\texport function saveState() {}\n\texport function beforeExit() {\n\t\tcleanup();\n\t}\n</script>\n\n<input type=\"file\" accept=\"image/png, image/svg+xml\" class=\"hidden\" bind:this={fileInput} onchange={handleFileChange} />\n\n<!-- Controls registered to master toolbar; no DOM toolbar here -->\n","/**\n * @file src/routes/(app)/imageEditor/widgets/Watermark/index.ts\n * @description Registers the Watermark tool and its controls.\n *\n * Features:\n * - Registers the Watermark tool and its controls.\n */\nimport type { Component } from 'svelte';\nimport Tool from './Tool.svelte';\n\nexport default {\n\tkey: 'watermark',\n\ttitle: 'Watermark',\n\ticon: 'mdi:copyright',\n\ttool: Tool as unknown as Component<Record<string, unknown>>\n};\n","/**\n * @file src/routes/(app)/imageEditor/widgets/registry.ts\n * @description Dynamic widgets registry using import.meta.glob for discoverability\n *\n * Features:\n * - Dynamic widgets registry using import.meta.glob for discoverability\n */\nimport type { Component } from 'svelte';\n\nexport interface EditorWidget {\n\tkey: string;\n\ttitle: string;\n\ticon?: string;\n\ttool: Component<Record<string, unknown>>;\n\tcontrols?: Component<Record<string, unknown>>; // Optional: widgets register controls dynamically via imageEditorStore\n}\n\n// Load all widgets declared under ./<Widget>/index.ts (PascalCase folders only)\nconst modules = import.meta.glob('./[A-Z]*/index.ts', { eager: true }) as Record<string, unknown>;\n\nexport const editorWidgets: EditorWidget[] = Object.values(modules)\n\t.map((m) => {\n\t\tconst mod = m as { default?: EditorWidget; editorWidget?: EditorWidget };\n\t\treturn mod.default ?? mod.editorWidget;\n\t})\n\t.filter((w): w is EditorWidget => !!w);\n","import type { MediaImage } from '@shared/utils/media/mediaModels';\nimport { mode } from '@shared/stores/collectionStore.svelte';\nimport { meta_data } from '@shared/utils/utils';\n\nexport const getWidgetData = async (\n\t_data: File | MediaImage | undefined,\n\tfield: any,\n\tvalue: any\n): Promise<File | MediaImage | { _id: string | undefined } | undefined> => {\n\tif (_data && _data instanceof File) {\n\t\t(_data as any).path = field.path;\n\t}\n\n\tif (value && !(value instanceof File) && _data && !(_data instanceof File) && _data?._id !== value?._id && value?._id && mode.value === 'edit') {\n\t\tmeta_data.add('media_images_remove', [value._id.toString()]);\n\t}\n\n\t// Assuming validateInput is defined in MediaUpload.svelte and needs to be called there\n\t// This function only returns the data, not handles validation directly\n\n\treturn _data || mode.value === 'create' ? _data : { _id: (value as MediaImage)?._id };\n};\n","<!--\n@file src/widgets/core/MediaUpload/MediaUpload.svelte\n@component\n**Media Upload Widget Component**\n\nThis component allows users to upload and manage single media files (images).\nIt integrates with a media library modal for selecting existing assets and provides\nfunctionality for image editing and basic file information display.\n\n### Props\n- `field`: FieldType & { path: string } - Configuration for the media upload field, including validation rules and storage path.\n- `value`: File | MediaImage - The currently selected file or media image object.\n\n### Features\n- **File Upload**: Allows direct file uploads via a file input.\n- **Media Library Integration**: Opens a modal to select existing media from the library.\n- **Image Preview**: Displays a preview of the selected image.\n- **Image Editing**: Provides an option to open a modal for image manipulation.\n- **File Information Display**: Shows details like file name, size, type, and timestamps.\n- **Validation**: Integrates with Valibot for client-side validation of file types.\n- **Reactivity**: Uses Svelte 5 runes (`$state`, `$props`, `$effect`) for efficient state management.\n- **Styling**: Adheres to the project's style guide using Tailwind CSS utility classes and semantic colors.\n-->\n<script lang=\"ts\">\n\timport type { ISODateString } from '@cms-types';\n\timport { convertTimestampToDateString, getFieldName } from '@shared/utils/utils';\n\timport { isoDateStringToDate } from '@shared/utils/dateUtils';\n\timport { logger } from '@shared/utils/logger';\n\n\t// ParaglideJS\n\timport * as m from '@shared/paraglide/messages';\n\n\t// Stores\n\timport { validationStore } from '@shared/stores/store.svelte';\n\timport { collectionValue } from '@shared/stores/collectionStore.svelte';\n\n\t// Components\n\timport type { MediaImage, WatermarkOptions } from '@shared/utils/media/mediaModels';\n\timport FileInput from '@cms/components/system/inputs/FileInput.svelte';\n\timport ImageEditorModal from '@cms/components/imageEditor/ImageEditorModal.svelte';\n\timport { updateMediaMetadata } from '@shared/utils/media/api';\n\n\t// Define reactive state\n\tlet isFlipped = $state(false);\n\n\tlet validationError: string | null = $state(null);\n\tlet debounceTimeout: number | undefined;\n\tlet showEditor = $state(false);\n\n\t// Define props\n\tlet { field, value = $bindable<File | MediaImage | undefined>() } = $props(); // 'value' is the bindable prop\n\n\t// Extract watermark preset from field configuration\n\tconst watermarkPreset = $derived((field as any).watermark as WatermarkOptions | undefined);\n\n\t// Effect to initialize 'value' if it's undefined and a default is available\n\t// This runs after the component has initialized and 'value' would have received its initial binding\n\t$effect(() => {\n\t\tif (value === undefined && (collectionValue.value as any)[getFieldName(field)] !== undefined) {\n\t\t\tvalue = (collectionValue.value as any)[getFieldName(field)];\n\t\t}\n\t});\n\n\t// Define validation schema\n\timport { object, string, number, union, instance, check, pipe, record, parse, type ValiError } from 'valibot';\n\n\tconst validImageTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/svg+xml'];\n\n\tconst fileSchema = pipe(\n\t\tinstance(File),\n\t\tcheck((input: File) => validImageTypes.includes(input.type), 'Invalid file format')\n\t);\n\n\tconst thumbnailSchema = object({\n\t\twidth: number(),\n\t\theight: number(),\n\t\turl: string()\n\t});\n\n\tconst mediaImageSchema = object({\n\t\t_id: string(),\n\t\tname: string(),\n\t\ttype: string(),\n\t\tsize: number(),\n\t\tpath: string(),\n\t\tthumbnails: record(string(), thumbnailSchema),\n\t\tcreatedAt: number(),\n\t\tupdatedAt: number()\n\t});\n\n\tconst widgetSchema = union([fileSchema, mediaImageSchema]);\n\n\t// Validation function\n\tfunction validateSchema(data: unknown): string | null {\n\t\ttry {\n\t\t\tparse(widgetSchema, data);\n\t\t\tvalidationStore.clearError(getFieldName(field));\n\t\t\treturn null;\n\t\t} catch (error) {\n\t\t\tif ((error as ValiError<any>).issues) {\n\t\t\t\tconst valiError = error as ValiError<any>;\n\t\t\t\tconst errorMessage = valiError.issues[0]?.message || 'Invalid input';\n\t\t\t\tvalidationStore.setError(getFieldName(field), errorMessage);\n\t\t\t\treturn errorMessage;\n\t\t\t}\n\t\t\treturn 'Invalid input';\n\t\t}\n\t}\n\n\t// Validate input with debounce\n\tfunction validateInput() {\n\t\tif (debounceTimeout) clearTimeout(debounceTimeout);\n\t\tdebounceTimeout = window.setTimeout(() => {\n\t\t\tvalidationError = validateSchema(value);\n\t\t}, 300);\n\t}\n\n\tasync function handleEditorSave(detail: { dataURL: string; file: File }) {\n\t\tconst { file: editedFile } = detail;\n\t\t// Create form data for the API request\n\t\tconst formData = new FormData();\n\t\tformData.append('processType', 'save');\n\t\tformData.append('files', editedFile);\n\n\t\t// Pass watermark options from field config if configured\n\t\tif (watermarkPreset) {\n\t\t\tformData.append('watermarkOptions', JSON.stringify(watermarkPreset));\n\t\t}\n\n\t\ttry {\n\t\t\t// Send to media API\n\t\t\tconst saveResponse = await fetch('/api/media/process', {\n\t\t\t\tmethod: 'POST',\n\t\t\t\tbody: formData\n\t\t\t});\n\n\t\t\tif (!saveResponse.ok) {\n\t\t\t\tconst errorData = await saveResponse.json();\n\t\t\t\tthrow new Error(errorData.error || 'Failed to save edited image');\n\t\t\t}\n\n\t\t\tconst result = await saveResponse.json();\n\t\t\tif (!result.success || !result.data.data[0]?.success) {\n\t\t\t\tthrow new Error(result.data.data[0]?.error || 'Failed to process edited image');\n\t\t\t}\n\n\t\t\t// Update the widget data with the new persisted image data\n\t\t\tvalue = result.data.data[0].data; // Assign directly to the bindable prop\n\t\t\tshowEditor = false;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error saving edited image:', error);\n\t\t}\n\t}\n\n\tlet focalPoint = $state({ x: 50, y: 50 });\n\tlet isDraggingFocalPoint = $state(false);\n\tlet containerRef: HTMLDivElement | undefined = $state(undefined); // Changed to $state\n\n\t// Global event handlers\n\tfunction handleGlobalMouseMove(event: MouseEvent) {\n\t\tif (isDraggingFocalPoint && containerRef) {\n\t\t\thandleFocalPointDrag(event, containerRef);\n\t\t}\n\t}\n\n\tfunction handleGlobalMouseUp() {\n\t\tif (isDraggingFocalPoint) {\n\t\t\tsaveFocalPoint();\n\t\t}\n\t}\n\n\t$effect(() => {\n\t\tif (value && !(value instanceof File) && value.metadata?.focalPoint) {\n\t\t\tfocalPoint = value.metadata.focalPoint;\n\t\t} else {\n\t\t\tfocalPoint = { x: 50, y: 50 };\n\t\t}\n\t});\n\n\t// Effect to attach/detach global listeners\n\t$effect(() => {\n\t\tif (isDraggingFocalPoint) {\n\t\t\twindow.addEventListener('mousemove', handleGlobalMouseMove);\n\t\t\twindow.addEventListener('mouseup', handleGlobalMouseUp);\n\t\t} else {\n\t\t\twindow.removeEventListener('mousemove', handleGlobalMouseMove);\n\t\t\twindow.removeEventListener('mouseup', handleGlobalMouseUp);\n\t\t}\n\n\t\t// Cleanup on component destroy\n\t\treturn () => {\n\t\t\twindow.removeEventListener('mousemove', handleGlobalMouseMove);\n\t\t\twindow.removeEventListener('mouseup', handleGlobalMouseUp);\n\t\t};\n\t});\n\n\tfunction handleFocalPointDrag(event: MouseEvent, container: HTMLDivElement) {\n\t\tif (!isDraggingFocalPoint) return;\n\t\tconst rect = container.getBoundingClientRect();\n\t\tlet x = ((event.clientX - rect.left) / rect.width) * 100;\n\t\tlet y = ((event.clientY - rect.top) / rect.height) * 100;\n\n\t\t// Clamp values between 0 and 100\n\t\tfocalPoint.x = Math.max(0, Math.min(100, x));\n\t\tfocalPoint.y = Math.max(0, Math.min(100, y));\n\t}\n\n\tasync function saveFocalPoint() {\n\t\tisDraggingFocalPoint = false;\n\t\tif (value && !(value instanceof File) && value._id) {\n\t\t\ttry {\n\t\t\t\tawait updateMediaMetadata(value._id, { focalPoint });\n\t\t\t\t// Optionally show a success toast\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error('Failed to save focal point', e);\n\t\t\t\t// Optionally show an error toast\n\t\t\t}\n\t\t}\n\t}\n\n\timport { getWidgetData } from './widgetData';\n\n\t// The `WidgetData` function needs to be explicitly defined or called when needed.\n\texport async function WidgetDataExport() {\n\t\treturn getWidgetData(value, field, value);\n\t}\n\n\t// Helper function to get timestamp\n\tfunction getTimestamp(date: Date | number | ISODateString): number {\n\t\tif (typeof date === 'number') return date;\n\t\tif (typeof date === 'string') return isoDateStringToDate(date as ISODateString).getTime();\n\t\treturn date.getTime();\n\t}\n</script>\n\n<div class=\"relative mb-4 min-h-1\">\n\t{#if !value}\n\t\t<!-- File Input -->\n\t\t<div class=\"rounded-lg border-2 border-dashed border-transparent\" class:!border-error-500={!!validationError}>\n\t\t\t<FileInput bind:value bind:multiple={field.multiupload} onChange={validateInput} />\n\t\t</div>\n\t{:else}\n\t\t<div\n\t\t\tclass=\"flex w-full max-w-full flex-col border-2 border-dashed border-surface-600 bg-surface-200 dark:border-surface-500 dark:bg-surface-700\"\n\t\t\tclass:error={!!validationError}\n\t\t>\n\t\t\t<!-- Preview -->\n\t\t\t<div class=\"mx-2 flex flex-col gap-2\">\n\t\t\t\t<!-- Image Header -->\n\t\t\t\t<div class=\"flex items-center justify-between gap-2\">\n\t\t\t\t\t<p class=\"text-left\">\n\t\t\t\t\t\t{m.widget_ImageUpload_Name()}\n\t\t\t\t\t\t<span class=\"text-tertiary-500 dark:text-primary-500\">{value instanceof File ? value.name : (value as MediaImage).path}</span>\n\t\t\t\t\t</p>\n\n\t\t\t\t\t<p class=\"text-left\">\n\t\t\t\t\t\t{m.widget_ImageUpload_Size()}\n\t\t\t\t\t\t<span class=\"text-tertiary-500 dark:text-primary-500\">{((value.size ?? 0) / 1024).toFixed(2)} KB</span>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t\t<!-- Image and Actions Container -->\n\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t{#if !isFlipped}\n\t\t\t\t\t\t<div class=\"relative col-span-11 m-auto\" bind:this={containerRef}>\n\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\tsrc={value instanceof File ? URL.createObjectURL(value) : value.thumbnails?.sm?.url || value.url}\n\t\t\t\t\t\t\t\talt=\"Preview\"\n\t\t\t\t\t\t\t\tclass=\"max-h-[200px] max-w-[500px] rounded\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{#if value && !(value instanceof File)}\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclass=\"absolute cursor-move\"\n\t\t\t\t\t\t\t\t\tstyle={`left: ${focalPoint.x}%; top: ${focalPoint.y}%; transform: translate(-50%, -50%);`}\n\t\t\t\t\t\t\t\t\tonmousedown={() => (isDraggingFocalPoint = true)}\n\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t\t\taria-label=\"Set focal point\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<iconify-icon icon=\"mdi:plus-circle-outline\" width=\"24\" class=\"text-primary-500 drop-shadow-lg\"></iconify-icon>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{:else}\n\t\t\t\t\t\t<div class=\"col-span-11 ml-2 grid grid-cols-2 gap-1 text-left\">\n\t\t\t\t\t\t\t<p class=\"\">{m.widget_ImageUpload_Type()}</p>\n\t\t\t\t\t\t\t<p class=\"font-bold text-tertiary-500 dark:text-primary-500\">{(value as any).type}</p>\n\t\t\t\t\t\t\t<p class=\"\">Path:</p>\n\t\t\t\t\t\t\t<p class=\"font-bold text-tertiary-500 dark:text-primary-500\">{(value as any).path}</p>\n\t\t\t\t\t\t\t<p class=\"\">{m.widget_ImageUpload_Uploaded()}</p>\n\t\t\t\t\t\t\t<p class=\"font-bold text-tertiary-500 dark:text-primary-500\">\n\t\t\t\t\t\t\t\t{convertTimestampToDateString(getTimestamp((value as any) instanceof File ? (value as any).lastModified : (value as any).createdAt))}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p class=\"\">{m.widget_ImageUpload_LastModified()}</p>\n\t\t\t\t\t\t\t<p class=\"font-bold text-tertiary-500 dark:text-primary-500\">\n\t\t\t\t\t\t\t\t{convertTimestampToDateString(getTimestamp((value as any) instanceof File ? (value as any).lastModified : (value as any).updatedAt))}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\n\t\t\t\t\t<!-- Buttons -->\n\t\t\t\t\t<div class=\"col-span-1 flex flex-col items-end justify-between gap-2 p-2\">\n\t\t\t\t\t\t<!-- Edit -->\n\t\t\t\t\t\t<button onclick={() => (showEditor = true)} aria-label=\"Edit image\" class=\"preset-outlined-surface-500 btn-icon\" title=\"Edit image\">\n\t\t\t\t\t\t\t<iconify-icon icon=\"material-symbols:edit\" width=\"24\" class=\"text-primary-500\"></iconify-icon>\n\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t<!-- Flip -->\n\t\t\t\t\t\t<button onclick={() => (isFlipped = !isFlipped)} aria-label=\"Flip\" class=\"preset-outlined-surface-500 btn-icon\" title=\"Flip details\">\n\t\t\t\t\t\t\t<iconify-icon\n\t\t\t\t\t\t\t\ticon=\"uiw:reload\"\n\t\t\t\t\t\t\t\twidth=\"24\"\n\t\t\t\t\t\t\t\tclass={isFlipped ? ' rotate-90 text-yellow-500 transition-transform duration-300' : 'text-white  transition-transform duration-300'}\n\t\t\t\t\t\t\t></iconify-icon>\n\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t<!-- Delete -->\n\t\t\t\t\t\t<button onclick={() => (value = undefined)} aria-label=\"Delete\" class=\"preset-outlined-surface-500 btn-icon\" title=\"Delete image\">\n\t\t\t\t\t\t\t<iconify-icon icon=\"material-symbols:delete-outline\" width=\"30\" class=\"text-error-500\"></iconify-icon>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t{/if}\n\n\t<!-- Error Message -->\n\t{#if validationError}\n\t\t<p id={`${getFieldName(field)}-error`} class=\"absolute -bottom-4 left-0 w-full text-center text-xs text-error-500\" role=\"alert\">\n\t\t\t{validationError}\n\t\t</p>\n\t{/if}\n\n\t<!-- Editor Modal -->\n\t{#if showEditor}\n\t\t<ImageEditorModal image={value instanceof File ? null : value} {watermarkPreset} onsave={handleEditorSave} close={() => (showEditor = false)} />\n\t{/if}\n</div>\n"],"names":["$$renderer","$.escape","m.widget_ImageUpload_Upload","m.widget_ImageUpload_Drag","m.widget_ImageUpload_Replace","m.widget_ImageUpload_Allowed","$.attr","m.widget_ImageUpload_BrowseNew","m.widget_ImageUpload_SelectMedia","Tool","editorWidget","$.attr_class","m.widget_ImageUpload_Name","m.widget_ImageUpload_Size","$.attr_style"],"mappings":"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"}