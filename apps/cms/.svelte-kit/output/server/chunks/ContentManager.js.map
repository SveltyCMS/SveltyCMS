{"version":3,"file":"ContentManager.js","sources":["../../../../src/content/ContentManager.ts"],"sourcesContent":["/**\n * @file src/content/ContentManager.ts\n * @description Content management system core.\n *\n * Features:\n * - Singleton pattern for global access\n * - Lazy initialization with race condition handling\n * - In-memory caching with distributed cache (Redis) support\n * - Robust reconciliation between filesystem and database\n * - Optimized first collection retrieval with intelligent caching\n * - Comprehensive content structure retrieval (flat and nested)\n * - Bulk content node operations with database sync\n * - Detailed logging for monitoring and debugging\n * - TypeScript types for strong typing and IDE support\n\n */\n\nimport type { ContentNode, Schema, ContentNodeOperation, DatabaseId, IContentManager } from '@cms-types';\nimport { logger } from '@shared/utils/logger.server'; // Server-only file\nimport { dateToISODateString } from '@shared/utils/dateUtils';\nimport { v4 as uuidv4 } from 'uuid';\n// Removed static import to prevent circular dependency with WidgetRegistryService\n// import { generateCategoryNodesFromPaths, processModule } from './utils';\nimport { CacheCategory } from '@shared/database/CacheCategory'; // ‚úÖ Safe for client - no Redis imports\n\n// ‚úÖ Server-only imports - lazy loaded to prevent client-side bundling\nconst getCacheService = async () => (await import('@shared/database/CacheService')).cacheService;\nconst getRedisTTL = async () => (await import('@shared/database/CacheService')).REDIS_TTL_S;\nconst invalidateCategoryCache = async (\n\t...args: Parameters<typeof import('@shared/database/mongodb/methods/mongoDBCacheUtils').invalidateCategoryCache>\n) => (await import('@shared/database/mongodb/methods/mongoDBCacheUtils')).invalidateCategoryCache(...args);\nconst normalizeId = (id: string) => id.replace(/-/g, ''); // Inline function to avoid import\n\n// --- Server-Side Dynamic Imports ---\nconst getFs = async () => (await import('node:fs/promises')).default;\nconst getDbAdapter = async () => (await import('@shared/database/db')).dbAdapter;\n\nexport interface NavigationNode {\n\t_id: string;\n\tname: string;\n\tpath?: string;\n\ticon?: string;\n\tnodeType: 'category' | 'collection';\n\torder?: number;\n\tstatus?: string;\n\tlastModified?: Date;\n\tparentId?: string;\n\ttranslations?: { languageTag: string; translationName: string }[];\n\tchildren?: NavigationNode[];\n\thasChildren?: boolean;\n}\n\n/**\n * Singleton class that manages the entire content lifecycle.\n *\n * Responsibilities:\n * - Initialization and loading of content from filesystem and database.\n * - maintaining the single source of truth for content structure.\n * - Handling content updates and synchronization.\n * - Providing reactive content versioning for client-side polling.\n */\nclass ContentManager implements IContentManager {\n\tprivate static instance: ContentManager;\n\n\t// State for robust initialization, preventing race conditions\n\tprivate initState: 'uninitialized' | 'initializing' | 'initialized' | 'error' = 'uninitialized';\n\tprivate initPromise: Promise<void> | null = null;\n\n\t// --- Unified Data Structures (Single Source of Truth) ---\n\t/** Primary map holding the complete state. Key is the node's _id. */\n\tprivate contentNodeMap: Map<string, ContentNode> = new Map();\n\t/** Optimized lookup map to quickly find a node's ID by its path. */\n\tprivate pathLookupMap: Map<string, string> = new Map();\n\t/**\n\t * Version timestamp for reactive updates.\n\t * Incremented whenever content structure changes.\n\t * Clients poll this version to trigger updates.\n\t */\n\tprivate contentVersion: number = Date.now();\n\n\t// --- first collection caching for instant access ---\n\tprivate firstCollectionCache: {\n\t\tcollection: Schema | null;\n\t\ttimestamp: number;\n\t\ttenantId?: string;\n\t} | null = null;\n\tprivate readonly FIRST_COLLECTION_CACHE_TTL = 60 * 1000; // 60 seconds\n\tprivate collectionCache = new Map<string, { schema: Schema | null; timestamp: number }>();\n\tprivate readonly COLLECTION_CACHE_TTL = 20 * 1000; // 20 seconds\n\n\tprivate metrics = {\n\t\tinitializationTime: 0,\n\t\tcacheHits: 0,\n\t\tcacheMisses: 0,\n\t\tlastRefresh: 0,\n\t\toperationCounts: {\n\t\t\tcreate: 0,\n\t\t\tupdate: 0,\n\t\t\tdelete: 0,\n\t\t\tmove: 0\n\t\t}\n\t};\n\n\tprivate collectionDependencies = new Map<string, Set<string>>();\n\tprivate snapshots: Map<\n\t\tstring,\n\t\t{\n\t\t\tnodes: Map<string, ContentNode>;\n\t\t\tpaths: Map<string, string>;\n\t\t\ttimestamp: number;\n\t\t}\n\t> = new Map();\n\tprivate performanceMetrics = {\n\t\toperations: new Map<string, { count: number; totalTime: number; avgTime: number }>()\n\t};\n\n\tprivate constructor() {}\n\n\tpublic static getInstance(): ContentManager {\n\t\tif (!ContentManager.instance) {\n\t\t\tContentManager.instance = new ContentManager();\n\t\t}\n\t\treturn ContentManager.instance;\n\t}\n\n\t/**\n\t * Health check for monitoring systems\n\t */\n\tpublic getHealthStatus(): {\n\t\tstate: string;\n\t\tnodeCount: number;\n\t\tcollectionCount: number;\n\t\tcacheAge: number | null;\n\t\tversion: number;\n\t} {\n\t\tconst collections = Array.from(this.contentNodeMap.values()).filter((node) => node.nodeType === 'collection');\n\n\t\tconst cacheAge = this.firstCollectionCache ? Date.now() - this.firstCollectionCache.timestamp : null;\n\n\t\treturn {\n\t\t\tstate: this.initState,\n\t\t\tnodeCount: this.contentNodeMap.size,\n\t\t\tcollectionCount: collections.length,\n\t\t\tcacheAge,\n\t\t\tversion: this.contentVersion\n\t\t};\n\t}\n\n\tpublic getDiagnostics(): {\n\t\tmaps: {\n\t\t\tcontentNodes: number;\n\t\t\tpathLookup: number;\n\t\t};\n\t\tcache: {\n\t\t\thasFirstCollection: boolean;\n\t\t\tcacheAge: number | null;\n\t\t\ttenantId?: string;\n\t\t};\n\t\tstate: string;\n\t\tversion: number;\n\t} {\n\t\treturn {\n\t\t\tmaps: {\n\t\t\t\tcontentNodes: this.contentNodeMap.size,\n\t\t\t\tpathLookup: this.pathLookupMap.size\n\t\t\t},\n\t\t\tcache: {\n\t\t\t\thasFirstCollection: !!this.firstCollectionCache?.collection,\n\t\t\t\tcacheAge: this.firstCollectionCache ? Date.now() - this.firstCollectionCache.timestamp : null,\n\t\t\t\ttenantId: this.firstCollectionCache?.tenantId\n\t\t\t},\n\t\t\tstate: this.initState,\n\t\t\tversion: this.contentVersion\n\t\t};\n\t}\n\n\tpublic getMetrics() {\n\t\treturn {\n\t\t\t...this.metrics,\n\t\t\tuptime: Date.now() - this.metrics.lastRefresh,\n\t\t\tcacheHitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0\n\t\t};\n\t}\n\n\tpublic validateStructure() {\n\t\tconst errors: string[] = [];\n\t\tconst warnings: string[] = [];\n\n\t\t// Check for orphaned nodes\n\t\tfor (const [id, node] of this.contentNodeMap.entries()) {\n\t\t\tif (node.parentId && !this.contentNodeMap.has(node.parentId)) {\n\t\t\t\terrors.push(`Node ${id} (${node.path}) has missing parent ${node.parentId}`);\n\t\t\t}\n\t\t}\n\n\t\t// Check for path consistency\n\t\tfor (const [path, id] of this.pathLookupMap.entries()) {\n\t\t\tif (!this.contentNodeMap.has(id)) {\n\t\t\t\terrors.push(`Path ${path} points to missing node ${id}`);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t\twarnings\n\t\t};\n\t}\n\n\tprivate trackCacheHit(hit: boolean): void {\n\t\tif (hit) {\n\t\t\tthis.metrics.cacheHits++;\n\t\t} else {\n\t\t\tthis.metrics.cacheMisses++;\n\t\t}\n\t}\n\n\t// Initializes the ContentManager, handling race conditions and loading data\n\tpublic async initialize(tenantId?: string): Promise<void> {\n\t\t// Already initialized - return immediately\n\t\tif (this.initState === 'initialized') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Already initializing - wait for existing initialization\n\t\tif (this.initPromise) {\n\t\t\tlogger.debug('[ContentManager] Waiting for existing initialization to complete');\n\t\t\treturn this.initPromise;\n\t\t}\n\n\t\t// Start new initialization\n\t\tlogger.info('[ContentManager] Starting initialization', { tenantId });\n\t\tthis.initPromise = this._doInitialize(tenantId);\n\n\t\ttry {\n\t\t\tawait this.initPromise;\n\t\t} catch (error) {\n\t\t\t// Reset promise to allow retry\n\t\t\tthis.initPromise = null;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Core initialization logic\n\tprivate async _doInitialize(tenantId?: string): Promise<void> {\n\t\tconst { isSetupComplete } = await import('@shared/utils/setupCheck');\n\n\t\t// Guard: If setup is not complete, skip heavy content loading.\n\t\t// The Setup Wizard does not need CMS content.\n\t\tif (!isSetupComplete()) {\n\t\t\tlogger.info('Setup not complete. ContentManager skipping initialization (SETUP MODE).');\n\t\t\tthis.initState = 'initialized'; // Mark as initialized to prevent blocking\n\t\t\tthis.metrics.initializationTime = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.initState = 'initializing';\n\t\tconst startTime = performance.now();\n\t\tconst maxRetries = 3;\n\t\tlet lastError: Error | null = null;\n\n\t\tfor (let attempt = 1; attempt <= maxRetries; attempt++) {\n\t\t\ttry {\n\t\t\t\tlogger.trace(`ContentManager initialization attempt ${attempt}/${maxRetries}`, { tenantId });\n\n\t\t\t\t// 1. Attempt to load from a high-speed cache (e.g., Redis).\n\t\t\t\tif (await this._loadStateFromCache(tenantId)) {\n\t\t\t\t\tthis.initState = 'initialized';\n\t\t\t\t\tthis.metrics.initializationTime = performance.now() - startTime;\n\t\t\t\t\tlogger.info(`üöÄ ContentManager initialized from cache in ${this._getElapsedTime(startTime)}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// 2. If cache fails, perform a full load from source (files and DB).\n\t\t\t\tawait this._fullReload(tenantId);\n\n\t\t\t\tthis.initState = 'initialized';\n\t\t\t\tthis.metrics.initializationTime = performance.now() - startTime;\n\t\t\t\tthis.metrics.lastRefresh = Date.now();\n\t\t\t\tlogger.info(`üì¶ ContentManager fully initialized in ${this._getElapsedTime(startTime)}`);\n\t\t\t\treturn;\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\t\tlogger.warn(`Initialization attempt ${attempt} failed:`, lastError.message);\n\n\t\t\t\tif (attempt < maxRetries) {\n\t\t\t\t\tconst delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);\n\t\t\t\t\tlogger.debug(`Retrying in ${delay}ms...`);\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, delay));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.initState = 'error';\n\t\tlogger.error('ContentManager initialization failed after all retries:', lastError);\n\t\tthrow lastError || new Error('Initialization failed');\n\t}\n\n\t/**\n\t * Forces a full reload of all collections and content structure.\n\t * Updates the `contentVersion` to trigger client-side reactivity.\n\t *\n\t * @param tenantId - Optional tenant ID for multi-tenant environments.\n\t */\n\tpublic async refresh(tenantId?: string): Promise<void> {\n\t\tlogger.info('Refreshing ContentManager state...');\n\t\tthis.initState = 'initializing';\n\t\tthis.clearFirstCollectionCache(); // Clear cache on refresh\n\t\tthis.initPromise = this._fullReload(tenantId).then(() => {\n\t\t\tthis.initState = 'initialized';\n\t\t\tthis.contentVersion = Date.now(); // Update version to notify clients\n\t\t});\n\t\tawait this.initPromise;\n\t}\n\n\t// Returns all loaded collection schemas\n\tpublic async getCollections(tenantId?: string): Promise<Schema[]> {\n\t\treturn this.withPerfTracking('getCollections', async () => {\n\t\t\t// Auto-initialize on first access (lazy loading)\n\t\t\tif (this.initState !== 'initialized') {\n\t\t\t\tawait this.initialize(tenantId);\n\t\t\t}\n\t\t\tconst collections: Schema[] = [];\n\t\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\t\tif (node.nodeType === 'collection' && node.collectionDef && (!tenantId || node.tenantId === tenantId)) {\n\t\t\t\t\tcollections.push(node.collectionDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn collections;\n\t\t});\n\t}\n\n\t/**\n\t * Returns the current content version timestamp.\n\t * Used by the API to expose the version for client-side polling.\n\t */\n\tpublic getContentVersion(): number {\n\t\treturn this.contentVersion;\n\t}\n\n\t/**\n\t * Returns the first available collection schema with intelligent caching.\n\t * This is optimized for instant access during setup/login flows.\n\t *\n\t * Caches the first collection for 60s to provide  instant response times for critical startup paths.\n\t *\n\t * @param tenantId - Optional tenant ID for multi-tenant filtering\n\t * @param forceRefresh - Force cache bypass and refresh\n\t */\n\tpublic async getFirstCollection(tenantId?: string, forceRefresh: boolean = false): Promise<Schema | undefined> {\n\t\t// Check cache first\n\t\tconst now = Date.now();\n\t\tif (\n\t\t\t!forceRefresh &&\n\t\t\tthis.firstCollectionCache &&\n\t\t\tthis.firstCollectionCache.tenantId === tenantId &&\n\t\t\tnow - this.firstCollectionCache.timestamp < this.FIRST_COLLECTION_CACHE_TTL\n\t\t) {\n\t\t\tconst cacheAge = ((now - this.firstCollectionCache.timestamp) / 1000).toFixed(1);\n\t\t\tlogger.debug(`‚ö° First collection from cache (age: ${cacheAge}s)`);\n\t\t\treturn this.firstCollectionCache.collection;\n\t\t}\n\n\t\t// Cache miss or expired - fetch collections\n\t\tconst startTime = performance.now();\n\t\tconst collections = await this.getCollections(tenantId);\n\t\tconst firstCollection = collections.length > 0 ? collections[0] : undefined;\n\t\tconst fetchTime = performance.now() - startTime;\n\n\t\t// Update cache\n\t\tthis.firstCollectionCache = {\n\t\t\tcollection: firstCollection,\n\t\t\ttimestamp: now,\n\t\t\ttenantId\n\t\t};\n\n\t\tif (firstCollection) {\n\t\t\tlogger.info(`üìã First collection loaded: ${firstCollection.name} ` + `(${firstCollection._id}) in ${fetchTime.toFixed(2)}ms`);\n\t\t} else {\n\t\t\tlogger.debug('No collections available in system');\n\t\t}\n\n\t\treturn firstCollection;\n\t}\n\n\t/**\n\t * Get redirect URL for first collection (convenience method for login/setup flows)\n\t *\n\t * @param language - User's language for the URL path\n\t * @param tenantId - Optional tenant ID\n\t * @returns Redirect URL or null if no collections exist\n\t */\n\tpublic async getFirstCollectionRedirectUrl(language: string = 'en', tenantId?: string): Promise<string | null> {\n\t\tconst collection = await this.getFirstCollection(tenantId);\n\n\t\tif (!collection || !collection._id) {\n\t\t\tlogger.debug('Cannot build redirect URL - no collection or _id available');\n\t\t\treturn null;\n\t\t}\n\n\t\t// The collection ID is the UUID, but we prefer the human-readable path if available.\n\t\tconst pathOrId = collection.path || collection._id;\n\t\tconst redirectUrl = `/${language}${pathOrId}`;\n\n\t\tlogger.debug(`üìç First collection redirect URL (UUID-based): ${redirectUrl}`);\n\t\treturn redirectUrl;\n\t}\n\n\t// Clear first collection cache (use when collections are modified)\n\tpublic clearFirstCollectionCache(): void {\n\t\tthis.firstCollectionCache = null;\n\t\tlogger.debug('First collection cache cleared');\n\t}\n\n\t// Retrieves the entire content structure as a nested tree\n\tpublic async getContentStructure(): Promise<ContentNode[]> {\n\t\t// Don't call during initialization - prevents deadlock\n\t\tif (this.initState === 'initializing') {\n\t\t\tlogger.warn('[ContentManager] getContentStructure called during initialization, returning empty array');\n\t\t\treturn [];\n\t\t}\n\n\t\t// Auto-initialize on first access (lazy loading)\n\t\tif (this.initState !== 'initialized') {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\t// logger.trace('[ContentManager] getContentStructure - contentNodeMap size:', this.contentNodeMap.size);\n\t\t// logger.trace('[ContentManager] getContentStructure - contentNodeMap entries:', Array.from(this.contentNodeMap.entries()));\n\n\t\t// Create a structured, nested tree from the flat map for UI consumption.\n\t\tconst nodes = new Map<string, ContentNode>(\n\t\t\tArray.from(this.contentNodeMap.entries()).map(([id, node]) => [id, { ...node, children: [] as ContentNode[] }])\n\t\t);\n\t\tconst tree: ContentNode[] = [];\n\n\t\tfor (const node of nodes.values()) {\n\t\t\tif (node.parentId && nodes.has(node.parentId)) {\n\t\t\t\tnodes.get(node.parentId)!.children!.push(node as ContentNode);\n\t\t\t} else {\n\t\t\t\ttree.push(node as ContentNode);\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Get navigation structure with progressive loading\n\t * Loads only visible nodes first, defers children until expanded\n\t */\n\tpublic async getNavigationStructureProgressive(options?: {\n\t\tmaxDepth?: number;\n\t\texpandedIds?: Set<string>;\n\t\ttenantId?: string;\n\t}): Promise<NavigationNode[]> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tawait this.initialize(options?.tenantId);\n\t\t}\n\n\t\tconst maxDepth = options?.maxDepth ?? 1; // Default: only root level\n\t\tconst expandedIds = options?.expandedIds ?? new Set<string>();\n\n\t\tconst buildTree = (parentId: string | undefined, currentDepth: number): NavigationNode[] => {\n\t\t\tconst children: NavigationNode[] = [];\n\n\t\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\t\tif (node.parentId === parentId) {\n\t\t\t\t\tconst nodeDepth = currentDepth + 1;\n\t\t\t\t\tconst shouldLoadChildren = nodeDepth < maxDepth || expandedIds.has(node._id);\n\t\t\t\t\tconst hasChildren = this.contentNodeMap.size > 0 && Array.from(this.contentNodeMap.values()).some((n) => n.parentId === node._id);\n\n\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t_id: node._id,\n\t\t\t\t\t\tname: node.name,\n\t\t\t\t\t\tpath: node.path,\n\t\t\t\t\t\ticon: node.icon,\n\t\t\t\t\t\tnodeType: node.nodeType,\n\t\t\t\t\t\torder: node.order,\n\t\t\t\t\t\tparentId: node.parentId,\n\t\t\t\t\t\ttranslations: node.translations,\n\t\t\t\t\t\t// Only load children if depth allows or node is expanded\n\t\t\t\t\t\tchildren: shouldLoadChildren ? buildTree(node._id, nodeDepth) : undefined,\n\t\t\t\t\t\thasChildren: hasChildren && !shouldLoadChildren\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn children.sort((a, b) => (a.order ?? 999) - (b.order ?? 999));\n\t\t};\n\n\t\treturn buildTree(undefined, 0);\n\t}\n\n\t/**\n\t * Get children of a specific node (for lazy loading in TreeView)\n\t */\n\tpublic getNodeChildren(nodeId: string, tenantId?: string): ContentNode[] {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst children: ContentNode[] = [];\n\n\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\tif (node.parentId === nodeId && (!tenantId || node.tenantId === tenantId)) {\n\t\t\t\tchildren.push({\n\t\t\t\t\t_id: node._id,\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tpath: node.path,\n\t\t\t\t\ticon: node.icon,\n\t\t\t\t\tnodeType: node.nodeType,\n\t\t\t\t\torder: node.order,\n\t\t\t\t\tparentId: node.parentId,\n\t\t\t\t\ttranslations: node.translations,\n\t\t\t\t\tcreatedAt: node.createdAt,\n\t\t\t\t\tupdatedAt: node.updatedAt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn children.sort((a, b) => (a.order ?? 999) - (b.order ?? 999));\n\t}\n\n\t/**\n\t * Returns a lightweight navigation structure without full collection definitions.\n\t * This is suitable for serialization to the client (e.g., for navigation menus and TreeView).\n\t * Includes only essential metadata needed for display and ordering.\n\t */\n\tpublic async getNavigationStructure(): Promise<NavigationNode[]> {\n\t\t// Don't call during initialization - prevents deadlock\n\t\tif (this.initState === 'initializing') {\n\t\t\tlogger.warn('[ContentManager] getNavigationStructure called during initialization, returning empty array');\n\t\t\treturn [];\n\t\t}\n\n\t\t// Auto-initialize on first access (lazy loading)\n\t\tif (this.initState !== 'initialized') {\n\t\t\tawait this.initialize();\n\t\t}\n\n\t\tconst fullStructure = await this.getContentStructure();\n\n\t\t// Strip out collection definitions, keep only metadata + translations for localization\n\n\t\tconst stripToNavigation = (nodes: ContentNode[]): NavigationNode[] => {\n\t\t\treturn nodes.map((node) => ({\n\t\t\t\t_id: node._id,\n\t\t\t\tname: node.name,\n\t\t\t\tpath: node.path,\n\t\t\t\ticon: node.icon,\n\t\t\t\tnodeType: node.nodeType,\n\t\t\t\torder: node.order,\n\t\t\t\tparentId: node.parentId,\n\t\t\t\ttranslations: node.translations, // Include translations for client-side localization\n\t\t\t\tchildren: node.children && node.children.length > 0 ? stripToNavigation(node.children) : undefined\n\t\t\t}));\n\t\t};\n\n\t\tconst result = stripToNavigation(fullStructure);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Preload adjacent collections in navigation tree\n\t * Called by TreeView on node expand/hover\n\t */\n\tpublic async preloadAdjacentCollections(nodeId: string, depth: number = 1): Promise<void> {\n\t\tif (this.initState !== 'initialized' || depth <= 0) return;\n\n\t\tconst node = this.contentNodeMap.get(nodeId);\n\t\tif (!node) return;\n\n\t\t// Preload siblings\n\t\tif (node.parentId) {\n\t\t\tfor (const sibling of this.contentNodeMap.values()) {\n\t\t\t\tif (sibling.parentId === node.parentId && sibling._id !== nodeId) {\n\t\t\t\t\tawait this.getCollection(sibling._id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Preload children\n\t\tfor (const child of this.contentNodeMap.values()) {\n\t\t\tif (child.parentId === nodeId) {\n\t\t\t\tawait this.getCollection(child._id);\n\t\t\t\tif (depth > 1) {\n\t\t\t\t\tawait this.preloadAdjacentCollections(child._id, depth - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the content structure directly from the database (not from in-memory cache).\n\t * This is used by CollectionBuilder to ensure it has the most current persisted state.\n\t * Returns lightweight data without heavy collectionDef.fields arrays.\n\t *\n\t * @param format 'flat' or 'nested' - default 'nested'\n\t * @returns ContentNode[] from database (with minimal collectionDef, no fields)\n\t */\n\tpublic async getContentStructureFromDatabase(format: 'flat' | 'nested' = 'nested'): Promise<ContentNode[]> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst dbAdapter = await getDbAdapter();\n\t\tif (!dbAdapter) {\n\t\t\tthrow new Error('Database adapter is not available');\n\t\t}\n\n\t\tconst result = await dbAdapter.content.nodes.getStructure(format);\n\n\t\tif (!result.success) {\n\t\t\tlogger.error('[ContentManager] Failed to get content structure from database:', result.error);\n\t\t\treturn [];\n\t\t}\n\n\t\tlogger.trace('[ContentManager] getContentStructureFromDatabase - retrieved nodes:', result.data.length);\n\t\treturn result.data;\n\t}\n\n\t// Gets a specific collection by its ID or path\n\t/**\n\t * Get collection by any identifier (path, content node ID, or collection UUID).\n\t *\n\t * @param identifier - Can be a path, content node ID, or collection UUID\n\t * @param tenantId - Optional tenant ID for filtering\n\t * @returns Schema or undefined if not found\n\t */\n\tpublic async getCollection(identifier: string, tenantId?: string): Promise<Schema | undefined> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\t// Check memory cache first\n\t\tconst cacheKey = `${identifier}:${tenantId ?? 'default'}`;\n\t\tconst cached = this.collectionCache.get(cacheKey);\n\n\t\tif (cached && Date.now() - cached.timestamp < this.COLLECTION_CACHE_TTL) {\n\t\t\tthis.trackCacheHit(true);\n\t\t\treturn cached.schema;\n\t\t}\n\n\t\tthis.trackCacheHit(false);\n\n\t\t// Try 1: Look up by path first\n\t\tconst nodeId = this.pathLookupMap.get(identifier) ?? identifier;\n\t\tlet node = this.contentNodeMap.get(nodeId);\n\n\t\t// Try 2: If not found, search by collection UUID (_id in collectionDef)\n\t\tif (!node) {\n\t\t\tfor (const [, contentNode] of this.contentNodeMap.entries()) {\n\t\t\t\tif (contentNode.collectionDef?._id === identifier) {\n\t\t\t\t\tnode = contentNode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter by tenantId if provided\n\t\tif (node?.collectionDef && tenantId && node.tenantId !== tenantId) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst result = node?.collectionDef ?? undefined;\n\n\t\t// Cache the result\n\t\tthis.collectionCache.set(cacheKey, { schema: result, timestamp: Date.now() });\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Alias for getCollection for backward compatibility\n\t */\n\tpublic async getCollectionById(collectionId: string, tenantId?: string): Promise<Schema | undefined> {\n\t\treturn await this.getCollection(collectionId, tenantId);\n\t}\n\n\t/**\n\t * Get collections with pagination support for memory efficiency\n\t * @param tenantId - Optional tenant ID\n\t * @param page - Page number (1-based)\n\t * @param pageSize - Number of collections per page\n\t * @returns Paginated collections with metadata\n\t */\n\tpublic async getCollectionsPaginated(\n\t\ttenantId?: string,\n\t\tpage: number = 1,\n\t\tpageSize: number = 20\n\t): Promise<{\n\t\tcollections: Schema[];\n\t\ttotal: number;\n\t\tpage: number;\n\t\tpageSize: number;\n\t\ttotalPages: number;\n\t}> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tawait this.initialize(tenantId);\n\t\t}\n\n\t\tconst allCollections: Schema[] = [];\n\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\tif (node.nodeType === 'collection' && node.collectionDef && (!tenantId || node.tenantId === tenantId)) {\n\t\t\t\tallCollections.push(node.collectionDef);\n\t\t\t}\n\t\t}\n\n\t\tconst total = allCollections.length;\n\t\tconst totalPages = Math.ceil(total / pageSize);\n\t\tconst startIndex = (page - 1) * pageSize;\n\t\tconst endIndex = startIndex + pageSize;\n\t\tconst collections = allCollections.slice(startIndex, endIndex);\n\n\t\treturn {\n\t\t\tcollections,\n\t\t\ttotal,\n\t\t\tpage,\n\t\t\tpageSize,\n\t\t\ttotalPages\n\t\t};\n\t}\n\n\t/**\n\t * Get multiple collections in a single operation\n\t * @param identifiers - Array of collection IDs or paths\n\t * @param tenantId - Optional tenant ID\n\t * @returns Map of identifier to Schema\n\t */\n\tpublic async getCollectionsBulk(identifiers: string[], tenantId?: string): Promise<Map<string, Schema>> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst results = new Map<string, Schema>();\n\n\t\tfor (const identifier of identifiers) {\n\t\t\tconst collection = await this.getCollection(identifier, tenantId);\n\t\t\tif (collection) {\n\t\t\t\tresults.set(identifier, collection);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Search collections by name, path, or metadata\n\t * @param query - Search query\n\t * @param filters - Optional filters\n\t * @returns Matching collections\n\t */\n\tpublic async searchCollections(\n\t\tquery: string,\n\t\tfilters?: {\n\t\t\ttenantId?: string;\n\t\t\tstatus?: string;\n\t\t\tnodeType?: 'category' | 'collection';\n\t\t\thasIcon?: boolean;\n\t\t}\n\t): Promise<Schema[]> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tawait this.initialize(filters?.tenantId);\n\t\t}\n\n\t\tconst normalizedQuery = query.toLowerCase();\n\t\tconst results: Schema[] = [];\n\n\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\t// Apply nodeType filter\n\t\t\tif (filters?.nodeType && node.nodeType !== filters.nodeType) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only process collections\n\t\t\tif (node.nodeType !== 'collection' || !node.collectionDef) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Apply tenant filter\n\t\t\tif (filters?.tenantId && node.tenantId !== filters.tenantId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst collection = node.collectionDef;\n\n\t\t\t// Apply status filter\n\t\t\tif (filters?.status && collection.status !== filters.status) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Apply icon filter\n\t\t\tif (filters?.hasIcon !== undefined) {\n\t\t\t\tconst hasIcon = !!collection.icon;\n\t\t\t\tif (hasIcon !== filters.hasIcon) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search in name and path\n\t\t\tconst name = (collection.name || '').toLowerCase();\n\t\t\tconst path = (collection.path || '').toLowerCase();\n\n\t\t\tif (name.includes(normalizedQuery) || path.includes(normalizedQuery)) {\n\t\t\t\tresults.push(collection);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Invalidate specific cache entries without clearing everything\n\t * @param paths - Array of paths to invalidate\n\t */\n\tpublic async invalidateSpecificCaches(paths: string[]): Promise<void> {\n\t\t// Clear collection-specific caches\n\t\tfor (const path of paths) {\n\t\t\tconst nodeId = this.pathLookupMap.get(path);\n\t\t\tif (nodeId) {\n\t\t\t\tconst node = this.contentNodeMap.get(nodeId);\n\t\t\t\tif (node?.collectionDef?._id) {\n\t\t\t\t\t// Clear from collection cache\n\t\t\t\t\tconst cacheKeys = [`${node.collectionDef._id}:default`, `${path}:default`];\n\t\t\t\t\tfor (const key of cacheKeys) {\n\t\t\t\t\t\tthis.collectionCache.delete(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Increment version to notify clients\n\t\tthis.contentVersion = Date.now();\n\t\tlogger.debug(`Invalidated cache for ${paths.length} paths`);\n\t}\n\n\t/**\n\t * Pre-warm cache for visible entries in EntryList\n\t * Called by EntryList's batch preload during idle time\n\t */\n\tpublic async warmEntriesCache(collectionId: string, entryIds: string[], tenantId?: string): Promise<void> {\n\t\tconst collection = await this.getCollection(collectionId, tenantId);\n\t\tif (!collection) return;\n\n\t\t// Cache collection metadata for all entries at once\n\t\tconst cacheKey = `collection:${collectionId}:metadata`;\n\n\t\tif (!this.collectionCache.has(cacheKey)) {\n\t\t\tthis.collectionCache.set(cacheKey, {\n\t\t\t\tschema: {\n\t\t\t\t\t_id: collection._id,\n\t\t\t\t\tname: collection.name,\n\t\t\t\t\ticon: collection.icon,\n\t\t\t\t\tfields: collection.fields?.map((f: any) => ({\n\t\t\t\t\t\tdb_fieldName: (f as any).db_fieldName,\n\t\t\t\t\t\tlabel: (f as any).label,\n\t\t\t\t\t\ttype: (f as any).type,\n\t\t\t\t\t\ttranslated: (f as any).translated\n\t\t\t\t\t}))\n\t\t\t\t} as any,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\t\t}\n\n\t\tlogger.debug(`[ContentManager] Warmed cache for ${entryIds.length} entries in collection ${collectionId}`);\n\t}\n\n\t/**\n\t * Register that collectionA depends on collectionB\n\t * Useful for invalidation cascades\n\t */\n\tpublic registerDependency(collectionId: string, dependsOn: string): void {\n\t\tif (!this.collectionDependencies.has(collectionId)) {\n\t\t\tthis.collectionDependencies.set(collectionId, new Set());\n\t\t}\n\t\tthis.collectionDependencies.get(collectionId)!.add(dependsOn);\n\t\tlogger.debug(`Registered dependency: ${collectionId} -> ${dependsOn}`);\n\t}\n\n\t/**\n\t * Get all collections that depend on a given collection\n\t */\n\tpublic getDependentCollections(collectionId: string): string[] {\n\t\tconst dependents: string[] = [];\n\t\tfor (const [id, deps] of this.collectionDependencies.entries()) {\n\t\t\tif (deps.has(collectionId)) {\n\t\t\t\tdependents.push(id);\n\t\t\t}\n\t\t}\n\t\treturn dependents;\n\t}\n\n\t/**\n\t * Invalidate a collection and all its dependents\n\t */\n\tpublic async invalidateWithDependents(collectionId: string): Promise<void> {\n\t\tconst toInvalidate = [collectionId, ...this.getDependentCollections(collectionId)];\n\n\t\tlogger.debug(`Invalidating ${collectionId} and ${toInvalidate.length - 1} dependents`);\n\n\t\t// Clear caches\n\t\tfor (const id of toInvalidate) {\n\t\t\tfor (const [key] of this.collectionCache.entries()) {\n\t\t\t\tif (key.startsWith(`${id}:`)) {\n\t\t\t\t\tthis.collectionCache.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Increment version\n\t\tthis.contentVersion = Date.now();\n\t}\n\n\t/**\n\t * Get lightweight collection stats for EntryList header\n\t * Avoids loading full collection definition when only metadata is needed\n\t */\n\tpublic async getCollectionStats(\n\t\tidentifier: string,\n\t\ttenantId?: string\n\t): Promise<{\n\t\t_id: string;\n\t\tname: string;\n\t\ticon?: string;\n\t\tpath?: string;\n\t\tfieldCount: number;\n\t\thasRevisions: boolean;\n\t\thasLivePreview: boolean;\n\t\tstatus?: string;\n\t} | null> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst cacheKey = `stats:${identifier}:${tenantId ?? 'default'}`;\n\t\tconst cached = this.collectionCache.get(cacheKey);\n\n\t\tif (cached && Date.now() - cached.timestamp < this.COLLECTION_CACHE_TTL) {\n\t\t\treturn cached.schema as any;\n\t\t}\n\n\t\tconst nodeId = this.pathLookupMap.get(identifier) ?? identifier;\n\t\tlet node = this.contentNodeMap.get(nodeId);\n\n\t\tif (!node) {\n\t\t\tfor (const [, contentNode] of this.contentNodeMap.entries()) {\n\t\t\t\tif (contentNode.collectionDef?._id === identifier) {\n\t\t\t\t\tnode = contentNode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!node?.collectionDef || (tenantId && node.tenantId !== tenantId)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst stats = {\n\t\t\t_id: node.collectionDef._id as string,\n\t\t\tname: node.collectionDef.name as string,\n\t\t\ticon: node.collectionDef.icon,\n\t\t\tpath: node.collectionDef.path,\n\t\t\tfieldCount: node.collectionDef.fields?.length ?? 0,\n\t\t\thasRevisions: node.collectionDef.revision === true,\n\t\t\thasLivePreview: node.collectionDef.livePreview === true,\n\t\t\tstatus: node.collectionDef.status\n\t\t};\n\n\t\tthis.collectionCache.set(cacheKey, {\n\t\t\tschema: stats as any,\n\t\t\ttimestamp: Date.now()\n\t\t});\n\n\t\treturn stats;\n\t}\n\tpublic async updateCollectionMetadata(\n\t\tcollectionId: string,\n\t\tmetadata: { name?: string; icon?: string; description?: string },\n\t\ttenantId?: string\n\t): Promise<void> {\n\t\tconst collection = await this.getCollectionById(collectionId, tenantId);\n\t\tif (!collection) {\n\t\t\tthrow new Error(`Collection ${collectionId} not found`);\n\t\t}\n\n\t\t// Update fields\n\t\tif (metadata.name) collection.name = metadata.name;\n\t\tif (metadata.icon) collection.icon = metadata.icon;\n\t\t// Description might not be in Schema type, check if needed\n\n\t\t// Persist changes (assuming dbAdapter has a method for this, or we update the file/db)\n\t\t// Since collections are file-based or db-based depending on setup.\n\t\t// If file-based, we can't easily update from here without writing to file.\n\t\t// If db-based (e.g. for user-created collections), we update DB.\n\n\t\t// For now, let's assume we just invalidate cache to reflect external changes or if we had a DB update method.\n\t\t// But the user asked to implement it.\n\t\t// Let's assume we update the in-memory map and invalidate.\n\n\t\tthis.collectionCache.delete(collectionId);\n\t\tawait this.invalidateWithDependents(collectionId);\n\n\t\tlogger.info(`Updated metadata for collection ${collectionId}`);\n\t}\n\n\tpublic async getCollectionMetadata(\n\t\tidentifier: string,\n\t\ttenantId?: string\n\t): Promise<{\n\t\t_id: string;\n\t\tname: string;\n\t\tpath?: string;\n\t\ticon?: string;\n\t\tstatus?: string;\n\t\ttenantId?: string;\n\t\tfieldCount: number;\n\t} | null> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst nodeId = this.pathLookupMap.get(identifier) ?? identifier;\n\t\tlet node = this.contentNodeMap.get(nodeId);\n\n\t\tif (!node) {\n\t\t\tfor (const [, contentNode] of this.contentNodeMap.entries()) {\n\t\t\t\tif (contentNode.collectionDef?._id === identifier) {\n\t\t\t\t\tnode = contentNode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!node?.collectionDef || (tenantId && node.tenantId !== tenantId)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst collection = node.collectionDef;\n\t\treturn {\n\t\t\t_id: collection._id as string,\n\t\t\tname: collection.name as string,\n\t\t\tpath: collection.path,\n\t\t\ticon: collection.icon,\n\t\t\tstatus: collection.status,\n\t\t\ttenantId: collection.tenantId,\n\t\t\tfieldCount: collection.fields?.length ?? 0\n\t\t};\n\t}\n\n\t/**\n\t * Get field metadata with translation status\n\t * Optimizes Fields component translation progress indicators\n\t */\n\tpublic async getFieldMetadataWithTranslations(\n\t\tcollectionId: string,\n\t\tavailableLanguages: string[],\n\t\ttenantId?: string\n\t): Promise<\n\t\tArray<{\n\t\t\tdb_fieldName: string;\n\t\t\tlabel: string;\n\t\t\ttranslated: boolean;\n\t\t\ttranslationStatus: Record<string, boolean>;\n\t\t}>\n\t> {\n\t\tconst collection = await this.getCollection(collectionId, tenantId);\n\t\tif (!collection?.fields) return [];\n\n\t\treturn collection.fields.map((field: any) => {\n\t\t\tconst translationStatus: Record<string, boolean> = {};\n\n\t\t\tif (field.translated) {\n\t\t\t\t// Initialize all languages as untranslated\n\t\t\t\tfor (const lang of availableLanguages) {\n\t\t\t\t\ttranslationStatus[lang] = false; // Will be updated by actual entry data\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdb_fieldName: field.db_fieldName || field.label,\n\t\t\t\tlabel: field.label,\n\t\t\t\ttranslated: field.translated === true,\n\t\t\t\ttranslationStatus\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Create a snapshot of current state\n\t * @param snapshotId - Unique identifier for the snapshot\n\t */\n\tpublic createSnapshot(snapshotId: string): void {\n\t\tthis.snapshots.set(snapshotId, {\n\t\t\tnodes: new Map(this.contentNodeMap),\n\t\t\tpaths: new Map(this.pathLookupMap),\n\t\t\ttimestamp: Date.now()\n\t\t});\n\n\t\tlogger.info(`Created snapshot: ${snapshotId}`);\n\n\t\t// Keep only last 5 snapshots\n\t\tif (this.snapshots.size > 5) {\n\t\t\tconst oldestKey = Array.from(this.snapshots.keys())[0];\n\t\t\tthis.snapshots.delete(oldestKey);\n\t\t}\n\t}\n\n\t/**\n\t * Rollback to a previous snapshot\n\t * @param snapshotId - Snapshot to restore\n\t */\n\tpublic async rollbackToSnapshot(snapshotId: string): Promise<boolean> {\n\t\tconst snapshot = this.snapshots.get(snapshotId);\n\t\tif (!snapshot) {\n\t\t\tlogger.warn(`Snapshot not found: ${snapshotId}`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.contentNodeMap = new Map(snapshot.nodes);\n\t\tthis.pathLookupMap = new Map(snapshot.paths);\n\t\tthis.contentVersion = Date.now();\n\n\t\t// Clear caches\n\t\tthis.collectionCache.clear();\n\t\tthis.firstCollectionCache = null;\n\n\t\tlogger.info(`Rolled back to snapshot: ${snapshotId}`);\n\t\treturn true;\n\t}\n\n\t/**\n\t * List available snapshots\n\t */\n\tpublic listSnapshots(): Array<{ id: string; timestamp: number; age: number }> {\n\t\tconst now = Date.now();\n\t\treturn Array.from(this.snapshots.entries()).map(([id, snapshot]) => ({\n\t\t\tid,\n\t\t\ttimestamp: snapshot.timestamp,\n\t\t\tage: now - snapshot.timestamp\n\t\t}));\n\t}\n\n\t/**\n\t * Get all descendants of a node (category or collection)\n\t * @param nodeId - Parent node ID\n\t * @returns Array of descendant nodes\n\t */\n\tpublic getDescendants(nodeId: string): ContentNode[] {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst descendants: ContentNode[] = [];\n\t\tconst queue: string[] = [nodeId];\n\t\tconst visited = new Set<string>();\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst currentId = queue.shift()!;\n\n\t\t\tif (visited.has(currentId)) continue;\n\t\t\tvisited.add(currentId);\n\n\t\t\t// Find children\n\t\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\t\tif (node.parentId === currentId) {\n\t\t\t\t\tdescendants.push(node);\n\t\t\t\t\tqueue.push(node._id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn descendants;\n\t}\n\n\t/**\n\t * Get the path from root to a specific node\n\t * @param nodeId - Target node ID\n\t * @returns Array of nodes from root to target\n\t */\n\tpublic getNodePath(nodeId: string): ContentNode[] {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst path: ContentNode[] = [];\n\t\tlet currentNode = this.contentNodeMap.get(nodeId);\n\n\t\twhile (currentNode) {\n\t\t\tpath.unshift(currentNode);\n\t\t\tcurrentNode = currentNode.parentId ? this.contentNodeMap.get(currentNode.parentId) : undefined;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Resolve multiple paths in a single operation\n\t * Optimizes TreeView node lookup when building navigation\n\t */\n\tpublic resolvePathsBulk(paths: string[]): Map<string, ContentNode | null> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst results = new Map<string, ContentNode | null>();\n\n\t\t// Single pass through paths\n\t\tfor (const path of paths) {\n\t\t\tconst nodeId = this.pathLookupMap.get(path);\n\t\t\tconst node = nodeId ? this.contentNodeMap.get(nodeId) : null;\n\t\t\tresults.set(path, node ?? null);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get breadcrumb trail for a path\n\t * Optimizes category breadcrumb display in EntryList\n\t */\n\tpublic getBreadcrumb(path: string): Array<{ name: string; path: string }> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst segments = path.split('/').filter(Boolean);\n\t\tconst breadcrumb: Array<{ name: string; path: string }> = [];\n\n\t\tlet currentPath = '';\n\t\tfor (const segment of segments) {\n\t\t\tcurrentPath += `/${segment}`;\n\t\t\tconst nodeId = this.pathLookupMap.get(currentPath);\n\t\t\tconst node = nodeId ? this.contentNodeMap.get(nodeId) : null;\n\n\t\t\tif (node) {\n\t\t\t\tbreadcrumb.push({\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tpath: currentPath\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn breadcrumb;\n\t}\n\n\t/**\n\t * Move a node and all its descendants to a new parent\n\t * @param nodeId - Node to move\n\t * @param newParentId - New parent ID (or undefined for root)\n\t */\n\tpublic async moveNodeWithDescendants(nodeId: string, newParentId: string | undefined): Promise<void> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst node = this.contentNodeMap.get(nodeId);\n\t\tif (!node) {\n\t\t\tthrow new Error(`Node not found: ${nodeId}`);\n\t\t}\n\n\t\t// Prevent circular references\n\t\tif (newParentId) {\n\t\t\tconst newParentPath = this.getNodePath(newParentId);\n\t\t\tif (newParentPath.some((n) => n._id === nodeId)) {\n\t\t\t\tthrow new Error('Cannot move node to its own descendant');\n\t\t\t}\n\t\t}\n\n\t\t// Update the node\n\t\tnode.parentId = newParentId as DatabaseId | undefined;\n\t\tnode.updatedAt = dateToISODateString(new Date());\n\n\t\t// Update in database\n\t\tconst dbAdapter = await getDbAdapter();\n\t\tif (!dbAdapter) {\n\t\t\tthrow new Error('Database adapter is not available');\n\t\t}\n\n\t\tawait dbAdapter.content.nodes.bulkUpdate([\n\t\t\t{\n\t\t\t\tpath: node.path as string,\n\t\t\t\tchanges: { parentId: newParentId as DatabaseId | undefined, updatedAt: node.updatedAt }\n\t\t\t}\n\t\t]);\n\n\t\t// Increment version\n\t\tthis.contentVersion = Date.now();\n\n\t\tlogger.info(`Moved node ${nodeId} to parent ${newParentId || 'root'}`);\n\t}\n\n\t/**\n\t * Track operation performance\n\t */\n\tprivate trackOperation(operation: string, durationMs: number): void {\n\t\tif (!this.performanceMetrics.operations.has(operation)) {\n\t\t\tthis.performanceMetrics.operations.set(operation, {\n\t\t\t\tcount: 0,\n\t\t\t\ttotalTime: 0,\n\t\t\t\tavgTime: 0\n\t\t\t});\n\t\t}\n\n\t\tconst metric = this.performanceMetrics.operations.get(operation)!;\n\t\tmetric.count++;\n\t\tmetric.totalTime += durationMs;\n\t\tmetric.avgTime = metric.totalTime / metric.count;\n\t}\n\n\t/**\n\t * Wrapper for performance tracking\n\t */\n\tprivate async withPerfTracking<T>(operation: string, fn: () => Promise<T>): Promise<T> {\n\t\tconst start = performance.now();\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\tthis.trackOperation(operation, performance.now() - start);\n\t\t}\n\t}\n\n\t/**\n\t * Get performance metrics\n\t */\n\tpublic getPerformanceMetrics() {\n\t\treturn {\n\t\t\t...this.metrics,\n\t\t\toperations: Array.from(this.performanceMetrics.operations.entries()).map(([op, stats]) => ({\n\t\t\t\toperation: op,\n\t\t\t\t...stats\n\t\t\t}))\n\t\t};\n\t}\n\n\t/**\n\t * Handles bulk content structure operations (create, update, move, rename, delete).\n\t * Updates both the database and in-memory state, then returns the updated structure.\n\t * @param operations Array of content node operations to perform\n\t * @returns Updated content structure as flat array\n\t */\n\tpublic async upsertContentNodes(operations: ContentNodeOperation[]): Promise<ContentNode[]> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\n\t\tconst dbAdapter = await getDbAdapter();\n\t\tif (!dbAdapter) {\n\t\t\tthrow new Error('Database adapter is not available');\n\t\t}\n\n\t\tlogger.debug('[ContentManager] upsertContentNodes - processing operations:', operations.length);\n\n\t\t// Process each operation\n\t\tconst bulkUpdates: Array<{ path: string; changes: Partial<ContentNode> }> = [];\n\t\tconst bulkCreates: Array<Omit<ContentNode, 'createdAt' | 'updatedAt'>> = [];\n\n\t\tfor (const operation of operations) {\n\t\t\tconst { type, node } = operation;\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'create': {\n\t\t\t\t\tif (!node.path) {\n\t\t\t\t\t\tlogger.warn('[ContentManager] Node missing path, skipping:', node);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// For creation, we need _id and all fields. createdAt/updatedAt are handled by adapter/DB\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { createdAt, updatedAt, ...createFields } = node;\n\n\t\t\t\t\tbulkCreates.push(createFields);\n\n\t\t\t\t\tthis.contentNodeMap.set(node._id, node);\n\t\t\t\t\tif (node.path) this.pathLookupMap.set(node.path, node._id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'update':\n\t\t\t\tcase 'rename':\n\t\t\t\tcase 'move': {\n\t\t\t\t\tif (!node.path) {\n\t\t\t\t\t\tlogger.warn('[ContentManager] Node missing path, skipping:', node);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Exclude immutable fields from updates\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { _id, createdAt, ...changeableFields } = node;\n\n\t\t\t\t\tbulkUpdates.push({\n\t\t\t\t\t\tpath: node.path,\n\t\t\t\t\t\tchanges: { ...changeableFields, updatedAt: dateToISODateString(new Date()) }\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.contentNodeMap.set(node._id, node);\n\t\t\t\t\tif (node.path) this.pathLookupMap.set(node.path, node._id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'delete': {\n\t\t\t\t\tif (node.path) await dbAdapter.content.nodes.delete(node.path);\n\t\t\t\t\tthis.contentNodeMap.delete(node._id);\n\t\t\t\t\tif (node.path) this.pathLookupMap.delete(node.path);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warn('[ContentManager] Unknown operation type:', type);\n\t\t\t}\n\t\t}\n\n\t\tif (bulkCreates.length > 0) {\n\t\t\tawait dbAdapter.content.nodes.createMany(bulkCreates);\n\t\t\tlogger.info('[ContentManager] Bulk created nodes:', bulkCreates.length);\n\t\t}\n\n\t\tif (bulkUpdates.length > 0) {\n\t\t\tawait dbAdapter.content.nodes.bulkUpdate(bulkUpdates);\n\t\t\tlogger.info('[ContentManager] Bulk updated nodes:', bulkUpdates.length);\n\t\t}\n\n\t\treturn await this.getContentStructureFromDatabase('flat');\n\t}\n\n\t/**\n\t * Optimized method for reordering content nodes using transactional logic.\n\t * This replaces the generic upsertContentNodes for drag-and-drop operations.\n\t */\n\tpublic async reorderContentNodes(operations: ContentNodeOperation[]): Promise<ContentNode[]> {\n\t\tif (this.initState !== 'initialized') {\n\t\t\tthrow new Error('ContentManager is not initialized.');\n\t\t}\n\t\tconst dbAdapter = await getDbAdapter();\n\t\tif (!dbAdapter) {\n\t\t\tthrow new Error('Database adapter is not available');\n\t\t}\n\n\t\t// Transform operations to reorder items\n\t\tconst reorderItems = operations.map((op) => {\n\t\t\tconst { node } = op;\n\t\t\treturn {\n\t\t\t\tid: node._id,\n\t\t\t\tparentId: typeof node.parentId === 'string' ? node.parentId : (node.parentId as any)?.toString() || null,\n\t\t\t\torder: node.order || 0,\n\t\t\t\tpath: node.path || '' // Path should be recalculated and correct before reaching here\n\t\t\t};\n\t\t});\n\n\t\t// Call the transactional reorder method\n\t\tawait dbAdapter.content.nodes.reorderStructure(reorderItems);\n\n\t\t// Update in-memory state\n\t\tfor (const op of operations) {\n\t\t\tconst { node } = op;\n\t\t\tthis.contentNodeMap.set(node._id, node);\n\t\t\tif (node.path) this.pathLookupMap.set(node.path, node._id);\n\t\t}\n\n\t\tlogger.info('[ContentManager] Reordered nodes:', reorderItems.length);\n\t\treturn await this.getContentStructureFromDatabase('flat');\n\t}\n\n\t// ===================================================================================\n\t// PRIVATE METHODS (Core Logic)\n\t// ===================================================================================\n\n\tprivate async _fullReload(tenantId?: string): Promise<void> {\n\t\tconst schemas = await this._scanAndProcessFiles();\n\t\tawait this._reconcileAndBuildStructure(schemas);\n\t\tawait this._populateCache(tenantId);\n\t}\n\n\t// Scans the compiledCollections directory and processes each file into a Schema object\n\tprivate async _scanAndProcessFiles(): Promise<Schema[]> {\n\t\tconst compiledDirectoryPath = import.meta.env.VITE_COLLECTIONS_FOLDER || 'compiledCollections';\n\n\t\ttry {\n\t\t\tconst fs = await getFs();\n\t\t\tawait fs.access(compiledDirectoryPath);\n\t\t} catch {\n\t\t\tlogger.trace(`Compiled collections directory not found: ${compiledDirectoryPath}`);\n\t\t\treturn [];\n\t\t}\n\n\t\tconst files = await this._recursivelyGetFiles(compiledDirectoryPath);\n\t\tconst jsFiles = files.filter((file) => file.endsWith('.js'));\n\n\t\t// Process in batches to avoid memory spikes\n\t\tconst BATCH_SIZE = 10;\n\t\tconst schemas: Schema[] = [];\n\n\t\tfor (let i = 0; i < jsFiles.length; i += BATCH_SIZE) {\n\t\t\tconst batch = jsFiles.slice(i, i + BATCH_SIZE);\n\t\t\tconst batchSchemas = await Promise.all(batch.map((filePath) => this._processSchemaFile(filePath)));\n\t\t\tschemas.push(...batchSchemas.filter((s): s is Schema => !!s));\n\n\t\t\tlogger.trace(`Processed batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(jsFiles.length / BATCH_SIZE)}`);\n\t\t}\n\n\t\treturn schemas;\n\t}\n\n\tprivate async _processSchemaFile(filePath: string): Promise<Schema | null> {\n\t\ttry {\n\t\t\tconst fs = await getFs();\n\t\t\tconst content = await fs.readFile(filePath, 'utf-8');\n\t\t\tconst { processModule } = await import('./utils');\n\t\t\tconst moduleData = await processModule(content);\n\n\t\t\tif (!moduleData?.schema) return null;\n\n\t\t\tconst schema = moduleData.schema as Schema;\n\t\t\tconst path = this._extractPathFromFilePath(filePath);\n\t\t\tconst fileName = filePath.split('/').pop()?.replace('.js', '') ?? 'unknown';\n\n\t\t\treturn {\n\t\t\t\t...schema,\n\t\t\t\t_id: schema._id!,\n\t\t\t\tpath: path,\n\t\t\t\tname: schema.name || fileName,\n\t\t\t\ttenantId: schema.tenantId ?? undefined\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.warn(`Could not process collection file: ${filePath}`, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Synchronizes schemas from files with the database and builds the in-memory maps\n\tprivate async _reconcileAndBuildStructure(schemas: Schema[]): Promise<void> {\n\t\tconst dbAdapter = await getDbAdapter();\n\n\t\t// In setup mode (no database), just build in-memory structure from files only\n\t\tif (!dbAdapter) {\n\t\t\tlogger.info('[ContentManager] No database available (setup mode) - building structure from files only');\n\t\t\tawait this._buildInMemoryStructureFromSchemas(schemas);\n\t\t\treturn;\n\t\t}\n\n\t\tconst { generateCategoryNodesFromPaths } = await import('./utils');\n\t\tconst fileCategoryNodes = generateCategoryNodesFromPaths(schemas);\n\t\tconst dbResult = await dbAdapter.content.nodes.getStructure('flat');\n\n\t\tconst dbNodeMap = new Map<string, ContentNode>(\n\t\t\tdbResult.success\n\t\t\t\t? dbResult.data.filter((node: ContentNode) => typeof node.path === 'string').map((node: ContentNode) => [node.path as string, node])\n\t\t\t\t: []\n\t\t);\n\n\t\t// Build operations with parentId resolution in a single pass\n\t\tconst operations = this._buildReconciliationOperations(schemas, fileCategoryNodes, dbNodeMap);\n\n\t\t// Ensure all Mongoose models are created/registered\n\t\t// This is critical for CRUD operations to work!\n\t\tfor (const schema of schemas) {\n\t\t\ttry {\n\t\t\t\tif ('fields' in schema) {\n\t\t\t\t\tawait dbAdapter.collection.createModel(schema);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Failed to register model for collection ${schema.name}:`, error);\n\t\t\t}\n\t\t}\n\n\t\t// Single bulk upsert with all data including parentIds\n\t\tif (operations.length > 0) {\n\t\t\tawait this._bulkUpsertWithParentIds(dbAdapter, operations);\n\t\t}\n\n\t\t// Load final structure and rebuild maps\n\t\tawait this._loadFinalStructure(dbAdapter, operations);\n\t}\n\n\tprivate _buildReconciliationOperations(\n\t\tschemas: Schema[],\n\t\tfileCategoryNodes: Map<string, { name: string }>,\n\t\tdbNodeMap: Map<string, ContentNode>\n\t): ContentNode[] {\n\t\tconst operations: ContentNode[] = [];\n\t\tconst now = dateToISODateString(new Date());\n\t\tconst pathToIdMap = new Map<string, DatabaseId>();\n\n\t\t// Helper to cast string to DatabaseId\n\t\tconst toDatabaseId = (id: string) => id as DatabaseId;\n\n\t\t// First pass: Create all operations with temporary IDs\n\t\tfor (const [path, fileNode] of fileCategoryNodes.entries()) {\n\t\t\tconst dbNode = dbNodeMap.get(path);\n\t\t\tconst nodeId = toDatabaseId(dbNode?._id ?? uuidv4().replace(/-/g, ''));\n\n\t\t\toperations.push({\n\t\t\t\t_id: nodeId,\n\t\t\t\tparentId: undefined,\n\t\t\t\tpath,\n\t\t\t\tname: (dbNode?.name ?? fileNode.name) as string,\n\t\t\t\ticon: dbNode?.icon ?? 'bi:folder',\n\t\t\t\torder: dbNode?.order ?? 999,\n\t\t\t\tnodeType: 'category',\n\t\t\t\ttranslations: dbNode?.translations ?? [],\n\t\t\t\tcreatedAt: dbNode?.createdAt ? dateToISODateString(new Date(dbNode.createdAt)) : now,\n\t\t\t\tupdatedAt: now\n\t\t\t});\n\n\t\t\tpathToIdMap.set(path, nodeId);\n\t\t}\n\n\t\t// Add collection operations\n\t\tfor (const schema of schemas) {\n\t\t\tif (!schema.path) continue;\n\t\t\tconst dbNode = dbNodeMap.get(schema.path);\n\t\t\tconst nodeId = toDatabaseId(schema._id as string);\n\n\t\t\toperations.push({\n\t\t\t\t_id: nodeId,\n\t\t\t\tparentId: undefined,\n\t\t\t\tpath: schema.path,\n\t\t\t\tname: typeof schema.name === 'string' ? schema.name : String(schema.name),\n\t\t\t\ticon: schema.icon ?? dbNode?.icon ?? 'bi:file',\n\t\t\t\tslug: schema.slug ?? dbNode?.slug,\n\t\t\t\tdescription: schema.description ?? dbNode?.description,\n\t\t\t\torder: dbNode?.order ?? 999,\n\t\t\t\tnodeType: 'collection',\n\t\t\t\ttranslations: schema.translations ?? dbNode?.translations ?? [],\n\t\t\t\tcollectionDef: schema,\n\t\t\t\ttenantId: schema.tenantId,\n\t\t\t\tcreatedAt: dbNode?.createdAt ? dateToISODateString(new Date(dbNode.createdAt)) : now,\n\t\t\t\tupdatedAt: now\n\t\t\t});\n\n\t\t\tpathToIdMap.set(schema.path, nodeId);\n\t\t}\n\n\t\t// Sort by depth and resolve parentIds in single pass\n\t\toperations.sort((a, b) => {\n\t\t\tconst depthA = (a.path?.split('/').length ?? 0) - 1;\n\t\t\tconst depthB = (b.path?.split('/').length ?? 0) - 1;\n\t\t\treturn depthA - depthB;\n\t\t});\n\n\t\t// Resolve parentIds\n\t\tfor (const op of operations) {\n\t\t\tif (!op.path) continue;\n\t\t\tconst pathParts = op.path.split('/').filter(Boolean);\n\t\t\tif (pathParts.length > 1) {\n\t\t\t\tconst parentPath = '/' + pathParts.slice(0, -1).join('/');\n\t\t\t\top.parentId = pathToIdMap.get(parentPath) ?? dbNodeMap.get(parentPath)?._id;\n\t\t\t}\n\t\t}\n\n\t\treturn operations;\n\t}\n\n\tprivate async _bulkUpsertWithParentIds(dbAdapter: any, operations: ContentNode[]): Promise<void> {\n\t\tconst upsertOps = operations.map((op) => ({\n\t\t\tpath: op.path as string,\n\t\t\tchanges: {\n\t\t\t\t...op,\n\t\t\t\tcollectionDef: op.collectionDef\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\t_id: op.collectionDef._id,\n\t\t\t\t\t\t\tname: op.collectionDef.name,\n\t\t\t\t\t\t\ticon: op.collectionDef.icon,\n\t\t\t\t\t\t\tstatus: op.collectionDef.status,\n\t\t\t\t\t\t\tpath: op.collectionDef.path,\n\t\t\t\t\t\t\ttenantId: op.collectionDef.tenantId,\n\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t} as Schema)\n\t\t\t\t\t: undefined\n\t\t\t}\n\t\t}));\n\n\t\tawait dbAdapter.content.nodes.bulkUpdate(upsertOps);\n\n\t\t// Fix any existing nodes that have mismatched IDs (from before this fix)\n\t\tconst nodesToFix = operations\n\t\t\t.filter((op) => op.nodeType === 'collection' && op._id)\n\t\t\t.map((op) => ({\n\t\t\t\tpath: op.path as string,\n\t\t\t\texpectedId: op._id as string,\n\t\t\t\tchanges: {\n\t\t\t\t\t...op,\n\t\t\t\t\tcollectionDef: op.collectionDef\n\t\t\t\t\t\t? ({\n\t\t\t\t\t\t\t\t_id: op.collectionDef._id,\n\t\t\t\t\t\t\t\tname: op.collectionDef.name,\n\t\t\t\t\t\t\t\ticon: op.collectionDef.icon,\n\t\t\t\t\t\t\t\tstatus: op.collectionDef.status,\n\t\t\t\t\t\t\t\tpath: op.collectionDef.path,\n\t\t\t\t\t\t\t\ttenantId: op.collectionDef.tenantId,\n\t\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t\t} as Schema)\n\t\t\t\t\t\t: undefined\n\t\t\t\t}\n\t\t\t}));\n\n\t\tif (nodesToFix.length > 0 && dbAdapter.content.nodes.fixMismatchedNodeIds) {\n\t\t\tconst fixResult = await dbAdapter.content.nodes.fixMismatchedNodeIds(nodesToFix);\n\t\t\tif (fixResult.fixed > 0) {\n\t\t\t\tlogger.info(`[ContentManager] Fixed ${fixResult.fixed} nodes with mismatched IDs`);\n\t\t\t}\n\t\t}\n\n\t\tawait invalidateCategoryCache(CacheCategory.CONTENT);\n\t\tlogger.debug('[ContentManager] Single-pass bulk upsert completed');\n\t}\n\n\tprivate async _loadFinalStructure(dbAdapter: any, operations: ContentNode[]): Promise<void> {\n\t\t// CRITICAL: Fetch the final structure from database after all phases complete\n\t\t// This ensures we have the correct parentId relationships and MongoDB-assigned _ids\n\t\tlogger.debug('[ContentManager] Final phase: Fetching complete structure from database');\n\t\tconst finalStructureResult = await dbAdapter.content.nodes.getStructure('flat', {}, true); // bypassCache = true\n\n\t\tif (!finalStructureResult.success || !finalStructureResult.data) {\n\t\t\tlogger.error('[ContentManager] Failed to fetch final structure from database');\n\t\t\tthrow new Error('Failed to fetch final content structure');\n\t\t}\n\n\t\tconst finalNodes = finalStructureResult.data;\n\t\t// Clear and rebuild local maps with the complete database structure\n\t\tthis.contentNodeMap.clear();\n\t\tthis.pathLookupMap.clear();\n\n\t\t// Build maps from the final database structure\n\t\tfor (const node of finalNodes) {\n\t\t\t// Ensure we normalize the _id\n\t\t\tconst normalizedId = normalizeId(node._id);\n\t\t\tif (!normalizedId) {\n\t\t\t\tlogger.warn(`[ContentManager] Could not normalize _id for node ${node.path}`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// For collections, restore the full schema from our operations array (from filesystem)\n\t\t\tif (node.nodeType === 'collection') {\n\t\t\t\tconst schemaFromOps = operations.find((op) => op._id === normalizedId || op.path === node.path);\n\t\t\t\tif (schemaFromOps?.collectionDef) {\n\t\t\t\t\tnode.collectionDef = schemaFromOps.collectionDef;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to maps\n\t\t\tthis.contentNodeMap.set(normalizedId as DatabaseId, node);\n\t\t\tif (node.path) {\n\t\t\t\tthis.pathLookupMap.set(node.path, normalizedId as DatabaseId);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`[ContentManager] Maps rebuilt: contentNodeMap=${this.contentNodeMap.size}, pathLookupMap=${this.pathLookupMap.size}`);\n\t}\n\n\t// Build in-memory structure from schemas only (used in setup mode when no database is available)\n\tprivate async _buildInMemoryStructureFromSchemas(schemas: Schema[]): Promise<void> {\n\t\tconst now = dateToISODateString(new Date());\n\t\tconst { generateCategoryNodesFromPaths } = await import('./utils');\n\t\tconst fileCategoryNodes = generateCategoryNodesFromPaths(schemas);\n\t\tconst pathToIdMap = new Map<string, DatabaseId>();\n\n\t\t// Helper to cast string to DatabaseId\n\t\tconst toDatabaseId = (id: string) => id as DatabaseId;\n\n\t\t// Clear existing maps\n\t\tthis.contentNodeMap.clear();\n\t\tthis.pathLookupMap.clear();\n\n\t\t// First: Add all category nodes\n\t\tfor (const [path, fileNode] of fileCategoryNodes.entries()) {\n\t\t\tconst nodeId = toDatabaseId(uuidv4().replace(/-/g, ''));\n\t\t\tconst parentPath = path.split('/').slice(0, -1).join('/') || undefined;\n\t\t\tconst parentId = parentPath ? pathToIdMap.get(parentPath) : undefined;\n\n\t\t\tconst node: ContentNode = {\n\t\t\t\t_id: nodeId,\n\t\t\t\tparentId,\n\t\t\t\tpath,\n\t\t\t\tname: fileNode.name,\n\t\t\t\ticon: 'bi:folder',\n\t\t\t\torder: 999,\n\t\t\t\tnodeType: 'category',\n\t\t\t\ttranslations: [],\n\t\t\t\tcreatedAt: now,\n\t\t\t\tupdatedAt: now\n\t\t\t};\n\n\t\t\tthis.contentNodeMap.set(nodeId, node);\n\t\t\tthis.pathLookupMap.set(path, nodeId);\n\t\t\tpathToIdMap.set(path, nodeId);\n\t\t}\n\n\t\t// Second: Add all collection nodes\n\t\tfor (const schema of schemas) {\n\t\t\tif (!schema.path) continue;\n\t\t\tconst nodeId = toDatabaseId(schema._id as string);\n\t\t\tconst parentPath = schema.path.split('/').slice(0, -1).join('/') || undefined;\n\t\t\tconst parentId = parentPath ? pathToIdMap.get(parentPath) : undefined;\n\n\t\t\tconst node: ContentNode = {\n\t\t\t\t_id: nodeId,\n\t\t\t\tparentId,\n\t\t\t\tpath: schema.path,\n\t\t\t\tname: typeof schema.name === 'string' ? schema.name : String(schema.name),\n\t\t\t\ticon: schema.icon ?? 'bi:file',\n\t\t\t\torder: 999,\n\t\t\t\tnodeType: 'collection',\n\t\t\t\ttranslations: schema.translations ?? [],\n\t\t\t\tcollectionDef: schema,\n\t\t\t\ttenantId: schema.tenantId,\n\t\t\t\tcreatedAt: now,\n\t\t\t\tupdatedAt: now\n\t\t\t};\n\n\t\t\tthis.contentNodeMap.set(nodeId, node);\n\t\t\tthis.pathLookupMap.set(schema.path, nodeId);\n\t\t\tpathToIdMap.set(schema.path, nodeId);\n\t\t}\n\n\t\tlogger.info(`[ContentManager] Built in-memory structure: ${this.contentNodeMap.size} nodes (setup mode)`);\n\t}\n\n\t// Populates the distributed cache (e.g., Redis) with the current state\n\tprivate async _populateCache(tenantId?: string): Promise<void> {\n\t\ttry {\n\t\t\tconst state = {\n\t\t\t\tnodes: Array.from(this.contentNodeMap.values()),\n\t\t\t\tversion: this.contentVersion,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t};\n\n\t\t\tconst cacheService = await getCacheService();\n\t\t\tconst REDIS_TTL = await getRedisTTL();\n\n\t\t\t// Store complete structure\n\t\t\tawait cacheService.set('cms:content_structure', state, REDIS_TTL, tenantId);\n\n\t\t\t// Pre-warm frequently accessed paths\n\t\t\tawait this._warmFrequentPaths(cacheService, REDIS_TTL, tenantId);\n\t\t} catch (error) {\n\t\t\t// In setup mode, caching may not be available - that's OK\n\t\t\tlogger.debug('[ContentManager] Cache population skipped (likely setup mode):', error instanceof Error ? error.message : String(error));\n\t\t}\n\t}\n\n\t// 2. Fix _warmFrequentPaths - build tree directly without calling methods\n\tprivate async _warmFrequentPaths(cacheService: any, ttl: number, tenantId?: string): Promise<void> {\n\t\t// Cache first collection for instant access\n\t\tconst collections = Array.from(this.contentNodeMap.values()).filter((node) => node.nodeType === 'collection' && node.collectionDef);\n\n\t\tif (collections.length > 0) {\n\t\t\tawait cacheService.set('cms:first_collection', collections[0].collectionDef, ttl, tenantId);\n\t\t\tlogger.debug('[ContentManager] Warmed first collection cache');\n\t\t}\n\n\t\t// Cache navigation structure - build directly without calling methods that check initState\n\t\t// CRITICAL: Don't call getNavigationStructure() here as it checks initState and causes deadlock\n\t\tconst buildNavTree = (parentId?: string): NavigationNode[] => {\n\t\t\tconst children: NavigationNode[] = [];\n\t\t\tfor (const node of this.contentNodeMap.values()) {\n\t\t\t\tif (node.parentId === parentId) {\n\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t_id: node._id,\n\t\t\t\t\t\tname: node.name,\n\t\t\t\t\t\tpath: node.path,\n\t\t\t\t\t\ticon: node.icon,\n\t\t\t\t\t\tnodeType: node.nodeType,\n\t\t\t\t\t\torder: node.order,\n\t\t\t\t\t\tparentId: node.parentId,\n\t\t\t\t\t\ttranslations: node.translations,\n\t\t\t\t\t\tchildren: buildNavTree(node._id)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn children.sort((a, b) => (a.order ?? 999) - (b.order ?? 999));\n\t\t};\n\n\t\tconst navStructure = buildNavTree(undefined);\n\t\tawait cacheService.set('cms:navigation_structure', navStructure, ttl, tenantId);\n\t\tlogger.debug('[ContentManager] Warmed navigation structure cache');\n\t}\n\n\t// Tries to load the state from the distributed cache\n\tprivate async _loadStateFromCache(tenantId?: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst cacheService = await getCacheService();\n\t\t\tawait cacheService.initialize();\n\t\t\tconst state = await cacheService.get<{ nodes: ContentNode[] }>('cms:content_structure', tenantId);\n\t\t\tif (!state || !state.nodes || state.nodes.length === 0) {\n\t\t\t\tlogger.debug('[ContentManager] Cache miss or empty - will perform full load');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlogger.debug(`[ContentManager] Cache hit - loading ${state.nodes.length} nodes from cache`);\n\t\t\tthis.contentNodeMap.clear();\n\t\t\tthis.pathLookupMap.clear();\n\t\t\tfor (const node of state.nodes) {\n\t\t\t\tthis.contentNodeMap.set(node._id, node);\n\t\t\t\tif (node.path) {\n\t\t\t\t\tthis.pathLookupMap.set(node.path, node._id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.debug('[ContentManager] State successfully loaded from cache');\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tlogger.debug('[ContentManager] Cache load failed, proceeding with full load:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// --- Helper and Utility Methods ---\n\tprivate async _recursivelyGetFiles(dir: string): Promise<string[]> {\n\t\tconst fs = await getFs();\n\t\tconst entries = await fs.readdir(dir, { withFileTypes: true });\n\t\tconst files = await Promise.all(\n\t\t\tentries.map((entry) => {\n\t\t\t\tconst resolvedPath = `${dir}/${entry.name}`;\n\t\t\t\treturn entry.isDirectory() ? this._recursivelyGetFiles(resolvedPath) : Promise.resolve(resolvedPath);\n\t\t\t})\n\t\t);\n\t\treturn files.flat();\n\t}\n\n\tprivate _extractPathFromFilePath(filePath: string): string {\n\t\tconst compiledDir = import.meta.env.VITE_COLLECTIONS_FOLDER || 'compiledCollections';\n\t\tlet relativePath = filePath.substring(filePath.indexOf(compiledDir) + compiledDir.length);\n\t\trelativePath = relativePath.replace(/\\.js$/, '');\n\t\treturn relativePath.startsWith('/') ? relativePath : `/${relativePath}`;\n\t}\n\n\tprivate _getElapsedTime(startTime: number): string {\n\t\treturn `${(performance.now() - startTime).toFixed(2)}ms`;\n\t}\n}\n\n// Now, define helper functions outside the class.\n\n// Export the class so db.ts can access static methods like getInstance()\nexport { ContentManager };\n\n// And finally, export the instance.\nexport const contentManager = ContentManager.getInstance();\n"],"names":["uuidv4"],"mappings":"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"}