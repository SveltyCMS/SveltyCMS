{"version":3,"file":"loadingStore.svelte.js","sources":["../../../../../../shared/stores/src/loadingStore.svelte.ts"],"sourcesContent":["/**\n * @file src/stores/loadingStore.svelte.ts\n * @description Enterprise-grade global loading state management aligned with SSR architecture.\n * Prevents UI flashes with intelligent context-aware loading states. Follows SveltyCMS state\n * management patterns: server-first, reactive, and self-optimizing.\n *\n * @example\n * import { globalLoadingStore, loadingOperations } from '@shared/stores/loadingStore.svelte';\n * // Manual control\n * globalLoadingStore.startLoading(loadingOperations.dataFetch);\n * await fetchData();\n * globalLoadingStore.stopLoading(loadingOperations.dataFetch);\n *\n * await globalLoadingStore.withLoading(\n *   loadingOperations.dataFetch,\n *   async () => await fetchData()\n * );\n *\n * Features:\n * - SSR-safe: Guards against server-side execution\n * - Smart context detection: Auto-detects operation type from context\n * - Stack-based: Handles concurrent operations gracefully\n * - Auto-cleanup: Prevents stuck loading states with timeouts\n * - TypeScript: Full type safety with discriminated unions\n */\n\nimport { SvelteSet } from 'svelte/reactivity';\nimport { SvelteMap } from 'svelte/reactivity';\nimport { browser } from '$app/environment';\n\n// Predefined loading operations for consistency\nexport const loadingOperations = {\n\tnavigation: 'navigation',\n\tdataFetch: 'data-fetch',\n\tauthentication: 'authentication',\n\tinitialization: 'initialization',\n\timageUpload: 'image-upload',\n\tformSubmission: 'form-submission',\n\tconfigSave: 'config-save',\n\troleManagement: 'role-management',\n\tpermissionUpdate: 'permission-update',\n\ttokenGeneration: 'token-generation',\n\tcollectionLoad: 'collection-load',\n\twidgetInit: 'widget-init'\n} as const;\n\nexport type LoadingOperation = (typeof loadingOperations)[keyof typeof loadingOperations];\n\n// Enhanced loading state with metadata\ninterface LoadingEntry {\n\treason: string;\n\tstartTime: number;\n\tcontext?: string;\n\ttimeoutId?: ReturnType<typeof setTimeout>;\n\tprogress?: number;\n\tcanCancel?: boolean;\n\tonCancel?: () => void;\n}\n\n// Enterprise-grade loading store with automatic cleanup and SSR safety\nexport class LoadingStore {\n\tprivate _isLoading = $state(false);\n\tprivate _loadingReason = $state<string | null>(null);\n\tprivate _loadingStack = $state<SvelteSet<string>>(new SvelteSet());\n\tprivate _loadingEntries = new SvelteMap<string, LoadingEntry>();\n\tprivate _maxTimeout = 30000; // 30 second max timeout for safety\n\tprivate _progress = $state<number | null>(null);\n\tprivate _canCancel = $state(false);\n\tprivate _onCancel = $state<(() => void) | undefined>(undefined);\n\n\t// Public getters\n\tget isLoading() {\n\t\treturn this._isLoading;\n\t}\n\n\tget loadingReason() {\n\t\treturn this._loadingReason;\n\t}\n\n\tget loadingStack() {\n\t\treturn this._loadingStack;\n\t}\n\n\tget progress() {\n\t\treturn this._progress;\n\t}\n\n\tget canCancel() {\n\t\treturn this._canCancel;\n\t}\n\n\tget onCancel() {\n\t\treturn this._onCancel;\n\t}\n\n\t/**\n\t * Start a loading operation with automatic timeout protection\n\t * @param reason - The loading operation type\n\t * @param context - Optional context for debugging\n\t * @param timeout - Custom timeout in ms (default: 30s)\n\t */\n\tstartLoading(reason: string, context?: string, timeout: number = this._maxTimeout) {\n\t\t// SSR guard: Only run in browser\n\t\tif (!browser) return;\n\n\t\t// Prevent duplicate entries\n\t\tif (this._loadingStack.has(reason)) {\n\t\t\tconsole.warn(`[LoadingStore] Operation \"${reason}\" already in progress`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create timeout to auto-cleanup stuck states\n\t\tconst timeoutId = setTimeout(() => {\n\t\t\tconsole.warn(`[LoadingStore] Auto-cleanup: \"${reason}\" exceeded ${timeout}ms`);\n\t\t\tthis.stopLoading(reason);\n\t\t}, timeout);\n\n\t\t// Add to stack and entries\n\t\tthis._loadingStack.add(reason);\n\t\tthis._loadingEntries.set(reason, {\n\t\t\treason,\n\t\t\tstartTime: Date.now(),\n\t\t\tcontext,\n\t\t\ttimeoutId\n\t\t});\n\n\t\tthis._isLoading = true;\n\t\tthis._loadingReason = reason;\n\n\t\tif (context) {\n\t\t\tconsole.debug(`[LoadingStore] Started: ${reason} (${context})`);\n\t\t}\n\t}\n\n\t/**\n\t * Stop a loading operation and clean up\n\t * @param reason - The loading operation type to stop\n\t */\n\tstopLoading(reason: string) {\n\t\t// SSR guard\n\t\tif (!browser) return;\n\n\t\tif (!this._loadingStack.has(reason)) {\n\t\t\treturn; // Already stopped or never started\n\t\t}\n\n\t\t// Clear timeout and remove entry\n\t\tconst entry = this._loadingEntries.get(reason);\n\t\tif (entry?.timeoutId) {\n\t\t\tclearTimeout(entry.timeoutId);\n\t\t}\n\t\tthis._loadingEntries.delete(reason);\n\n\t\t// Remove from stack\n\t\tthis._loadingStack.delete(reason);\n\n\t\t// Update state\n\t\tif (this._loadingStack.size === 0) {\n\t\t\tthis._isLoading = false;\n\t\t\tthis._loadingReason = null;\n\t\t\tthis._progress = null;\n\t\t\tthis._canCancel = false;\n\t\t\tthis._onCancel = undefined;\n\t\t} else {\n\t\t\t// Update to most recent operation\n\t\t\tconst entries = Array.from(this._loadingStack);\n\t\t\tconst newReason = entries[entries.length - 1];\n\t\t\tthis._loadingReason = newReason;\n\n\t\t\t// Restore progress/cancel state of the active operation\n\t\t\tconst newEntry = this._loadingEntries.get(newReason);\n\t\t\tif (newEntry) {\n\t\t\t\tthis._progress = newEntry.progress ?? null;\n\t\t\t\tthis._canCancel = newEntry.canCancel ?? false;\n\t\t\t\tthis._onCancel = newEntry.onCancel;\n\t\t\t}\n\t\t}\n\n\t\tif (entry) {\n\t\t\tconst duration = Date.now() - entry.startTime;\n\t\t\tconsole.debug(`[LoadingStore] Stopped: ${reason} (${duration}ms)`);\n\t\t}\n\t}\n\n\t/**\n\t * Update loading progress and cancellation for the current operation\n\t */\n\tupdateStatus(reason: string, progress?: number, canCancel?: boolean, onCancel?: () => void) {\n\t\tif (!browser || !this._loadingEntries.has(reason)) return;\n\n\t\tconst entry = this._loadingEntries.get(reason)!;\n\n\t\tif (progress !== undefined) {\n\t\t\tentry.progress = progress;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._progress = progress;\n\t\t\t}\n\t\t}\n\n\t\tif (canCancel !== undefined) {\n\t\t\tentry.canCancel = canCancel;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._canCancel = canCancel;\n\t\t\t}\n\t\t}\n\n\t\tif (onCancel !== undefined) {\n\t\t\tentry.onCancel = onCancel;\n\t\t\tif (this._loadingReason === reason) {\n\t\t\t\tthis._onCancel = onCancel;\n\t\t\t}\n\t\t}\n\n\t\tthis._loadingEntries.set(reason, entry);\n\t}\n\n\t// Forcefully clear all loading states (emergency use only)\n\tclearLoading() {\n\t\tif (!browser) return;\n\n\t\t// Clear all timeouts\n\t\tfor (const entry of this._loadingEntries.values()) {\n\t\t\tif (entry.timeoutId) {\n\t\t\t\tclearTimeout(entry.timeoutId);\n\t\t\t}\n\t\t}\n\n\t\tthis._loadingEntries.clear();\n\t\tthis._loadingStack.clear();\n\t\tthis._isLoading = false;\n\t\tthis._loadingReason = null;\n\t\tthis._progress = null;\n\t\tthis._canCancel = false;\n\t\tthis._onCancel = undefined;\n\n\t\tconsole.warn('[LoadingStore] Force cleared all loading states');\n\t}\n\n\t// Check if a specific operation is currently loading\n\tisLoadingReason(reason: string): boolean {\n\t\treturn this._loadingStack.has(reason);\n\t}\n\n\t/**\n\t * Wrap an async operation with automatic loading state management\n\t * Handles errors and ensures cleanup even if promise rejects\n\t *\n\t * @example\n\t * await globalLoadingStore.withLoading(\n\t *   loadingOperations.dataFetch,\n\t *   async () => {\n\t *     const data = await fetch('/api/data');\n\t *     return data.json();\n\t *   }\n\t * );\n\t */\n\tasync withLoading<T>(reason: string, operation: () => Promise<T>, context?: string): Promise<T> {\n\t\tthis.startLoading(reason, context);\n\t\ttry {\n\t\t\tconst result = await operation();\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[LoadingStore] Operation \"${reason}\" failed:`, error);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tthis.stopLoading(reason);\n\t\t}\n\t}\n\n\t// Get loading statistics (for debugging)\n\tgetStats() {\n\t\tif (!browser) return null;\n\n\t\treturn {\n\t\t\tisLoading: this._isLoading,\n\t\t\tcurrentReason: this._loadingReason,\n\t\t\tactiveCount: this._loadingStack.size,\n\t\t\tactiveOperations: Array.from(this._loadingStack),\n\t\t\tentries: Array.from(this._loadingEntries.entries()).map(([reason, entry]) => ({\n\t\t\t\treason,\n\t\t\t\tduration: Date.now() - entry.startTime,\n\t\t\t\tcontext: entry.context\n\t\t\t}))\n\t\t};\n\t}\n}\n\n// Create and export singleton instance\nexport const globalLoadingStore = new LoadingStore();\n"],"names":[],"mappings":";;MA+Ba,oBAAA;AAAA,EAEZ,WAAW;AAAA,EACX,gBAAgB;AAAA,EAIhB,YAAY;;AAsBA,MAAA,aAAa;AAAA,EACjB,aAAoB;AAAA,EACpB,iBAAuC;AAAA,EACvC,oBAA8C,UAAA;AAAA,EAC9C,sBAAsB,UAAA;AAAA,EACtB,cAAc;AAAA;AAAA,EACd,YAAkC;AAAA,EAClC,aAAoB;AAAA,EACpB;;EAGJ,IAAA,YAAY;AACR,WAAA,KAAK;AAAA,EACb;AAAA,EAEI,IAAA,gBAAgB;AACZ,WAAA,KAAK;AAAA,EACb;AAAA,EAEI,IAAA,eAAe;AACX,WAAA,KAAK;AAAA,EACb;AAAA,EAEI,IAAA,WAAW;AACP,WAAA,KAAK;AAAA,EACb;AAAA,EAEI,IAAA,YAAY;AACR,WAAA,KAAK;AAAA,EACb;AAAA,EAEI,IAAA,WAAW;AACP,WAAA,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,QAAgB,SAAkB,UAAkB,KAAK,aAAa;AAE7E;AAAA,EA6BN;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,QAAgB;AAEtB;AAAA,EA0CN;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,QAAgB,UAAmB,WAAqB,UAAuB;AAC3C;AAAA,EA0BjD;AAAA;AAAA,EAGA,eAAe;AACT;AAAA,EAkBN;AAAA;AAAA,EAGA,gBAAgB,QAAyB;AACjC,WAAA,KAAK,cAAc,IAAI,MAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeM,MAAA,YAAe,QAAgB,WAA6B,SAA8B;AAC/F,SAAK,aAAa,QAAQ,OAAO;QAC7B;AACG,YAAA,eAAe,UAAA;aACd;AAAA,IACR,SAAS,OAAO;AACf,cAAQ,MAAA,6BAAmC,MAAM,aAAa,KAAK;YAC7D;AAAA,IACP,UAAA;AACC,WAAK,YAAY,MAAM;AAAA,IACxB;AAAA,EACD;AAAA;AAAA,EAGA,WAAW;WACW;AAAA,EAatB;AACD;AAGa,MAAA,yBAAyB,aAAA;"}