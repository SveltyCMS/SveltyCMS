{"version":3,"file":"authToken.js","sources":["../../../../../../shared/database/src/mongodb/models/authToken.ts"],"sourcesContent":["/**\n * @file src/auth/mongoDBAuth/tokenAdapter.ts\n * @description MongoDB adapter for token-related operations.\n *\n * ### Features:\n * - Create, validate, and consume tokens\n * - Manage token schemas and models\n * - Handle token expiration\n * - Token generation and validation\n * - Token schema definition\n * - Token expiration handling\n * - Integration with MongoDB through Mongoose\n */\n\nimport type { Model } from 'mongoose';\nimport mongoose, { Schema, type Document, type QueryFilter } from 'mongoose';\n\nimport { v4 as uuidv4 } from 'uuid';\n\n// Types\nimport type { DatabaseResult, ISODateString } from '@shared/database/dbInterface';\nimport type { Token } from '@shared/database/auth/types';\n\n// System Logging\nimport { logger } from '@shared/utils/logger';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\n\n// Define the Token schema\nexport const TokenSchema = new Schema(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // UUID primary key\n\t\tuser_id: { type: String, required: true }, // ID of the user who owns the token, required field\n\t\ttenantId: { type: String, index: true }, // Tenant identifier for multi-tenancy\n\t\ttoken: { type: String, required: true, unique: true }, // Token string, required field\n\t\temail: { type: String, required: true }, // Email associated with the token, required field\n\t\texpires: { type: Date, required: true }, // Expiry timestamp of the token, required field\n\t\ttype: { type: String, required: true }, // Type of the token, required field\n\t\tusername: { type: String, required: false }, // Username associated with the token\n\t\trole: { type: String, required: false }, // Role associated with the token\n\t\tblocked: { type: Boolean, required: false, default: false } // Whether the token is blocked\n\t},\n\t{\n\t\ttimestamps: true, // Automatically adds `createdAt` and `updatedAt` fields\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// --- Indexes ---\n// TTL index: Automatically delete expired tokens (auto-cleanup)\nTokenSchema.index({ expires: 1 }, { expireAfterSeconds: 0 });\n\n// Compound indexes for common query patterns (50-80% performance boost)\nTokenSchema.index({ user_id: 1, type: 1, expires: 1 }); // User's active tokens by type\nTokenSchema.index({ email: 1, type: 1, expires: 1 }); // Email verification/reset queries\nTokenSchema.index({ tenantId: 1, type: 1, expires: 1 }); // Multi-tenant token queries\nTokenSchema.index({ tenantId: 1, user_id: 1, type: 1 }); // Tenant-specific user tokens\nTokenSchema.index({ type: 1, expires: 1, blocked: 1 }); // Active tokens by type (admin queries)\n\ninterface TokenDocument extends Omit<Document, '_id'>, Omit<Token, '_id'> {\n\t_id: string;\n}\n\n/**\n * TokenAdapter class handles all token-related database operations.\n * This is a partial implementation that will be composed with other adapters.\n */\nexport class TokenAdapter {\n\tprivate TokenModel: Model<TokenDocument>;\n\n\tconstructor() {\n\t\t// Force model recreation if schema changed\n\t\tif (mongoose.models.auth_tokens) {\n\t\t\tdelete mongoose.models.auth_tokens;\n\t\t}\n\n\t\t// Create the Token model\n\t\tthis.TokenModel = mongoose.models?.auth_tokens || mongoose.model<TokenDocument>('auth_tokens', TokenSchema);\n\t}\n\n\tasync createToken(data: {\n\t\tuser_id: string;\n\t\temail: string;\n\t\texpires: ISODateString;\n\t\ttype: string;\n\t\tusername?: string;\n\t\trole?: string;\n\t\ttenantId?: string;\n\t}): Promise<DatabaseResult<string>> {\n\t\ttry {\n\t\t\t// Use uuidv4 for token generation - much simpler and safer\n\t\t\tconst token = uuidv4().replace(/-/g, ''); // Remove hyphens for a cleaner 32-character token\n\t\t\tconst newToken = new this.TokenModel({\n\t\t\t\tuser_id: data.user_id,\n\t\t\t\ttenantId: data.tenantId,\n\t\t\t\temail: data.email.toLowerCase(), // Normalize email to lowercase\n\t\t\t\texpires: data.expires,\n\t\t\t\ttype: data.type,\n\t\t\t\tusername: data.username,\n\t\t\t\trole: data.role,\n\t\t\t\ttoken\n\t\t\t});\n\t\t\tawait newToken.save();\n\t\t\tlogger.debug('Token created', { user_id: data.user_id, type: data.type, tenantId: data.tenantId });\n\t\t\treturn { success: true, data: token };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.createToken: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id: data.user_id, type: data.type });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_CREATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Validate a token\n\n\tasync validateToken(\n\t\ttoken: string,\n\t\tuser_id?: string,\n\t\ttype?: string,\n\t\ttenantId?: string\n\t): Promise<DatabaseResult<{ success: boolean; message: string; email?: string }>> {\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst query: any = { token };\n\t\t\tif (user_id) query.user_id = user_id;\n\t\t\tif (type) query.type = type;\n\t\t\tif (tenantId) query.tenantId = tenantId;\n\n\t\t\tconst tokenDoc = await this.TokenModel.findOne(query).lean();\n\t\t\tif (!tokenDoc) {\n\t\t\t\tlogger.warn('Invalid token', { token });\n\t\t\t\treturn { success: true, data: { success: false, message: 'Token is invalid' } };\n\t\t\t} // Check if token is blocked\n\n\t\t\tif (tokenDoc.blocked) {\n\t\t\t\tlogger.warn('Blocked token', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { success: false, message: 'Token is blocked' } };\n\t\t\t}\n\n\t\t\tif (new Date(tokenDoc.expires) > new Date()) {\n\t\t\t\tlogger.debug('Token validated', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { success: true, message: 'Token is valid', email: tokenDoc.email } };\n\t\t\t} else {\n\t\t\t\tlogger.warn('Expired token', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { success: false, message: 'Token is expired' } };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.validateToken: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token, user_id, type });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_VALIDATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Consume a token\n\n\tasync consumeToken(\n\t\ttoken: string,\n\t\tuser_id?: string,\n\t\ttype?: string,\n\t\ttenantId?: string\n\t): Promise<DatabaseResult<{ status: boolean; message: string }>> {\n\t\ttry {\n\t\t\tconst query: QueryFilter<TokenDocument> = { token };\n\t\t\tif (user_id) query.user_id = user_id;\n\t\t\tif (type) query.type = type;\n\t\t\tif (tenantId) query.tenantId = tenantId;\n\n\t\t\tconst tokenDoc = await this.TokenModel.findOneAndDelete(query).lean();\n\t\t\tif (!tokenDoc) {\n\t\t\t\tlogger.warn('Invalid token consumption attempt', { token });\n\t\t\t\treturn { success: true, data: { status: false, message: 'Token is invalid' } };\n\t\t\t} // Check if token was blocked\n\n\t\t\tif (tokenDoc.blocked) {\n\t\t\t\tlogger.warn('Blocked token consumption attempt', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { status: false, message: 'Token is blocked' } };\n\t\t\t}\n\n\t\t\tif (new Date(tokenDoc.expires) > new Date()) {\n\t\t\t\tlogger.debug('Token consumed', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { status: true, message: 'Token is valid and consumed' } };\n\t\t\t} else {\n\t\t\t\tlogger.warn('Expired token consumed', { user_id: tokenDoc.user_id, type: tokenDoc.type });\n\t\t\t\treturn { success: true, data: { status: false, message: 'Token is expired' } };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.consumeToken: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token, user_id, type });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_CONSUMPTION_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Get all tokens\n\n\tasync getAllTokens(filter?: Record<string, unknown>): Promise<DatabaseResult<Token[]>> {\n\t\ttry {\n\t\t\tconst tokens = await this.TokenModel.find(filter || {}).lean();\n\t\t\tlogger.debug('All tokens retrieved', { count: tokens.length });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: tokens.map((tokenDoc) => this.formatToken(tokenDoc))\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.getAllTokens: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { filter });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_RETRIEVAL_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Delete expired tokens\n\n\tasync deleteExpiredTokens(): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst result = await this.TokenModel.deleteMany({ expires: { $lte: new Date().toISOString() } });\n\t\t\tlogger.info('Expired tokens deleted', { deletedCount: result.deletedCount });\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.deleteExpiredTokens: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_DELETION_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Delete multiple tokens by token strings\n\n\tasync deleteTokens(token_ids: string[], tenantId?: string): Promise<DatabaseResult<{ deletedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { token: { $in: token_ids } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\t\t\tconst result = await this.TokenModel.deleteMany(filter);\n\t\t\tlogger.info('Tokens deleted', { deletedCount: result.deletedCount, token_ids });\n\t\t\treturn { success: true, data: { deletedCount: result.deletedCount } };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.deleteTokens: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token_ids });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_DELETION_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Block multiple tokens (set them as blocked )\n\n\tasync blockTokens(token_ids: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { token: { $in: token_ids } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\t\t\t// Set blocked status to true\n\t\t\tconst result = await this.TokenModel.updateMany(filter, { blocked: true });\n\t\t\tlogger.info('Tokens blocked', { modifiedCount: result.modifiedCount, token_ids });\n\t\t\treturn { success: true, data: { modifiedCount: result.modifiedCount } };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.blockTokens: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token_ids });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_BLOCK_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Unblock multiple tokens\n\n\tasync unblockTokens(token_ids: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { token: { $in: token_ids } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\t\t\t// Set blocked status to false to unblock\n\t\t\tconst result = await this.TokenModel.updateMany(filter, { blocked: false });\n\t\t\tlogger.info('Tokens unblocked', { modifiedCount: result.modifiedCount, token_ids });\n\t\t\treturn { success: true, data: { modifiedCount: result.modifiedCount } };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.unblockTokens: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token_ids });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_UNBLOCK_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Update a single token\n\n\tasync updateToken(token_id: string, tokenData: Partial<Token>, tenantId?: string): Promise<DatabaseResult<Token>> {\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst filter: any = { token: token_id };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst result = (await this.TokenModel.findOneAndUpdate(filter, { $set: tokenData }, { new: true, lean: true })) as any;\n\n\t\t\tif (result) {\n\t\t\t\tlogger.debug('Token updated successfully', { token_id });\n\t\t\t\treturn { success: true, data: result as Token };\n\t\t\t} else {\n\t\t\t\tlogger.warn('Token not found', { token_id });\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Token not found',\n\t\t\t\t\terror: { code: 'TOKEN_NOT_FOUND', message: 'Token not found' }\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.updateToken: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token_id, tokenData });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_UPDATE_ERROR', message }\n\t\t\t};\n\t\t}\n\t} // Get token details by token value\n\n\tasync getTokenByValue(token: string, tenantId?: string): Promise<DatabaseResult<Token | null>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { token };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\t\t\tconst tokenDoc = await this.TokenModel.findOne(filter).lean();\n\t\t\tconst result = tokenDoc\n\t\t\t\t? {\n\t\t\t\t\t\t_id: tokenDoc._id.toString(),\n\t\t\t\t\t\tuser_id: tokenDoc.user_id,\n\t\t\t\t\t\ttoken: tokenDoc.token,\n\t\t\t\t\t\temail: tokenDoc.email,\n\t\t\t\t\t\texpires: tokenDoc.expires,\n\t\t\t\t\t\ttype: tokenDoc.type,\n\t\t\t\t\t\tblocked: tokenDoc.blocked,\n\t\t\t\t\t\tusername: tokenDoc.username,\n\t\t\t\t\t\trole: tokenDoc.role,\n\t\t\t\t\t\tcreatedAt: tokenDoc.createdAt,\n\t\t\t\t\t\tupdatedAt: tokenDoc.updatedAt\n\t\t\t\t\t}\n\t\t\t\t: null;\n\t\t\treturn { success: true, data: result };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in TokenAdapter.getTokenByValue: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { token });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_RETRIEVAL_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate formatToken(token: Partial<Token> & { _id?: string | mongoose.Types.ObjectId }): Token {\n\t\t// Accepts both TokenDocument and plain objects from .lean()\n\t\tconst { _id, ...tokenData } = token;\n\t\t// Remove _id from tokenData if present\n\t\tif ('_id' in tokenData) {\n\t\t\tdelete (tokenData as Record<string, unknown>)._id;\n\t\t}\n\t\t// Compose the Token object, ensuring id is always a string\n\t\tconst result = {\n\t\t\tid: _id ? _id.toString() : '',\n\t\t\t...tokenData\n\t\t};\n\t\t// If you want to ensure type safety, cast to unknown first, then Token\n\t\treturn result as unknown as Token;\n\t}\n}\n"],"names":["uuidv4"],"mappings":"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"}