{"version":3,"file":"MediaService.server.js","sources":["../../../../../../shared/utils/src/media/mediaProcessing.ts","../../../../../../shared/utils/src/media/mediaProcessing.server.ts","../../../../../../shared/services/src/MediaService.server.ts"],"sourcesContent":["/**\n * @file src/utils/media/mediaProcessing.ts\n * @description Client-safe media utilities (filename sanitization)\n *\n * Features:\n * - Safe filename extraction & sanitization\n * - Extension normalization\n * - Client-side compatible (no server deps)\n */\n\nimport { sanitize } from '@shared/utils/utils';\nimport { logger } from '@shared/utils/logger';\n\n/** Sanitize filename for safe upload/storage */\nexport function sanitizedFilename(original: string): { name: string; ext: string } {\n\tif (!original || typeof original !== 'string') {\n\t\tthrow new Error('Invalid filename');\n\t}\n\n\tconst dot = original.lastIndexOf('.');\n\tconst name = dot > 0 ? original.slice(0, dot) : original;\n\tconst ext = dot > 0 ? original.slice(dot + 1).toLowerCase() : '';\n\n\tlogger.trace('Filename sanitized', { original, name, ext });\n\n\treturn { name: sanitize(name), ext };\n}\n\n/** Alias for backward compatibility */\nexport function getSanitizedFileName(filename: string): { fileNameWithoutExt: string; ext: string } {\n\tconst { name, ext } = sanitizedFilename(filename);\n\treturn { fileNameWithoutExt: name, ext };\n}\n","/**\n * @file src/utils/media/mediaProcessing.server.ts\n * @description Server-side media processing (hashing & metadata extraction)\n *\n * Features:\n * - SHA-256 content hashing (first 20 chars)\n * - Sharp-based image metadata\n * - Safe buffer handling\n */\n\nimport { error } from '@sveltejs/kit';\nimport { logger } from '@shared/utils/logger.server';\nimport { sha256 } from '@shared/utils/utils';\n\n/** Hash file content (SHA-256, 20-char hex) */\nexport async function hashFileContent(buffer: ArrayBuffer | Buffer): Promise<string> {\n\tif (!buffer || buffer.byteLength === 0) {\n\t\tthrow error(400, 'Cannot hash empty buffer');\n\t}\n\n\ttry {\n\t\tconst arr = (buffer instanceof Buffer ? buffer : new Uint8Array(buffer)) as any;\n\t\tconst hash = await sha256(arr);\n\t\tconst short = hash.slice(0, 20);\n\n\t\tlogger.debug('File hashed', { size: buffer.byteLength, hash: short });\n\n\t\treturn short;\n\t} catch (err) {\n\t\tconst msg = err instanceof Error ? err.message : String(err);\n\t\tlogger.error('Hashing failed', { size: buffer.byteLength, error: msg });\n\t\tthrow error(500, `Hashing error: ${msg}`);\n\t}\n}\n\n/** Extract image metadata with Sharp */\nexport async function extractMetadata(buffer: Buffer): Promise<import('sharp').Metadata> {\n\ttry {\n\t\tconst sharp = (await import('sharp')).default;\n\t\tconst meta = await sharp(buffer).metadata();\n\n\t\tlogger.debug('Metadata extracted', {\n\t\t\tformat: meta.format,\n\t\t\tsize: meta.size,\n\t\t\twidth: meta.width,\n\t\t\theight: meta.height\n\t\t});\n\n\t\treturn meta;\n\t} catch (err) {\n\t\tconst msg = err instanceof Error ? err.message : String(err);\n\t\tlogger.error('Metadata extraction failed', { size: buffer.length, error: msg });\n\t\tthrow error(500, `Metadata error: ${msg}`);\n\t}\n}\n","/**\n * @file shared/services/src/MediaService.server.ts\n * @description Provides a service class for media operations.\n *\n * ### Features\n * - File Upload\n * - File Storage\n * - File Resizing\n * - File Access Control\n *\n * ### Security\n * - MIME Type Validation\n * - File Size Limiting\n * - File Type Filtering\n * - File Deduplication\n *\n * ### Performance\n * - File Caching\n * - File Deduplication\n * - File Resizing\n *\n * ### Storage\n * - File Storage\n * - File Deduplication\n * - File Resizing\n *\n */\n\nimport { error } from '@sveltejs/kit';\nimport mime from 'mime-types';\nimport Path from 'path';\n\n// Database Interface\nimport type { DatabaseId, IDBAdapter } from '@shared/database/dbInterface';\nimport type { User, Role } from '@shared/database/auth/types';\n\nimport sharp from 'sharp';\nimport type { MediaTypeEnum, MediaAccess, ResizedImage, WatermarkOptions, MediaItem, MediaBase } from '@shared/utils/media/mediaModels';\nimport { MediaType as MediaTypeEnumValue } from '@shared/utils/media/mediaModels';\nimport { getSanitizedFileName } from '@shared/utils/media/mediaProcessing';\nimport { hashFileContent } from '@shared/utils/media/mediaProcessing.server';\nimport { saveFileToDisk, saveResizedImages } from '@shared/utils/media/mediaStorage.server';\n// IMPORT SERVER-SIDE VALIDATION\nimport { validateMediaFileServer } from '@shared/utils/media/mediaUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Media Cache\nimport { cacheService } from '@shared/database/CacheService';\n\n// Types\nimport type { BaseEntity, ISODateString } from '@cms-types/content';\n\n// Extended MediaBase interface to include thumbnails\ninterface MediaBaseWithThumbnails extends MediaBase {\n\tthumbnails?: Record<string, ResizedImage>;\n\toriginalId?: DatabaseId | null;\n}\n\nexport class MediaService {\n\tprivate db: IDBAdapter;\n\tprivate initialized: boolean = false;\n\t// Define your allowed types regex\n\tprivate readonly mimeTypePattern = /^(image|video|audio)\\/(jpeg|png|gif|svg\\+xml|webp|mp4|webm|ogg|mpeg)|(application\\/pdf)$/;\n\n\tconstructor(db: IDBAdapter) {\n\t\tthis.db = db;\n\t\tthis.checkDatabaseConnection();\n\t}\n\n\t// Check if database is connected\n\tprivate checkDatabaseConnection() {\n\t\tif (!this.db) {\n\t\t\tconst message = 'Database adapter is not available';\n\t\t\tlogger.error(message);\n\t\t\tthrow error(500, message);\n\t\t}\n\n\t\tthis.initialized = true;\n\t}\n\n\t// Ensure service is initialized before operations\n\tprivate ensureInitialized() {\n\t\tif (!this.initialized) {\n\t\t\tthis.checkDatabaseConnection();\n\t\t}\n\t}\n\n\t/**\n\t * Uploads a file to storage (disk or cloud)\n\t */\n\tprivate async uploadFile(\n\t\tbuffer: Buffer,\n\t\tfileName: string,\n\t\tmimeType: string,\n\t\tuserId: string,\n\t\tbasePath: string,\n\t\twatermarkOptions?: WatermarkOptions\n\t): Promise<{ url: string; path: string; hash: string; resized: Record<string, ResizedImage> }> {\n\t\tconst startTime = performance.now();\n\n\t\ttry {\n\t\t\tlogger.debug('Starting file upload', { fileName, fileSize: buffer.length, userId });\n\n\t\t\tlet imageBuffer = buffer;\n\n\t\t\t// Apply watermark if options are provided and it's an image\n\t\t\tif (watermarkOptions && mimeType.startsWith('image/')) {\n\t\t\t\ttry {\n\t\t\t\t\tconst watermarkImagePath = Path.join(process.cwd(), 'static', watermarkOptions.url);\n\t\t\t\t\tconst watermarkBuffer = await sharp(watermarkImagePath)\n\t\t\t\t\t\t.resize({\n\t\t\t\t\t\t\twidth: Math.floor((await sharp(imageBuffer).metadata()).width! * (watermarkOptions.scale / 100))\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.png()\n\t\t\t\t\t\t.toBuffer();\n\n\t\t\t\t\timageBuffer = await sharp(imageBuffer)\n\t\t\t\t\t\t.composite([\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinput: watermarkBuffer,\n\t\t\t\t\t\t\t\tgravity: watermarkOptions.position,\n\t\t\t\t\t\t\t\tblend: 'over'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t])\n\t\t\t\t\t\t.toBuffer();\n\t\t\t\t\tlogger.info('Watermark applied successfully', { fileName });\n\t\t\t\t} catch (wmError) {\n\t\t\t\t\tlogger.error('Could not apply watermark', { fileName, error: wmError });\n\t\t\t\t\t// Fail gracefully, proceed with original image\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst hash = await hashFileContent(imageBuffer);\n\t\t\tconst { fileNameWithoutExt, ext } = getSanitizedFileName(fileName);\n\t\t\tconst sanitizedFileName = fileNameWithoutExt;\n\n\t\t\t// Save original image in 'original' subfolder\n\t\t\tconst originalSubfolder = 'original';\n\t\t\tconst originalFileName = `${sanitizedFileName}-${hash}.${ext}`;\n\t\t\t// This is the RELATIVE path, e.g., \"avatars/original/image-hash.jpg\"\n\t\t\tconst relativePath = Path.posix.join(basePath, originalSubfolder, originalFileName);\n\n\t\t\tlogger.debug('Saving original file', { relativePath, basePath, subfolder: originalSubfolder });\n\n\t\t\t// saveFileToDisk handles both local and cloud saving\n\t\t\tconst publicUrl = await saveFileToDisk(imageBuffer, relativePath);\n\n\t\t\t// Process image if it's an image type\n\t\t\tconst isImage = mimeType.startsWith('image/');\n\t\t\tlet resizedImages: Record<string, ResizedImage> = {};\n\n\t\t\tif (isImage && ext !== 'svg') {\n\t\t\t\t// Don't resize SVGs\n\t\t\t\tlogger.debug('Processing image variants', { fileName, mimeType });\n\t\t\t\t// saveResizedImages signature: (buffer, hash, baseName, ext, baseDir)\n\t\t\t\tresizedImages = await saveResizedImages(imageBuffer, hash, sanitizedFileName, ext, basePath);\n\t\t\t}\n\n\t\t\tlogger.info('File upload completed', {\n\t\t\t\tfileName,\n\t\t\t\turl: publicUrl,\n\t\t\t\trelativePath,\n\t\t\t\tfileSize: imageBuffer.length,\n\t\t\t\tisImage,\n\t\t\t\tresizedVariants: Object.keys(resizedImages),\n\t\t\t\ttotalProcessingTime: performance.now() - startTime\n\t\t\t});\n\n\t\t\treturn { url: publicUrl, path: relativePath, hash, resized: resizedImages };\n\t\t} catch (err) {\n\t\t\tconst message = `Error uploading file: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, {\n\t\t\t\tfileName,\n\t\t\t\terror: err,\n\t\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\t\tprocessingTime: performance.now() - startTime\n\t\t\t});\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t/**\n\t * Saves a file to storage and creates a database record.\n\t */\n\n\t// Saves a media file and its associated data\n\tpublic async saveMedia(\n\t\tfile: File,\n\t\tuserId: string,\n\t\taccess: MediaAccess,\n\t\tbasePath: string = 'global',\n\t\twatermarkOptions?: WatermarkOptions,\n\t\toriginalId?: DatabaseId | null\n\t): Promise<MediaItem> {\n\t\tconst startTime = performance.now();\n\t\tthis.ensureInitialized();\n\t\tlogger.trace('Starting media upload process', {\n\t\t\tfilename: file.name,\n\t\t\tfileSize: file.size,\n\t\t\tmimeType: file.type\n\t\t});\n\t\tif (!file) {\n\t\t\tconst message = 'File is required';\n\t\t\tlogger.error(message, { processingTime: performance.now() - startTime });\n\t\t\tthrow Error(message);\n\t\t}\n\n\t\t// Convert File to Buffer\n\t\tconst buffer = Buffer.from(await file.arrayBuffer());\n\t\tconst mimeType = file.type || mime.lookup(file.name) || 'application/octet-stream';\n\n\t\t// USE SERVER-SIDE VALIDATION\n\t\tconst validation = validateMediaFileServer(buffer, file.name, this.mimeTypePattern, 50 * 1024 * 1024); // 50MB limit\n\t\tif (!validation.valid) {\n\t\t\tconst message = `File validation failed: ${validation.message}`;\n\t\t\tlogger.error(message, {\n\t\t\t\tfileName: file.name,\n\t\t\t\tfileSize: file.size,\n\t\t\t\tprocessingTime: performance.now() - startTime\n\t\t\t});\n\t\t\tthrow Error(message);\n\t\t}\n\n\t\ttry {\n\t\t\t// First upload the file and get basic file info\n\t\t\tconst { url, path, hash, resized } = await this.uploadFile(buffer, file.name, mimeType, userId, basePath, watermarkOptions);\n\n\t\t\t// Extract advanced metadata\n\t\t\tconst sharpMeta = await sharp(buffer).metadata();\n\t\t\tconst advancedMetadata = {\n\t\t\t\tformat: sharpMeta.format,\n\t\t\t\twidth: sharpMeta.width,\n\t\t\t\theight: sharpMeta.height,\n\t\t\t\tspace: sharpMeta.space,\n\t\t\t\tchannels: sharpMeta.channels,\n\t\t\t\tdensity: sharpMeta.density,\n\t\t\t\thasProfile: sharpMeta.hasProfile,\n\t\t\t\thasAlpha: sharpMeta.hasAlpha,\n\t\t\t\texif: sharpMeta.exif?.toString('base64'), // Store as base64 to avoid binary issues\n\t\t\t\tiptc: sharpMeta.iptc?.toString('base64'), // Store as base64\n\t\t\t\ticc: sharpMeta.icc?.toString('base64')\n\t\t\t};\n\n\t\t\t// Create media object with required properties\n\t\t\tconst mediaType = this.getMediaType(mimeType);\n\t\t\tif (!mediaType) {\n\t\t\t\tconst message = 'Invalid media type';\n\t\t\t\tlogger.error(message, { mimeType, processingTime: performance.now() - startTime });\n\t\t\t\tthrow Error(message);\n\t\t\t}\n\n\t\t\tconst media: Omit<MediaBaseWithThumbnails, '_id'> = {\n\t\t\t\ttype: mediaType,\n\t\t\t\thash: hash,\n\t\t\t\tfilename: file.name,\n\t\t\t\tpath: path, // Store the relative path\n\t\t\t\turl: url, // Store the public URL\n\t\t\t\tmimeType: mimeType,\n\t\t\t\tsize: file.size,\n\t\t\t\tuser: userId as DatabaseId,\n\t\t\t\tcreatedAt: new Date().toISOString() as ISODateString,\n\t\t\t\tupdatedAt: new Date().toISOString() as ISODateString,\n\t\t\t\tmetadata: {\n\t\t\t\t\toriginalFilename: file.name,\n\t\t\t\t\tuploadedBy: userId,\n\t\t\t\t\tuploadTimestamp: new Date().toISOString(),\n\t\t\t\t\tprocessingTimeMs: performance.now() - startTime,\n\t\t\t\t\tadvancedMetadata: advancedMetadata\n\t\t\t\t},\n\t\t\t\toriginalId: originalId,\n\t\t\t\tversions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\turl: url,\n\t\t\t\t\t\tcreatedAt: new Date().toISOString() as ISODateString,\n\t\t\t\t\t\tcreatedBy: userId as DatabaseId\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\taccess,\n\t\t\t\tthumbnails: resized || {}\n\t\t\t};\n\n\t\t\t// Create clean media object for database storage\n\t\t\tconst cleanMedia = this.createCleanMediaObject(media);\n\n\t\t\tlogger.debug('Saving media to database', {\n\t\t\t\tfilename: cleanMedia.filename,\n\t\t\t\tmimeType: cleanMedia.mimeType,\n\t\t\t\tcollection: 'MediaItem' // <-- Log the correct collection\n\t\t\t});\n\n\t\t\t//  Save to 'MediaItem'\n\t\t\tconst result = await this.db.crud.insert<MediaItem>('MediaItem', cleanMedia);\n\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\tconst mediaId = result.data._id;\n\n\t\t\tlogger.debug('Media saved to database', {\n\t\t\t\tmediaId,\n\t\t\t\tprocessingTime: performance.now() - startTime\n\t\t\t});\n\n\t\t\t// Retrieve the saved media with its ID\n\t\t\tconst findResult = await this.db.crud.findOne<MediaItem>('MediaItem', { _id: mediaId });\n\n\t\t\tif (!findResult.success) {\n\t\t\t\tthrow findResult.error;\n\t\t\t}\n\t\t\tconst savedMedia = findResult.data;\n\n\t\t\t// Cache the saved media\n\t\t\tif (savedMedia) {\n\t\t\t\tawait cacheService.set(`media:${mediaId}`, savedMedia, 3600);\n\t\t\t} else {\n\t\t\t\tlogger.warn('Saved media not found in database', { mediaId });\n\t\t\t}\n\n\t\t\tlogger.info('Media processing completed successfully', {\n\t\t\t\tmediaId,\n\t\t\t\toriginalUrl: (savedMedia as MediaItem).path,\n\t\t\t\tthumbnails: Object.keys((savedMedia as MediaItem).thumbnails ?? {}),\n\t\t\t\ttotalProcessingTime: performance.now() - startTime\n\t\t\t});\n\n\t\t\treturn savedMedia as unknown as MediaItem;\n\t\t} catch (err) {\n\t\t\tconst message = `Error saving media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, {\n\t\t\t\tfileName: file?.name,\n\t\t\t\terror: err,\n\t\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\t\tprocessingTime: performance.now() - startTime\n\t\t\t});\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\tprivate createCleanMediaObject(object: Omit<MediaBaseWithThumbnails, '_id'>): Omit<MediaItem, '_id' | 'createdAt' | 'updatedAt'> {\n\t\t// Type-safe mapping from MediaBaseWithThumbnails to a database-ready object\n\t\treturn {\n\t\t\tfilename: object.filename,\n\t\t\t// originalFilename: object.filename, // Removed as it's not in MediaItem/MediaBase\n\t\t\thash: object.hash,\n\t\t\tpath: object.path,\n\t\t\tsize: object.size,\n\t\t\tmimeType: object.mimeType,\n\t\t\tthumbnails: object.thumbnails || {},\n\t\t\tmetadata: object.metadata || {},\n\t\t\taccess: object.access, // Mapped access\n\t\t\tuser: object.user as DatabaseId,\n\t\t\ttype: object.type as any // Cast to avoid complex union matching issues here\n\t\t\t// createdBy: object.user as DatabaseId,\n\t\t\t// updatedBy: object.user as DatabaseId,\n\t\t\t// originalId: object.originalId\n\t\t} as any; // Using any for now to bypass strict union check for insertion, relying on Runtime valid structure\n\t}\n\n\t// Updates a media item with new data\n\tpublic async updateMedia(id: string, updates: Partial<MediaItem>): Promise<void> {\n\t\tthis.ensureInitialized();\n\t\tif (!id || typeof id !== 'string' || id.trim().length === 0) {\n\t\t\tthrow Error('Invalid id: Must be a non-empty string');\n\t\t}\n\n\t\tif (!updates || typeof updates !== 'object') {\n\t\t\tthrow Error('Invalid updates: Must be a valid MediaItem partial object');\n\t\t}\n\t\ttry {\n\t\t\tconst result = await this.db.crud.update('MediaItem', id as DatabaseId, updates);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\t// Invalidate cache\n\t\t\tawait cacheService.delete(`media:${id}`);\n\t\t\tlogger.info('Media updated successfully', { id });\n\t\t} catch (err) {\n\t\t\tconst message = `Error updating media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Deletes a media item\n\tpublic async deleteMedia(id: string): Promise<void> {\n\t\tthis.ensureInitialized();\n\t\tif (!id || typeof id !== 'string' || id.trim().length === 0) {\n\t\t\tthrow Error('Invalid id: Must be a non-empty string');\n\t\t}\n\t\ttry {\n\t\t\tconst result = await this.db.crud.delete('MediaItem', id as DatabaseId);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\t// Remove from cache\n\t\t\tawait cacheService.delete(`media:${id}`);\n\t\t\tlogger.info('Media deleted successfully', { id });\n\t\t} catch (err) {\n\t\t\tconst message = `Error deleting media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Sets access permissions for a media item\n\tpublic async setMediaAccess(id: string, access: MediaAccess): Promise<void> {\n\t\tthis.ensureInitialized();\n\t\tif (!id || typeof id !== 'string' || id.trim().length === 0) {\n\t\t\tthrow Error('Invalid id: Must be a non-empty string');\n\t\t}\n\n\t\t// Access is now a string union, not array\n\t\ttry {\n\t\t\tconst result = await this.db.crud.update('MediaItem', id as DatabaseId, { access } as unknown as Partial<MediaItem>);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\t// Invalidate cache\n\t\t\tawait cacheService.delete(`media:${id}`);\n\t\t\tlogger.info('Media access updated successfully', { id, access });\n\t\t} catch (err) {\n\t\t\tconst message = `Error setting media access: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Retrieves a media item by its ID, enforcing access control\n\tpublic async getMedia(id: string, user: User, roles: Role[]): Promise<MediaItem> {\n\t\tthis.ensureInitialized();\n\t\tif (!id || typeof id !== 'string' || id.trim().length === 0) {\n\t\t\tthrow Error('Invalid id: Must be a non-empty string');\n\t\t}\n\t\ttry {\n\t\t\t// Check cache first\n\t\t\tconst cachedMedia = await cacheService.get<MediaItem>(`media:${id}`);\n\t\t\tif (cachedMedia) {\n\t\t\t\t// Basic access check for cached items\n\t\t\t\tconst isAdmin = roles.some((r) => r.isAdmin);\n\t\t\t\tif (isAdmin || cachedMedia.user === user._id || cachedMedia.access === 'public') {\n\t\t\t\t\tlogger.info('Media retrieved from cache', { id });\n\t\t\t\t\t// Ensure cached media has URL (in case it was cached without it)\n\t\t\t\t\treturn this.enrichMediaWithUrl(cachedMedia);\n\t\t\t\t}\n\t\t\t\t// If cached but no access, fall through to DB fetch for fresh check (or just deny)\n\t\t\t}\n\n\t\t\tconst result = await this.db.crud.findOne<MediaItem>('MediaItem', { _id: id as DatabaseId });\n\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\tconst media = result.data;\n\n\t\t\tif (!media) {\n\t\t\t\tthrow error(404, 'Media not found');\n\t\t\t}\n\n\t\t\t// Access Control Logic\n\t\t\t// Access Control Logic\n\t\t\tconst isAdmin = roles.some((r) => r.isAdmin);\n\t\t\tconst isOwner = media.user === user._id; // Updated to match MediaBase\n\t\t\tconst isPublic = media.access === 'public';\n\n\t\t\tif (!isAdmin && !isOwner && !isPublic) {\n\t\t\t\t// TODO: Add fine-grained permission check (e.g. 'media.read') if needed\n\t\t\t\tlogger.warn('Access denied to media item', { mediaId: id, userId: user._id, roles: roles.map((r) => r.name) });\n\t\t\t\tthrow error(403, 'Access denied');\n\t\t\t}\n\n\t\t\t// Cache the media for future requests\n\t\t\tawait cacheService.set(`media:${id}`, media, 3600);\n\n\t\t\treturn this.enrichMediaWithUrl(media);\n\t\t} catch (err) {\n\t\t\tconst message = `Error getting media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tif (typeof err === 'object' && err !== null && 'status' in err) {\n\t\t\t\tconst status = (err as { status?: number }).status;\n\t\t\t\tif (status === 403 || status === 404) throw err;\n\t\t\t}\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Helper to add URL to media object\n\tprivate enrichMediaWithUrl(media: MediaItem): MediaItem {\n\t\tlet url = media.path;\n\t\t// If path is already a URL, use it\n\t\tif (url.startsWith('http://') || url.startsWith('https://')) {\n\t\t\t// do nothing\n\t\t} else if (!url.startsWith('/')) {\n\t\t\t// Assume local file path, prepend /files/\n\t\t\turl = `/files/${url}`;\n\t\t}\n\n\t\treturn {\n\t\t\t...media,\n\t\t\turl\n\t\t} as MediaItem;\n\t}\n\n\t// Bulk delete media items\n\tpublic async bulkDeleteMedia(ids: string[]): Promise<void> {\n\t\tthis.ensureInitialized();\n\t\tif (!Array.isArray(ids) || ids.some((id) => typeof id !== 'string' || id.trim().length === 0)) {\n\t\t\tthrow Error('Invalid ids: Must be an array of non-empty strings');\n\t\t}\n\t\ttry {\n\t\t\tconst convertedIds = ids.map((id) => id as DatabaseId);\n\t\t\t// Use `as unknown` to allow for complex query operators like $in\n\t\t\tconst result = await this.db.crud.deleteMany('MediaItem', { _id: { $in: convertedIds } } as unknown as Partial<BaseEntity>);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error;\n\t\t\t}\n\t\t\t// Remove from cache\n\t\t\tawait Promise.all(ids.map((id) => cacheService.delete(`media:${id}`)));\n\t\t\tlogger.info('Bulk media deletion successful', { count: ids.length });\n\t\t} catch (err) {\n\t\t\tconst message = `Error bulk deleting media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Search media items\n\tpublic async searchMedia(query: string, page: number = 1, limit: number = 20): Promise<{ media: MediaItem[]; total: number }> {\n\t\tthis.ensureInitialized();\n\t\ttry {\n\t\t\tconst searchCriteria = {\n\t\t\t\t$or: [{ filename: { $regex: query, $options: 'i' } }, { 'metadata.tags': { $regex: query, $options: 'i' } }]\n\t\t\t};\n\n\t\t\tconst options = { offset: (page - 1) * limit, limit: limit };\n\n\t\t\tconst [mediaResult, totalResult] = await Promise.all([\n\t\t\t\tthis.db.crud.findMany<MediaItem>('MediaItem', searchCriteria as unknown as Partial<MediaItem>, options),\n\t\t\t\tthis.db.crud.count('MediaItem', searchCriteria as unknown as Partial<BaseEntity>)\n\t\t\t]);\n\n\t\t\tif (!mediaResult.success) {\n\t\t\t\tthrow mediaResult.error;\n\t\t\t}\n\t\t\tif (!totalResult.success) {\n\t\t\t\tthrow totalResult.error;\n\t\t\t}\n\n\t\t\treturn { media: mediaResult.data as unknown as MediaItem[], total: totalResult.data };\n\t\t} catch (err) {\n\t\t\tconst message = `Error searching media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// List media items\n\tpublic async listMedia(page: number = 1, limit: number = 20): Promise<{ media: MediaItem[]; total: number }> {\n\t\tthis.ensureInitialized();\n\t\ttry {\n\t\t\tconst options = { offset: (page - 1) * limit, limit: limit };\n\n\t\t\tconst [mediaResult, totalResult] = await Promise.all([\n\t\t\t\tthis.db.crud.findMany<MediaItem>('MediaItem', {}, options),\n\t\t\t\tthis.db.crud.count('MediaItem', {})\n\t\t\t]);\n\n\t\t\tif (!mediaResult.success) {\n\t\t\t\tthrow mediaResult.error;\n\t\t\t}\n\t\t\tif (!totalResult.success) {\n\t\t\t\tthrow totalResult.error;\n\t\t\t}\n\n\t\t\treturn { media: mediaResult.data as unknown as MediaItem[], total: totalResult.data };\n\t\t} catch (err) {\n\t\t\tconst message = `Error listing media: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { error: err });\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Determines the media type based on the MIME type\n\tprivate getMediaType(mimeType: string): MediaTypeEnum {\n\t\tif (!mimeType) throw Error('Mime type is required');\n\n\t\tif (mimeType.startsWith('image/')) {\n\t\t\treturn MediaTypeEnumValue.Image;\n\t\t} else if (mimeType.startsWith('video/')) {\n\t\t\treturn MediaTypeEnumValue.Video;\n\t\t} else if (mimeType.startsWith('audio/')) {\n\t\t\treturn MediaTypeEnumValue.Audio;\n\t\t} else if (mimeType === 'application/pdf') {\n\t\t\treturn MediaTypeEnumValue.Document;\n\t\t} else {\n\t\t\t// Fallback for other document types\n\t\t\tif (mimeType.startsWith('application/') || mimeType.startsWith('text/')) {\n\t\t\t\treturn MediaTypeEnumValue.Document;\n\t\t\t}\n\t\t\tthrow Error(`Unsupported media type: ${mimeType}`);\n\t\t}\n\t}\n\n\tpublic async saveRemoteMedia(url: string, userId: string, access: MediaAccess, basePath: string = 'global'): Promise<MediaItem> {\n\t\tconst response = await fetch(url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`Failed to fetch remote file: ${response.statusText}`);\n\t\t}\n\t\tconst buffer = Buffer.from(await response.arrayBuffer());\n\t\tconst fileName = Path.basename(new URL(url).pathname);\n\t\tconst mimeType = response.headers.get('content-type') || mime.lookup(fileName) || 'application/octet-stream';\n\t\tconst file = new File([buffer], fileName, { type: mimeType });\n\n\t\treturn this.saveMedia(file, userId, access, basePath);\n\t}\n}\n"],"names":["logger","sharp","Path","path","isAdmin","MediaTypeEnumValue"],"mappings":"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"}