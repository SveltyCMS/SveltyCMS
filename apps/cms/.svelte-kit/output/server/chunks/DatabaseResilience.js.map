{"version":3,"file":"DatabaseResilience.js","sources":["../../../../../../shared/database/src/DatabaseResilience.ts"],"sourcesContent":["/**\n * @file src/databases/DatabaseResilience.ts\n * @description Database resilience and self-healing system\n *\n * Features:\n * - Automatic retry with exponential backoff\n * - Self-healing database reconnection\n * - Connection pool diagnostics\n * - Admin notifications on failures\n * - Comprehensive error tracking\n */\n\nimport { logger } from '@shared/utils/logger';\nimport { updateServiceHealth, getSystemState } from '@shared/stores/system';\nimport type { DatabaseError } from './dbInterface';\n\n// Type definitions\nexport interface RetryConfig {\n\tmaxAttempts: number;\n\tinitialDelayMs: number;\n\tmaxDelayMs: number;\n\tbackoffMultiplier: number;\n\tjitterMs: number;\n}\n\nexport interface ConnectionPoolDiagnostics {\n\ttotalConnections: number;\n\tactiveConnections: number;\n\tidleConnections: number;\n\twaitingRequests: number;\n\tpoolUtilization: number;\n\tavgConnectionTime: number;\n\thealthStatus: 'healthy' | 'degraded' | 'critical';\n\trecommendations: string[];\n}\n\nexport interface ResilienceMetrics {\n\ttotalRetries: number;\n\tsuccessfulRetries: number;\n\tfailedRetries: number;\n\ttotalReconnections: number;\n\tsuccessfulReconnections: number;\n\tlastFailureTime?: number;\n\tlastRecoveryTime?: number;\n\taverageRecoveryTime: number;\n\tconnectionUptime: number;\n\tfailureHistory: Array<{\n\t\ttimestamp: number;\n\t\terror: string;\n\t\trecovered: boolean;\n\t\trecoveryTime?: number;\n\t}>;\n}\n\n// Default retry configuration\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n\tmaxAttempts: 5,\n\tinitialDelayMs: 1000, // 1 second\n\tmaxDelayMs: 32000, // 32 seconds\n\tbackoffMultiplier: 2,\n\tjitterMs: 500\n};\n\n/**\n * Database Resilience Manager\n * Handles automatic retries, reconnection, and health monitoring\n */\nexport class DatabaseResilience {\n\tprivate metrics: ResilienceMetrics = {\n\t\ttotalRetries: 0,\n\t\tsuccessfulRetries: 0,\n\t\tfailedRetries: 0,\n\t\ttotalReconnections: 0,\n\t\tsuccessfulReconnections: 0,\n\t\taverageRecoveryTime: 0,\n\t\tconnectionUptime: 0,\n\t\tfailureHistory: []\n\t};\n\n\tprivate retryConfig: RetryConfig;\n\tprivate isReconnecting = false;\n\tprivate connectionEstablishedAt?: number;\n\tprivate monitoringInterval?: NodeJS.Timeout;\n\n\tconstructor(config?: Partial<RetryConfig>) {\n\t\tthis.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...config };\n\t\tthis.startHealthMonitoring();\n\t}\n\n\t// Execute operation with automatic retry and exponential backoff\n\tasync executeWithRetry<T>(operation: () => Promise<T>, operationName: string, onRetry?: (attempt: number, error: Error) => void): Promise<T> {\n\t\tlet lastError: Error | undefined;\n\n\t\tfor (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {\n\t\t\ttry {\n\t\t\t\tconst result = await operation();\n\n\t\t\t\tif (attempt > 1) {\n\t\t\t\t\t// Operation succeeded after retry\n\t\t\t\t\tthis.metrics.successfulRetries++;\n\t\t\t\t\tlogger.info(`âœ“ Operation '${operationName}' succeeded after ${attempt} attempt(s)`);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error as Error;\n\t\t\t\tthis.metrics.totalRetries++;\n\n\t\t\t\tif (attempt < this.retryConfig.maxAttempts) {\n\t\t\t\t\tconst delay = this.calculateBackoffDelay(attempt);\n\n\t\t\t\t\tlogger.warn(`Operation '${operationName}' failed (attempt ${attempt}/${this.retryConfig.maxAttempts}), retrying in ${delay}ms...`, {\n\t\t\t\t\t\terror: lastError.message\n\t\t\t\t\t});\n\n\t\t\t\t\t// Call retry callback if provided\n\t\t\t\t\tif (onRetry) {\n\t\t\t\t\t\tonRetry(attempt, lastError);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this.sleep(delay);\n\t\t\t\t} else {\n\t\t\t\t\tthis.metrics.failedRetries++;\n\t\t\t\t\tlogger.error(`Operation '${operationName}' failed after ${this.retryConfig.maxAttempts} attempts`, { error: lastError.message });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow lastError || new Error(`Operation '${operationName}' failed after all retry attempts`);\n\t}\n\n\t// Attempt to reconnect to database with self-healing\n\tasync attemptReconnection(reconnectFn: () => Promise<void>, notifyAdmins: (error: DatabaseError) => Promise<void>): Promise<boolean> {\n\t\tif (this.isReconnecting) {\n\t\t\tlogger.debug('Reconnection already in progress, skipping...');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.isReconnecting = true;\n\t\tthis.metrics.totalReconnections++;\n\n\t\tconst startTime = Date.now();\n\t\tconst failureRecord = {\n\t\t\ttimestamp: startTime,\n\t\t\terror: 'Connection lost',\n\t\t\trecovered: false,\n\t\t\trecoveryTime: undefined as number | undefined\n\t\t};\n\n\t\ttry {\n\t\t\tupdateServiceHealth('database', 'initializing', 'Attempting database reconnection...');\n\n\t\t\tawait this.executeWithRetry(reconnectFn, 'Database Reconnection', (attempt, error) => {\n\t\t\t\tupdateServiceHealth('database', 'unhealthy', `Reconnection attempt ${attempt}/${this.retryConfig.maxAttempts} failed: ${error.message}`);\n\t\t\t});\n\n\t\t\tconst recoveryTime = Date.now() - startTime;\n\t\t\tfailureRecord.recovered = true;\n\t\t\tfailureRecord.recoveryTime = recoveryTime;\n\n\t\t\tthis.metrics.successfulReconnections++;\n\t\t\tthis.metrics.lastRecoveryTime = Date.now();\n\t\t\tthis.updateAverageRecoveryTime(recoveryTime);\n\t\t\tthis.connectionEstablishedAt = Date.now();\n\n\t\t\tupdateServiceHealth('database', 'healthy', 'Database reconnected successfully');\n\t\t\tlogger.info(`âœ“ Database reconnected successfully in ${recoveryTime}ms`);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconst dbError: DatabaseError = {\n\t\t\t\tcode: 'RECONNECTION_FAILED',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error',\n\t\t\t\tdetails: { attempts: this.retryConfig.maxAttempts }\n\t\t\t};\n\n\t\t\tthis.metrics.lastFailureTime = Date.now();\n\t\t\tupdateServiceHealth('database', 'unhealthy', 'Database reconnection failed', dbError.message);\n\n\t\t\t// Notify admins of persistent failure\n\t\t\tawait notifyAdmins(dbError);\n\n\t\t\tlogger.fatal('Database reconnection failed after all attempts', { error: dbError });\n\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tthis.metrics.failureHistory.push(failureRecord);\n\t\t\t// Keep only last 50 failure records\n\t\t\tif (this.metrics.failureHistory.length > 50) {\n\t\t\t\tthis.metrics.failureHistory = this.metrics.failureHistory.slice(-50);\n\t\t\t}\n\t\t\tthis.isReconnecting = false;\n\t\t}\n\t}\n\n\t/**\n\t * Get connection pool diagnostics\n\t * Fetches real-time statistics from MongoDB connection pool\n\t */\n\tasync getPoolDiagnostics(): Promise<ConnectionPoolDiagnostics> {\n\t\ttry {\n\t\t\t// Import mongoose dynamically to get pool stats\n\t\t\tconst mongoose = await import('mongoose');\n\n\t\t\t// Get connection pool stats from mongoose\n\t\t\tconst poolStats = await this.getMongoosePoolStats(mongoose.default);\n\n\t\t\tconst poolUtilization = poolStats.total > 0 ? (poolStats.active / poolStats.total) * 100 : 0;\n\t\t\tconst healthStatus = this.determinePoolHealth(poolUtilization, poolStats.waiting);\n\t\t\tconst recommendations = this.generatePoolRecommendations(poolStats, poolUtilization);\n\n\t\t\treturn {\n\t\t\t\ttotalConnections: poolStats.total,\n\t\t\t\tactiveConnections: poolStats.active,\n\t\t\t\tidleConnections: poolStats.idle,\n\t\t\t\twaitingRequests: poolStats.waiting,\n\t\t\t\tpoolUtilization,\n\t\t\t\tavgConnectionTime: poolStats.avgConnectionTime,\n\t\t\t\thealthStatus,\n\t\t\t\trecommendations\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to get pool diagnostics', { error });\n\n\t\t\t// Return default diagnostics on error\n\t\t\treturn {\n\t\t\t\ttotalConnections: 0,\n\t\t\t\tactiveConnections: 0,\n\t\t\t\tidleConnections: 0,\n\t\t\t\twaitingRequests: 0,\n\t\t\t\tpoolUtilization: 0,\n\t\t\t\tavgConnectionTime: 0,\n\t\t\t\thealthStatus: 'critical',\n\t\t\t\trecommendations: ['Unable to retrieve pool statistics - database may be disconnected']\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get MongoDB-specific pool statistics from mongoose connection\n\tprivate async getMongoosePoolStats(mongoose: typeof import('mongoose')): Promise<{\n\t\ttotal: number;\n\t\tactive: number;\n\t\tidle: number;\n\t\twaiting: number;\n\t\tavgConnectionTime: number;\n\t}> {\n\t\t// Check if connected\n\t\tif (mongoose.connection.readyState !== 1) {\n\t\t\treturn {\n\t\t\t\ttotal: 0,\n\t\t\t\tactive: 0,\n\t\t\t\tidle: 0,\n\t\t\t\twaiting: 0,\n\t\t\t\tavgConnectionTime: 0\n\t\t\t};\n\t\t}\n\n\t\t// Get pool stats from connection\n\t\t// Note: mongoose doesn't expose detailed pool stats directly\n\t\t// We'll use the connection config and infer from connection state\n\t\t// const client = mongoose.connection.getClient();\n\n\t\t// Try to get pool stats from MongoDB driver\n\t\tconst poolStats = {\n\t\t\ttotal: 50, // Default maxPoolSize from config\n\t\t\tactive: 0,\n\t\t\tidle: 0,\n\t\t\twaiting: 0,\n\t\t\tavgConnectionTime: 0\n\t\t};\n\n\t\ttry {\n\t\t\t// TODO: Revisit this code to get pool stats without accessing internal properties\n\t\t\t// // Access internal pool stats if available (MongoDB Node.js driver specific)\n\t\t\t// const topology = client?.topology;\n\t\t\t// if (topology && typeof topology.s === 'object') {\n\t\t\t// \tconst servers = topology.s.servers;\n\t\t\t// \tif (servers && servers.size > 0) {\n\t\t\t// \t\tconst serverArray = Array.from(servers.values());\n\t\t\t// \t\tconst firstServer = serverArray[0];\n\t\t\t// \t\tif (firstServer?.s?.pool) {\n\t\t\t// \t\t\tconst pool = firstServer.s.pool;\n\t\t\t// \t\t\t// Try to get current connections count\n\t\t\t// \t\t\tconst totalConnections = pool.totalConnectionCount || pool.s?.options?.maxPoolSize || 50;\n\t\t\t// \t\t\tconst availableConnections = pool.availableConnectionCount || 0;\n\t\t\t// \t\t\tconst pendingConnections = pool.pendingConnectionCount || 0;\n\t\t\t// \t\t\tpoolStats = {\n\t\t\t// \t\t\t\ttotal: totalConnections,\n\t\t\t// \t\t\t\tactive: totalConnections - availableConnections,\n\t\t\t// \t\t\t\tidle: availableConnections,\n\t\t\t// \t\t\t\twaiting: pendingConnections,\n\t\t\t// \t\t\t\tavgConnectionTime: 0 // Not available from pool\n\t\t\t// \t\t\t};\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t} catch (err) {\n\t\t\t// If we can't access internal stats, return defaults\n\t\t\tlogger.debug('Unable to access detailed MongoDB pool stats, using defaults', { error: err });\n\t\t}\n\n\t\treturn poolStats;\n\t}\n\n\t// Get resilience metrics\n\tgetMetrics(): ResilienceMetrics {\n\t\tconst uptime = this.connectionEstablishedAt ? Date.now() - this.connectionEstablishedAt : 0;\n\n\t\treturn {\n\t\t\t...this.metrics,\n\t\t\tconnectionUptime: uptime\n\t\t};\n\t}\n\n\t// Check if database connection is healthy\n\tasync healthCheck(pingFn: () => Promise<number>): Promise<{\n\t\thealthy: boolean;\n\t\tlatency: number;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst latency = await pingFn();\n\n\t\t\tconst healthy = latency < 1000; // Consider healthy if latency < 1s\n\t\t\tconst message = healthy ? `Database healthy (latency: ${latency}ms)` : `Database degraded (latency: ${latency}ms)`;\n\n\t\t\treturn { healthy, latency, message };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\thealthy: false,\n\t\t\t\tlatency: -1,\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Health check failed'\n\t\t\t};\n\t\t}\n\t}\n\n\t// Start continuous health monitoring\n\tprivate startHealthMonitoring(): void {\n\t\t// Monitor every 30 seconds\n\t\tthis.monitoringInterval = setInterval(() => {\n\t\t\tthis.updateConnectionUptime();\n\t\t}, 30000);\n\t}\n\n\t// Stop health monitoring (cleanup)\n\tstop(): void {\n\t\tif (this.monitoringInterval) {\n\t\t\tclearInterval(this.monitoringInterval);\n\t\t\tthis.monitoringInterval = undefined;\n\t\t}\n\t}\n\n\t// Calculate exponential backoff delay with jitter\n\tprivate calculateBackoffDelay(attempt: number): number {\n\t\tconst exponentialDelay = Math.min(\n\t\t\tthis.retryConfig.initialDelayMs * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1),\n\t\t\tthis.retryConfig.maxDelayMs\n\t\t);\n\n\t\t// Add random jitter to prevent thundering herd\n\t\tconst jitter = Math.random() * this.retryConfig.jitterMs;\n\n\t\treturn Math.floor(exponentialDelay + jitter);\n\t}\n\n\t// Sleep utility\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n\n\t// Update average recovery time with exponential moving average\n\tprivate updateAverageRecoveryTime(newRecoveryTime: number): void {\n\t\tif (this.metrics.averageRecoveryTime === 0) {\n\t\t\tthis.metrics.averageRecoveryTime = newRecoveryTime;\n\t\t} else {\n\t\t\t// EMA with alpha = 0.3\n\t\t\tthis.metrics.averageRecoveryTime = 0.3 * newRecoveryTime + 0.7 * this.metrics.averageRecoveryTime;\n\t\t}\n\t}\n\n\t// Update connection uptime\n\tprivate updateConnectionUptime(): void {\n\t\tif (this.connectionEstablishedAt) {\n\t\t\tthis.metrics.connectionUptime = Date.now() - this.connectionEstablishedAt;\n\t\t}\n\t}\n\n\t// Determine pool health status based on metrics\n\tprivate determinePoolHealth(utilization: number, waiting: number): 'healthy' | 'degraded' | 'critical' {\n\t\tif (waiting > 10 || utilization > 90) {\n\t\t\treturn 'critical';\n\t\t}\n\t\tif (waiting > 5 || utilization > 75) {\n\t\t\treturn 'degraded';\n\t\t}\n\t\treturn 'healthy';\n\t}\n\n\t// Generate recommendations based on pool stats\n\tprivate generatePoolRecommendations(stats: { total: number; active: number; idle: number; waiting: number }, utilization: number): string[] {\n\t\tconst recommendations: string[] = [];\n\n\t\tif (utilization > 90) {\n\t\t\trecommendations.push('Pool utilization is very high (>90%). Consider increasing maxPoolSize.');\n\t\t}\n\n\t\tif (stats.waiting > 10) {\n\t\t\trecommendations.push(`${stats.waiting} requests are waiting for connections. Increase pool size or optimize queries.`);\n\t\t}\n\n\t\tif (stats.idle > stats.total * 0.8) {\n\t\t\trecommendations.push('Pool has many idle connections. Consider reducing minPoolSize to save resources.');\n\t\t}\n\n\t\tif (stats.total < 10) {\n\t\t\trecommendations.push('Pool size is very small. Consider increasing for better concurrency.');\n\t\t}\n\n\t\tif (recommendations.length === 0) {\n\t\t\trecommendations.push('Connection pool is healthy and well-configured.');\n\t\t}\n\n\t\treturn recommendations;\n\t}\n}\n\n// Send email notification to administrators\nexport async function notifyAdminsOfDatabaseFailure(error: DatabaseError, metrics: ResilienceMetrics): Promise<void> {\n\ttry {\n\t\t// Check if SMTP is configured\n\t\tconst { getPrivateSetting } = await import(/* @vite-ignore */ '@shared/services/settingsService');\n\t\tconst smtpHost = await getPrivateSetting('SMTP_HOST');\n\n\t\tif (!smtpHost) {\n\t\t\tlogger.debug('SMTP not configured, skipping admin notification email');\n\t\t\treturn;\n\t\t}\n\n\t\t// Get admin users\n\t\t// Use relative path to avoid alias resolution issues\n\t\tconst { auth } = await import(/* @vite-ignore */ './db');\n\t\tif (!auth) {\n\t\t\tlogger.warn('Auth service not available, cannot fetch admin users for notification');\n\t\t\treturn;\n\t\t}\n\n\t\tconst allUsers = await auth.getAllUsers();\n\t\tconst adminUsers = allUsers.filter((user) => user.role === 'admin');\n\t\tif (!adminUsers || adminUsers.length === 0) {\n\t\t\tlogger.warn('No admin users found to notify');\n\t\t\treturn;\n\t\t}\n\n\t\t// Prepare email data\n\t\tconst { publicEnv } = await import(/* @vite-ignore */ '@shared/stores/globalSettings.svelte');\n\t\tconst systemState = getSystemState();\n\n\t\tconst emailData = {\n\t\t\tsubject: `ðŸš¨ Critical: Database Connection Failure - ${publicEnv.SITE_NAME || 'SveltyCMS'}`,\n\t\t\trecipientEmail: adminUsers.map((u) => u.email).filter(Boolean),\n\t\t\ttemplateName: 'databaseFailure',\n\t\t\tprops: {\n\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS',\n\t\t\t\terror: {\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tmessage: error.message,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t},\n\t\t\t\tmetrics: {\n\t\t\t\t\ttotalReconnections: metrics.totalReconnections,\n\t\t\t\t\tsuccessfulReconnections: metrics.successfulReconnections,\n\t\t\t\t\tfailedRetries: metrics.failedRetries,\n\t\t\t\t\taverageRecoveryTime: Math.round(metrics.averageRecoveryTime),\n\t\t\t\t\tlastFailureTime: metrics.lastFailureTime ? new Date(metrics.lastFailureTime).toISOString() : 'Unknown'\n\t\t\t\t},\n\t\t\t\tsystemState: {\n\t\t\t\t\toverall: systemState.overallState,\n\t\t\t\t\tdatabaseStatus: systemState.services.database.status,\n\t\t\t\t\tdatabaseMessage: systemState.services.database.message\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\thostLink: publicEnv.HOST_PROD || `http://localhost:5173`\n\t\t\t}\n\t\t};\n\n\t\t// Send email via API (server-side fetch)\n\t\tconst response = await fetch('/api/sendMail', {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\tbody: JSON.stringify(emailData)\n\t\t});\n\n\t\tif (response.ok) {\n\t\t\tlogger.info(`Database failure notification sent to ${adminUsers.length} admin(s)`);\n\t\t} else {\n\t\t\tlogger.error(`Failed to send database failure notification: ${response.status}`);\n\t\t}\n\t} catch (notificationError) {\n\t\tlogger.error('Error sending admin notification', { error: notificationError });\n\t\t// Don't throw - notification failure shouldn't block other operations\n\t}\n}\n\n// Global resilience instance (singleton)\nlet resilienceInstance: DatabaseResilience | null = null;\n\nexport function getDatabaseResilience(config?: Partial<RetryConfig>): DatabaseResilience {\n\tif (!resilienceInstance) {\n\t\tresilienceInstance = new DatabaseResilience(config);\n\t}\n\treturn resilienceInstance;\n}\n\nexport function resetDatabaseResilience(): void {\n\tif (resilienceInstance) {\n\t\tresilienceInstance.stop();\n\t\tresilienceInstance = null;\n\t}\n}\n"],"names":[],"mappings":"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"}