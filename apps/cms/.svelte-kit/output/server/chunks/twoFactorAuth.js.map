{"version":3,"file":"twoFactorAuth.js","sources":["../../../../../../shared/database/src/auth/totp.ts","../../../../../../shared/database/src/auth/twoFactorAuth.ts"],"sourcesContent":["/**\n * @file src/databases/auth/totp.ts\n * @description Time-based One-Time Password (TOTP) implementation for two-factor authentication\n * using only Node.js built-in crypto module. It follows RFC 6238 standard.\n *\n * Features:\n * - Generate TOTP secrets\n * - Generate QR code URLs for authenticator apps\n * - Generate manual entry details\n * - Generate current TOTP codes\n * - Verify TOTP codes with time drift tolerance\n * - Generate and verify backup codes\n * - Validate TOTP secret format\n *\n * Note: This implementation avoids external dependencies to keep the bundle size minimal.\n */\n\n// Server-side only: Dynamic import to prevent bundling in client code\nlet crypto: typeof import('node:crypto');\n\nasync function getCrypto() {\n\tif (!crypto) {\n\t\tcrypto = await import('node:crypto');\n\t}\n\treturn crypto;\n}\n\nconst TOTP_CONFIG = {\n\tSECRET_LENGTH: 20,\n\tWINDOW: 1,\n\tSTEP: 30,\n\tDIGITS: 6,\n\tALGORITHM: 'sha1' as const\n};\n\n// Base32 encoding (RFC 4648)\nconst BASE32_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\nfunction base32Encode(buffer: Buffer): string {\n\tlet bits = 0;\n\tlet value = 0;\n\tlet output = '';\n\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tvalue = (value << 8) | buffer[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\toutput += BASE32_CHARS[(value >>> (bits - 5)) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\toutput += BASE32_CHARS[(value << (5 - bits)) & 31];\n\t}\n\n\t// Add padding\n\twhile (output.length % 8 !== 0) {\n\t\toutput += '=';\n\t}\n\n\treturn output;\n}\n\nfunction base32Decode(encoded: string): Buffer {\n\t// Remove padding and convert to uppercase\n\tencoded = encoded.replace(/=+$/, '').toUpperCase();\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\tconst output = Buffer.alloc(Math.ceil((encoded.length * 5) / 8));\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst char = encoded[i];\n\t\tconst charValue = BASE32_CHARS.indexOf(char);\n\n\t\tif (charValue === -1) {\n\t\t\tthrow new Error(`Invalid base32 character: ${char}`);\n\t\t}\n\n\t\tvalue = (value << 5) | charValue;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\toutput[index++] = (value >>> (bits - 8)) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn output.subarray(0, index);\n}\n\nexport async function generateTOTPSecret(): Promise<string> {\n\tconst cryptoModule = await getCrypto();\n\tconst buffer = cryptoModule.randomBytes(TOTP_CONFIG.SECRET_LENGTH);\n\treturn base32Encode(buffer);\n}\n\nexport function generateQRCodeURL(secret: string, userEmail: string, serviceName: string): string {\n\tconst label = encodeURIComponent(`${serviceName}:${userEmail}`);\n\tconst issuer = encodeURIComponent(serviceName);\n\treturn `otpauth://totp/${label}?secret=${secret}&issuer=${issuer}`;\n}\n\nexport function generateManualEntryDetails(\n\tsecret: string,\n\tuserEmail: string,\n\tserviceName: string\n): {\n\taccount: string;\n\tsecret: string;\n\tissuer: string;\n\talgorithm: string;\n\tdigits: number;\n\tperiod: number;\n} {\n\treturn {\n\t\taccount: userEmail,\n\t\tsecret: secret,\n\t\tissuer: serviceName,\n\t\talgorithm: TOTP_CONFIG.ALGORITHM,\n\t\tdigits: TOTP_CONFIG.DIGITS,\n\t\tperiod: TOTP_CONFIG.STEP\n\t};\n}\n\nexport async function getCurrentTOTPCode(secret: string): Promise<string> {\n\tconst cryptoModule = await getCrypto();\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst counter = Math.floor(now / TOTP_CONFIG.STEP);\n\n\tconst keyBuffer = base32Decode(secret);\n\tconst counterBuffer = Buffer.alloc(8);\n\tcounterBuffer.writeUInt32BE(Math.floor(counter / 0x100000000), 0);\n\tcounterBuffer.writeUInt32BE(counter & 0xffffffff, 4);\n\n\tconst hmac = cryptoModule.createHmac(TOTP_CONFIG.ALGORITHM, keyBuffer);\n\thmac.update(counterBuffer);\n\tconst digest = hmac.digest();\n\n\tconst offset = digest[digest.length - 1] & 0xf;\n\tconst truncated =\n\t\t((digest[offset] & 0x7f) << 24) | ((digest[offset + 1] & 0xff) << 16) | ((digest[offset + 2] & 0xff) << 8) | (digest[offset + 3] & 0xff);\n\n\tconst code = (truncated % Math.pow(10, TOTP_CONFIG.DIGITS)).toString().padStart(TOTP_CONFIG.DIGITS, '0');\n\treturn code;\n}\n\nexport async function verifyTOTPCode(secret: string, userCode: string): Promise<boolean> {\n\tif (!userCode || userCode.length !== TOTP_CONFIG.DIGITS) {\n\t\treturn false;\n\t}\n\n\tconst cryptoModule = await getCrypto();\n\tconst now = Math.floor(Date.now() / 1000);\n\n\t// Check current window and adjacent windows (for time drift tolerance)\n\tfor (let i = -TOTP_CONFIG.WINDOW; i <= TOTP_CONFIG.WINDOW; i++) {\n\t\tconst counter = Math.floor(now / TOTP_CONFIG.STEP) + i;\n\n\t\tconst keyBuffer = base32Decode(secret);\n\t\tconst counterBuffer = Buffer.alloc(8);\n\t\tcounterBuffer.writeUInt32BE(Math.floor(counter / 0x100000000), 0);\n\t\tcounterBuffer.writeUInt32BE(counter & 0xffffffff, 4);\n\n\t\tconst hmac = cryptoModule.createHmac(TOTP_CONFIG.ALGORITHM, keyBuffer);\n\t\thmac.update(counterBuffer);\n\t\tconst digest = hmac.digest();\n\n\t\tconst offset = digest[digest.length - 1] & 0xf;\n\t\tconst truncated =\n\t\t\t((digest[offset] & 0x7f) << 24) | ((digest[offset + 1] & 0xff) << 16) | ((digest[offset + 2] & 0xff) << 8) | (digest[offset + 3] & 0xff);\n\n\t\tconst code = (truncated % Math.pow(10, TOTP_CONFIG.DIGITS)).toString().padStart(TOTP_CONFIG.DIGITS, '0');\n\n\t\t// Timing-safe comparison\n\t\tif (code === userCode) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function generateBackupCodes(count: number = 10): Promise<string[]> {\n\tconst cryptoModule = await getCrypto();\n\tconst codes: string[] = [];\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst code = cryptoModule.randomBytes(4).toString('hex').toUpperCase();\n\t\tcodes.push(code);\n\t}\n\n\treturn codes;\n}\n\nexport async function hashBackupCode(code: string): Promise<string> {\n\tconst cryptoModule = await getCrypto();\n\treturn cryptoModule.createHash('sha256').update(code.toLowerCase()).digest('hex');\n}\n\nexport async function verifyBackupCode(code: string, hashedCode: string): Promise<boolean> {\n\tconst cryptoModule = await getCrypto();\n\tconst hash = cryptoModule.createHash('sha256').update(code.toLowerCase()).digest('hex');\n\treturn cryptoModule.timingSafeEqual(Buffer.from(hash), Buffer.from(hashedCode));\n}\n\nexport function isValidTOTPSecret(secret: string): boolean {\n\t// Basic validation for base32 encoded secret\n\tconst base32Regex = /^[A-Z2-7]+=*$/;\n\treturn typeof secret === 'string' && secret.length >= 16 && base32Regex.test(secret);\n}\n","/**\n * @file src/databases/auth/twoFactorAuth.ts\n * @description Two-Factor Authentication service layer\n *\n * This module provides high-level 2FA operations that integrate with the auth system.\n * It handles user 2FA setup, verification, backup codes, and recovery.\n *\n * Features:\n * - Setup and enable 2FA for users\n * - Verify 2FA codes during login\n * - Generate and manage backup codes\n * - Disable 2FA with proper verification\n * - Multi-tenant aware operations\n */\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\nimport type { IDBAdapter, ISODateString } from '@shared/database/dbInterface';\nimport {\n\tgenerateBackupCodes,\n\tgenerateManualEntryDetails,\n\tgenerateQRCodeURL,\n\tgenerateTOTPSecret,\n\thashBackupCode,\n\tisValidTOTPSecret,\n\tverifyBackupCode,\n\tverifyTOTPCode\n} from './totp';\nimport type { TwoFactorSetupResponse, TwoFactorVerificationResult } from './twoFactorAuthTypes';\nimport type { User } from './types';\n\n// Re-export types for compatibility\nexport type { TwoFactorSetupResponse, TwoFactorVerificationResult } from './twoFactorAuthTypes';\n\n// Type for the auth interface extracted from IDBAdapter\ntype AuthInterface = IDBAdapter['auth'];\n\n// Two-Factor Authentication Service\nexport class TwoFactorAuthService {\n\tprivate db: AuthInterface;\n\tprivate serviceName: string;\n\n\tconstructor(db: AuthInterface, serviceName: string = 'SveltyCMS') {\n\t\tthis.db = db;\n\t\tthis.serviceName = serviceName;\n\t}\n\n\t/**\n\t * Initialize 2FA setup for a user\n\t * This generates a new secret and backup codes but doesn't enable 2FA yet\n\t */\n\tasync initiate2FASetup(userId: string, userEmail: string, tenantId?: string): Promise<TwoFactorSetupResponse> {\n\t\ttry {\n\t\t\tlogger.info('Initiating 2FA setup', { userId, tenantId });\n\n\t\t\t// Generate new TOTP secret (now async)\n\t\t\tconst secret = await generateTOTPSecret();\n\n\t\t\t// Generate QR code URL for authenticator apps\n\t\t\tconst qrCodeURL = generateQRCodeURL(secret, userEmail, this.serviceName);\n\n\t\t\t// Generate manual entry details for apps that don't support QR codes\n\t\t\tconst manualEntryDetails = generateManualEntryDetails(secret, userEmail, this.serviceName);\n\n\t\t\t// Generate backup codes (now async)\n\t\t\tconst backupCodes = await generateBackupCodes(10);\n\n\t\t\t// Return setup information (don't save to DB yet)\n\t\t\tconst response: TwoFactorSetupResponse = {\n\t\t\t\tsecret,\n\t\t\t\tqrCodeURL,\n\t\t\t\tmanualEntryDetails,\n\t\t\t\tbackupCodes: [...backupCodes] // Return plain codes to user\n\t\t\t};\n\n\t\t\tlogger.info('2FA setup initiated successfully', { userId, tenantId });\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to initiate 2FA setup: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t/**\n\t * Complete 2FA setup by verifying the first TOTP code\n\t * This enables 2FA for the user and saves the secret and backup codes\n\t */\n\tasync complete2FASetup(userId: string, secret: string, verificationCode: string, backupCodes: string[], tenantId?: string): Promise<boolean> {\n\t\ttry {\n\t\t\tlogger.info('Completing 2FA setup', { userId, tenantId });\n\n\t\t\t// Validate the secret\n\t\t\tif (!isValidTOTPSecret(secret)) {\n\t\t\t\tthrow new Error('Invalid TOTP secret format');\n\t\t\t}\n\n\t\t\t// Verify the TOTP code (now async)\n\t\t\tif (!(await verifyTOTPCode(secret, verificationCode))) {\n\t\t\t\tlogger.warn('2FA setup failed - invalid verification code', { userId, tenantId });\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Hash backup codes for secure storage (now async)\n\t\t\tconst hashedBackupCodes = await Promise.all(backupCodes.map((code) => hashBackupCode(code)));\n\n\t\t\t// Update user with 2FA settings\n\t\t\tconst updateData: Partial<User> = {\n\t\t\t\tis2FAEnabled: true,\n\t\t\t\ttotpSecret: secret,\n\t\t\t\tbackupCodes: hashedBackupCodes,\n\t\t\t\tlast2FAVerification: new Date().toISOString() as ISODateString\n\t\t\t};\n\n\t\t\tconst result = await this.db.updateUserAttributes(userId, updateData, tenantId);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow new Error('Failed to update user 2FA settings');\n\t\t\t}\n\n\t\t\tlogger.info('2FA setup completed successfully', { userId, tenantId });\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to complete 2FA setup: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t/**\n\t * Verify 2FA code during authentication\n\t * Supports both TOTP codes and backup codes\n\t */\n\tasync verify2FA(userId: string, code: string, tenantId?: string): Promise<TwoFactorVerificationResult> {\n\t\ttry {\n\t\t\tlogger.debug('Verifying 2FA code', { userId, tenantId });\n\n\t\t\t// Get user data\n\t\t\tconst userResult = await this.db.getUserById(userId, tenantId);\n\t\t\tif (!userResult.success || !userResult.data) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'User not found'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst user = userResult.data;\n\n\t\t\t// Check if 2FA is enabled\n\t\t\tif (!user.is2FAEnabled) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: '2FA is not enabled for this user'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// First try TOTP verification (now async)\n\t\t\tif (user.totpSecret && (await verifyTOTPCode(user.totpSecret, code))) {\n\t\t\t\t// Update last verification time\n\t\t\t\tawait this.db.updateUserAttributes(\n\t\t\t\t\tuserId,\n\t\t\t\t\t{\n\t\t\t\t\t\tlast2FAVerification: new Date().toISOString() as ISODateString\n\t\t\t\t\t},\n\t\t\t\t\ttenantId\n\t\t\t\t);\n\n\t\t\t\tlogger.info('2FA verification successful via TOTP', { userId, tenantId });\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmethod: 'totp',\n\t\t\t\t\tmessage: '2FA verification successful'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Try backup code verification (now async)\n\t\t\tif (user.backupCodes && user.backupCodes.length > 0) {\n\t\t\t\tfor (let i = 0; i < user.backupCodes.length; i++) {\n\t\t\t\t\tconst hashedCode = user.backupCodes[i];\n\t\t\t\t\tif (await verifyBackupCode(code, hashedCode)) {\n\t\t\t\t\t\t// Remove used backup code\n\t\t\t\t\t\tconst updatedBackupCodes = [...user.backupCodes];\n\t\t\t\t\t\tupdatedBackupCodes.splice(i, 1);\n\n\t\t\t\t\t\t// Update user with remaining backup codes\n\t\t\t\t\t\tawait this.db.updateUserAttributes(\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbackupCodes: updatedBackupCodes,\n\t\t\t\t\t\t\t\tlast2FAVerification: new Date().toISOString() as ISODateString\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttenantId\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlogger.info('2FA verification successful via backup code', {\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\ttenantId,\n\t\t\t\t\t\t\tremainingBackupCodes: updatedBackupCodes.length\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tmethod: 'backup',\n\t\t\t\t\t\t\tmessage: `2FA verification successful using backup code. ${updatedBackupCodes.length} backup codes remaining.`,\n\t\t\t\t\t\t\tbackupCodeUsed: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.warn('2FA verification failed', { userId, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid 2FA code'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst message = `2FA verification error: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: '2FA verification failed due to system error'\n\t\t\t};\n\t\t}\n\t}\n\n\t// Disable 2FA for a user (requires current password or admin permission)\n\tasync disable2FA(userId: string, tenantId?: string): Promise<boolean> {\n\t\ttry {\n\t\t\tlogger.info('Disabling 2FA', { userId, tenantId });\n\n\t\t\t// Update user to disable 2FA and clear secrets\n\t\t\tconst updateData: Partial<User> = {\n\t\t\t\tis2FAEnabled: false,\n\t\t\t\ttotpSecret: undefined,\n\t\t\t\tbackupCodes: undefined,\n\t\t\t\tlast2FAVerification: undefined\n\t\t\t};\n\n\t\t\tconst result = await this.db.updateUserAttributes(userId, updateData, tenantId);\n\n\t\t\tif (!result.success) {\n\t\t\t\tthrow new Error('Failed to disable 2FA');\n\t\t\t}\n\n\t\t\tlogger.info('2FA disabled successfully', { userId, tenantId });\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to disable 2FA: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t// Generate new backup codes for a user (invalidates old ones)\n\tasync regenerateBackupCodes(userId: string, tenantId?: string): Promise<string[]> {\n\t\ttry {\n\t\t\tlogger.info('Regenerating backup codes', { userId, tenantId });\n\n\t\t\t// Get user to verify 2FA is enabled\n\t\t\tconst userResult = await this.db.getUserById(userId, tenantId);\n\t\t\tif (!userResult.success || !userResult.data || !userResult.data.is2FAEnabled) {\n\t\t\t\tthrow new Error('2FA is not enabled for this user');\n\t\t\t}\n\n\t\t\t// Generate new backup codes (now async)\n\t\t\tconst newBackupCodes = await generateBackupCodes(10);\n\t\t\tconst hashedBackupCodes = await Promise.all(newBackupCodes.map((code) => hashBackupCode(code)));\n\n\t\t\t// Update user with new backup codes\n\t\t\tconst result = await this.db.updateUserAttributes(\n\t\t\t\tuserId,\n\t\t\t\t{\n\t\t\t\t\tbackupCodes: hashedBackupCodes\n\t\t\t\t},\n\t\t\t\ttenantId\n\t\t\t);\n\n\t\t\tif (!result.success) {\n\t\t\t\tthrow new Error('Failed to update backup codes');\n\t\t\t}\n\n\t\t\tlogger.info('Backup codes regenerated successfully', { userId, tenantId });\n\t\t\treturn newBackupCodes; // Return plain codes to user\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to regenerate backup codes: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t//Get 2FA status for a user\n\tasync get2FAStatus(\n\t\tuserId: string,\n\t\ttenantId?: string\n\t): Promise<{\n\t\tenabled: boolean;\n\t\thasBackupCodes: boolean;\n\t\tbackupCodesCount: number;\n\t\tlastVerification?: ISODateString;\n\t}> {\n\t\ttry {\n\t\t\tconst userResult = await this.db.getUserById(userId, tenantId);\n\t\t\tif (!userResult.success || !userResult.data) {\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst user = userResult.data;\n\n\t\t\treturn {\n\t\t\t\tenabled: user.is2FAEnabled || false,\n\t\t\t\thasBackupCodes: Boolean(user.backupCodes && user.backupCodes.length > 0),\n\t\t\t\tbackupCodesCount: user.backupCodes ? user.backupCodes.length : 0,\n\t\t\t\tlastVerification: user.last2FAVerification\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to get 2FA status: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tlogger.error(message, { userId, tenantId });\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\n// Create a singleton instance for the default auth database\nlet defaultTwoFactorService: TwoFactorAuthService | null = null;\n\nexport function createTwoFactorAuthService(db: AuthInterface, serviceName?: string): TwoFactorAuthService {\n\treturn new TwoFactorAuthService(db, serviceName);\n}\n\nexport function getDefaultTwoFactorAuthService(db: AuthInterface): TwoFactorAuthService {\n\tif (!defaultTwoFactorService) {\n\t\tdefaultTwoFactorService = new TwoFactorAuthService(db);\n\t}\n\treturn defaultTwoFactorService;\n}\n"],"names":[],"mappings":"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"}