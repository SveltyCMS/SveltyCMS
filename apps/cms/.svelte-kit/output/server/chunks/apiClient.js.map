{"version":3,"file":"apiClient.js","sources":["../../../../../../shared/utils/src/toast.ts","../../../../../../shared/utils/src/apiClient.ts"],"sourcesContent":["/**\n * @file src/utils/toast.ts\n * Centralized toast utility for consistent notifications across modals/components.\n */\n\nimport { toaster } from '@shared/stores/store.svelte';\nimport { logger } from '@shared/utils/logger';\n\nexport type ToastType = 'success' | 'info' | 'warning' | 'error';\n\n/**\n * Displays a toast notification using Skeleton v4 toaster.\n * @param message The message to display.\n * @param type The type of toast (success, info, warning, error). Defaults to 'info'.\n * @param timeout Custom timeout in milliseconds. Defaults to 3000ms.\n */\nexport function showToast(message: string, type: ToastType = 'info', timeout: number = 3000): void {\n\ttry {\n\t\ttoaster.create({\n\t\t\ttitle: type.charAt(0).toUpperCase() + type.slice(1), // Title Case (Success, Error, Info, Warning)\n\t\t\tdescription: message,\n\t\t\ttype: type,\n\t\t\tduration: timeout\n\t\t});\n\t} catch (err) {\n\t\tlogger.error('[toast] Failed to show toast:', err);\n\t}\n}\n","/**\n * @file src/utils/apiClient.ts\n * @description Modern API client for RESTful collection endpoints with enhanced performance and caching\n * @example GET /api/collections/posts?limit=10&offset=0\n *\n * Features:\n *    * Performance optimization with QueryBuilder\n *    * Caching support for efficient data fetching\n *    * Error handling and logging\n *    * Custom log formatters\n *    * Conditional source file tracking\n *    * Error tracking service integration\n */\n\nimport type { ISODateString } from '@cms-types/content';\nimport { logger } from '@shared/utils/logger';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\n\n// --- Type Definitions ---\nexport interface ApiResponse<T = unknown> {\n\tsuccess: boolean;\n\tdata?: T;\n\terror?: string;\n}\n\nexport interface RevisionDiff {\n\tdiff: Record<string, { status: 'modified' | 'added' | 'deleted'; old?: unknown; new?: unknown; value?: unknown }>;\n\trevisionData: Record<string, unknown>;\n}\n\nexport interface RevisionMeta {\n\t_id: string;\n\trevision_at: ISODateString; // ISO date string\n\trevision_by: string;\n}\n\nexport interface Collection {\n\t_id: string;\n\tname: string;\n\tfields: Record<string, unknown>[];\n\t// Add other collection properties as needed\n}\n\ninterface GetDataResponse {\n\titems: Record<string, unknown>[];\n\ttotal: number;\n\ttotalPages: number;\n\tpage?: number;\n\tpageSize?: number;\n}\n\n// --- Core API Functions ---\nasync function fetchApi<T>(endpoint: string, options: RequestInit): Promise<ApiResponse<T>> {\n\ttry {\n\t\tconst response = await fetch(endpoint, {\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\tcredentials: 'include',\n\t\t\t...options\n\t\t});\n\t\tif (!response.ok) {\n\t\t\tconst errorData = await response.json().catch(() => ({ error: `HTTP error! Status: ${response.status}` }));\n\t\t\tthrow new Error(errorData.error || `An unknown error occurred.`);\n\t\t}\n\t\treturn await response.json();\n\t} catch (error) {\n\t\tconst err = error as Error;\n\t\tlogger.error(`[API Client Error]`, err);\n\t\treturn { success: false, error: err.message };\n\t}\n}\n\n// --- Entry Action Functions ---\nexport function createEntry(collectionId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(payload)\n\t});\n}\n\nexport function updateEntry(collectionId: string, entryId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}`, {\n\t\tmethod: 'PATCH',\n\t\tbody: JSON.stringify(payload)\n\t});\n}\n\nexport function batchUpdateEntries(collectionId: string, payload: Record<string, unknown>): Promise<ApiResponse<unknown>> {\n\t// Use the status endpoint for batch status updates\n\tconst { ids, status, ...otherFields } = payload;\n\tif (status && ids && Array.isArray(ids)) {\n\t\t// Use status endpoint for status changes\n\t\treturn fetchApi(`/api/collections/${collectionId}/${ids[0]}/status`, {\n\t\t\tmethod: 'PATCH',\n\t\t\tbody: JSON.stringify({ status, entries: ids, ...otherFields })\n\t\t});\n\t}\n\t// For other batch operations, we might need a different approach\n\t// For now, throw error if not status update\n\tthrow new Error('Batch updates only supported for status changes');\n}\n\nexport function updateEntryStatus(collectionId: string, entryId: string, status: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}/status`, {\n\t\tmethod: 'PATCH',\n\t\tbody: JSON.stringify({ status })\n\t});\n}\n\nexport function deleteEntry(collectionId: string, entryId: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/${entryId}`, {\n\t\tmethod: 'DELETE'\n\t});\n}\n\nexport function batchDeleteEntries(collectionId: string, entryIds: string[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'delete', entryIds })\n\t});\n}\n\nexport function createClones(collectionId: string, entries: Record<string, unknown>[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch-clone`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ entries })\n\t});\n}\n\n// Batch operations for entries\nexport function batchCloneEntries(collectionId: string, entryIds: string[]): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'clone', entryIds })\n\t});\n}\n\nexport function batchUpdateEntriesStatus(collectionId: string, entryIds: string[], status: string): Promise<ApiResponse<unknown>> {\n\treturn fetchApi(`/api/collections/${collectionId}/batch`, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ action: 'status', entryIds, status })\n\t});\n}\n\n// --- Revision Functions ---\n\n// A wrapper for a POST request to compare a revision with current data\nexport async function getRevisionDiff(params: {\n\tcollectionId: string;\n\tentryId: string;\n\trevisionId: string;\n\tcurrentData: Record<string, unknown>;\n}): Promise<ApiResponse<RevisionDiff>> {\n\tconst { collectionId, entryId, revisionId, currentData } = params;\n\tconst endpoint = `/api/collections/${collectionId}/${entryId}/revisions/diff`;\n\n\treturn fetchApi(endpoint, {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ revisionId, currentData })\n\t});\n}\n\n// Specialized function for revisions\nexport async function getRevisions(\n\tcollectionId: string,\n\tentryId: string,\n\toptions: {\n\t\tpage?: number;\n\t\tlimit?: number;\n\t\trevisionId?: string;\n\t\tcompareWith?: string;\n\t\tmetaOnly?: boolean;\n\t} = {}\n): Promise<ApiResponse<RevisionMeta[]>> {\n\tconst endpoint = `/api/collections/${collectionId}/${entryId}/revisions`;\n\tconst searchParams = new URLSearchParams(options as Record<string, string>).toString();\n\tconst url = `${endpoint}?${searchParams}`;\n\n\treturn fetchApi(url, { method: 'GET' });\n}\n\n// --- Data & Cache Functions ---\nconst CACHE_TTL_MS = 30 * 1000; // 30 seconds cache TTL\n\ninterface CacheEntry {\n\tdata: GetDataResponse;\n\ttimestamp: number;\n\tttl: number;\n}\nconst dataCache = new Map<string, CacheEntry>();\n\nfunction generateCacheKey(query: Record<string, unknown>): string {\n\tconst normalizedQuery = {\n\t\tcollectionId: (query.collectionId as string)?.trim().toLowerCase(),\n\t\tpage: query.page || 1,\n\t\tpageSize: query.pageSize || query.limit || 25,\n\t\tcontentLanguage: query.contentLanguage || publicEnv.DEFAULT_CONTENT_LANGUAGE,\n\t\tfilter: query.filter || '{}',\n\t\tsortField: query.sortField || 'createdAt',\n\t\tsortDirection: query.sortDirection || 'desc',\n\t\t_langChange: query._langChange || 0\n\t};\n\treturn JSON.stringify(normalizedQuery);\n}\n\nfunction isCacheValid(cacheEntry: CacheEntry): boolean {\n\treturn Date.now() - cacheEntry.timestamp < cacheEntry.ttl;\n}\n\nexport function invalidateCollectionCache(collectionId: string): void {\n\tconst normalizedCollectionId = collectionId.trim().toLowerCase();\n\tfor (const [key] of dataCache.entries()) {\n\t\tif (key.includes(`\"collectionId\":\"${normalizedCollectionId}\"`)) {\n\t\t\tdataCache.delete(key);\n\t\t}\n\t}\n\tlogger.info(`[Cache] Invalidated for collection ${collectionId}`);\n}\n\n// Enhanced getData function using new RESTful endpoints\nexport async function getData(query: {\n\tcollectionId: string;\n\tpage?: number;\n\tpageSize?: number;\n\tlimit?: number; // Backward compatibility\n\tcontentLanguage?: string;\n\tfilter?: string;\n\tsortField?: string;\n\tsortDirection?: 'asc' | 'desc';\n\tsort?: string; // Backward compatibility\n\t_langChange?: number;\n}): Promise<ApiResponse<GetDataResponse>> {\n\tconst cacheKey = generateCacheKey(query);\n\tconst cached = dataCache.get(cacheKey);\n\n\tif (cached && isCacheValid(cached)) {\n\t\tlogger.info(`[Cache] HIT for ${cacheKey}`);\n\t\treturn { success: true, data: cached.data };\n\t}\n\tlogger.info(`[Cache] MISS for ${cacheKey}`);\n\n\tconst { collectionId, ...params } = query;\n\tconst searchParams = new URLSearchParams(params as Record<string, string>).toString();\n\tconst endpoint = `/api/collections/${collectionId}?${searchParams}`;\n\n\tconst result = await fetchApi<GetDataResponse>(endpoint, { method: 'GET' });\n\n\t// Add debugging for production issues\n\tif (result.success && result.data) {\n\t\t// Validate the response format\n\t\tif (!result.data.items || !Array.isArray(result.data.items)) {\n\t\t\tlogger.error(`[getData] Invalid response format:`, {\n\t\t\t\tendpoint,\n\t\t\t\thasItems: !!result.data.items,\n\t\t\t\titemsType: typeof result.data.items,\n\t\t\t\tresponseKeys: Object.keys(result.data)\n\t\t\t});\n\t\t\treturn { success: false, error: 'Invalid response format from server' };\n\t\t}\n\n\t\tdataCache.set(cacheKey, { data: result.data, timestamp: Date.now(), ttl: CACHE_TTL_MS });\n\t\tlogger.info(`[getData] Success:`, {\n\t\t\tendpoint,\n\t\t\titemCount: result.data.items.length,\n\t\t\ttotal: result.data.total,\n\t\t\tcached: true\n\t\t});\n\t} else if (!result.success) {\n\t\tlogger.error(`[getData] API Error:`, { endpoint, error: result.error });\n\t}\n\n\treturn result;\n}\n\n// Get all collections list\nexport async function getCollections(\n\toptions: {\n\t\tincludeFields?: boolean;\n\t\tincludeStats?: boolean;\n\t} = {}\n): Promise<ApiResponse<Collection[]>> {\n\tconst params = new URLSearchParams(options as Record<string, string>);\n\tconst endpoint = `/api/collections?${params.toString()}`;\n\treturn fetchApi(endpoint, { method: 'GET' });\n}\n"],"names":[],"mappings":";;;;AAgBO,SAAS,UAAU,SAAiB,OAAkB,QAAQ,UAAkB,KAAY;AAClG,MAAI;AACH,YAAQ,OAAO;AAAA,MACd,OAAO,KAAK,OAAO,CAAC,EAAE,gBAAgB,KAAK,MAAM,CAAC;AAAA;AAAA,MAClD,aAAa;AAAA,MACb;AAAA,MACA,UAAU;AAAA,IAAA,CACV;AAAA,EACF,SAAS,KAAK;AACb,WAAO,MAAM,iCAAiC,GAAG;AAAA,EAClD;AACD;ACyBA,eAAe,SAAY,UAAkB,SAA+C;AAC3F,MAAI;AACH,UAAM,WAAW,MAAM,MAAM,UAAU;AAAA,MACtC,SAAS,EAAE,gBAAgB,mBAAA;AAAA,MAC3B,aAAa;AAAA,MACb,GAAG;AAAA,IAAA,CACH;AACD,QAAI,CAAC,SAAS,IAAI;AACjB,YAAM,YAAY,MAAM,SAAS,KAAA,EAAO,MAAM,OAAO,EAAE,OAAO,uBAAuB,SAAS,MAAM,KAAK;AACzG,YAAM,IAAI,MAAM,UAAU,SAAS,4BAA4B;AAAA,IAChE;AACA,WAAO,MAAM,SAAS,KAAA;AAAA,EACvB,SAAS,OAAO;AACf,UAAM,MAAM;AACZ,WAAO,MAAM,sBAAsB,GAAG;AACtC,WAAO,EAAE,SAAS,OAAO,OAAO,IAAI,QAAA;AAAA,EACrC;AACD;AAiBO,SAAS,mBAAmB,cAAsB,SAAiE;AAEzH,QAAM,EAAE,KAAK,QAAQ,GAAG,gBAAgB;AACxC,MAAI,UAAU,OAAO,MAAM,QAAQ,GAAG,GAAG;AAExC,WAAO,SAAS,oBAAoB,YAAY,IAAI,IAAI,CAAC,CAAC,WAAW;AAAA,MACpE,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,EAAE,QAAQ,SAAS,KAAK,GAAG,YAAA,CAAa;AAAA,IAAA,CAC7D;AAAA,EACF;AAGA,QAAM,IAAI,MAAM,iDAAiD;AAClE;AASO,SAAS,YAAY,cAAsB,SAAgD;AACjG,SAAO,SAAS,oBAAoB,YAAY,IAAI,OAAO,IAAI;AAAA,IAC9D,QAAQ;AAAA,EAAA,CACR;AACF;AAEO,SAAS,mBAAmB,cAAsB,UAAmD;AAC3G,SAAO,SAAS,oBAAoB,YAAY,UAAU;AAAA,IACzD,QAAQ;AAAA,IACR,MAAM,KAAK,UAAU,EAAE,QAAQ,UAAU,UAAU;AAAA,EAAA,CACnD;AACF;AAEO,SAAS,aAAa,cAAsB,SAAmE;AACrH,SAAO,SAAS,oBAAoB,YAAY,gBAAgB;AAAA,IAC/D,QAAQ;AAAA,IACR,MAAM,KAAK,UAAU,EAAE,SAAS;AAAA,EAAA,CAChC;AACF;AAoJA,eAAsB,eACrB,UAGI,IACiC;AACrC,QAAM,SAAS,IAAI,gBAAgB,OAAiC;AACpE,QAAM,WAAW,oBAAoB,OAAO,SAAA,CAAU;AACtD,SAAO,SAAS,UAAU,EAAE,QAAQ,OAAO;AAC5C;"}