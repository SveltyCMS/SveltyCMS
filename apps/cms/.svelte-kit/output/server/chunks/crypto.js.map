{"version":3,"file":"crypto.js","sources":["../../../../../../shared/utils/src/crypto.ts"],"sourcesContent":["/**\n * @file src/utils/crypto.ts\n * @description Enterprise-grade cryptography utilities using Argon2 for key derivation\n *\n * QUANTUM COMPUTING SECURITY NOTICE:\n * ==================================\n * This module is designed with quantum resistance in mind:\n *\n * - Argon2id: Memory-hard algorithm that resists quantum speedup (quantum computers\n *   don't have memory advantages over classical computers)\n * - AES-256-GCM: Even with Grover's algorithm reducing it to 128-bit quantum security,\n *   2^128 operations remain computationally infeasible\n * - No RSA/ECC: We don't use public-key cryptography vulnerable to Shor's algorithm\n *\n * Current Status: SECURE against quantum threats for next 15-30+ years\n * Migration Path: Plan to add CRYSTALS-Kyber/Dilithium (NIST PQC standards) around 2030\n *\n * This module provides:\n * - Password hashing with Argon2id (winner of Password Hashing Competition)\n * - Key derivation from passwords using Argon2 (more secure than PBKDF2)\n * - AES-256-GCM encryption/decryption with Argon2-derived keys\n * - Secure random token generation\n * - SHA256 checksum generation for data integrity\n *\n * @see https://csrc.nist.gov/projects/post-quantum-cryptography for PQC updates\n */\n\nimport { logger } from '@shared/utils/logger';\n\n// Import argon2 and crypto (server-side only)\nlet argon2: typeof import('argon2') | null = null;\nlet crypto: typeof import('crypto') | null = null;\n\nif (typeof window === 'undefined') {\n\ttry {\n\t\targon2 = await import('argon2');\n\t\tcrypto = await import('crypto');\n\t} catch (error) {\n\t\tlogger.error('Failed to load cryptographic modules', { error });\n\t}\n}\n\n/**\n * Argon2 configuration for enterprise security\n *\n * QUANTUM RESISTANCE NOTES:\n * - Argon2 is inherently quantum-resistant due to its memory-hard property\n * - Grover's algorithm doesn't provide significant speedup for memory-bound operations\n * - The 64 MB memory requirement per hash limits quantum computer advantages\n * - Quantum computers excel at computation, not memory access patterns\n *\n * These settings provide a good balance between security and performance\n * while maintaining strong resistance against both classical and quantum attacks.\n */\nexport const argon2Config = {\n\t// Memory cost in KiB (64 MB) - Makes attacks expensive even with quantum computers\n\tmemory: 65536,\n\t// Time cost (number of iterations) - Adds computational complexity\n\ttime: 3,\n\t// Parallelism factor (number of threads) - Optimizes for modern CPUs\n\tparallelism: 4,\n\t// Use Argon2id (hybrid version - best for most use cases)\n\ttype: 2 as const, // argon2id\n\t// Output hash length in bytes\n\thashLength: 32\n};\n\n// AES-256-GCM encryption configuration\n// QUANTUM RESISTANCE: AES-256 provides 128-bit quantum security (Grover's algorithm)\n// which is still computationally infeasible (2^128 operations = billions of years)\nexport const encryptionConfig = {\n\talgorithm: 'aes-256-gcm' as const,\n\tkeyLength: 32, // 256 bits (128-bit quantum security)\n\tivLength: 16, // 128 bits\n\tsaltLength: 32, // 256 bits (128-bit quantum security)\n\tauthTagLength: 16 // 128 bits (provides data integrity)\n};\n\n/**\n * Hash a password using Argon2id\n *\n * @param password - Plain text password to hash\n * @returns Promise resolving to hashed password\n * @throws Error if argon2 is not available\n */\nexport async function hashPassword(password: string): Promise<string> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\treturn argon2.hash(password, {\n\t\t...argon2Config,\n\t\ttype: argon2.argon2id\n\t});\n}\n\n/**\n * Verify a password against its hash using Argon2\n *\n * @param password - Plain text password to verify\n * @param hash - Hashed password to compare against\n * @returns Promise resolving to true if password matches\n * @throws Error if argon2 is not available\n */\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\treturn argon2.verify(hash, password);\n}\n\n/**\n * Derive a cryptographic key from a password using Argon2\n * This is more secure than PBKDF2 for key derivation\n *\n * QUANTUM RESISTANCE:\n * Argon2's memory-hard property makes it quantum-resistant because:\n * 1. Quantum computers don't have memory advantages (limited qubits)\n * 2. Memory access patterns can't be parallelized effectively by quantum algorithms\n * 3. Grover's algorithm doesn't help with memory-bound operations\n *\n * This makes Argon2 an excellent choice for long-term key derivation security.\n *\n * @param password - Password to derive key from\n * @param salt - Salt for key derivation (should be unique per encryption)\n * @returns Promise resolving to derived key buffer\n * @throws Error if argon2 is not available\n */\nexport async function deriveKey(password: string, salt: Buffer): Promise<Buffer> {\n\tif (!argon2) {\n\t\tthrow new Error('Argon2 not available - server-side only');\n\t}\n\n\t// Use Argon2 to derive a raw key (not encoded)\n\tconst hash = await argon2.hash(password, {\n\t\t...argon2Config,\n\t\ttype: argon2.argon2id,\n\t\tsalt,\n\t\traw: true\n\t});\n\n\t// Ensure key is exactly 32 bytes for AES-256\n\treturn Buffer.from(hash).subarray(0, encryptionConfig.keyLength);\n}\n\n/**\n * Encrypt data using AES-256-GCM with Argon2-derived key\n *\n * QUANTUM RESISTANCE:\n * - AES-256: Even with Grover's algorithm, maintains 128-bit quantum security\n * - GCM mode: Provides authenticated encryption (integrity + confidentiality)\n * - Argon2 key derivation: Quantum-resistant due to memory-hard property\n *\n * This combination provides strong security against both classical and quantum attacks.\n * For ultra-long-term storage (20+ years), consider adding post-quantum key encapsulation\n * (CRYSTALS-Kyber) in hybrid mode once NIST standards are widely implemented.\n *\n * @param data - Data object to encrypt\n * @param password - Password to derive encryption key from\n * @returns Base64-encoded encrypted data (salt + iv + authTag + ciphertext)\n * @throws Error if crypto modules are not available\n */\nexport async function encryptData(data: Record<string, unknown>, password: string): Promise<string> {\n\tif (!crypto || !argon2) {\n\t\tthrow new Error('Crypto modules not available - server-side only');\n\t}\n\n\t// Generate random salt and IV\n\tconst salt = crypto.randomBytes(encryptionConfig.saltLength);\n\tconst iv = crypto.randomBytes(encryptionConfig.ivLength);\n\n\t// Derive key using Argon2 (more secure than PBKDF2)\n\tconst key = await deriveKey(password, salt);\n\n\t// Create cipher\n\tconst cipher = crypto.createCipheriv(encryptionConfig.algorithm, key, iv);\n\n\t// Encrypt data\n\tconst plaintext = JSON.stringify(data);\n\tconst encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);\n\n\t// Get authentication tag\n\tconst authTag = cipher.getAuthTag();\n\n\t// Combine: salt + iv + authTag + encrypted data\n\tconst combined = Buffer.concat([salt, iv, authTag, encrypted]);\n\n\tlogger.debug('Data encrypted successfully', {\n\t\tsaltLength: salt.length,\n\t\tivLength: iv.length,\n\t\tauthTagLength: authTag.length,\n\t\tencryptedLength: encrypted.length\n\t});\n\n\treturn combined.toString('base64');\n}\n\n/**\n * Decrypt data using AES-256-GCM with Argon2-derived key\n *\n * @param encryptedData - Base64-encoded encrypted data\n * @param password - Password to derive decryption key from\n * @returns Decrypted data object\n * @throws Error if decryption fails or password is incorrect\n */\nexport async function decryptData(encryptedData: string, password: string): Promise<Record<string, unknown>> {\n\tif (!crypto || !argon2) {\n\t\tthrow new Error('Crypto modules not available - server-side only');\n\t}\n\n\ttry {\n\t\t// Decode base64\n\t\tconst combined = Buffer.from(encryptedData, 'base64');\n\n\t\t// Extract components\n\t\tlet offset = 0;\n\t\tconst salt = combined.subarray(offset, offset + encryptionConfig.saltLength);\n\t\toffset += encryptionConfig.saltLength;\n\n\t\tconst iv = combined.subarray(offset, offset + encryptionConfig.ivLength);\n\t\toffset += encryptionConfig.ivLength;\n\n\t\tconst authTag = combined.subarray(offset, offset + encryptionConfig.authTagLength);\n\t\toffset += encryptionConfig.authTagLength;\n\n\t\tconst encrypted = combined.subarray(offset);\n\n\t\t// Derive key using same password and salt\n\t\tconst key = await deriveKey(password, salt);\n\n\t\t// Create decipher\n\t\tconst decipher = crypto.createDecipheriv(encryptionConfig.algorithm, key, iv);\n\t\tdecipher.setAuthTag(authTag);\n\n\t\t// Decrypt data\n\t\tconst decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);\n\n\t\tlogger.debug('Data decrypted successfully', {\n\t\t\tdecryptedLength: decrypted.length\n\t\t});\n\n\t\treturn JSON.parse(decrypted.toString('utf8'));\n\t} catch (error) {\n\t\tlogger.error('Decryption failed', { error });\n\t\tthrow new Error('Failed to decrypt data. Password may be incorrect or data corrupted.');\n\t}\n}\n\n/**\n * Creates a SHA256 checksum for any given data object.\n * Useful for data integrity checks and detecting changes.\n *\n * @param data - The data to hash (will be stringified).\n * @returns A hex-encoded SHA256 hash.\n * @throws Error if crypto is not available.\n */\nexport function createChecksum(data: unknown): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\tconst str = JSON.stringify(data);\n\treturn crypto.createHash('sha256').update(str).digest('hex');\n}\n\n/**\n * Generate a secure random token\n *\n * @param length - Length of token in bytes (default: 32)\n * @returns Hex-encoded random token\n * @throws Error if crypto is not available\n */\nexport function generateRandomToken(length: number = 32): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\n\treturn crypto.randomBytes(length).toString('hex');\n}\n\n/**\n * Generate a secure random UUID\n *\n * @returns UUID string\n * @throws Error if crypto is not available\n */\nexport function generateUUID(): string {\n\tif (!crypto) {\n\t\tthrow new Error('Crypto not available - server-side only');\n\t}\n\n\treturn crypto.randomUUID();\n}\n\n/**\n * Check if cryptographic modules are available\n *\n * @returns True if crypto and argon2 are available\n */\nexport function isCryptoAvailable(): boolean {\n\treturn crypto !== null && argon2 !== null;\n}\n"],"names":[],"mappings":"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"}