{"version":3,"file":"index8.js","sources":["../../../../../../shared/stores/src/system/types.ts","../../../../../../shared/stores/src/system/async.ts"],"sourcesContent":["/**\n * @file src/stores/system/types.ts\n * @description Type definitions for the system state and health architecture.\n */\n\n// System-wide states\nexport type SystemState = 'IDLE' | 'INITIALIZING' | 'READY' | 'DEGRADED' | 'FAILED';\n\n// Individual service health statuses\nexport type ServiceHealth = 'healthy' | 'unhealthy' | 'initializing';\n\n// State-specific timing metrics (up/down/idle)\nexport interface StateTimingMetrics {\n\t// Startup (IDLE → INITIALIZING → READY)\n\tstartup: {\n\t\tcount: number; // Number of startups\n\t\tavgTime?: number; // Average startup time\n\t\tminTime?: number; // Fastest startup\n\t\tmaxTime?: number; // Slowest startup\n\t\tlastTime?: number; // Most recent startup time\n\t\ttrend: 'improving' | 'stable' | 'degrading' | 'unknown'; // Performance trend\n\t};\n\t// Shutdown (READY → IDLE)\n\tshutdown: {\n\t\tcount: number;\n\t\tavgTime?: number;\n\t\tminTime?: number;\n\t\tmaxTime?: number;\n\t\tlastTime?: number;\n\t\ttrend: 'improving' | 'stable' | 'degrading' | 'unknown';\n\t};\n\t// Idle time (time spent in IDLE state)\n\tidle: {\n\t\tcount: number; // Number of idle periods\n\t\tavgDuration?: number; // Average idle duration\n\t\tminDuration?: number; // Shortest idle period\n\t\tmaxDuration?: number; // Longest idle period\n\t\tlastDuration?: number; // Most recent idle duration\n\t\ttotalTime: number; // Total time spent idle\n\t};\n\t// Active time (time spent in READY state)\n\tactive: {\n\t\tcount: number; // Number of active periods\n\t\tavgDuration?: number; // Average active duration\n\t\tminDuration?: number; // Shortest active period\n\t\tmaxDuration?: number; // Longest active period\n\t\tlastDuration?: number; // Most recent active duration\n\t\ttotalTime: number; // Total time spent active\n\t};\n}\n\n// Anomaly detection thresholds (self-learning)\nexport interface AnomalyThresholds {\n\tmaxStartupTime: number; // Max acceptable startup time\n\tmaxShutdownTime: number; // Max acceptable shutdown time\n\tmaxConsecutiveFailures: number; // Max failures before alert\n\tminUptimePercentage: number; // Min acceptable uptime %\n\tlastCalibrated?: number; // When thresholds were last updated\n\tcalibrationCount: number; // Number of calibrations performed\n}\n\n// Performance metrics for a service lifecycle\nexport interface ServicePerformanceMetrics {\n\tinitializationStartedAt?: number; // When initialization began\n\tinitializationCompletedAt?: number; // When initialization completed\n\tinitializationDuration?: number; // Total time taken to initialize (ms)\n\tlastHealthCheckAt?: number; // Last time health was checked\n\thealthCheckCount: number; // Number of health checks performed\n\tfailureCount: number; // Number of times service became unhealthy\n\tlastFailureAt?: number; // Timestamp of last failure\n\taverageInitTime?: number; // Running average of init times\n\tminInitTime?: number; // Fastest initialization time\n\tmaxInitTime?: number; // Slowest initialization time\n\trestartCount: number; // Number of times service was restarted\n\n\t// Enhanced state-specific metrics\n\tstateTimings: StateTimingMetrics;\n\tanomalyThresholds: AnomalyThresholds;\n\tconsecutiveFailures: number; // Current streak of failures\n\tuptimePercentage: number; // Percentage of time service is healthy\n}\n\n// Service status with enhanced metrics\nexport interface ServiceStatus {\n\tstatus: ServiceHealth;\n\tmessage: string;\n\tlastChecked?: number;\n\terror?: string;\n\tmetrics: ServicePerformanceMetrics;\n}\n\n// System-wide performance metrics\nexport interface SystemPerformanceMetrics {\n\ttotalInitializations: number;\n\tsuccessfulInitializations: number;\n\tfailedInitializations: number;\n\taverageTotalInitTime?: number;\n\tminTotalInitTime?: number;\n\tmaxTotalInitTime?: number;\n\tlastInitDuration?: number;\n\tstateTransitions: Array<{\n\t\tfrom: SystemState;\n\t\tto: SystemState;\n\t\ttimestamp: number;\n\t\treason?: string;\n\t}>;\n}\n\n// ✅ ENTERPRISE ENHANCEMENT: Added 'widgets' as a monitored service\n// This allows the system health monitor to track widget availability and dependencies\nexport const SERVICE_NAMES = ['database', 'auth', 'cache', 'contentManager', 'themeManager', 'widgets'] as const;\nexport type ServiceName = (typeof SERVICE_NAMES)[number];\nexport type ServicesMap = {\n\t[K in ServiceName]: ServiceStatus;\n};\n\n// Main system state store interface\nexport interface SystemStateStore {\n\toverallState: SystemState;\n\tservices: ServicesMap;\n\tperformanceMetrics: SystemPerformanceMetrics;\n\tlastStateChange?: number; // Timestamp of last state transition\n\tinitializationStartedAt?: number; // When system initialization began\n\tinitializationCompletedAt?: number; // When system initialization completed\n}\n\nexport interface AnomalyDetection {\n\ttype: 'slow_startup' | 'slow_shutdown' | 'consecutive_failures' | 'low_uptime' | 'degrading_performance';\n\tseverity: 'low' | 'medium' | 'high' | 'critical';\n\tmessage: string;\n\tdetails: {\n\t\tactual?: string;\n\t\tthreshold?: string;\n\t\texcess?: string;\n\t\tfailures?: number;\n\t\tuptime?: string;\n\t\ttrend?: string;\n\t\tavgTime?: string;\n\t\tlastTime?: string;\n\t};\n}\n","/**\n * @file src/stores/system/async.ts\n * @description Asynchronous utilities for waiting on system state.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport { getSystemState, systemState } from './state';\nimport { SERVICE_BASELINE_TIMES, DEFAULT_SYSTEM_READY_TIMEOUT } from './config';\nimport type { ServiceName } from './types';\n\ninterface WaitOptions {\n\ttimeoutMs?: number;\n\tsignal?: AbortSignal;\n}\n\n/**\n * Wait for the system to be ready (async with AbortSignal support)\n */\nexport async function waitForSystemReady(options: WaitOptions = {}): Promise<boolean> {\n\tconst { timeoutMs = DEFAULT_SYSTEM_READY_TIMEOUT, signal } = options;\n\n\tif (signal?.aborted) return Promise.reject(new DOMException('Aborted', 'AbortError'));\n\n\t// Check initial state synchronously\n\tlet currentState = getSystemState();\n\tif (currentState.overallState === 'READY' || currentState.overallState === 'DEGRADED') {\n\t\treturn true;\n\t}\n\tif (currentState.overallState === 'FAILED') {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tlet timeoutId: NodeJS.Timeout | undefined;\n\n\t\tconst cleanup = () => {\n\t\t\tclearTimeout(timeoutId);\n\t\t\tunsubscribe();\n\t\t\tsignal?.removeEventListener('abort', onAbort);\n\t\t};\n\n\t\tconst onAbort = () => {\n\t\t\tcleanup();\n\t\t\treject(new DOMException('Aborted', 'AbortError'));\n\t\t};\n\n\t\tconst unsubscribe = systemState.subscribe((state) => {\n\t\t\tif (state.overallState === 'READY' || state.overallState === 'DEGRADED') {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(true);\n\t\t\t} else if (state.overallState === 'FAILED') {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(false);\n\t\t\t}\n\t\t});\n\n\t\tsignal?.addEventListener('abort', onAbort, { once: true });\n\n\t\tif (timeoutMs > 0) {\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tcleanup();\n\t\t\t\tcurrentState = getSystemState();\n\t\t\t\tlogger.warn(`System ready timeout after ${timeoutMs}ms`, { state: currentState.overallState });\n\t\t\t\tresolve(false);\n\t\t\t}, timeoutMs);\n\t\t}\n\t});\n}\n\n/**\n * Calculate intelligent timeout for a service based on historical performance\n */\nexport function getServiceTimeout(serviceName: ServiceName, multiplier: number = 3): number {\n\tconst state = getSystemState();\n\tconst service = state.services[serviceName];\n\tconst baseline = SERVICE_BASELINE_TIMES[serviceName];\n\n\t// If we have historical data, use average + buffer\n\tif (service.metrics.averageInitTime) {\n\t\t// Use 3x average or max time (whichever is larger) as timeout\n\t\tconst calculated = Math.max(service.metrics.averageInitTime * multiplier, (service.metrics.maxInitTime ?? baseline) * 1.5);\n\t\treturn Math.min(calculated, 30000); // Cap at 30 seconds\n\t}\n\n\t// Fallback to baseline * multiplier\n\treturn baseline * multiplier;\n}\n\n/**\n * Wait for a specific service to be healthy with AbortSignal support\n */\nexport async function waitForServiceHealthy(serviceName: ServiceName, options: WaitOptions = {}): Promise<boolean> {\n\tconst { timeoutMs, signal } = options;\n\tconst effectiveTimeout = timeoutMs ?? getServiceTimeout(serviceName);\n\n\tif (signal?.aborted) return Promise.reject(new DOMException('Aborted', 'AbortError'));\n\n\t// Check initial state synchronously\n\tlet currentState = getSystemState();\n\tif (currentState.services[serviceName].status === 'healthy') {\n\t\treturn true;\n\t}\n\tif (currentState.services[serviceName].status === 'unhealthy') {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tlet timeoutId: NodeJS.Timeout | undefined;\n\n\t\tconst cleanup = () => {\n\t\t\tclearTimeout(timeoutId);\n\t\t\tunsubscribe();\n\t\t\tsignal?.removeEventListener('abort', onAbort);\n\t\t};\n\n\t\tconst onAbort = () => {\n\t\t\tcleanup();\n\t\t\treject(new DOMException('Aborted', 'AbortError'));\n\t\t};\n\n\t\tconst unsubscribe = systemState.subscribe((state) => {\n\t\t\tconst service = state.services[serviceName];\n\t\t\tif (service.status === 'healthy') {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(true);\n\t\t\t} else if (service.status === 'unhealthy') {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(false);\n\t\t\t}\n\t\t});\n\n\t\tsignal?.addEventListener('abort', onAbort, { once: true });\n\n\t\tif (effectiveTimeout > 0) {\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tcleanup();\n\t\t\t\tcurrentState = getSystemState();\n\t\t\t\tlogger.warn(`Service ${serviceName} healthy timeout after ${effectiveTimeout}ms`, {\n\t\t\t\t\tstatus: currentState.services[serviceName].status\n\t\t\t\t});\n\t\t\t\tresolve(false);\n\t\t\t}, effectiveTimeout);\n\t\t}\n\t});\n}\n"],"names":[],"mappings":";;;;AA8GO,MAAM,gBAAgB,CAAC,YAAY,QAAQ,SAAS,kBAAkB,gBAAgB,SAAS;AC5FtG,eAAsB,mBAAmB,UAAuB,IAAsB;AACrF,QAAM,EAAE,YAAY,8BAA8B,OAAA,IAAW;AAE7D,MAAI,QAAQ,QAAS,QAAO,QAAQ,OAAO,IAAI,aAAa,WAAW,YAAY,CAAC;AAGpF,MAAI,eAAe,eAAA;AACnB,MAAI,aAAa,iBAAiB,WAAW,aAAa,iBAAiB,YAAY;AACtF,WAAO;AAAA,EACR;AACA,MAAI,aAAa,iBAAiB,UAAU;AAC3C,WAAO;AAAA,EACR;AAEA,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,QAAI;AAEJ,UAAM,UAAU,MAAM;AACrB,mBAAa,SAAS;AACtB,kBAAA;AACA,cAAQ,oBAAoB,SAAS,OAAO;AAAA,IAC7C;AAEA,UAAM,UAAU,MAAM;AACrB,cAAA;AACA,aAAO,IAAI,aAAa,WAAW,YAAY,CAAC;AAAA,IACjD;AAEA,UAAM,cAAc,YAAY,UAAU,CAAC,UAAU;AACpD,UAAI,MAAM,iBAAiB,WAAW,MAAM,iBAAiB,YAAY;AACxE,gBAAA;AACA,gBAAQ,IAAI;AAAA,MACb,WAAW,MAAM,iBAAiB,UAAU;AAC3C,gBAAA;AACA,gBAAQ,KAAK;AAAA,MACd;AAAA,IACD,CAAC;AAED,YAAQ,iBAAiB,SAAS,SAAS,EAAE,MAAM,MAAM;AAEzD,QAAI,YAAY,GAAG;AAClB,kBAAY,WAAW,MAAM;AAC5B,gBAAA;AACA,uBAAe,eAAA;AACf,eAAO,KAAK,8BAA8B,SAAS,MAAM,EAAE,OAAO,aAAa,cAAc;AAC7F,gBAAQ,KAAK;AAAA,MACd,GAAG,SAAS;AAAA,IACb;AAAA,EACD,CAAC;AACF;AAKO,SAAS,kBAAkB,aAA0B,aAAqB,GAAW;AAC3F,QAAM,QAAQ,eAAA;AACd,QAAM,UAAU,MAAM,SAAS,WAAW;AAC1C,QAAM,WAAW,uBAAuB,WAAW;AAGnD,MAAI,QAAQ,QAAQ,iBAAiB;AAEpC,UAAM,aAAa,KAAK,IAAI,QAAQ,QAAQ,kBAAkB,aAAa,QAAQ,QAAQ,eAAe,YAAY,GAAG;AACzH,WAAO,KAAK,IAAI,YAAY,GAAK;AAAA,EAClC;AAGA,SAAO,WAAW;AACnB;AAKA,eAAsB,sBAAsB,aAA0B,UAAuB,IAAsB;AAClH,QAAM,EAAE,WAAW,OAAA,IAAW;AAC9B,QAAM,mBAAmB,aAAa,kBAAkB,WAAW;AAEnE,MAAI,QAAQ,QAAS,QAAO,QAAQ,OAAO,IAAI,aAAa,WAAW,YAAY,CAAC;AAGpF,MAAI,eAAe,eAAA;AACnB,MAAI,aAAa,SAAS,WAAW,EAAE,WAAW,WAAW;AAC5D,WAAO;AAAA,EACR;AACA,MAAI,aAAa,SAAS,WAAW,EAAE,WAAW,aAAa;AAC9D,WAAO;AAAA,EACR;AAEA,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,QAAI;AAEJ,UAAM,UAAU,MAAM;AACrB,mBAAa,SAAS;AACtB,kBAAA;AACA,cAAQ,oBAAoB,SAAS,OAAO;AAAA,IAC7C;AAEA,UAAM,UAAU,MAAM;AACrB,cAAA;AACA,aAAO,IAAI,aAAa,WAAW,YAAY,CAAC;AAAA,IACjD;AAEA,UAAM,cAAc,YAAY,UAAU,CAAC,UAAU;AACpD,YAAM,UAAU,MAAM,SAAS,WAAW;AAC1C,UAAI,QAAQ,WAAW,WAAW;AACjC,gBAAA;AACA,gBAAQ,IAAI;AAAA,MACb,WAAW,QAAQ,WAAW,aAAa;AAC1C,gBAAA;AACA,gBAAQ,KAAK;AAAA,MACd;AAAA,IACD,CAAC;AAED,YAAQ,iBAAiB,SAAS,SAAS,EAAE,MAAM,MAAM;AAEzD,QAAI,mBAAmB,GAAG;AACzB,kBAAY,WAAW,MAAM;AAC5B,gBAAA;AACA,uBAAe,eAAA;AACf,eAAO,KAAK,WAAW,WAAW,0BAA0B,gBAAgB,MAAM;AAAA,UACjF,QAAQ,aAAa,SAAS,WAAW,EAAE;AAAA,QAAA,CAC3C;AACD,gBAAQ,KAAK;AAAA,MACd,GAAG,gBAAgB;AAAA,IACpB;AAAA,EACD,CAAC;AACF;"}