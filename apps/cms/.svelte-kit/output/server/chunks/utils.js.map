{"version":3,"file":"utils.js","sources":["../../../../../../shared/utils/src/utils.ts"],"sourcesContent":["/**\n * @file src/utils/utils.ts\n * @description A comprehensive utility module for the SvelteKit CMS project.\n *\n * This file contains a wide range of utility functions and helpers used throughout the application, including:\n * - Form data handling and conversion (obj2formData, col2formData)\n * - File and media operations (sanitize, formatBytes, deleteOldTrashFiles)\n * - Date and time formatting (convertTimestampToDateString, formatUptime, ReadableExpireIn)\n * - Data manipulation and validation (extractData, deepCopy, validateValibot)\n * - Internationalization helpers (getTextDirection)\n * - UI-related utilities (getGuiFields, motion)\n * - String manipulation (pascalToCamelCase, getEditDistance)\n * - And various other helper functions\n *\n * The module also defines important constants and types used across the application.\n *\n * @requires various - Including fs, axios, valibot, and custom types/interfaces\n * @requires @stores/store - For accessing Svelte stores\n * @requires @root/config/public - For accessing public environment variables\n *\n * @exports numerous utility functions and constants\n */\n\nimport type { FieldInstance, FieldValue } from '@cms-types/content';\nimport type { GuiFieldConfig } from '@cms-types';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\nimport type { BaseIssue, BaseSchema } from 'valibot';\n\n// Stores\nimport { app } from '@shared/stores/store.svelte';\n\n// System Logger\nimport { logger, type LoggableValue } from '@shared/utils/logger';\n\n// Validation\nimport * as v from 'valibot';\n\nexport const config = {\n\theaders: {\n\t\t'Content-Type': 'multipart/form-data'\n\t}\n};\n\nexport function uniqueItems(items: Record<string, unknown>[], key: string): object[] {\n\tconst uniqueItems = Array.from(new Map(items.map((item) => [item[key], item])).values());\n\n\treturn uniqueItems;\n}\n\n// This function generates GUI fields based on field parameters and a GUI schema.\nexport const getGuiFields = (fieldParams: Record<string, unknown>, GuiSchema: Record<string, GuiFieldConfig>): Record<string, unknown> => {\n\tconst guiFields: Record<string, unknown> = {};\n\tfor (const key in GuiSchema) {\n\t\tif (Object.prototype.hasOwnProperty.call(fieldParams, key) && Array.isArray(fieldParams[key])) {\n\t\t\tguiFields[key] = deepCopy(fieldParams[key] as unknown[]);\n\t\t} else if (Object.prototype.hasOwnProperty.call(fieldParams, key)) {\n\t\t\tguiFields[key] = fieldParams[key];\n\t\t}\n\t}\n\treturn guiFields;\n};\n\n// Function to convert an object to form data\nexport const obj2formData = (obj: Record<string, unknown>) => {\n\tconst formData = new FormData();\n\n\tconst transformValue = (value: unknown): string | Blob => {\n\t\tif (value instanceof Blob) {\n\t\t\treturn value;\n\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\treturn JSON.stringify(value);\n\t\t} else if (typeof value === 'boolean' || typeof value === 'number') {\n\t\t\treturn value.toString();\n\t\t} else if (value === null || value === undefined) {\n\t\t\treturn '';\n\t\t}\n\t\treturn String(value);\n\t};\n\n\tfor (const key in obj) {\n\t\tconst value = obj[key];\n\t\tif (value !== undefined) {\n\t\t\tformData.append(key, transformValue(value));\n\t\t}\n\t}\n\n\treturn formData;\n};\n\n// Converts data to FormData object with optimized file handling and type safety\nexport const col2formData = async (getData: Record<string, () => Promise<unknown> | unknown>): Promise<FormData> => {\n\tconst formData = new FormData();\n\n\tconst processValue = async (value: unknown): Promise<string | Blob> => {\n\t\tif (value instanceof Blob) return value;\n\t\tif (value instanceof Promise) {\n\t\t\tconst resolvedValue = await value;\n\t\t\treturn processValue(resolvedValue);\n\t\t}\n\t\tif (value instanceof Object) {\n\t\t\treturn JSON.stringify(value);\n\t\t}\n\t\treturn String(value);\n\t};\n\n\tconst appendToForm = async () => {\n\t\tfor (const [key, getter] of Object.entries(getData)) {\n\t\t\tconst value = getter();\n\t\t\tconst processedValue = await processValue(value);\n\t\t\tformData.append(key, processedValue);\n\t\t}\n\t};\n\n\tawait appendToForm();\n\treturn formData;\n};\n\n// Helper function to sanitize file names\nexport function sanitize(str: string) {\n\treturn str.replace(/\\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');\n}\n\n// Get the environment variables for image sizes\nconst env_sizes = publicEnv.IMAGE_SIZES || {};\nexport const SIZES = { ...env_sizes, original: 0, thumbnail: 200 } as const;\n\n// Takes an object and recursively parses any values that can be converted to JSON\nexport function parse<T>(obj: unknown): T {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn obj as T;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => parse(item)) as unknown as T;\n\t}\n\n\tconst result = {} as { [key: string]: unknown };\n\tfor (const [key, value] of Object.entries(obj as object)) {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\tresult[key] = JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\tresult[key] = value;\n\t\t\t}\n\t\t} else {\n\t\t\tresult[key] = parse(value);\n\t\t}\n\t}\n\treturn result as T;\n}\n\n// Convert an object to form data\nexport const toFormData = (obj: Record<string, string | number | boolean>): FormData => {\n\tconst formData = new FormData();\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tformData.append(key, String(value));\n\t}\n\treturn formData;\n};\n\n// Converts fields to schema object\ninterface SchemaField {\n\ttype: string;\n\twidget?: unknown;\n\t[key: string]: unknown;\n}\n\nexport const fieldsToSchema = (fields: SchemaField[]): Record<string, unknown> => {\n\tconst schema: Record<string, unknown> = {};\n\n\tfor (const field of fields) {\n\t\tconst { type, ...rest } = field;\n\t\tschema[type] = rest;\n\t}\n\n\treturn schema;\n};\n\n// Returns field's database field name or label\nexport function getFieldName(field: Partial<FieldInstance> & { label: string }, rawName = false): string {\n\tif (!field) return '';\n\n\t// Use explicit db_fieldName if available\n\tif (field.db_fieldName) {\n\t\treturn rawName ? field.db_fieldName : field.db_fieldName;\n\t}\n\n\t// Special field name mappings\n\tconst specialMappings: Record<string, string> = {\n\t\t'First Name': 'first_name',\n\t\t'Last Name': 'last_name'\n\t};\n\n\t// Get the field name from label, or fallback to widget name\n\tlet name = field.label;\n\tif (!name && 'widget' in field && field.widget?.Name) {\n\t\tname = field.widget.Name;\n\t}\n\tif (!name && 'type' in field) {\n\t\tname = field.type as string;\n\t}\n\tif (!name) {\n\t\tname = 'unknown_field';\n\t}\n\n\t// Return raw UI name if requested\n\tif (rawName) return name;\n\n\t// Check special mappings first\n\tif (specialMappings[name]) {\n\t\treturn specialMappings[name];\n\t}\n\n\t// Default sanitization:\n\t// 1. Convert to lowercase\n\t// 2. Replace spaces with underscores\n\t// 3. Remove special characters\n\treturn name\n\t\t.toLowerCase()\n\t\t.replace(/\\s+/g, '_')\n\t\t.replace(/[^a-z0-9_]/g, '');\n}\n\n// Sanitizes field names for use in GraphQL type names\n// GraphQL type names must be valid identifiers: [A-Za-z_][A-Za-z0-9_]*\nexport function sanitizeGraphQLTypeName(name: string): string {\n\tif (!name) return '';\n\n\t// 1. Replace spaces with underscores\n\t// 2. Remove special characters except underscores\n\t// 3. Ensure it starts with a letter or underscore\n\tlet sanitized = name.replace(/\\s+/g, '_').replace(/[^A-Za-z0-9_]/g, '');\n\n\t// Ensure the name starts with a letter or underscore (GraphQL requirement)\n\tif (sanitized && !/^[A-Za-z_]/.test(sanitized)) {\n\t\tsanitized = `_${sanitized}`;\n\t}\n\n\treturn sanitized || '_invalid_name';\n}\n\n// Extract data from fields\nexport async function extractData(fieldsData: Record<string, FieldInstance>): Promise<Record<string, unknown>> {\n\tconst result: Record<string, unknown> = {};\n\tfor (const [key, field] of Object.entries(fieldsData)) {\n\t\tif (field.callback) {\n\t\t\tresult[key] = await field.callback({ data: field as unknown as Record<string, FieldValue> });\n\t\t} else {\n\t\t\tresult[key] = field.default ?? null;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction deepCopy<T>(obj: T): T {\n\tif (obj === null || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => deepCopy(item)) as unknown as T;\n\t}\n\n\tconst copy = {} as T;\n\tfor (const key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tcopy[key] = deepCopy(obj[key]);\n\t\t}\n\t}\n\treturn copy;\n}\n\n// Remove file extension\nexport function removeExtension(fileName: string): string {\n\treturn fileName.replace(/\\.[^/.]+$/, '');\n}\n\n/**\n * Formats a file size in bytes to the appropriate unit (bytes, kilobytes, megabytes, or gigabytes).\n * @param sizeInBytes - The size of the file in bytes.\n * @returns The formatted file size as a string.\n */\nexport function formatBytes(bytes: number): string {\n\tif (bytes === 0 || isNaN(bytes)) {\n\t\treturn '0 bytes';\n\t}\n\n\tif (bytes < 0) {\n\t\tthrow Error('Input size cannot be negative');\n\t}\n\n\tconst units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'];\n\tlet power = 0;\n\n\twhile (bytes >= 1024 && power < units.length - 1) {\n\t\tbytes /= 1024;\n\t\tpower++;\n\t}\n\n\treturn `${bytes.toFixed(2)} ${units[power]}`;\n}\n\n// Function to convert Unix timestamp to readable date string\nexport function convertTimestampToDateString(timestamp: number) {\n\tif (timestamp === null || timestamp === undefined) {\n\t\treturn '-';\n\t}\n\n\tconst options: Intl.DateTimeFormatOptions = {\n\t\tday: '2-digit',\n\t\tmonth: '2-digit',\n\t\tyear: 'numeric',\n\t\thour: '2-digit',\n\t\tminute: '2-digit',\n\t\thour12: false\n\t};\n\tconst locale = app.contentLanguage;\n\tconst date = new Date(timestamp * 1000);\n\treturn date.toLocaleDateString(locale, options);\n}\n\nexport function formatUptime(uptime: number) {\n\tconst units = [\n\t\t{ label: ['year', 'years'], value: 365 * 24 * 60 * 60 },\n\t\t{ label: ['month', 'months'], value: 30 * 24 * 60 * 60 },\n\t\t{ label: ['week', 'weeks'], value: 7 * 24 * 60 * 60 },\n\t\t{ label: ['day', 'days'], value: 24 * 60 * 60 },\n\t\t{ label: ['hour', 'hours'], value: 60 * 60 },\n\t\t{ label: ['minute', 'minutes'], value: 60 },\n\t\t{ label: ['second', 'seconds'], value: 1 }\n\t];\n\n\tconst result: string[] = [];\n\tfor (const unit of units) {\n\t\tconst quotient = Math.floor(uptime / unit.value);\n\t\tif (quotient > 0) {\n\t\t\tresult.push(`${quotient} ${unit.label[quotient > 1 ? 1 : 0]}`);\n\t\t\tuptime %= unit.value;\n\t\t}\n\t}\n\n\treturn result.join(' ');\n}\n\n// Export function for ReadableExpireIn\nexport function ReadableExpireIn(expiresIn: string) {\n\tconst expiresInNumber = parseInt(expiresIn, 10);\n\tconst expirationTime = expiresInNumber ? new Date(Date.now() + expiresInNumber * 1000) : new Date();\n\n\tconst daysDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60 * 60 * 24));\n\tconst hoursDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60 * 60)) % 24;\n\tconst minutesDiff = Math.floor((expirationTime.getTime() - Date.now()) / (1000 * 60)) % 60;\n\n\tconst daysText = daysDiff > 0 ? `${daysDiff} day${daysDiff > 1 ? 's' : ''}` : '';\n\tconst hoursText = hoursDiff > 0 ? `${hoursDiff} hour${hoursDiff > 1 ? 's' : ''}` : '';\n\tconst minutesText = minutesDiff > 0 ? `${minutesDiff} minute${minutesDiff > 1 ? 's' : ''}` : '';\n\n\treturn `${daysText} ${hoursText} ${minutesText}`.trim();\n}\n\n// Get elements by ID\ninterface ElementStore {\n\t[key: string]: {\n\t\tid: string;\n\t\tcallback: (data: unknown) => void;\n\t}[];\n}\n\nexport const get_elements_by_id = {\n\tstore: {} as ElementStore,\n\tadd(collection: string, id: string, callback: (data: unknown) => void) {\n\t\tif (!this.store[collection]) {\n\t\t\tthis.store[collection] = [];\n\t\t}\n\t\tthis.store[collection].push({ id, callback });\n\t},\n\tasync getAll(dbAdapter: { get: (id: string) => Promise<unknown> }) {\n\t\tfor (const collection in this.store) {\n\t\t\tfor (const item of this.store[collection]) {\n\t\t\t\tconst data = await dbAdapter.get(item.id);\n\t\t\t\titem.callback(data);\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Meta data types\ninterface MetaData {\n\tmedia_images_remove?: string[];\n\t[key: string]: unknown;\n}\n\nexport const meta_data = {\n\tmeta_data: {} as MetaData,\n\tadd(key: keyof MetaData, data: unknown) {\n\t\tthis.meta_data[key] = data;\n\t},\n\tget(): MetaData {\n\t\treturn this.meta_data;\n\t},\n\tclear() {\n\t\tthis.meta_data = {};\n\t},\n\tis_empty(): boolean {\n\t\treturn Object.keys(this.meta_data).length === 0;\n\t}\n};\n\n// Convert data to string\ninterface StringHelperParams {\n\tfield?: FieldInstance;\n\tdata: unknown[];\n\tpath?: (lang: string) => string;\n}\n\nexport function toStringHelper({ data }: StringHelperParams): string {\n\tif (!Array.isArray(data)) return '';\n\treturn data.map((item: unknown) => String(item)).join(', ');\n}\n\n// Get random hex string\nexport function getRandomHex(size: number): string {\n\tconst bytes = new Uint8Array(size);\n\tfor (let i = 0; i < size; i++) {\n\t\tbytes[i] = Math.floor(Math.random() * 256);\n\t}\n\treturn Array.from(bytes)\n\t\t.map((byte) => byte.toString(16).padStart(2, '0'))\n\t\t.join('');\n}\n\n// Escape regex metacharacters\nexport function escapeRegex(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// Get current date in YYYY-MM-DD format\nexport function getCurrentDate(): string {\n\tconst d = new Date();\n\treturn d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');\n}\n\n// Convert hex to array buffer\nexport function hex2arrayBuffer(hex: string): ArrayBuffer {\n\tconst bytes = new Uint8Array(hex.length / 2);\n\tfor (let i = 0; i < hex.length; i += 2) {\n\t\tbytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n\t}\n\treturn bytes.buffer;\n}\n\n// Convert array buffer to hex\nexport function arrayBuffer2hex(buffer: ArrayBuffer): string {\n\treturn Array.from(new Uint8Array(buffer))\n\t\t.map((byte) => byte.toString(16).padStart(2, '0'))\n\t\t.join('');\n}\n\n// SHA-256 hash function\nexport async function sha256(buffer: ArrayBuffer): Promise<string> {\n\tconst hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n\treturn arrayBuffer2hex(hashBuffer);\n}\n\n// Enhanced debounce utility with flexible patterns\nexport function debounce(delay: number = 300, immediate: boolean = false) {\n\tlet timer: NodeJS.Timeout | undefined;\n\tlet hasExecuted = false;\n\n\treturn (fn: () => void) => {\n\t\tconst shouldExecuteImmediately = immediate && !hasExecuted;\n\n\t\tif (shouldExecuteImmediately) {\n\t\t\tfn();\n\t\t\thasExecuted = true;\n\t\t\treturn;\n\t\t}\n\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => {\n\t\t\tfn();\n\t\t}, delay);\n\t};\n}\n\n// Traditional debounce pattern - takes function and delay, returns debounced version\ndebounce.create = function <T extends (...args: unknown[]) => unknown>(func: T, wait: number = 300): (...args: Parameters<T>) => void {\n\tlet timeout: ReturnType<typeof setTimeout>;\n\n\treturn function executedFunction(...args: Parameters<T>) {\n\t\tconst later = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tfunc(...args);\n\t\t};\n\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t};\n};\n\n// Validates data against a Valibot schema, returning errors or null if valid\nexport function validateValibot<T>(schema: BaseSchema<T, T, BaseIssue<unknown>>, value?: T): null | { [P in keyof T]?: string[] } {\n\ttry {\n\t\t// Use v.safeParse to handle parsing\n\t\tconst result = v.safeParse(schema, value);\n\n\t\tif (result.success) {\n\t\t\treturn null; // No errors\n\t\t}\n\n\t\tconst fieldErrors = {} as { [P in keyof T]?: string[] };\n\n\t\t// Iterate over issues and populate field errors\n\t\tfor (const issue of result.issues) {\n\t\t\tconst path = issue.path?.[0]?.key as keyof T;\n\t\t\tif (path) {\n\t\t\t\tfieldErrors[path] = fieldErrors[path] || [];\n\t\t\t\tfieldErrors[path]!.push(issue.message);\n\t\t\t}\n\t\t}\n\n\t\treturn fieldErrors;\n\t} catch (error) {\n\t\tlogger.error('Validation error:', error as LoggableValue);\n\t\treturn null;\n\t}\n}\n\nexport function getTextDirection(lang: string): string {\n\tconst rtlLanguages = ['ar', 'he', 'fa', 'ur', 'dv', 'ha', 'khw', 'ks', 'ku', 'ps', 'syr', 'ug', 'yi'];\n\treturn rtlLanguages.includes(lang) ? 'rtl' : 'ltr';\n}\n\nexport async function motion(start: number[], end: number[], duration: number, cb: (current: number[]) => void) {\n\tconst current = [...start];\n\tlet elapsed = 0;\n\tlet time = Date.now();\n\tlet has_passed = false;\n\tsetTimeout(() => {\n\t\thas_passed = true;\n\t}, duration);\n\treturn new Promise<void>((resolve) => {\n\t\tfunction animation(current: number[]) {\n\t\t\telapsed = Date.now() - time;\n\t\t\tconst ds = start.map((s, i) => (s - end[i]) / (duration / elapsed));\n\n\t\t\ttime = Date.now();\n\t\t\tfor (const index in ds) {\n\t\t\t\tcurrent[index] -= ds[index];\n\t\t\t}\n\n\t\t\tif (has_passed) {\n\t\t\t\tcb(end);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcb(current);\n\t\t\t\trequestAnimationFrame(() => animation(current));\n\t\t\t}\n\t\t}\n\n\t\trequestAnimationFrame(() => animation(current));\n\t});\n}\n\nexport function getEditDistance(a: string, b: string): number | undefined {\n\tif (a.length === 0) return b.length;\n\tif (b.length === 0) return a.length;\n\n\tconst insertionCost = 1;\n\tconst deletionCost = 1;\n\tconst substitutionCost = 1;\n\n\tconst matrix: number[][] = [];\n\n\tfor (let i = 0; i <= b.length; i++) {\n\t\tmatrix[i] = [i];\n\t}\n\tfor (let j = 0; j <= a.length; j++) {\n\t\tmatrix[0][j] = j;\n\t}\n\n\tfor (let i = 1; i <= b.length; i++) {\n\t\tfor (let j = 1; j <= a.length; j++) {\n\t\t\tif (b.charAt(i - 1) === a.charAt(j - 1)) {\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j - 1];\n\t\t\t} else {\n\t\t\t\tmatrix[i][j] = Math.min(matrix[i - 1][j - 1] + substitutionCost, Math.min(matrix[i][j - 1] + insertionCost, matrix[i - 1][j] + deletionCost));\n\t\t\t}\n\t\t}\n\t}\n\n\tconst maxDistance = Math.max(a.length, b.length);\n\tconst normalizedDistance = matrix[b.length][a.length] / maxDistance;\n\n\treturn normalizedDistance;\n}\n\n// PascalCase to camelCase conversion\nexport const pascalToCamelCase = (str: string): string => {\n\tif (!str) return str;\n\treturn str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n// Type assertion helper - used for widget type assertions\nexport function asAny<T>(value: unknown): T {\n\treturn value as T;\n}\n"],"names":[],"mappings":"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"}