{"version":3,"file":"_page.server.ts.js","sources":["../../../../../../../../shared/utils/src/server/collection-utils.server.ts","../../../../../../src/routes/login/+page.server.ts"],"sourcesContent":["import { contentManager } from '@content/ContentManager';\nimport type { Locale } from '@shared/paraglide/runtime';\nimport { logger } from '@shared/utils/logger.server';\nimport { SvelteMap } from 'svelte/reactivity';\n\n/**\n * Constructs a redirect URL to the first available collection, prefixed with the given language.\n * Returns null if no collections are found, allowing the caller to decide on a fallback route.\n * @param language The validated user language (e.g., 'en', 'de').\n */\nexport async function fetchAndRedirectToFirstCollection(language: Locale): Promise<string | null> {\n\ttry {\n\t\tlogger.debug(`Fetching first collection path for language: ${language}`);\n\n\t\tconst firstCollection = await contentManager.getFirstCollection();\n\t\tif (firstCollection?.path) {\n\t\t\t// Ensure the collection path has a leading slash\n\t\t\tconst collectionPath = firstCollection.path.startsWith('/') ? firstCollection.path : `/${firstCollection.path}`;\n\t\t\tconst redirectUrl = `/${language}${collectionPath}`;\n\t\t\tlogger.info(`Redirecting to first collection: ${firstCollection.name} at path: ${redirectUrl}`);\n\t\t\treturn redirectUrl;\n\t\t}\n\n\t\tlogger.warn('No collections found via getFirstCollection(), returning null.');\n\t\treturn null; // Return null if no collections are configured\n\t} catch (err) {\n\t\tlogger.error('Error in fetchAndRedirectToFirstCollection:', err);\n\t\treturn null; // Return null on error\n\t}\n}\n\nconst cachedFirstCollectionPaths = new SvelteMap<Locale, { path: string; expiry: number }>();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache\n\n/**\n * A cached function to get the redirect path for the first available collection.\n * The cache is language-aware and helps avoid redundant database lookups.\n * @param language The validated user language.\n */\nexport async function getCachedFirstCollectionPath(language: Locale): Promise<string | null> {\n\tconst now = Date.now();\n\tconst cachedEntry = cachedFirstCollectionPaths.get(language);\n\n\t// Return cached result if still valid\n\tif (cachedEntry && now < cachedEntry.expiry) {\n\t\treturn cachedEntry.path;\n\t}\n\n\t// Fetch fresh data by calling the utility function\n\tconst result = await fetchAndRedirectToFirstCollection(language);\n\n\t// Cache the result if it's a valid path\n\tif (result) {\n\t\tcachedFirstCollectionPaths.set(language, { path: result, expiry: now + CACHE_DURATION });\n\t}\n\n\treturn result;\n}\n","/**\n * @file src/routes/login/+page.server.ts\n * @description Server-side logic for the login page.\n *\n * @example\n * <PermissionSettings />\n *\n * ### Props\n * - `user`: The authenticated user data.\n *\n * ### Features\n * - User authentication and authorization\n * - Proper typing for user data\n */\n\nimport { dev } from '$app/environment';\nimport { fail, redirect, type Actions, type Cookies } from '@sveltejs/kit';\nimport type { PageServerLoad } from './$types';\n\n// Rate Limiter\nimport { RateLimiter } from 'sveltekit-rate-limiter/server';\n\n// Cache invalidation\nimport { invalidateUserCountCache } from '@cms/hooks/handleAuthorization';\n\n// valibot schemas\nimport { forgotFormSchema, loginFormSchema, resetFormSchema, signUpFormSchema } from '@shared/utils/formSchemas';\nimport { flatten, safeParse } from 'valibot';\n\n// Auth\nimport { generateGoogleAuthUrl, googleAuth } from '@shared/database/auth/googleAuth';\nimport type { User } from '@shared/database/auth/types';\nimport { auth, dbInitPromise } from '@shared/database/db';\nimport { google } from 'googleapis';\n\n// Utils\nimport type { ISODateString } from '@cms-types';\n\n// Stores\nimport type { Locale } from '@shared/paraglide/runtime';\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { publicEnv } from '@shared/stores/globalSettings.svelte';\nimport type { Schema, FieldDefinition, WidgetPlaceholder } from '@cms-types';\nimport { app } from '@shared/stores/store.svelte';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Content Manager for redirects\nimport { contentManager } from '@content/ContentManager';\n\nconst limiter = new RateLimiter({\n\tIP: [200, 'h'], // 200 requests per hour per IP\n\tIPUA: [100, 'm'], // 100 requests per minute per IP+User-Agent\n\tcookie: {\n\t\tname: 'ratelimit',\n\t\tsecret: getPrivateSettingSync('JWT_SECRET_KEY'),\n\t\trate: [50, 'm'], // 50 requests per minute per cookie\n\t\tpreflight: true\n\t}\n});\n\n// Password strength configuration\nconst MIN_PPASSWORD_LENGTH = publicEnv.PASSWORD_LENGTH || 8;\nconst YELLOW_LENGTH = MIN_PPASSWORD_LENGTH + 3;\nconst GREEN_LENGTH = YELLOW_LENGTH + 4;\n\n// Function to calculate password strength (matches the logic in PasswordStrength.svelte)\nfunction calculatePasswordStrength(password: string): number {\n\tif (password.length >= GREEN_LENGTH) return 3;\n\tif (password.length >= YELLOW_LENGTH) return 2;\n\tif (password.length >= MIN_PPASSWORD_LENGTH) return 1;\n\treturn 0;\n}\n\n// Helper function to check database health by querying system state\nasync function checkDatabaseHealth(): Promise<{ healthy: boolean; reason?: string }> {\n\ttry {\n\t\t// First check system state - leverage existing state management\n\t\tconst { getSystemState, isServiceHealthy } = await import('@shared/stores/system');\n\t\tconst systemState = getSystemState();\n\n\t\t// If database service is explicitly unhealthy in state management, return early\n\t\tif (!isServiceHealthy('database')) {\n\t\t\tconst dbStatus = systemState.services.database;\n\t\t\treturn {\n\t\t\t\thealthy: false,\n\t\t\t\treason: dbStatus.message || dbStatus.error || 'Database service is unhealthy'\n\t\t\t};\n\t\t}\n\n\t\t// If system is in FAILED state, check if it's database-related\n\t\tif (systemState.overallState === 'FAILED') {\n\t\t\tconst lastFailure = systemState.performanceMetrics.stateTransitions\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.find((t) => t.to === 'FAILED');\n\t\t\tif (lastFailure?.reason) {\n\t\t\t\treturn { healthy: false, reason: lastFailure.reason };\n\t\t\t}\n\t\t}\n\n\t\t// State looks good, verify database actually has data (setup completion check)\n\t\tawait dbInitPromise;\n\n\t\tconst { auth } = await import('@shared/database/db');\n\t\tif (!auth) {\n\t\t\treturn { healthy: false, reason: 'Authentication service not initialized' };\n\t\t}\n\n\t\t// Lightweight check: verify database has roles (indicates setup was completed)\n\t\ttry {\n\t\t\tconst roles = await auth.getAllRoles();\n\t\t\tif (!roles || roles.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\thealthy: false,\n\t\t\t\t\treason: 'Database is empty - no roles found. Setup may not have completed successfully.'\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\thealthy: false,\n\t\t\t\treason: `Failed to query roles: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t};\n\t\t}\n\n\t\treturn { healthy: true };\n\t} catch (error) {\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\treturn { healthy: false, reason: `Database connection error: ${errorMessage}` };\n\t}\n}\n\n// Helper function to wait for auth service to be ready\nasync function waitForAuthService(maxWaitMs: number = 10000): Promise<boolean> {\n\tconst startTime = Date.now();\n\tlogger.debug(`Waiting for auth service to be ready (timeout: ${maxWaitMs}ms)...`);\n\n\twhile (Date.now() - startTime < maxWaitMs) {\n\t\ttry {\n\t\t\t// Check if database initialization is complete\n\t\t\tif (dbInitPromise) {\n\t\t\t\t// Check if the promise is still pending\n\t\t\t\tconst dbStatus = await Promise.race([dbInitPromise.then(() => 'ready'), new Promise((resolve) => setTimeout(() => resolve('timeout'), 100))]);\n\n\t\t\t\tif (dbStatus === 'timeout') {\n\t\t\t\t\t// Database initialization is still in progress\n\t\t\t\t\tlogger.debug('Database initialization still in progress...');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if auth service is ready\n\t\t\tif (auth && typeof auth.validateSession === 'function') {\n\t\t\t\tlogger.debug(`Auth service ready after ${Date.now() - startTime}ms`);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Log progress every 5 seconds\n\t\t\tconst elapsed = Date.now() - startTime;\n\t\t\tif (elapsed % 5000 < 100) {\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`Auth service not ready yet, elapsed: ${elapsed}ms, auth: ${!!auth}, validateSession: ${auth && typeof auth.validateSession === 'function'}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100)); // Wait 100ms before checking again\n\t\t} catch (error) {\n\t\t\tlogger.error(`Error while waiting for auth service: ${error instanceof Error ? error.message : String(error)}`);\n\t\t\t// Continue waiting even if there's an error\n\t\t}\n\t}\n\n\tlogger.error(`Auth service not ready after ${maxWaitMs}ms timeout`);\n\treturn false;\n}\n\nimport { getCachedFirstCollectionPath } from '@shared/utils/server/collection-utils.server';\n\n// Helper function to check if OAuth should be available\nasync function shouldShowOAuth(hasInviteToken: boolean): Promise<boolean> {\n\t// If Google OAuth is not enabled, never show it\n\tif (!publicEnv.USE_GOOGLE_OAUTH) {\n\t\treturn false;\n\t}\n\n\t// If there's an invite token, show OAuth (invited user can choose OAuth)\n\tif (hasInviteToken) {\n\t\treturn true;\n\t}\n\n\t// Optimization: If OAuth is enabled, we generally want to show it.\n\t// The previous check for existing users was redundant because it returned true regardless.\n\t// We just verify auth service is available.\n\ttry {\n\t\tawait dbInitPromise;\n\t\tif (!auth) {\n\t\t\tlogger.warn('Auth service not available for OAuth user check');\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (error) {\n\t\tlogger.error('Error checking for OAuth availability:', error);\n\t\treturn true; // Fail open to allow login attempts\n\t}\n}\n\n// Define wrapped schemas for caching\n// Schemas are imported directly\n\nexport const load: PageServerLoad = async ({ url, cookies, fetch, request, locals }) => {\n\tconst demoMode = getPrivateSettingSync('DEMO');\n\t// --- START: Language Validation Logic ---\n\tconst langFromStore = app.systemLanguage as Locale | null;\n\t// Use PUBLIC_ENV.LOCALES for validation, fallback to BASE_LOCALE\n\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE]) as Locale[];\n\tconst userLanguage = (langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale)) || 'en';\n\t// --- END: Language Validation Logic ---\n\n\ttry {\n\t\t// Check system state first - leverage existing state management for performance\n\t\tconst { getSystemState } = await import('@shared/stores/system');\n\t\tconst systemState = getSystemState();\n\n\t\t// If system is FAILED, provide detailed error immediately without waiting\n\t\tif (systemState.overallState === 'FAILED') {\n\t\t\tlogger.error('System is in FAILED state, cannot proceed with login');\n\t\t\tconst lastFailure = systemState.performanceMetrics.stateTransitions\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.find((t) => t.to === 'FAILED');\n\n\t\t\treturn {\n\t\t\t\tfirstUserExists: true,\n\t\t\t\tshowOAuth: false,\n\t\t\t\thasExistingOAuthUsers: false,\n\t\t\t\tloginForm: {},\n\t\t\t\tforgotForm: {},\n\t\t\t\tresetForm: {},\n\t\t\t\tsignUpForm: {},\n\t\t\t\tshowDatabaseError: true,\n\t\t\t\terrorReason: lastFailure?.reason || 'System initialization failed. Please check the database connection and configuration.',\n\t\t\t\tcanReset: true,\n\t\t\t\tauthNotReady: true,\n\t\t\t\tauthNotReadyMessage: lastFailure?.reason || 'System initialization failed. Please check the database connection and configuration.',\n\t\t\t\tdemoMode\n\t\t\t};\n\t\t}\n\n\t\t// Ensure initialization is complete\n\t\tawait dbInitPromise;\n\n\t\t// Fast health check using state management + database verification\n\t\tconst dbHealth = await checkDatabaseHealth();\n\t\tif (!dbHealth.healthy) {\n\t\t\tlogger.error(`Database health check failed: ${dbHealth.reason}`);\n\t\t\treturn {\n\t\t\t\tfirstUserExists: true,\n\t\t\t\tshowOAuth: false,\n\t\t\t\thasExistingOAuthUsers: false,\n\t\t\t\tloginForm: {},\n\t\t\t\tforgotForm: {},\n\t\t\t\tresetForm: {},\n\t\t\t\tsignUpForm: {},\n\t\t\t\tshowDatabaseError: true,\n\t\t\t\terrorReason: dbHealth.reason,\n\t\t\t\tcanReset: true,\n\t\t\t\tauthNotReady: true,\n\t\t\t\tauthNotReadyMessage: dbHealth.reason\n\t\t\t};\n\t\t}\n\n\t\t// Database is healthy, now check auth service (reduced timeout from 30s to 10s)\n\t\tconst authReady = await waitForAuthService();\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.warn('Authentication system is not ready yet, checking if database is empty');\n\n\t\t\t// Check if this is a \"database empty\" scenario\n\t\t\tconst { isSetupCompleteAsync } = await import('@shared/utils/setupCheck');\n\t\t\tconst setupComplete = await isSetupCompleteAsync();\n\n\t\t\tif (!setupComplete) {\n\t\t\t\tlogger.error('Database is empty but config exists. This typically means the database was manually dropped.');\n\t\t\t\treturn {\n\t\t\t\t\tfirstUserExists: true,\n\t\t\t\t\tshowOAuth: false,\n\t\t\t\t\thasExistingOAuthUsers: false,\n\t\t\t\t\tloginForm: {},\n\t\t\t\t\tforgotForm: {},\n\t\t\t\t\tresetForm: {},\n\t\t\t\t\tsignUpForm: {},\n\t\t\t\t\tauthNotReady: true,\n\t\t\t\t\tauthNotReadyMessage: 'Database is empty. Please restore your database from backup or delete config/private.ts to run setup again.',\n\t\t\t\t\tdemoMode\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Return fallback data instead of throwing error\n\t\t\treturn {\n\t\t\t\tfirstUserExists: true,\n\t\t\t\tshowOAuth: false, // Don't show OAuth if auth system isn't ready\n\t\t\t\thasExistingOAuthUsers: false,\n\t\t\t\tloginForm: {},\n\t\t\t\tforgotForm: {},\n\t\t\t\tresetForm: {},\n\t\t\t\tsignUpForm: {},\n\t\t\t\tauthNotReady: true,\n\t\t\t\tauthNotReadyMessage: 'System is still initializing. Please wait a moment and try again.',\n\t\t\t\tdemoMode\n\t\t\t};\n\t\t}\n\n\t\tif (!locals) locals = {} as App.Locals;\n\n\t\t// Check if user is already authenticated\n\t\tif (locals.user) {\n\t\t\tlogger.debug('User is already authenticated in load, attempting to redirect to collection');\n\n\t\t\t// Check if collections exist in the database\n\t\t\tconst finalCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\t\tlet redirectPath: string;\n\t\t\tif (finalCollectionPath) {\n\t\t\t\t// Collections exist - redirect to first collection\n\t\t\t\tredirectPath = finalCollectionPath;\n\t\t\t\tlogger.debug(`Authenticated user redirect to collection: ${redirectPath}`);\n\t\t\t} else {\n\t\t\t\t// No collections available - redirect based on permissions\n\t\t\t\tlogger.debug('No collections available for authenticated user, redirecting based on permissions');\n\t\t\t\tconst { hasPermissionWithRoles } = await import('@shared/database/auth/permissions');\n\t\t\t\tconst isAdmin = hasPermissionWithRoles(locals.user, 'config:collectionbuilder', []);\n\t\t\t\tredirectPath = isAdmin ? '/config/collectionbuilder' : '/user';\n\t\t\t}\n\n\t\t\tthrow redirect(302, redirectPath);\n\t\t}\n\n\t\t// Rate limiter preflight check\n\t\tif (limiter.cookieLimiter?.preflight) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tawait limiter.cookieLimiter.preflight({ request, cookies } as any);\n\t\t}\n\n\t\t// THE NEW \"INTELLIGENT LOADER\" LOGIC\n\t\tconst inviteToken = url.searchParams.get('invite_token');\n\n\t\tif (inviteToken) {\n\t\t\t// This is an invite flow!\n\t\t\tconst tokenData = await auth.validateRegistrationToken(inviteToken);\n\n\t\t\tif (tokenData.isValid && tokenData.details) {\n\t\t\t\t// Token is valid! Prepare the page for invite-based signup.\n\t\t\t\tlogger.info('Valid invite token detected. Preparing invite signup form.');\n\n\t\t\t\t// Check firstUserExists for consistency\n\t\t\t\tconst firstUserExists = locals.isFirstUser === false;\n\n\t\t\t\t// Check if OAuth should be shown (with invite token)\n\t\t\t\tconst showOAuth = await shouldShowOAuth(true);\n\n\t\t\t\treturn {\n\t\t\t\t\tfirstUserExists,\n\t\t\t\t\tisInviteFlow: true,\n\t\t\t\t\tshowOAuth,\n\t\t\t\t\thasExistingOAuthUsers: false, // Not relevant for invite flow\n\t\t\t\t\ttoken: inviteToken,\n\t\t\t\t\tinvitedEmail: tokenData.details.email,\n\t\t\t\t\troleId: tokenData.details.role, // Pass the roleId from the token\n\t\t\t\t\tloginForm: {},\n\t\t\t\t\tforgotForm: {},\n\t\t\t\t\tresetForm: {},\n\t\t\t\t\tsignUpForm: {},\n\t\t\t\t\tdemoMode\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Token is invalid, expired, or already used.\n\t\t\t\t// Instead of completely blocking, let the user access the form\n\t\t\t\t// and pre-fill the token so they can see what's wrong or enter a different one\n\t\t\t\tlogger.warn('Invalid invite token detected, but allowing form access with pre-filled token.');\n\n\t\t\t\t// Check firstUserExists for consistency\n\t\t\t\tconst firstUserExists = locals.isFirstUser === false;\n\n\t\t\t\t// Check if OAuth should be shown (invalid invite, but has token)\n\t\t\t\tconst showOAuth = await shouldShowOAuth(true);\n\n\t\t\t\t// Pre-fill the form with the invalid token and show a warning\n\t\t\t\tconst signUpForm = { token: inviteToken }; // Pre-fill with the invalid token\n\n\t\t\t\treturn {\n\t\t\t\t\tfirstUserExists,\n\t\t\t\t\tisInviteFlow: false, // Not a proper invite flow since token is invalid\n\t\t\t\t\tshowOAuth,\n\t\t\t\t\thasExistingOAuthUsers: false,\n\t\t\t\t\tinviteError:\n\t\t\t\t\t\t'This invitation token appears to be invalid, expired, or already used. Please check with your administrator or enter a different token.',\n\t\t\t\t\tloginForm: {},\n\t\t\t\t\tforgotForm: {},\n\t\t\t\t\tresetForm: {},\n\t\t\t\t\tsignUpForm,\n\t\t\t\t\tdemoMode\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Use the firstUserExists value from locals (set by hooks)\n\t\tconst firstUserExists = locals.isFirstUser === false;\n\t\tlogger.debug(`In load: firstUserExists determined as: ${firstUserExists} (based on locals.isFirstUser: ${locals.isFirstUser})`);\n\n\t\t// Note: If no users exist, handleSetup hook will redirect to /setup before this code runs\n\n\t\tconst code = url.searchParams.get('code');\n\t\tlogger.debug(`Authorization code from URL: ${code ?? 'none'}`);\n\n\t\t// Handle Google OAuth flow if code is present\n\t\tif (publicEnv.USE_GOOGLE_OAUTH && code) {\n\t\t\tlogger.debug('Entering Google OAuth flow in load function');\n\t\t\ttry {\n\t\t\t\tconst googleAuthInstance = await googleAuth();\n\t\t\t\tif (!googleAuthInstance) throw Error('Google OAuth client is not initialized');\n\n\t\t\t\tlogger.debug('Fetching tokens using authorization code...');\n\t\t\t\tconst { tokens } = await googleAuthInstance.getToken(code);\n\t\t\t\tif (!tokens) throw new Error('Failed to retrieve Google OAuth tokens.');\n\n\t\t\t\tgoogleAuthInstance.setCredentials(tokens);\n\t\t\t\tconst oauth2 = google.oauth2('v2');\n\t\t\t\t// Assign auth client to oauth2 context options with proper type\n\t\t\t\t(oauth2.context._options as { auth?: typeof googleAuthInstance }).auth = googleAuthInstance;\n\t\t\t\tconst { data: googleUser } = await oauth2.userinfo.get();\n\t\t\t\tlogger.debug(`Google user information: ${JSON.stringify(googleUser)}`);\n\n\t\t\t\t// Invite token comes back via OAuth state param\n\t\t\t\tconst stateParam = url.searchParams.get('state');\n\t\t\t\tconst inviteToken = stateParam ? decodeURIComponent(stateParam) : null;\n\t\t\t\tif (!auth) {\n\t\t\t\t\tthrow new Error('Auth service is not initialized');\n\t\t\t\t}\n\n\t\t\t\tconst getUser = async (): Promise<[User | null, boolean]> => {\n\t\t\t\t\tconst email = googleUser.email;\n\t\t\t\t\tif (!email) throw Error('Google did not return an email address.');\n\n\t\t\t\t\tconst existingUser = await auth!.checkUser({ email });\n\t\t\t\t\tif (existingUser) return [existingUser, false];\n\n\t\t\t\t\t// For non-first users (or any users), allow only invite-based registration\n\t\t\t\t\tif (!inviteToken) {\n\t\t\t\t\t\tlogger.warn('OAuth registration attempt without invite token in state');\n\t\t\t\t\t\treturn [null, false];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst tokenData = await auth!.validateRegistrationToken(inviteToken);\n\t\t\t\t\tif (!tokenData.isValid || !tokenData.details) {\n\t\t\t\t\t\tlogger.warn('Invalid/expired invite token used in OAuth registration');\n\t\t\t\t\t\treturn [null, false];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure email matches invitation\n\t\t\t\t\tif (tokenData.details.email.toLowerCase() !== email.toLowerCase()) {\n\t\t\t\t\t\tlogger.warn('Invite token email mismatch in OAuth registration', {\n\t\t\t\t\t\t\ttokenEmail: tokenData.details.email,\n\t\t\t\t\t\t\tgoogleEmail: email\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn [null, false];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst roleId = tokenData.details.role || 'user';\n\n\t\t\t\t\tconst newUser = await auth!.createUser({\n\t\t\t\t\t\temail,\n\t\t\t\t\t\tusername: googleUser.name || email.split('@')[0],\n\t\t\t\t\t\trole: roleId,\n\t\t\t\t\t\tpermissions: [],\n\t\t\t\t\t\tisRegistered: true,\n\t\t\t\t\t\tlastAuthMethod: 'google'\n\t\t\t\t\t});\n\n\t\t\t\t\t// Consume the invitation token after successful registration\n\t\t\t\t\tawait auth!.consumeRegistrationToken(inviteToken);\n\n\t\t\t\t\tlogger.info(`OAuth: Invited user created: ${newUser?.username}`);\n\t\t\t\t\tconst emailProps = {\n\t\t\t\t\t\tusername: googleUser.name || newUser?.username || '',\n\t\t\t\t\t\temail: email,\n\t\t\t\t\t\thostLink: publicEnv.HOST_PROD || `https://${request.headers.get('host')}`,\n\t\t\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS'\n\t\t\t\t\t};\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst mailResponse = await fetch('/api/sendMail', {\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\t\trecipientEmail: email,\n\t\t\t\t\t\t\t\tsubject: `Welcome to ${emailProps.sitename}`,\n\t\t\t\t\t\t\t\ttemplateName: 'welcomeUser',\n\t\t\t\t\t\t\t\tprops: emailProps,\n\t\t\t\t\t\t\t\tlanguageTag: app.systemLanguage\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!mailResponse.ok) {\n\t\t\t\t\t\t\tlogger.error(`OAuth: Failed to send welcome email to invited user via API. Status: ${mailResponse.status}`, {\n\t\t\t\t\t\t\t\temail,\n\t\t\t\t\t\t\t\tresponseText: await mailResponse.text()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.info(`OAuth: Welcome email request sent to invited user via API`, { email });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (emailError) {\n\t\t\t\t\t\tlogger.error(`OAuth: Error fetching /api/sendMail for invited user`, { email, error: emailError });\n\t\t\t\t\t}\n\t\t\t\t\treturn [newUser, false];\n\t\t\t\t};\n\n\t\t\t\tconst [user] = await getUser();\n\n\t\t\t\tif (user && user._id) {\n\t\t\t\t\tawait createSessionAndSetCookie(user._id, cookies);\n\t\t\t\t\tawait auth!.updateUserAttributes(user._id, { lastAuthMethod: 'google' });\n\n\t\t\t\t\t// Determine redirect path based on collections\n\t\t\t\t\tconst finalCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\t\t\t\tlet redirectPath: string;\n\t\t\t\t\tif (finalCollectionPath) {\n\t\t\t\t\t\t// Collections exist - redirect to first collection\n\t\t\t\t\t\tredirectPath = finalCollectionPath;\n\t\t\t\t\t\tlogger.debug(`OAuth login redirect to collection: ${redirectPath}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No collections available - redirect based on permissions\n\t\t\t\t\t\tlogger.debug('No collections available for OAuth login, redirecting based on permissions');\n\t\t\t\t\t\tconst { hasPermissionWithRoles } = await import('@shared/database/auth/permissions');\n\t\t\t\t\t\tconst isAdmin = hasPermissionWithRoles(user, 'config:collectionbuilder', []);\n\t\t\t\t\t\tredirectPath = isAdmin ? '/config/collectionbuilder' : '/user';\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow redirect(303, redirectPath);\n\t\t\t\t}\n\n\t\t\t\tlogger.warn(`OAuth: User processing ended without session creation for ${googleUser.email}.`);\n\t\t\t\t// Check if OAuth should be shown for error case\n\t\t\t\tconst showOAuth = await shouldShowOAuth(false);\n\t\t\t\treturn {\n\t\t\t\t\tisInviteFlow: false,\n\t\t\t\t\tfirstUserExists,\n\t\t\t\t\tshowOAuth,\n\t\t\t\t\thasExistingOAuthUsers: false, // Not relevant for error case\n\t\t\t\t\tloginForm: {},\n\t\t\t\t\tforgotForm: {},\n\t\t\t\t\tresetForm: {},\n\t\t\t\t\tsignUpForm: {},\n\t\t\t\t\toauthError: 'OAuth processing failed. Please try signing in with email or contact support.',\n\t\t\t\t\tdemoMode\n\t\t\t\t};\n\t\t\t} catch (oauthError) {\n\t\t\t\t// Check if this is a SvelteKit redirect (which is expected)\n\t\t\t\tif (oauthError instanceof Response && oauthError.status >= 300 && oauthError.status < 400) {\n\t\t\t\t\tthrow oauthError; // Re-throw redirects\n\t\t\t\t}\n\n\t\t\t\tconst err = oauthError as Error;\n\t\t\t\tlogger.error(`Error during Google OAuth login process: ${err.message}`, { stack: err.stack });\n\t\t\t\t// Check if OAuth should be shown for error case\n\t\t\t\tconst showOAuth = await shouldShowOAuth(false);\n\t\t\t\treturn {\n\t\t\t\t\tisInviteFlow: false,\n\t\t\t\t\tfirstUserExists,\n\t\t\t\t\tshowOAuth,\n\t\t\t\t\thasExistingOAuthUsers: false, // Not relevant for error case\n\t\t\t\t\tloginForm: {},\n\t\t\t\t\tforgotForm: {},\n\t\t\t\t\tresetForm: {},\n\t\t\t\t\tsignUpForm: {},\n\t\t\t\t\toauthError: `OAuth failed: ${err.message}. Please try again or use email login.`,\n\t\t\t\t\tdemoMode\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// This is a normal login flow (no invite token) - return standard forms\n\t\tconst loginForm = {};\n\t\tconst forgotForm = {};\n\t\tconst resetForm = {};\n\t\tconst signUpForm = {};\n\n\t\t// Check if OAuth should be shown\n\t\tconst showOAuth = await shouldShowOAuth(false);\n\n\t\t// Check if there are existing OAuth users (for better UX messaging)\n\t\tlet hasExistingOAuthUsers = false;\n\t\ttry {\n\t\t\tif (auth) {\n\t\t\t\t// Optimization: Use count instead of fetching all users\n\t\t\t\tconst count = await auth.getUserCount();\n\t\t\t\thasExistingOAuthUsers = count > 0;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error checking for existing OAuth users:', error);\n\t\t}\n\n\t\t// Calculate first collection path for client-side optimization (prefetching)\n\t\tconst firstCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\treturn {\n\t\t\tisInviteFlow: false,\n\t\t\tfirstUserExists,\n\t\t\tshowOAuth,\n\t\t\thasExistingOAuthUsers,\n\t\t\tloginForm,\n\t\t\tforgotForm,\n\t\t\tresetForm,\n\t\t\tsignUpForm,\n\t\t\tpkgVersion: publicEnv.PKG_VERSION || '0.0.0',\n\t\t\tdemoMode,\n\t\t\tfirstCollectionPath\n\t\t};\n\t} catch (initialError) {\n\t\tconst err = initialError as Error;\n\t\tif (err instanceof Response && err.status === 302) throw err;\n\n\t\tlogger.error(`Critical error in load function: ${err.message}`, { stack: err.stack });\n\t\treturn {\n\t\t\tisInviteFlow: false,\n\t\t\tfirstUserExists: true,\n\t\t\tshowOAuth: false, // Don't show OAuth in error case\n\t\t\thasExistingOAuthUsers: false,\n\t\t\tfirstCollection: null, // No collection info in error case\n\t\t\tloginForm: {},\n\t\t\tforgotForm: {},\n\t\t\tresetForm: {},\n\t\t\tsignUpForm: {},\n\t\t\terror: 'The login system encountered an unexpected error. Please try again later.',\n\t\t\tpkgVersion: publicEnv.PKG_VERSION || '0.0.0',\n\t\t\tdemoMode\n\t\t};\n\t}\n};\n\n// Actions for SignIn and SignUp a user with form data\nexport const actions: Actions = {\n\tsignUp: async (event) => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE || 'en']) as Locale[];\n\t\tconst userLanguage = langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale) || 'en';\n\t\tlogger.debug(`Validated user language for sign-up: ${userLanguage}`);\n\t\t// --- END: Language Validation Logic ---\n\n\t\t// Note: First-user registration is handled by /setup (enforced by handleSetup hook)\n\t\t// This action only handles invited user registration\n\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests. Please try again later.' });\n\t\t}\n\n\t\t// Ensure database initialization is complete\n\t\ttry {\n\t\t\tawait dbInitPromise;\n\t\t\tlogger.debug('Database initialization completed for signUp');\n\t\t} catch (error) {\n\t\t\tlogger.error('Database initialization failed for signUp:', error);\n\t\t\treturn fail(503, { message: 'Database system is not ready.' });\n\t\t}\n\n\t\t// Wait for auth service to be ready\n\t\tconst authReady = await waitForAuthService(10000);\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.error('Authentication system is not ready for signUp action');\n\t\t\treturn fail(503, { message: 'Authentication system is not ready.' });\n\t\t}\n\n\t\tlogger.debug('Auth service is ready for signUp action');\n\n\t\tconst formData = await event.request.formData();\n\t\tconst form = Object.fromEntries(formData);\n\t\tconst result = safeParse(signUpFormSchema, form);\n\n\t\tif (!result.success) {\n\t\t\tlogger.warn('SignUp form invalid:', { errors: result.issues });\n\t\t\treturn fail(400, { form, errors: flatten(result.issues).nested });\n\t\t}\n\n\t\tconst { email, username, password, token } = result.output;\n\n\t\t// Security: This action ONLY works for invited users with valid tokens.\n\t\t// First-user registration must go through /setup (enforced by hooks and load function).\n\t\tif (!token) {\n\t\t\tif (!token) {\n\t\t\t\treturn fail(403, { message: 'A valid invitation is required to create an account.', form });\n\t\t\t}\n\t\t}\n\n\t\tconst tokenData = await auth.validateRegistrationToken(token);\n\t\tif (!tokenData.isValid || !tokenData.details) {\n\t\t\tif (!tokenData.isValid || !tokenData.details) {\n\t\t\t\treturn fail(403, { message: 'This invitation is invalid, expired, or has already been used.', form });\n\t\t\t}\n\t\t}\n\n\t\t// Debug: Log the token details to see what we're getting\n\t\tlogger.debug('Token validation result:', {\n\t\t\ttokenData: tokenData.details,\n\t\t\trole: tokenData.details.role,\n\t\t\temail: tokenData.details.email\n\t\t});\n\n\t\t// Security: Check that the email in the form matches the one in the token record\n\t\tif (email.toLowerCase() !== tokenData.details.email.toLowerCase()) {\n\t\t\tif (email.toLowerCase() !== tokenData.details.email.toLowerCase()) {\n\t\t\t\treturn fail(403, { message: 'The provided email does not match the invitation.', form });\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Use optimized createUserAndSession for single database transaction\n\t\t\tconst sessionExpires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days\n\t\t\tconst userAndSessionResult = await auth.createUserAndSession(\n\t\t\t\t{\n\t\t\t\t\temail,\n\t\t\t\t\tusername,\n\t\t\t\t\tpassword,\n\t\t\t\t\trole: tokenData.details.role || 'user', // Use the role from the token with fallback to 'user'\n\t\t\t\t\tisRegistered: true,\n\t\t\t\t\tlastAuthMethod: 'password',\n\t\t\t\t\tlastActiveAt: new Date().toISOString() as ISODateString\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\texpires: sessionExpires.toISOString() as ISODateString\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (!userAndSessionResult.success || !userAndSessionResult.data) {\n\t\t\t\tconst errorMessage =\n\t\t\t\t\t!userAndSessionResult.success && 'error' in userAndSessionResult\n\t\t\t\t\t\t? userAndSessionResult.error?.message\n\t\t\t\t\t\t: 'Failed to create user and session';\n\t\t\t\tthrow new Error(errorMessage);\n\t\t\t}\n\t\t\tconst { user: newUser, session: newSession } = userAndSessionResult.data;\n\n\t\t\tlogger.info('User and session created successfully via token registration', {\n\t\t\t\tuserId: newUser._id,\n\t\t\t\tsessionId: newSession._id,\n\t\t\t\temail\n\t\t\t});\n\n\t\t\t// Invalidate user count cache so the system knows a new user now exists\n\t\t\tinvalidateUserCountCache();\n\n\t\t\t// Consume the invitation token immediately after use\n\t\t\tawait auth!.consumeRegistrationToken(token);\n\n\t\t\t// Send welcome email (best-effort; do not fail signup on email issues)\n\t\t\ttry {\n\t\t\t\tconst emailProps = {\n\t\t\t\t\tusername: username || email,\n\t\t\t\t\temail,\n\t\t\t\t\thostLink: publicEnv.HOST_PROD || `https://${event.request.headers.get('host')}`,\n\t\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS'\n\t\t\t\t};\n\t\t\t\tconst mailResponse = await event.fetch('/api/sendMail', {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\trecipientEmail: email,\n\t\t\t\t\t\tsubject: `Welcome to ${emailProps.sitename}`,\n\t\t\t\t\t\ttemplateName: 'welcomeUser',\n\t\t\t\t\t\tprops: emailProps,\n\t\t\t\t\t\tlanguageTag: userLanguage\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!mailResponse.ok) {\n\t\t\t\t\tlogger.error(`Failed to send welcome email via API. Status: ${mailResponse.status}`, {\n\t\t\t\t\t\temail,\n\t\t\t\t\t\tresponseText: await mailResponse.text()\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(`Welcome email request sent via API`, { email });\n\t\t\t\t}\n\t\t\t} catch (emailError) {\n\t\t\t\tlogger.error(`Error invoking /api/sendMail for invited user`, { email, error: emailError });\n\t\t\t}\n\n\t\t\t// Set session cookie using the already-created session\n\t\t\tconst SESSION_COOKIE_NAME = 'sid';\n\t\t\tevent.cookies.set(SESSION_COOKIE_NAME, newSession._id, {\n\t\t\t\tpath: '/',\n\t\t\t\thttpOnly: true,\n\t\t\t\tsameSite: 'lax',\n\t\t\t\tsecure: dev ? false : true,\n\t\t\t\tmaxAge: 60 * 60 * 24 * 7 // 7 days to match session expiry\n\t\t\t}); // Redirect to first collection\n\t\t\t// Check if collections exist in the database\n\t\t\tconst finalCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\t\tlet redirectPath: string;\n\t\t\tif (finalCollectionPath) {\n\t\t\t\t// Collections exist - redirect to first collection\n\t\t\t\tredirectPath = finalCollectionPath;\n\t\t\t\tlogger.debug(`SignUp redirect to collection: ${redirectPath}`);\n\t\t\t} else {\n\t\t\t\t// No collections available - redirect based on permissions\n\t\t\t\tlogger.debug('No collections available for signUp, redirecting based on permissions');\n\t\t\t\tconst { hasPermissionByAction } = await import('@shared/database/auth/permissions');\n\t\t\t\tconst isAdmin = hasPermissionByAction(newUser, 'manage', 'system', 'config:collectionbuilder');\n\t\t\t\tredirectPath = isAdmin ? '/config/collectionbuilder' : '/user';\n\t\t\t}\n\t\t\tthrow redirect(303, redirectPath);\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error('Error during invited user signup', { email, message: err.message, stack: err.stack });\n\t\t\treturn fail(500, { message: 'Failed to create account. Please try again later.', form });\n\t\t}\n\t},\n\n\tsignInOAuth: async (event) => {\n\t\t// Rate-limit and kickoff OAuth with optional invite_token in state\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests.' });\n\t\t}\n\t\tconst inviteToken = event.url.searchParams.get('invite_token');\n\t\tconst authUrl = await generateGoogleAuthUrl(inviteToken, undefined);\n\t\tthrow redirect(303, authUrl);\n\t},\n\n\tsignIn: async (event) => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE || 'en']) as Locale[];\n\t\tconst userLanguage = langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale) || 'en';\n\t\tlogger.debug(`Validated user language for sign-in: ${userLanguage}`);\n\t\t// --- END: Language Validation Logic ---\n\n\t\tconst startTime = performance.now();\n\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests. Please try again later.' });\n\t\t}\n\n\t\t// Wait for database initialization first\n\t\ttry {\n\t\t\tawait dbInitPromise;\n\t\t\tlogger.debug('Database initialization completed for signIn');\n\t\t} catch (error) {\n\t\t\tlogger.error('Database initialization failed for signIn:', error);\n\t\t\treturn fail(503, { message: 'Database system is not ready.' });\n\t\t}\n\n\t\t// Wait for auth service to be ready (with timeout)\n\t\tconst authReady = await waitForAuthService(10000); // 10 second timeout for sign-in\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.error('Authentication system is not ready for signIn action after waiting');\n\t\t\treturn fail(503, {\n\t\t\t\tmessage: 'Authentication system is not ready. Please wait a moment and try again.'\n\t\t\t});\n\t\t}\n\n\t\tlogger.debug('Auth service is ready for signIn action');\n\n\t\t// Validate form\n\t\tconst formData = await event.request.formData();\n\t\tconst emailRaw = formData.get('email')?.toString() ?? '';\n\t\tconst passwordRaw = formData.get('password')?.toString() ?? '';\n\t\tconst isTokenRaw = formData.get('isToken');\n\t\tconst isToken = isTokenRaw === 'true' || isTokenRaw === 'on';\n\n\t\tconst form = { email: emailRaw, password: passwordRaw, isToken };\n\t\tconst result = safeParse(loginFormSchema, form);\n\n\t\tif (!result.success) return fail(400, { form, errors: flatten(result.issues).nested });\n\n\t\tconst { email, password } = result.output;\n\t\t// isToken is already boolean from our manual parsing, but let's use result.output if schema didn't transform it weirdly\n\t\t// actually result.output.isToken should be boolean because schema says boolean() and we passed a boolean\n\n\t\tlet resp;\n\t\tlet redirectPath;\n\n\t\ttry {\n\t\t\t// Run authentication (collection path will be determined after auth success)\n\t\t\tconst authResult = await signInUser(email, password, isToken, event.cookies);\n\n\t\t\tresp = authResult;\n\n\t\t\tif (resp && resp.requires2FA) {\n\t\t\t\t// User needs 2FA verification - return fail() instead of message()\n\t\t\t\tlogger.debug('2FA verification required for user', { userId: resp.userId });\n\t\t\t\treturn fail(401, {\n\t\t\t\t\trequires2FA: true,\n\t\t\t\t\tuserId: resp.userId,\n\t\t\t\t\tmessage: 'Please enter your 2FA code to continue.'\n\t\t\t\t});\n\t\t\t} else if (resp && resp.status) {\n\t\t\t\t// message(signInForm, 'Sign-in successful!'); // No need to send message on success redirect\n\n\t\t\t\t// Check if collections exist in the database (runtime-created collections)\n\t\t\t\tconst finalCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\t\t\tif (finalCollectionPath) {\n\t\t\t\t\t// Collections exist - redirect to first collection\n\t\t\t\t\tredirectPath = finalCollectionPath;\n\t\t\t\t\tlogger.debug(`Login redirect to collection: ${redirectPath}`);\n\t\t\t\t} else {\n\t\t\t\t\t// No collections available - redirect based on permissions\n\t\t\t\t\tlogger.debug('No collections available, redirecting based on permissions');\n\t\t\t\t\tconst { hasPermissionByAction } = await import('@shared/database/auth/permissions');\n\t\t\t\t\tif (resp.user) {\n\t\t\t\t\t\tconst isAdmin = hasPermissionByAction(resp.user, 'manage', 'system', 'config:collectionbuilder');\n\t\t\t\t\t\tredirectPath = isAdmin ? '/config/collectionbuilder' : '/user';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tredirectPath = '/user';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst endTime = performance.now();\n\t\t\t\tlogger.debug(`SignIn completed in ${(endTime - startTime).toFixed(2)}ms`);\n\t\t\t} else {\n\t\t\t\tconst errorMessage = resp?.message || 'Invalid credentials or an error occurred.';\n\t\t\t\tlogger.warn(`Sign-in failed`, { email, errorMessage });\n\t\t\t\tconst errorMsg = resp?.message || 'Invalid credentials or an error occurred.';\n\t\t\t\tlogger.warn(`Sign-in failed`, { email, errorMsg });\n\t\t\t\treturn fail(401, { message: errorMessage, form });\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst err = e as Error;\n\t\t\tlogger.error(`Unexpected error in signIn action`, { email, message: err.message, stack: err.stack });\n\t\t\treturn fail(500, { message: 'An unexpected server error occurred.', form });\n\t\t}\n\n\t\t// Handle redirect outside try-catch\n\t\tif (redirectPath) {\n\t\t\tthrow redirect(303, redirectPath);\n\t\t}\n\t},\n\n\tverify2FA: async (event) => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE]) as Locale[];\n\t\tconst userLanguage = langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale);\n\t\t// --- END: Language Validation Logic ---\n\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests. Please try again later.' });\n\t\t}\n\n\t\t// Ensure database initialization is complete\n\t\ttry {\n\t\t\tawait dbInitPromise;\n\t\t\tlogger.debug('Database initialization completed for verify2FA');\n\t\t} catch (error) {\n\t\t\tlogger.error('Database initialization failed for verify2FA:', error);\n\t\t\treturn fail(503, { message: 'Database system is not ready.' });\n\t\t}\n\n\t\t// Wait for auth service to be ready\n\t\tconst authReady = await waitForAuthService(10000);\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.error('Authentication system is not ready for verify2FA action');\n\t\t\treturn fail(503, { message: 'Authentication system is not ready.' });\n\t\t}\n\n\t\tlogger.debug('Auth service is ready for verify2FA action');\n\n\t\ttry {\n\t\t\tconst formData = await event.request.formData();\n\t\t\tconst userId = formData.get('userId') as string;\n\t\t\tconst code = formData.get('code') as string;\n\n\t\t\tif (!userId || !code) {\n\t\t\t\treturn fail(400, { message: 'Missing required fields.' });\n\t\t\t}\n\n\t\t\t// Import 2FA service\n\t\t\tconst { getDefaultTwoFactorAuthService } = await import('@shared/database/auth/twoFactorAuth');\n\t\t\tif (!auth) {\n\t\t\t\treturn fail(500, { message: 'Auth service is not initialized' });\n\t\t\t}\n\t\t\tconst twoFactorService = getDefaultTwoFactorAuthService(auth as any); // Verify 2FA code\n\t\t\tconst result = await twoFactorService.verify2FA(userId, code);\n\t\t\tif (!result.success) {\n\t\t\t\tlogger.warn('2FA verification failed during login', { userId, reason: result.message });\n\t\t\t\treturn fail(400, { message: result.message });\n\t\t\t} // 2FA verification successful - get user and create session\n\t\t\tconst user = await auth.getUserById(userId);\n\t\t\tif (!user) {\n\t\t\t\tlogger.error('User not found after successful 2FA verification', { userId });\n\t\t\t\treturn fail(500, { message: 'User not found.' });\n\t\t\t}\n\n\t\t\t// Create session\n\t\t\tawait createSessionAndSetCookie(userId, event.cookies);\n\n\t\t\t// Update user attributes\n\t\t\tconst updatePromise = auth.updateUserAttributes(userId, {\n\t\t\t\tlastAuthMethod: 'password+2fa',\n\t\t\t\tlastActiveAt: new Date().toISOString() as ISODateString\n\t\t\t});\n\t\t\tupdatePromise.catch((err) => {\n\t\t\t\tlogger.error(`Failed to update user attributes after 2FA login for ${userId}:`, err);\n\t\t\t});\n\n\t\t\tlogger.info(`User logged in successfully with 2FA: ${user.username} (${userId})`);\n\n\t\t\t// Determine redirect path based on collections\n\t\t\tconst finalCollectionPath = await getCachedFirstCollectionPath(userLanguage);\n\n\t\t\tlet redirectPath: string;\n\t\t\tif (finalCollectionPath) {\n\t\t\t\t// Collections exist - redirect to first collection\n\t\t\t\tredirectPath = finalCollectionPath;\n\t\t\t\tlogger.debug(`2FA login redirect to collection: ${redirectPath}`);\n\t\t\t} else {\n\t\t\t\t// No collections available - redirect based on permissions\n\t\t\t\tlogger.debug('No collections available for 2FA login, redirecting based on permissions');\n\t\t\t\tconst { hasPermissionByAction } = await import('@shared/database/auth/permissions');\n\t\t\t\tconst isAdmin = hasPermissionByAction(user, 'manage', 'system', 'config:collectionbuilder');\n\t\t\t\tredirectPath = isAdmin ? '/config/collectionbuilder' : '/user';\n\t\t\t}\n\t\t\tthrow redirect(303, redirectPath);\n\t\t} catch (e) {\n\t\t\tif (e instanceof Response) {\n\t\t\t\tthrow e; // Re-throw redirect\n\t\t\t}\n\t\t\tconst err = e as Error;\n\t\t\tlogger.error(`Unexpected error in verify2FA action`, { message: err.message, stack: err.stack });\n\t\t\treturn fail(500, { message: 'An unexpected server error occurred.' });\n\t\t}\n\t},\n\n\tforgotPW: async (event) => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE || 'en']) as Locale[];\n\t\tconst userLanguage = langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale) || 'en';\n\t\t// --- END: Language Validation Logic ---\n\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests.' });\n\t\t}\n\t\t// Ensure database initialization is complete\n\t\ttry {\n\t\t\tawait dbInitPromise;\n\t\t\tlogger.debug('Database initialization completed for forgotPW');\n\t\t} catch (error) {\n\t\t\tlogger.error('Database initialization failed for forgotPW:', error);\n\t\t\treturn fail(503, { message: 'Database system is not ready.' });\n\t\t}\n\n\t\t// Wait for auth service to be ready\n\t\tconst authReady = await waitForAuthService(10000);\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.error('Authentication system is not ready for forgotPW action');\n\t\t\treturn fail(503, { message: 'Authentication system is not ready.' });\n\t\t}\n\n\t\tlogger.debug('Auth service is ready for forgotPW action');\n\n\t\tconst formData = await event.request.formData();\n\t\tconst form = Object.fromEntries(formData);\n\t\tconst result = safeParse(forgotFormSchema, form);\n\n\t\tif (!result.success) return fail(400, { form, errors: flatten(result.issues).nested });\n\n\t\tconst email = result.output.email.toLowerCase().trim();\n\t\tlet checkMail: ForgotPWCheckResult;\n\n\t\ttry {\n\t\t\tcheckMail = await forgotPWCheck(email);\n\n\t\t\tif (checkMail.success && checkMail.token && checkMail.expiresIn) {\n\t\t\t\tconst baseUrl = dev ? publicEnv.HOST_DEV : publicEnv.HOST_PROD;\n\t\t\t\tconst resetLink = `${baseUrl}/login?token=${checkMail.token}&email=${encodeURIComponent(email)}`;\n\t\t\t\tlogger.debug(`Reset link generated: ${resetLink}`);\n\n\t\t\t\tconst emailProps = {\n\t\t\t\t\temail: email,\n\t\t\t\t\ttoken: checkMail.token,\n\t\t\t\t\texpiresIn: checkMail.expiresIn,\n\t\t\t\t\tresetLink: resetLink,\n\t\t\t\t\tusername: checkMail.username || email,\n\t\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS'\n\t\t\t\t};\n\n\t\t\t\t// Use SvelteKit's fetch for server-side API calls\n\t\t\t\tconst mailResponse = await event.fetch('/api/sendMail', {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\trecipientEmail: email,\n\t\t\t\t\t\tsubject: `Password Reset Request for ${emailProps.sitename}`,\n\t\t\t\t\t\ttemplateName: 'forgottenPassword',\n\t\t\t\t\t\tprops: emailProps,\n\t\t\t\t\t\tlanguageTag: userLanguage\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\tif (!mailResponse.ok) {\n\t\t\t\t\tlogger.error(`Failed to send forgotten password email via API. Status: ${mailResponse.status}`, {\n\t\t\t\t\t\temail,\n\t\t\t\t\t\tresponseText: await mailResponse.text()\n\t\t\t\t\t});\n\t\t\t\t\t// Still return success but with emailSent: false to handle on frontend\n\t\t\t\t\treturn fail(400, { message: 'Password reset email sent successfully.', userExists: true, emailSent: false });\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(`Forgotten password email request sent via API`, { email });\n\t\t\t\t\treturn fail(400, { message: 'Password reset email sent successfully.', userExists: true, emailSent: true });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warn(`Forgotten password check failed`, { email, message: checkMail.message });\n\t\t\t\t// Return different response for user not found to allow frontend distinction\n\t\t\t\treturn fail(400, { message: 'User does not exist.', userExists: false });\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst err = e as Error;\n\t\t\tlogger.error(`Error in forgotPW action`, { email, message: err.message, stack: err.stack });\n\t\t\treturn fail(500, { message: 'An error occurred. Please try again.', form });\n\t\t}\n\t},\n\n\tresetPW: async (event) => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE || 'en']) as Locale[];\n\t\tconst userLanguage = langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale) || 'en';\n\t\t// --- END: Language Validation Logic ---\n\n\t\tif (await limiter.isLimited(event)) {\n\t\t\treturn fail(429, { message: 'Too many requests.' });\n\t\t}\n\t\t// Ensure database initialization is complete\n\t\ttry {\n\t\t\tawait dbInitPromise;\n\t\t\tlogger.debug('Database initialization completed for resetPW');\n\t\t} catch (error) {\n\t\t\tlogger.error('Database initialization failed for resetPW:', error);\n\t\t\treturn fail(503, { message: 'Database system is not ready.' });\n\t\t}\n\n\t\t// Wait for auth service to be ready\n\t\tconst authReady = await waitForAuthService(10000);\n\t\tif (!authReady || !auth) {\n\t\t\tlogger.error('Authentication system is not ready for resetPW action');\n\t\t\treturn fail(503, { message: 'Authentication system is not ready.' });\n\t\t}\n\n\t\tlogger.debug('Auth service is ready for resetPW action');\n\n\t\tconst formData = await event.request.formData();\n\t\tconst form = Object.fromEntries(formData);\n\t\tconst result = safeParse(resetFormSchema, form);\n\n\t\tif (!result.success) return fail(400, { form, errors: flatten(result.issues).nested });\n\n\t\tconst { password, token, email } = result.output;\n\n\t\ttry {\n\t\t\tconst resp = await resetPWCheck(password, token, email);\n\t\t\tlogger.debug(`Password reset check response`, { email, response: JSON.stringify(resp) });\n\n\t\t\tif (resp.status) {\n\t\t\t\tconst emailProps = {\n\t\t\t\t\tusername: resp.username || email,\n\t\t\t\t\temail: email,\n\t\t\t\t\thostLink: publicEnv.HOST_PROD || `https://${event.request.headers.get('host')}`,\n\t\t\t\t\tsitename: publicEnv.SITE_NAME || 'SveltyCMS'\n\t\t\t\t};\n\t\t\t\ttry {\n\t\t\t\t\t// Use SvelteKit's fetch for server-side API calls\n\t\t\t\t\tconst mailResponse = await event.fetch('/api/sendMail', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\t\trecipientEmail: email,\n\t\t\t\t\t\t\tsubject: `Your Password for ${emailProps.sitename} Has Been Updated`,\n\t\t\t\t\t\t\ttemplateName: 'updatedPassword', // Ensure this template exists\n\t\t\t\t\t\t\tprops: emailProps,\n\t\t\t\t\t\t\tlanguageTag: userLanguage\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t\tif (!mailResponse.ok) {\n\t\t\t\t\t\tlogger.error(`Failed to send password updated email via API. Status: ${mailResponse.status}`, {\n\t\t\t\t\t\t\temail,\n\t\t\t\t\t\t\tresponseText: await mailResponse.text()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(`Password updated confirmation email request sent via API`, { email });\n\t\t\t\t\t}\n\t\t\t\t} catch (emailError) {\n\t\t\t\t\tlogger.error(`Error fetching /api/sendMail for password updated confirmation`, { email, error: emailError });\n\t\t\t\t}\n\n\t\t\t\t// message(pwresetForm, 'Password reset successfully. You can now log in.');\n\t\t\t\tthrow redirect(303, '/login?reset=success');\n\t\t\t} else {\n\t\t\t\tlogger.warn(`Password reset failed`, { email, message: resp.message });\n\t\t\t\treturn fail(400, { message: resp.message || 'Password reset failed. The link may be invalid or expired.', form });\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Check if this is a redirect (which is expected and successful)\n\t\t\tif (e && typeof e === 'object' && 'status' in e && (e.status === 302 || e.status === 303)) {\n\t\t\t\t// Re-throw the redirect - this is the expected flow\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tconst err = e as Error;\n\t\t\tlogger.error(`Error in resetPW action`, { email, message: err.message, stack: err.stack });\n\t\t\treturn fail(500, { message: 'An unexpected error occurred during password reset.', form });\n\t\t}\n\t},\n\n\tprefetch: async () => {\n\t\t// --- START: Language Validation Logic ---\n\t\tconst langFromStore = app.systemLanguage as Locale | null;\n\t\tconst supportedLocales = (publicEnv.LOCALES || [publicEnv.BASE_LOCALE]) as Locale[];\n\t\tconst userLanguage = (langFromStore && supportedLocales.includes(langFromStore) ? langFromStore : (publicEnv.BASE_LOCALE as Locale)) || 'en';\n\t\t// --- END: Language Validation Logic ---\n\n\t\t// This action is called when user switches to SignIn/SignUp components\n\t\t// to get collection info for later data fetching after authentication\n\t\ttry {\n\t\t\tlogger.info(`Collection lookup triggered for language: ${userLanguage}`);\n\n\t\t\t// Get first collection from ContentManager (cached lookup)\n\t\t\tconst firstCollectionSchema = await contentManager.getFirstCollection();\n\t\t\tconst collectionInfo = firstCollectionSchema\n\t\t\t\t? {\n\t\t\t\t\t\tcollectionId: firstCollectionSchema._id,\n\t\t\t\t\t\tname: firstCollectionSchema.name,\n\t\t\t\t\t\tpath: firstCollectionSchema.path\n\t\t\t\t\t}\n\t\t\t\t: null;\n\n\t\t\tif (collectionInfo) {\n\t\t\t\tlogger.info(`Collection lookup completed successfully: ${collectionInfo.name}`);\n\t\t\t\treturn { success: true, collection: collectionInfo };\n\t\t\t} else {\n\t\t\t\tlogger.debug('No collection found');\n\t\t\t\treturn { success: false, error: 'No collection available' };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.debug('Collection lookup failed:', err);\n\t\t\treturn { success: false, error: 'Collection lookup failed' };\n\t\t}\n\t}\n};\n\n// Helper functions (createSessionAndSetCookie, signInUser, finishRegistration, forgotPWCheck, resetPWCheck)\n// remain largely the same as your provided code, with minor logging/error handling adjustments.\n// Ensure they are robust and correctly interact with your `auth` service.\n\nasync function createSessionAndSetCookie(user_id: string, cookies: Cookies): Promise<void> {\n\tconst expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\n\tif (!auth) throw Error('Auth service is not initialized when creating session.');\n\tconst session = await auth.createSession({ user_id, expires: expiresAt.toISOString() as ISODateString });\n\tlogger.debug(`Session created: ${session._id} for user ${user_id}`);\n\tconst sessionCookie = auth.createSessionCookie(session._id);\n\tconst attributes = sessionCookie.attributes as Record<string, unknown>;\n\tcookies.set(sessionCookie.name, sessionCookie.value, { ...attributes, path: '/' });\n}\n\nasync function signInUser(\n\temail: string,\n\tpassword: string,\n\tisToken: boolean,\n\tcookies: Cookies\n): Promise<{ status: boolean; message?: string; user?: User; requires2FA?: boolean; userId?: string }> {\n\tlogger.debug(`signInUser called`, { email, isToken });\n\tif (!auth) {\n\t\tlogger.error('Auth system not initialized for signInUser');\n\t\treturn { status: false, message: 'Authentication system unavailable.' };\n\t}\n\ttry {\n\t\tlet user: User | null = null;\n\t\tlet authSuccess = false;\n\n\t\tif (!isToken) {\n\t\t\tconst authResult = await auth.authenticate(email, password);\n\t\t\tif (authResult && authResult.user) {\n\t\t\t\tuser = authResult.user;\n\n\t\t\t\t// Check if user has 2FA enabled\n\t\t\t\tif (user.is2FAEnabled) {\n\t\t\t\t\tlogger.debug(`User has 2FA enabled, requiring 2FA verification`, { userId: user._id });\n\t\t\t\t\t// Don't create session yet - wait for 2FA verification\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\tmessage: '2FA verification required',\n\t\t\t\t\t\trequires2FA: true,\n\t\t\t\t\t\tuserId: user._id\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tauthSuccess = true;\n\t\t\t\t// Use the session that authenticate() already created\n\t\t\t\tconst sessionCookie = auth.createSessionCookie(authResult.sessionId);\n\t\t\t\tcookies.set(sessionCookie.name, sessionCookie.value, { ...(sessionCookie.attributes as Record<string, unknown>), path: '/' });\n\t\t\t} else {\n\t\t\t\tlogger.warn(`Password authentication failed`, { email });\n\t\t\t}\n\t\t} else {\n\t\t\tconst tokenValue = password;\n\t\t\tconst tempUser = await auth.checkUser({ email });\n\t\t\tif (!tempUser) {\n\t\t\t\tlogger.warn(`Token login attempt for non-existent user`, { email });\n\t\t\t\treturn { status: false, message: 'User does not exist.' };\n\t\t\t}\n\t\t\tconst result = await auth.consumeToken(tokenValue, tempUser._id);\n\t\t\tif (result.status) {\n\t\t\t\tuser = tempUser;\n\t\t\t\tauthSuccess = true;\n\t\t\t} else {\n\t\t\t\tlogger.warn(`Token consumption failed`, { email, message: result.message });\n\t\t\t\treturn { status: false, message: result.message || 'Invalid or expired token.' };\n\t\t\t}\n\t\t}\n\n\t\tif (!authSuccess || !user || !user._id) {\n\t\t\treturn { status: false, message: 'Invalid credentials or authentication failed.' };\n\t\t}\n\n\t\t// For token-based authentication, we need to create a session manually\n\t\t// For password authentication, the session was already created by authenticate()\n\t\tif (isToken) {\n\t\t\tawait createSessionAndSetCookie(user._id, cookies);\n\t\t}\n\n\t\t// Parallelize user attribute update for better performance\n\t\tconst updatePromise = auth.updateUserAttributes(user._id, {\n\t\t\tlastAuthMethod: isToken ? 'token' : 'password',\n\t\t\tlastActiveAt: new Date().toISOString() as ISODateString\n\t\t}); // Don't wait for attribute update to complete - fire and forget for better UX\n\t\tupdatePromise.catch((err) => {\n\t\t\tlogger.error(`Failed to update user attributes for ${user._id}:`, err);\n\t\t});\n\n\t\tlogger.info(`User logged in successfully: ${user.username} (${user._id})`);\n\t\treturn { status: true, message: 'Login successful', user };\n\t} catch (error) {\n\t\tconst err = error as Error;\n\t\tlogger.error(`Error in signInUser`, { email, message: err.message, stack: err.stack });\n\t\treturn { status: false, message: 'An internal error occurred during sign-in.' };\n\t}\n}\n\ninterface ForgotPWCheckResult {\n\tsuccess: boolean;\n\tmessage: string;\n\ttoken?: string;\n\texpiresIn?: Date;\n\tusername?: string;\n}\n\nasync function forgotPWCheck(email: string): Promise<ForgotPWCheckResult> {\n\tlogger.debug(`forgotPWCheck called`, { email });\n\tif (!auth) {\n\t\tlogger.error('Auth system not initialized for forgotPWCheck');\n\t\treturn { success: false, message: 'Authentication system unavailable.' };\n\t}\n\ttry {\n\t\tconst user = await auth.checkUser({ email });\n\t\tif (!user || !user._id) {\n\t\t\tlogger.warn(`forgotPWCheck: User not found`, { email });\n\t\t\treturn { success: false, message: 'User does not exist.' };\n\t\t}\n\t\tconst expiresInMs = 1 * 60 * 60 * 1000;\n\t\tconst expiresAt = new Date(Date.now() + expiresInMs);\n\t\tconst token = await auth.createToken({\n\t\t\tuser_id: user._id,\n\t\t\texpires: expiresAt.toISOString() as ISODateString,\n\t\t\ttype: 'password_reset'\n\t\t});\n\t\tlogger.info(`Password reset token created`, { email });\n\t\treturn { success: true, message: 'Password reset token generated.', token, expiresIn: expiresAt, username: user.username };\n\t} catch (error) {\n\t\tconst err = error as Error;\n\t\tlogger.error(`Error in forgotPWCheck`, { email, message: err.message, stack: err.stack });\n\t\treturn { success: false, message: 'An internal error occurred generating password reset token.' };\n\t}\n}\n\ninterface ResetPWResult {\n\tstatus: boolean;\n\tmessage?: string;\n\tusername?: string;\n}\n\nasync function resetPWCheck(password: string, token: string, email: string): Promise<ResetPWResult> {\n\tlogger.debug(`resetPWCheck called`, { email });\n\tif (!auth) {\n\t\tlogger.error('Auth system not initialized for resetPWCheck');\n\t\treturn { status: false, message: 'Authentication system unavailable.' };\n\t}\n\ttry {\n\t\tconst user = await auth.checkUser({ email });\n\t\tif (!user || !user._id) {\n\t\t\tlogger.warn(`resetPWCheck: User not found for token validation`, { email });\n\t\t\treturn { status: false, message: 'Invalid or expired reset link (user not found).' };\n\t\t}\n\t\tconst validate = await auth.consumeToken(token, user._id, 'password_reset');\n\t\tif (!validate.status) {\n\t\t\tlogger.warn(`resetPWCheck: Token consumption failed`, { email, message: validate.message });\n\t\t\treturn { status: false, message: validate.message || 'Invalid or expired reset link.' };\n\t\t}\n\t\tif (calculatePasswordStrength(password) < 1) {\n\t\t\treturn { status: false, message: 'Password is too weak.' };\n\t\t}\n\t\tawait auth.invalidateAllUserSessions(user._id);\n\t\tconst updateResult = await auth.updateUserPassword(email, password);\n\t\tif (!updateResult.status) {\n\t\t\tlogger.warn(`resetPWCheck: Password update failed`, { email, message: updateResult.message });\n\t\t\treturn { status: false, message: updateResult.message || 'Failed to update password.' };\n\t\t}\n\t\tlogger.info(`Password reset successfully`, { email });\n\t\treturn { status: true, username: user.username };\n\t} catch (error) {\n\t\tconst err = error as Error;\n\t\tlogger.error(`Error in resetPWCheck`, { email, message: err.message, stack: err.stack });\n\t\treturn { status: false, message: 'An internal error occurred during password reset.' };\n\t}\n}\n"],"names":["auth","logger","firstUserExists","showOAuth","signUpForm","inviteToken"],"mappings":"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"}