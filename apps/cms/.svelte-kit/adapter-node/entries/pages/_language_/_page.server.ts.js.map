{"version":3,"file":"_page.server.ts.js","sources":["../../../../../../src/content/index.ts","../../../../../../src/routes/[language]/+page.server.ts"],"sourcesContent":["/**\n * @file src/content/index.ts\n * @description Index file for Content Management.\n *\n * Improvements:\n * - **SSR Safety:** Dynamically imports DB only on server.\n * - **Stable IDs:** Replaced random UUIDs with deterministic hashing for Category IDs (prevents hydration mismatches).\n * - **Type Safety:** Improved typing for the db adapter import.\n */\n\nimport { browser, building, dev } from '$app/environment';\nimport { error } from '@sveltejs/kit';\nimport axios from 'axios';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Stores\nimport { collections, contentStructure, setCollection, setCollectionValue, setMode, unAssigned } from '@shared/stores/collectionStore.svelte';\n\n// Components\nimport { widgets } from '@shared/stores/widgetStore.svelte';\n\n// Types\nimport type { Category, ContentTypes, Schema } from './types';\nimport type { DatabaseId, ISODateString } from './types';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Constants\nconst BATCH_SIZE = 50;\nconst CONCURRENT_BATCHES = 5;\n\n// Cache\nlet importsCache: Record<ContentTypes, Schema> = {} as Record<ContentTypes, Schema>;\nlet collectionModelsCache: Partial<Record<ContentTypes, Schema>> | null = null;\n\n// --- Types ---\ninterface CategoryNode {\n\tid: number;\n\tname: string;\n\ticon: string;\n\torder: number;\n\tcollections: Schema[];\n\tsubcategories: Map<string, CategoryNode>;\n}\n\ninterface ProcessedModule {\n\tschema?: Schema;\n\tdefault?: Schema;\n}\n\ninterface CollectionData {\n\tid: string;\n\tname: string;\n\ticon: string;\n\tcollections: Schema[];\n\tsubcategories: Record<string, CollectionData>;\n}\n\n// --- Global State for Processing ---\nconst categoryLookup: Map<string, CategoryNode> = new Map();\nconst collectionsByCategory: Map<string, Set<Schema>> = new Map();\n\n// --- Helpers ---\n\nfunction chunks<T>(arr: T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size));\n}\n\n/**\n * Generates a stable numeric ID from a string.\n * Replaces uuidv4 to ensure category IDs remain consistent across restarts/renders.\n */\nfunction stringToHash(str: string): number {\n\tlet hash = 0;\n\tif (str.length === 0) return hash;\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str.charCodeAt(i);\n\t\thash = (hash << 5) - hash + char;\n\t\thash |= 0; // Convert to 32bit integer\n\t}\n\treturn Math.abs(hash);\n}\n\nasync function getCurrentPath() {\n\t// 1. Client-Side Early Exit (Optimization)\n\tif (!import.meta.env.SSR) {\n\t\tconst currentPath = typeof window !== 'undefined' ? window.location.pathname : '';\n\t\treturn {\n\t\t\tconfig: { fields: {}, isCollection: false, name: '', icon: '', path: currentPath, order: 0 },\n\t\t\tcurrentPath\n\t\t};\n\t}\n\n\t// 2. Server-Side Dynamic Import\n\ttry {\n\t\tconst { dbAdapter } = await import('@shared/database/db');\n\t\tif (!dbAdapter) return getDefaultPathConfig();\n\n\t\tconst result = await dbAdapter.content.nodes.getStructure('flat');\n\t\tif (!result.success || !result.data) {\n\t\t\tlogger.warn('Failed to get content nodes from database');\n\t\t\treturn getDefaultPathConfig();\n\t\t}\n\n\t\tconst currentPath = ''; // On server, we don't really have 'window.location' in the same way for this context\n\t\t// Logic adjustment: server doesn't usually need 'currentPath' for generation unless building static paths\n\n\t\treturn {\n\t\t\tconfig: { fields: {}, isCollection: false, name: '', icon: '', path: currentPath, order: 0 },\n\t\t\tcurrentPath\n\t\t};\n\t} catch (e) {\n\t\tlogger.warn('Error loading DB adapter in content index', e);\n\t\treturn getDefaultPathConfig();\n\t}\n}\n\nfunction getDefaultPathConfig() {\n\tconst currentPath = typeof window !== 'undefined' ? window.location.pathname : '';\n\treturn {\n\t\tconfig: {\n\t\t\tfields: {},\n\t\t\tisCollection: false,\n\t\t\tname: '',\n\t\t\ticon: '',\n\t\t\tpath: currentPath,\n\t\t\torder: 0\n\t\t},\n\t\tcurrentPath\n\t};\n}\n\n// Process a batch of collections\nasync function processBatch(collections: Schema[]): Promise<void> {\n\tfor (const col of collections) {\n\t\tif (!col.path) {\n\t\t\tlogger.warn(`Collection ${col.name} has no path`);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst pathSegments = col.path.split('/');\n\t\tlet currentPath = '';\n\t\tlet currentMap: Map<string, CategoryNode> = categoryLookup;\n\n\t\tfor (let i = 0; i < pathSegments.length; i++) {\n\t\t\tconst segment = pathSegments[i] ?? '';\n\t\t\tcurrentPath = currentPath ? `${currentPath}/${segment}` : segment;\n\n\t\t\tif (!currentMap.has(segment)) {\n\t\t\t\tconst configData = await getCurrentPath();\n\n\t\t\t\t// Use stable hash instead of random UUID\n\t\t\t\tconst stableId = stringToHash(segment);\n\n\t\t\t\tconst newNode: CategoryNode = {\n\t\t\t\t\tid: stableId,\n\t\t\t\t\tname: segment,\n\t\t\t\t\ticon: configData.config.icon ?? '',\n\t\t\t\t\torder: 'order' in configData.config && typeof configData.config.order === 'number' ? configData.config.order : 0,\n\t\t\t\t\tcollections: [],\n\t\t\t\t\tsubcategories: new Map()\n\t\t\t\t};\n\n\t\t\t\tcurrentMap.set(segment, newNode);\n\t\t\t\tcategoryLookup.set(currentPath, newNode);\n\t\t\t\tcollectionsByCategory.set(currentPath, new Set());\n\t\t\t}\n\n\t\t\t// If this is the last segment, add the collection\n\t\t\tif (i === pathSegments.length - 1) {\n\t\t\t\tconst categoryNode = categoryLookup.get(currentPath);\n\t\t\t\tif (categoryNode) {\n\t\t\t\t\tcategoryNode.collections.push(col);\n\t\t\t\t\tcollectionsByCategory.get(currentPath)?.add(col);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst nextNode = currentMap.get(segment);\n\t\t\tif (nextNode && nextNode.subcategories) {\n\t\t\t\tcurrentMap = nextNode.subcategories;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function to flatten and sort the category hierarchy\nfunction flattenAndSortCategories(): Record<string, CollectionData> {\n\tconst result: Record<string, CollectionData> = {};\n\tconst sortedCategories = Array.from(categoryLookup.entries()).sort(([, a], [, b]) => a.order - b.order);\n\n\tfor (const [path, category] of sortedCategories) {\n\t\tconst collections = Array.from(collectionsByCategory.get(path) || []).sort((a, b) => {\n\t\t\tconst orderA: number = a && typeof a.order === 'number' ? a.order : 0;\n\t\t\tconst orderB: number = b && typeof b.order === 'number' ? b.order : 0;\n\t\t\treturn orderA - orderB;\n\t\t});\n\n\t\tresult[path] = {\n\t\t\tid: category.id.toString(),\n\t\t\tname: category.name,\n\t\t\ticon: category.icon,\n\t\t\tcollections,\n\t\t\tsubcategories: {}\n\t\t};\n\t}\n\treturn result;\n}\n\nasync function createCategoriesFromPath(collections: Schema[]): Promise<Category[]> {\n\tcategoryLookup.clear();\n\tcollectionsByCategory.clear();\n\n\tconst batches = chunks(collections, BATCH_SIZE);\n\tfor (let i = 0; i < batches.length; i += CONCURRENT_BATCHES) {\n\t\tconst currentBatches = batches.slice(i, i + CONCURRENT_BATCHES);\n\t\tawait Promise.all(currentBatches.map(processBatch));\n\t}\n\n\tconst categoriesObject = flattenAndSortCategories();\n\tconst result: Category[] = Object.values(categoriesObject).map((cat) => ({\n\t\tid: parseInt(cat.id),\n\t\tname: cat.name,\n\t\ticon: cat.icon,\n\t\torder: 0,\n\t\tcollections: cat.collections.map((col) => col.name || '').filter(Boolean),\n\t\tsubcategories: undefined\n\t}));\n\n\t// logger.trace('Created categories:', result);\n\treturn result;\n}\n\n// Function to get collections with cache support\nexport async function getCollections(): Promise<Partial<Record<ContentTypes, Schema>>> {\n\tawait widgets.initialize();\n\n\tif (collectionModelsCache) {\n\t\treturn collectionModelsCache;\n\t}\n\n\tcollectionModelsCache = collections.all;\n\treturn collections.all;\n}\n\n// Function to update collections\nexport const updateCollections = async (recompile: boolean = false): Promise<void> => {\n\tlogger.trace('Starting updateCollections');\n\n\tif (recompile) {\n\t\timportsCache = {} as Record<ContentTypes, Schema>;\n\t}\n\n\ttry {\n\t\tconst imports = await getImports(recompile);\n\t\tconst _categories = await createCategoriesFromPath(Object.values(imports));\n\n\t\tconst _collections: Partial<Record<ContentTypes, Schema>> = {};\n\t\tfor (const category of _categories) {\n\t\t\tfor (const collectionName of category.collections) {\n\t\t\t\tconst col = imports[collectionName as ContentTypes];\n\t\t\t\tif (col && col.name) {\n\t\t\t\t\t_collections[col.name as ContentTypes] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update stores\n\t\tcontentStructure.value = _categories.map((cat) => ({\n\t\t\t_id: cat.id.toString() as DatabaseId,\n\t\t\tname: cat.name,\n\t\t\tnodeType: 'category',\n\t\t\ticon: cat.icon,\n\t\t\torder: cat.order,\n\t\t\tparentId: undefined,\n\t\t\tpath: '',\n\t\t\ttranslations: [],\n\t\t\tcollectionDef: undefined,\n\t\t\tchildren: [],\n\t\t\tcreatedAt: new Date().toISOString() as ISODateString,\n\t\t\tupdatedAt: new Date().toISOString() as ISODateString\n\t\t}));\n\n\t\tObject.keys(collections.all).forEach((key) => delete collections.all[key]);\n\t\tObject.assign(collections.all, _collections);\n\n\t\tconst unassigned = Object.values(imports).filter((x) => !Object.values(_collections).includes(x));\n\t\tObject.assign(unAssigned, unassigned.length > 0 ? unassigned[0] : { fields: [] });\n\n\t\tsetCollection({} as Schema);\n\t\tsetCollectionValue({});\n\t\tsetMode('view');\n\n\t\t// Update local version tracking\n\t\tif (importsCache && Object.keys(importsCache).length > 0) {\n\t\t\t// If we fetched via API, we might want to get the version from the response headers or a separate call\n\t\t\t// For now, we assume if we just updated, we are at the latest.\n\t\t\t// Ideally, updateCollections should return the version or accept it.\n\t\t}\n\n\t\tlogger.info(`Collections updated successfully. Count: ${Object.keys(_collections).length}`);\n\t} catch (err) {\n\t\tlogger.error(`Error in updateCollections: ${err}`);\n\t}\n};\n\n// Function to get imports based on environment\nasync function getImports(recompile: boolean = false): Promise<Record<ContentTypes, Schema>> {\n\tawait widgets.initialize();\n\n\tif (!recompile && Object.keys(importsCache).length > 0) {\n\t\treturn importsCache;\n\t}\n\n\t// Server-side production optimization\n\tif (!dev && !building && import.meta.env.SSR) {\n\t\ttry {\n\t\t\tconst { scanCompiledCollections } = await import('./collectionScanner');\n\t\t\tconst compiledCollections = await scanCompiledCollections();\n\t\t\tconst imports: Record<string, Schema> = {};\n\t\t\tfor (const collection of compiledCollections) {\n\t\t\t\tif (collection._id && collection.name) {\n\t\t\t\t\timports[collection.name] = collection;\n\t\t\t\t}\n\t\t\t}\n\t\t\timportsCache = imports as Record<ContentTypes, Schema>;\n\t\t\tlogger.info(`âœ… Loaded ${Object.keys(imports).length} collections via filesystem scanning`);\n\t\t\treturn importsCache;\n\t\t} catch (error) {\n\t\t\tlogger.warn('Failed to scan compiled collections, falling back to legacy import method:', error);\n\t\t}\n\t}\n\n\ttry {\n\t\tconst processModule = async (name: string, module: ProcessedModule, modulePath: string) => {\n\t\t\tconst collection = (module as { schema: Schema })?.schema ?? {};\n\t\t\tif (collection) {\n\t\t\t\t// Use stable hash for collection IDs too if possible, but UUID is okay for now if singular\n\t\t\t\tconst randomId = uuidv4();\n\t\t\t\tcollection.name = name as ContentTypes;\n\t\t\t\tcollection.icon = collection.icon || 'iconoir:info-empty';\n\t\t\t\tcollection.id = parseInt(randomId.toString().slice(0, 8), 16);\n\n\t\t\t\tconst pathSegments = modulePath.split('/config/collections/')[1]?.split('/') || [];\n\t\t\t\tconst fileName = pathSegments.pop()?.replace(/\\.ts$/, '') || '';\n\t\t\t\tconst categoryPath = pathSegments.join('/');\n\t\t\t\tconst collectionPath = categoryPath ? `/${categoryPath}/${fileName}` : `/${fileName}`;\n\t\t\t\tcollection.path = collectionPath;\n\n\t\t\t\timportsCache[name as ContentTypes] = collection as Schema;\n\t\t\t} else {\n\t\t\t\tlogger.error(`Error importing collection: ${name}`);\n\t\t\t}\n\t\t};\n\n\t\tif (dev || building) {\n\t\t\tconst modules = import.meta.glob(\n\t\t\t\t[\n\t\t\t\t\t'../../config/collections/**/*.ts',\n\t\t\t\t\t'!../../config/collections/**/index.ts',\n\t\t\t\t\t'!../../config/collections/**/types.ts',\n\t\t\t\t\t'!../../config/collections/**/utils/**/*.ts'\n\t\t\t\t],\n\t\t\t\t{ eager: false, import: 'default' }\n\t\t\t);\n\n\t\t\tconst entries = Object.entries(modules);\n\t\t\tconst batches = chunks(entries, BATCH_SIZE);\n\n\t\t\tfor (let i = 0; i < batches.length; i += CONCURRENT_BATCHES) {\n\t\t\t\tconst currentBatches = batches.slice(i, i + CONCURRENT_BATCHES);\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tcurrentBatches.map(async (batch) => {\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tbatch.map(async ([modulePath, moduleImport]) => {\n\t\t\t\t\t\t\t\tconst name = modulePath.split('/').pop()?.replace(/\\.ts$/, '') || '';\n\t\t\t\t\t\t\t\tconst module = await moduleImport();\n\t\t\t\t\t\t\t\tawait processModule(name, module as ProcessedModule, modulePath);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// Production Client-Side Fallback\n\t\t\tlet files: string[] = [];\n\t\t\ttry {\n\t\t\t\tconst collectionsResponse = browser ? (await axios.get('/api/collections')).data : await getCollections(); // Recursion safety check needed?\n\n\t\t\t\tif (collectionsResponse.success && Array.isArray(collectionsResponse.data.collections)) {\n\t\t\t\t\tfiles = collectionsResponse.data.collections.map((c: { name: string }) => `${c.name}.js`);\n\t\t\t\t} else if (Array.isArray(collectionsResponse)) {\n\t\t\t\t\tfiles = collectionsResponse;\n\t\t\t\t} else {\n\t\t\t\t\tfiles = [];\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Error fetching collection files: ${error}`);\n\t\t\t\tfiles = [];\n\t\t\t}\n\n\t\t\tconst batches = chunks(files, BATCH_SIZE);\n\t\t\tfor (let i = 0; i < batches.length; i += CONCURRENT_BATCHES) {\n\t\t\t\tconst currentBatches = batches.slice(i, i + CONCURRENT_BATCHES);\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tcurrentBatches.map(async (batch) => {\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tbatch.map(async (file) => {\n\t\t\t\t\t\t\t\tconst name = file.replace(/\\.js$/, '');\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst collectionModule =\n\t\t\t\t\t\t\t\t\t\ttypeof window !== 'undefined'\n\t\t\t\t\t\t\t\t\t\t\t? (await axios.get(`/api/collections/${name}?includeFields=true&_t=${Math.floor(Date.now() / 1000)}`)).data\n\t\t\t\t\t\t\t\t\t\t\t: await import(/* @vite-ignore */ `${import.meta.env.collectionsFolderJS}${file}`);\n\t\t\t\t\t\t\t\t\tawait processModule(name, collectionModule, file);\n\t\t\t\t\t\t\t\t} catch (moduleError) {\n\t\t\t\t\t\t\t\t\tlogger.error(`Error processing module ${name}: ${moduleError}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn importsCache;\n\t} catch (err) {\n\t\tlogger.error(`Error in getImports: ${err}`);\n\t\tthrow error(500, 'Failed to get imports');\n\t}\n}\n\n// --- Reactive Content System ---\nlet pollingInterval: NodeJS.Timeout | null = null;\nlet currentVersion: number = 0;\n\nexport async function initializeContent(pageData?: any) {\n\t// 1. Hydration (Server -> Client)\n\tif (pageData?.navigationStructure && pageData?.contentVersion) {\n\t\tlogger.info('ðŸ’§ Hydrating content from server data');\n\t\tcurrentVersion = pageData.contentVersion;\n\n\t\t// Transform navigation structure to internal format if needed,\n\t\t// or if the structure matches, just use it.\n\t\t// Note: getNavigationStructure returns a simplified tree.\n\t\t// We might need to map it back to the stores or adjust the stores to accept it.\n\t\t// For now, let's assume we still need to fetch the full collections if we want the full schema,\n\t\t// BUT for the sidebar navigation, the simplified structure is enough.\n\n\t\t// TODO: If we want full hydration, we should pass the full structure or\n\t\t// ensure the navigation structure is sufficient for the initial view.\n\t\t// For this optimization, let's assume we still fetch collections but we can skip if we have data.\n\n\t\t// Actually, let's trigger the update but use the version to avoid re-fetching if not needed.\n\t}\n\n\t// 2. Initial Load (if not hydrated or if we need full data)\n\tawait updateCollections();\n\n\t// 3. Start Polling\n\tstartPolling();\n}\n\nfunction startPolling() {\n\tif (pollingInterval || !browser) return;\n\n\tlogger.info('ðŸ“¡ Starting content version polling');\n\tpollingInterval = setInterval(async () => {\n\t\ttry {\n\t\t\tconst response = await axios.get('/api/content/version');\n\t\t\tconst serverVersion = response.data.version;\n\n\t\t\tif (serverVersion > currentVersion) {\n\t\t\t\tlogger.info(`ðŸ†• New content version detected: ${serverVersion} (current: ${currentVersion})`);\n\t\t\t\tcurrentVersion = serverVersion;\n\t\t\t\tawait updateCollections(true);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.warn('Failed to poll content version', error);\n\t\t}\n\t}, 10000); // Poll every 10 seconds\n}\n\nexport function stopPolling() {\n\tif (pollingInterval) {\n\t\tclearInterval(pollingInterval);\n\t\tpollingInterval = null;\n\t}\n}\n\nexport { contentStructure as categories };\n","/**\n * @file src/routes/(app)/[language]/+page.server.ts\n * @description Redirect handler for language-only URLs\n * Redirects /en (or any language) to the first available collection\n */\n\nimport { redirect } from '@sveltejs/kit';\nimport type { PageServerLoad } from './$types';\nimport { updateCollections, getCollections } from '@content';\nimport { logger } from '@shared/utils/logger.server';\n\nexport const load: PageServerLoad = async ({ params }) => {\n\tconst { language } = params;\n\n\ttry {\n\t\t// Update collections to ensure they're loaded\n\t\tawait updateCollections();\n\n\t\t// Get all collections\n\t\tconst collections = await getCollections();\n\t\tconst collectionList = Object.values(collections).filter(Boolean);\n\n\t\tlogger.info('[Language Redirect] Collections loaded', {\n\t\t\tlanguage,\n\t\t\tcollectionCount: collectionList.length,\n\t\t\tcollectionNames: collectionList.map((c) => c?.name)\n\t\t});\n\n\t\tif (collectionList.length === 0) {\n\t\t\tlogger.info('[Language Redirect] No collections found, redirecting to collectionbuilder');\n\t\t\tthrow redirect(302, `/config/collectionbuilder`);\n\t\t}\n\n\t\t// Get the first collection with a valid path\n\t\tconst firstCollection = collectionList.find((c) => c && c.path);\n\n\t\tif (firstCollection && firstCollection.path) {\n\t\t\t// Check if path already includes language\n\t\t\tconst redirectPath = firstCollection.path.startsWith(`/${language}`) ? firstCollection.path : `/${language}${firstCollection.path}`;\n\n\t\t\tlogger.info('[Language Redirect] Redirecting to first collection', {\n\t\t\t\tcollectionName: firstCollection.name,\n\t\t\t\tcollectionPath: firstCollection.path,\n\t\t\t\tredirectPath\n\t\t\t});\n\n\t\t\tthrow redirect(302, redirectPath);\n\t\t}\n\n\t\t// Fallback to collectionbuilder if no collection with path found\n\t\tlogger.warn('[Language Redirect] No collection with valid path found, redirecting to collectionbuilder');\n\t\tthrow redirect(302, `/config/collectionbuilder`);\n\t} catch (error) {\n\t\t// If it's already a redirect, rethrow it\n\t\tif (error && typeof error === 'object' && 'status' in error && (error as { status: number }).status === 302) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tlogger.error('Error in language redirect', { error });\n\t\t// Otherwise, fallback to collectionbuilder\n\t\tthrow redirect(302, `/config/collectionbuilder`);\n\t}\n};\n"],"names":["collections","error","uuidv4","logger"],"mappings":"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"}