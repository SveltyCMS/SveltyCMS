{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/routes/api/token/createToken/+server.ts"],"sourcesContent":["/**\n * @file: src/routes/api/user/createToken/+server.ts\n * @description: API endpoint for creating user registration tokens and sending invitation emails\n *\n * Features:\n * - **Defense in Depth**: Specific permission checking for token creation.\n * - Input validation using Valibot schemas.\n * - Safeguards against creating tokens for existing users or emails within the same tenant.\n * - Correct, environment-agnostic link generation for invitation emails.\n * - Error handling and logging.\n */\n\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport { error, json, type HttpError } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\n\n// Auth\nimport type { ISODateString } from '@cms-types';\nimport { auth, dbAdapter } from '@shared/database/db';\nimport { getDefaultRoles } from '@shared/database/auth/defaultRoles';\n\n// System Logger\nimport { logger } from '@shared/utils/logger.server';\n\n// Cache invalidation\nimport { cacheService } from '@shared/database/CacheService';\n\n// Input validation\nimport { addUserTokenSchema } from '@shared/utils/formSchemas';\nimport { v4 as uuidv4 } from 'uuid';\nimport { parse } from 'valibot';\n\n// ParaglideJS\nimport { getLocale } from '@shared/paraglide/runtime';\n\nexport const POST: RequestHandler = async ({ request, locals, fetch, url }) => {\n\ttry {\n\t\tconst { tenantId } = locals; // User and permissions are guaranteed by hooks\n\n\t\t// No permission checks needed - hooks already verified:\n\t\t// 1. User is authenticated\n\t\t// 2. User has correct role for 'api:token' endpoint\n\t\t// 3. User belongs to correct tenant (if multi-tenant)\n\n\t\tif (!auth || !dbAdapter) {\n\t\t\tlogger.error('Authentication system is not initialized');\n\t\t\tthrow error(500, 'Internal Server Error: Auth system not initialized');\n\t\t}\n\n\t\t// Note: tenantId validation is handled by hooks in multi-tenant mode\n\n\t\tconst body = await request.json();\n\t\tlogger.debug('Received token creation request:', { ...body, tenantId }); // Validate input using the Valibot schema\n\n\t\tconst validatedData = parse(addUserTokenSchema, body);\n\t\tlogger.debug('Validated data:', validatedData); // Validate the selected role\n\n\t\tconst roleInfo = getDefaultRoles().find((r) => r._id === validatedData.role);\n\t\tif (!roleInfo) {\n\t\t\tthrow error(400, 'Invalid role selected.');\n\t\t}\n\n\t\t// --- MULTI-TENANCY: Scope checks to the current tenant ---\n\t\tconst checkCriteria: { email: string; tenantId?: string } = { email: validatedData.email };\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tcheckCriteria.tenantId = tenantId;\n\t\t} // Quick checks (fail fast)\n\n\t\tconst [existingUser, existingTokens] = await Promise.all([auth.checkUser(checkCriteria), auth.getAllTokens(checkCriteria)]);\n\n\t\tif (existingUser) {\n\t\t\tlogger.warn('Attempted to create token for an already existing user in this tenant', { email: validatedData.email, tenantId });\n\t\t\tthrow error(409, 'A user with this email address already exists in this tenant.');\n\t\t}\n\n\t\tif (existingTokens && existingTokens.success && existingTokens.data && existingTokens.data.length > 0) {\n\t\t\tlogger.warn('Attempted to create a token for an email that already has one in this tenant', { email: validatedData.email, tenantId });\n\t\t\tthrow error(409, 'An invitation token for this email already exists in this tenant. Please delete the existing token first.');\n\t\t}\n\n\t\t// Calculate expiration date\n\t\tconst expirationInSeconds: Record<string, number> = {\n\t\t\t'2 hrs': 7200,\n\t\t\t'12 hrs': 43200,\n\t\t\t'2 days': 172800,\n\t\t\t'1 week': 604800,\n\t\t\t'2 weeks': 1209600,\n\t\t\t'1 month': 2592000\n\t\t};\n\t\tconst expiresInSeconds = expirationInSeconds[validatedData.expiresIn];\n\t\tif (!expiresInSeconds) {\n\t\t\tthrow error(400, 'Invalid expiration value provided.');\n\t\t}\n\t\tconst expires = new Date(Date.now() + expiresInSeconds * 1000); // Create token with pre-generated user_id for when user actually registers\n\n\t\t// Create token in database\n\t\t// For invite tokens, we use the database adapter directly since the user doesn't exist yet\n\t\tconst user_id = uuidv4();\n\t\tconst type = 'invite';\n\n\t\t// Use dbAdapter directly for invite tokens since the user doesn't exist yet\n\t\tconst tokenResult = await dbAdapter.auth.createToken({\n\t\t\tuser_id: user_id,\n\t\t\temail: validatedData.email.toLowerCase(), // Use the provided email directly\n\t\t\texpires: expires.toISOString() as ISODateString,\n\t\t\ttype,\n\t\t\t// Note: role is stored separately in the token metadata, not in the token itself\n\t\t\ttenantId: tenantId || undefined\n\t\t});\n\n\t\tif (!tokenResult.success || !tokenResult.data) {\n\t\t\tlogger.error('Failed to create token', { email: validatedData.email, tenantId });\n\t\t\tthrow error(500, 'Failed to create token.');\n\t\t}\n\n\t\t// Get the actual token string from the database result\n\t\tconst token = tokenResult.data;\n\n\t\tlogger.info('Token created successfully', { email: validatedData.email, role: validatedData.role, tenantId }); // Generate invitation link\n\n\t\tconst inviteLink = `${url.origin}/login?invite_token=${token}`; // Send invitation email\n\n\t\tconst emailResponse = await fetch(`${url.origin}/api/sendMail`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t'x-internal-call': 'true' // Mark as internal call to bypass auth\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\trecipientEmail: validatedData.email,\n\t\t\t\tsubject: 'Invitation to Register',\n\t\t\t\ttemplateName: 'userToken',\n\t\t\t\tprops: {\n\t\t\t\t\temail: validatedData.email,\n\t\t\t\t\trole: roleInfo.name, // Use the role name for display\n\t\t\t\t\ttoken: token,\n\t\t\t\t\ttokenLink: inviteLink,\n\t\t\t\t\texpiresInLabel: validatedData.expiresIn,\n\t\t\t\t\tlanguageTag: getLocale()\n\t\t\t\t}\n\t\t\t})\n\t\t}); // Handle email sending response\n\n\t\tif (!emailResponse.ok) {\n\t\t\tconst emailError = await emailResponse.json();\n\t\t\tlogger.error('Failed to send invitation email. Keeping token for manual/alternate delivery.', {\n\t\t\t\temail: validatedData.email,\n\t\t\t\terror: emailError\n\t\t\t});\n\t\t\t// Do NOT consume token here; return token so admin can deliver link manually in dev\n\t\t\treturn json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: emailError.message || 'Invitation email could not be sent (dev mode). Token preserved for manual delivery.',\n\t\t\t\ttoken: { value: token, expires: expires.toISOString() },\n\t\t\t\temail_sent: false,\n\t\t\t\tdev_mode: true\n\t\t\t});\n\t\t}\n\n\t\t// Check if email was actually sent or skipped due to dummy config\n\t\tconst emailResult = await emailResponse.json();\n\t\tconst emailSkipped = emailResult.dev_mode === true;\n\t\tconst smtpNotConfigured = emailResult.smtp_not_configured === true;\n\n\t\tif (emailSkipped || smtpNotConfigured) {\n\t\t\tconst reason = smtpNotConfigured ? 'SMTP not configured' : 'development mode';\n\t\t\tlogger.info(`Token created successfully - email sending skipped (${reason})`, {\n\t\t\t\temail: validatedData.email,\n\t\t\t\trole: roleInfo.name,\n\t\t\t\ttenantId,\n\t\t\t\tconfig_status: smtpNotConfigured ? 'smtp_not_configured' : 'dummy_email_config'\n\t\t\t});\n\t\t\t// Return token so it can be delivered manually in dev\n\t\t\tcacheService.delete('tokens', tenantId).catch((err) => {\n\t\t\t\tlogger.warn(`Failed to invalidate tokens cache: ${err.message}`);\n\t\t\t});\n\t\t\treturn json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: smtpNotConfigured\n\t\t\t\t\t? 'Token created; email not sent - SMTP not configured. Please configure email settings in System Settings.'\n\t\t\t\t\t: 'Token created; email sending skipped (development mode).',\n\t\t\t\ttoken: { value: token, expires: expires.toISOString() },\n\t\t\t\temail_sent: false,\n\t\t\t\tdev_mode: emailSkipped,\n\t\t\t\tsmtp_not_configured: smtpNotConfigured,\n\t\t\t\tuser_message: smtpNotConfigured ? emailResult.user_message : undefined\n\t\t\t});\n\t\t} else {\n\t\t\tlogger.info('Token created and email sent successfully', {\n\t\t\t\temail: validatedData.email,\n\t\t\t\trole: roleInfo.name,\n\t\t\t\ttenantId\n\t\t\t});\n\t\t} // Invalidate the admin cache for tokens so the UI refreshes immediately\n\n\t\tcacheService.delete('tokens', tenantId).catch((err) => {\n\t\t\tlogger.warn(`Failed to invalidate tokens cache: ${err.message}`);\n\t\t}); // Return success response\n\n\t\treturn json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Token created and email sent successfully.',\n\t\t\ttoken: { value: token, expires: expires.toISOString() },\n\t\t\temail_sent: true\n\t\t});\n\t} catch (err) {\n\t\tif (err instanceof Error && err.name === 'ValiError') {\n\t\t\tconst valiError = err as unknown as { issues: Array<{ message: string }> };\n\t\t\tconst issues = valiError.issues.map((issue) => issue.message).join(', ');\n\t\t\tlogger.warn('Invalid input for createToken API:', { issues });\n\t\t\tthrow error(400, `Invalid input: ${issues}`);\n\t\t}\n\n\t\tconst httpError = err as HttpError;\n\t\tconst status = httpError.status || 500;\n\t\tconst message = httpError.body?.message || 'An unexpected error occurred.';\n\n\t\tlogger.error('Error in createToken API:', {\n\t\t\terror: message,\n\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\tstatus\n\t\t});\n\n\t\treturn json({ success: false, message: status === 500 ? 'Internal Server Error' : message }, { status });\n\t}\n};\n"],"names":["uuidv4"],"mappings":"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"}