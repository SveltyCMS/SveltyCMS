{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/routes/api/logs/download/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/logs/download/+server.ts\n * @description API endpoint to download error logs from the server\n *\n * This endpoint allows administrators to download server error logs for troubleshooting.\n * Supports filtering by date range and log level, and can return logs in plain text or compressed format.\n *\n * Query Parameters:\n * - type: 'latest' | 'all' | 'archive' (default: 'latest')\n * - format: 'text' | 'gzip' (default: 'text')\n * - since: ISO date string (optional, filter logs after this date)\n * - level: 'error' | 'warn' | 'fatal' (optional, filter by log level)\n *\n * Authorization: Requires admin role\n */\n\nimport { error as svelteError } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { createReadStream, existsSync, statSync, readdirSync } from 'fs';\nimport { join, basename } from 'path';\nimport { createGzip } from 'zlib';\nimport { pipeline } from 'stream/promises';\nimport { Readable } from 'stream';\nimport { logger } from '@shared/utils/logger.server';\n\n/**\n * Download error logs from the server\n * GET /api/logs/download\n */\nexport const GET: RequestHandler = async ({ url, locals }) => {\n\ttry {\n\t\t// Check authentication and authorization\n\t\tif (!locals.user) {\n\t\t\tthrow svelteError(401, 'Authentication required');\n\t\t}\n\n\t\tif (locals.user.role !== 'admin') {\n\t\t\tthrow svelteError(403, 'Admin access required to download logs');\n\t\t}\n\n\t\t// Get query parameters\n\t\tconst type = url.searchParams.get('type') || 'latest';\n\t\tconst format = url.searchParams.get('format') || 'text';\n\t\tconst sinceParam = url.searchParams.get('since');\n\t\tconst levelFilter = url.searchParams.get('level');\n\n\t\t// Validate parameters\n\t\tif (!['latest', 'all', 'archive'].includes(type)) {\n\t\t\tthrow svelteError(400, 'Invalid type parameter. Must be: latest, all, or archive');\n\t\t}\n\n\t\tif (!['text', 'gzip'].includes(format)) {\n\t\t\tthrow svelteError(400, 'Invalid format parameter. Must be: text or gzip');\n\t\t}\n\n\t\t// Parse since date if provided\n\t\tlet sinceDate: Date | null = null;\n\t\tif (sinceParam) {\n\t\t\tsinceDate = new Date(sinceParam);\n\t\t\tif (isNaN(sinceDate.getTime())) {\n\t\t\t\tthrow svelteError(400, 'Invalid since date format. Use ISO 8601 format');\n\t\t\t}\n\t\t}\n\n\t\t// Determine log file path\n\t\tconst logsDir = join(process.cwd(), 'logs');\n\t\tconst logFiles: string[] = [];\n\n\t\tif (type === 'latest') {\n\t\t\tconst latestLog = join(logsDir, 'app.log');\n\t\t\tif (existsSync(latestLog)) {\n\t\t\t\tlogFiles.push(latestLog);\n\t\t\t}\n\t\t} else if (type === 'all') {\n\t\t\t// Get all log files (current + rotated)\n\t\t\tif (existsSync(logsDir)) {\n\t\t\t\tconst files = readdirSync(logsDir)\n\t\t\t\t\t.filter((f) => f.startsWith('app.log'))\n\t\t\t\t\t.map((f) => join(logsDir, f))\n\t\t\t\t\t.sort((a, b) => statSync(b).mtime.getTime() - statSync(a).mtime.getTime()); // Most recent first\n\t\t\t\tlogFiles.push(...files);\n\t\t\t}\n\t\t} else if (type === 'archive') {\n\t\t\t// Get only rotated/archived logs (compressed)\n\t\t\tif (existsSync(logsDir)) {\n\t\t\t\tconst files = readdirSync(logsDir)\n\t\t\t\t\t.filter((f) => f.startsWith('app.log.') && f.endsWith('.gz'))\n\t\t\t\t\t.map((f) => join(logsDir, f))\n\t\t\t\t\t.sort((a, b) => statSync(b).mtime.getTime() - statSync(a).mtime.getTime());\n\t\t\t\tlogFiles.push(...files);\n\t\t\t}\n\t\t}\n\n\t\tif (logFiles.length === 0) {\n\t\t\tthrow svelteError(404, 'No log files found');\n\t\t}\n\n\t\t// If single file and format is text, stream it directly\n\t\tif (logFiles.length === 1 && format === 'text' && !logFiles[0].endsWith('.gz')) {\n\t\t\tconst logFile = logFiles[0];\n\n\t\t\t// Apply filters if needed\n\t\t\tif (sinceDate || levelFilter) {\n\t\t\t\tconst filteredLogs = await filterLogs(logFile, sinceDate, levelFilter);\n\n\t\t\t\tlogger.info('Log download requested', {\n\t\t\t\t\tuser: locals.user.email,\n\t\t\t\t\ttype,\n\t\t\t\t\tformat,\n\t\t\t\t\tfilters: { since: sinceParam, level: levelFilter },\n\t\t\t\t\tlinesReturned: filteredLogs.split('\\n').length\n\t\t\t\t});\n\n\t\t\t\treturn new Response(filteredLogs, {\n\t\t\t\t\tstatus: 200,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/plain',\n\t\t\t\t\t\t'Content-Disposition': `attachment; filename=\"app-logs-${new Date().toISOString().split('T')[0]}.txt\"`,\n\t\t\t\t\t\t'Cache-Control': 'no-cache'\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// No filters - stream entire file\n\t\t\tconst stat = statSync(logFile);\n\t\t\tconst stream = createReadStream(logFile);\n\n\t\t\tlogger.info('Log download requested', {\n\t\t\t\tuser: locals.user.email,\n\t\t\t\ttype,\n\t\t\t\tformat,\n\t\t\t\tfileSize: stat.size\n\t\t\t});\n\n\t\t\treturn new Response(stream as unknown as BodyInit, {\n\t\t\t\tstatus: 200,\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/plain',\n\t\t\t\t\t'Content-Disposition': `attachment; filename=\"${basename(logFile)}\"`,\n\t\t\t\t\t'Content-Length': stat.size.toString(),\n\t\t\t\t\t'Cache-Control': 'no-cache'\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Multiple files or gzip format requested - combine and compress\n\t\tconst combinedLogs = await combineLogs(logFiles, sinceDate, levelFilter);\n\n\t\tlogger.info('Log download requested', {\n\t\t\tuser: locals.user.email,\n\t\t\ttype,\n\t\t\tformat,\n\t\t\tfiles: logFiles.length,\n\t\t\tfilters: { since: sinceParam, level: levelFilter },\n\t\t\tlinesReturned: combinedLogs.split('\\n').length\n\t\t});\n\n\t\tif (format === 'gzip') {\n\t\t\t// Compress logs\n\t\t\tconst buffer = Buffer.from(combinedLogs, 'utf-8');\n\t\t\tconst compressed = await compressBuffer(buffer);\n\n\t\t\treturn new Response(new Uint8Array(compressed), {\n\t\t\t\tstatus: 200,\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/gzip',\n\t\t\t\t\t'Content-Disposition': `attachment; filename=\"app-logs-${new Date().toISOString().split('T')[0]}.log.gz\"`,\n\t\t\t\t\t'Content-Encoding': 'gzip',\n\t\t\t\t\t'Cache-Control': 'no-cache'\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Return as text\n\t\treturn new Response(combinedLogs, {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'text/plain',\n\t\t\t\t'Content-Disposition': `attachment; filename=\"app-logs-${new Date().toISOString().split('T')[0]}.txt\"`,\n\t\t\t\t'Cache-Control': 'no-cache'\n\t\t\t}\n\t\t});\n\t} catch (err) {\n\t\tif (err && typeof err === 'object' && 'status' in err) {\n\t\t\tthrow err; // Re-throw SvelteKit errors\n\t\t}\n\n\t\tlogger.error('Error downloading logs', { error: err });\n\t\tthrow svelteError(500, 'Failed to download logs');\n\t}\n};\n\n// Filter logs by date and/or level\nasync function filterLogs(logFile: string, since: Date | null, level: string | null): Promise<string> {\n\tconst { readFile } = await import('fs/promises');\n\tconst content = await readFile(logFile, 'utf-8');\n\tconst lines = content.split('\\n');\n\n\tconst filtered = lines.filter((line) => {\n\t\tif (!line.trim()) return false;\n\n\t\ttry {\n\t\t\t// Try to parse as JSON (structured logs)\n\t\t\tconst log = JSON.parse(line);\n\n\t\t\t// Filter by date\n\t\t\tif (since && log.timestamp) {\n\t\t\t\tconst logDate = new Date(log.timestamp);\n\t\t\t\tif (logDate < since) return false;\n\t\t\t}\n\n\t\t\t// Filter by level\n\t\t\tif (level && log.level) {\n\t\t\t\tif (log.level.toLowerCase() !== level.toLowerCase()) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\t// Not JSON - include line if it contains error-related keywords when level filter is set\n\t\t\tif (level) {\n\t\t\t\tconst lowerLine = line.toLowerCase();\n\t\t\t\treturn lowerLine.includes(level.toLowerCase());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn filtered.join('\\n');\n}\n\n// Combine multiple log files\nasync function combineLogs(logFiles: string[], since: Date | null, level: string | null): Promise<string> {\n\tconst { readFile } = await import('fs/promises');\n\tconst { createGunzip } = await import('zlib');\n\tconst { Readable } = await import('stream');\n\n\tconst allLogs: string[] = [];\n\n\tfor (const file of logFiles) {\n\t\ttry {\n\t\t\tlet content: string;\n\n\t\t\tif (file.endsWith('.gz')) {\n\t\t\t\t// Decompress gzipped logs\n\t\t\t\tconst compressed = await readFile(file);\n\t\t\t\tconst gunzip = createGunzip();\n\t\t\t\tconst chunks: Buffer[] = [];\n\n\t\t\t\tawait pipeline(Readable.from(compressed), gunzip, async function* (source) {\n\t\t\t\t\tfor await (const chunk of source) {\n\t\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t\t\tyield; // Satisfy generator requirement\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tcontent = Buffer.concat(chunks).toString('utf-8');\n\t\t\t} else {\n\t\t\t\tcontent = await readFile(file, 'utf-8');\n\t\t\t}\n\n\t\t\t// Apply filters if needed\n\t\t\tif (since || level) {\n\t\t\t\tconst lines = content.split('\\n');\n\t\t\t\tconst filtered = lines.filter((line) => {\n\t\t\t\t\tif (!line.trim()) return false;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst log = JSON.parse(line);\n\n\t\t\t\t\t\tif (since && log.timestamp) {\n\t\t\t\t\t\t\tconst logDate = new Date(log.timestamp);\n\t\t\t\t\t\t\tif (logDate < since) return false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (level && log.level) {\n\t\t\t\t\t\t\tif (log.level.toLowerCase() !== level.toLowerCase()) return false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tif (level) {\n\t\t\t\t\t\t\tconst lowerLine = line.toLowerCase();\n\t\t\t\t\t\t\treturn lowerLine.includes(level.toLowerCase());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tallLogs.push(...filtered);\n\t\t\t} else {\n\t\t\t\tallLogs.push(content);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Failed to read log file: ${file}`, { error: err });\n\t\t}\n\t}\n\n\treturn allLogs.join('\\n');\n}\n\n// Compress buffer to gzip\nasync function compressBuffer(buffer: Buffer): Promise<Buffer> {\n\tconst gzip = createGzip();\n\tconst chunks: Buffer[] = [];\n\n\tawait pipeline(Readable.from(buffer), gzip, async function* (source) {\n\t\tfor await (const chunk of source) {\n\t\t\tchunks.push(chunk);\n\t\t\tyield; // Satisfy generator requirement\n\t\t}\n\t});\n\n\treturn Buffer.concat(chunks);\n}\n"],"names":["svelteError","Readable"],"mappings":"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"}