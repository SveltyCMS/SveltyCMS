{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/routes/api/import/full/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/import/full/+server.ts\n * @description API endpoint for importing full system configuration including settings and collections.\n *\n * Features:\n * - Import system settings and collections\n * - Validation of import data structure\n * - Conflict detection with current system state\n * - Three conflict resolution strategies: skip, overwrite, merge\n * - Support for encrypted sensitive data with quantum-resistant decryption\n * - Dry-run mode for validation without applying changes\n * - Audit logging of import actions\n */\n\nimport { json, type RequestHandler } from '@sveltejs/kit';\n\nimport { getDb, dbAdapter } from '@shared/database/db';\nimport { getAllSettings, invalidateSettingsCache } from '@shared/services/settingsService';\nimport { logger } from '@shared/utils/logger.server';\nimport { decryptData } from '@shared/utils/crypto';\nimport type {\n\tExportData,\n\tImportOptions,\n\tValidationResult,\n\tValidationError,\n\tValidationWarning,\n\tConflict,\n\tImportResult,\n\tExportMetadata,\n\tDatabaseId\n} from '@cms-types';\n\n/**\n * Decrypt sensitive data using quantum-resistant AES-256-GCM with Argon2-derived key\n *\n * QUANTUM COMPUTING SECURITY:\n * - AES-256-GCM: Provides 128-bit quantum security (still computationally infeasible)\n * - Argon2 key derivation: Memory-hard algorithm resists quantum speedup\n * - Combined security: Strong protection against both classical and quantum attacks\n *\n * Security Timeline: Secure for 15-30+ years against quantum computers\n *\n * Uses enterprise-grade cryptography from shared utils\n */\nasync function decryptSensitiveData(encryptedData: string, password: string): Promise<Record<string, unknown>> {\n\ttry {\n\t\treturn await decryptData(encryptedData, password);\n\t} catch {\n\t\tthrow new Error('Failed to decrypt sensitive data. Password may be incorrect.');\n\t}\n}\n\n// Validate import data structure\nasync function validateImportData(data: ExportData): Promise<ValidationResult> {\n\tconst errors: ValidationError[] = [];\n\tconst warnings: ValidationWarning[] = [];\n\n\t// Validate metadata\n\tif (!data.metadata) {\n\t\terrors.push({\n\t\t\tpath: 'metadata',\n\t\t\tmessage: 'Missing required metadata',\n\t\t\tcode: 'MISSING_METADATA'\n\t\t});\n\t} else {\n\t\tif (!data.metadata.exported_at) {\n\t\t\terrors.push({\n\t\t\t\tpath: 'metadata.exported_at',\n\t\t\t\tmessage: 'Missing export timestamp',\n\t\t\t\tcode: 'MISSING_TIMESTAMP'\n\t\t\t});\n\t\t}\n\n\t\tif (!data.metadata.cms_version) {\n\t\t\twarnings.push({\n\t\t\t\tpath: 'metadata.cms_version',\n\t\t\t\tmessage: 'Missing CMS version - compatibility cannot be verified',\n\t\t\t\tcode: 'MISSING_VERSION'\n\t\t\t});\n\t\t}\n\t}\n\n\t// Validate settings if present\n\tif (data.settings) {\n\t\tif (typeof data.settings !== 'object') {\n\t\t\terrors.push({\n\t\t\t\tpath: 'settings',\n\t\t\t\tmessage: 'Settings must be an object',\n\t\t\t\tcode: 'INVALID_SETTINGS_TYPE'\n\t\t\t});\n\t\t} else {\n\t\t\t// Validate each setting\n\t\t\tfor (const [key, value] of Object.entries(data.settings)) {\n\t\t\t\tif (key === '' || key === null || key === undefined) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tpath: `settings.${key}`,\n\t\t\t\t\t\tmessage: 'Invalid setting key',\n\t\t\t\t\t\tcode: 'INVALID_SETTING_KEY'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Check for null or undefined values\n\t\t\t\tif (value === null || value === undefined) {\n\t\t\t\t\twarnings.push({\n\t\t\t\t\t\tpath: `settings.${key}`,\n\t\t\t\t\t\tmessage: 'Setting has null or undefined value',\n\t\t\t\t\t\tcode: 'NULL_SETTING_VALUE'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Validate collections if present\n\tif (data.collections) {\n\t\tif (!Array.isArray(data.collections)) {\n\t\t\terrors.push({\n\t\t\t\tpath: 'collections',\n\t\t\t\tmessage: 'Collections must be an array',\n\t\t\t\tcode: 'INVALID_COLLECTIONS_TYPE'\n\t\t\t});\n\t\t} else {\n\t\t\tdata.collections.forEach((collection, index) => {\n\t\t\t\tif (!collection.id) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tpath: `collections[${index}].id`,\n\t\t\t\t\t\tmessage: 'Collection missing required id',\n\t\t\t\t\t\tcode: 'MISSING_COLLECTION_ID'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!collection.name) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tpath: `collections[${index}].name`,\n\t\t\t\t\t\tmessage: 'Collection missing required name',\n\t\t\t\t\t\tcode: 'MISSING_COLLECTION_NAME'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check if export has any data\n\tif (!data.settings && !data.collections) {\n\t\twarnings.push({\n\t\t\tpath: 'root',\n\t\t\tmessage: 'Export contains no settings or collections',\n\t\t\tcode: 'EMPTY_EXPORT'\n\t\t});\n\t}\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t\twarnings\n\t};\n}\n\n// Detect conflicts between current and import data\nasync function detectConflicts(importData: ExportData): Promise<Conflict[]> {\n\tconst conflicts: Conflict[] = [];\n\n\t// Check settings conflicts\n\tif (importData.settings) {\n\t\tconst currentSettings = await getAllSettings();\n\n\t\tfor (const [key, importValue] of Object.entries(importData.settings)) {\n\t\t\tconst currentValue = (currentSettings as Record<string, unknown>)[key];\n\n\t\t\tif (currentValue !== undefined) {\n\t\t\t\t// Value exists - check if different\n\t\t\t\tif (JSON.stringify(currentValue) !== JSON.stringify(importValue)) {\n\t\t\t\t\tconflicts.push({\n\t\t\t\t\t\ttype: 'setting',\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tcurrent: currentValue,\n\t\t\t\t\t\timport: importValue,\n\t\t\t\t\t\trecommendation: 'overwrite'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check collection conflicts\n\tif (importData.collections) {\n\t\t// TODO: Implement collection conflict detection\n\t\t// This depends on your collection storage structure\n\t}\n\n\tlogger.info(`Detected ${conflicts.length} conflicts`);\n\treturn conflicts;\n}\n\n/**\n * Merge two values intelligently\n */\nfunction mergeValues(current: unknown, imported: unknown): unknown {\n\t// If both are objects, merge properties\n\tif (typeof current === 'object' && typeof imported === 'object' && current !== null && imported !== null) {\n\t\tif (Array.isArray(current) && Array.isArray(imported)) {\n\t\t\t// For arrays, combine and deduplicate\n\t\t\treturn [...new Set([...current, ...imported])];\n\t\t}\n\n\t\t// For objects, merge properties\n\t\treturn { ...current, ...imported };\n\t}\n\n\t// For primitives, prefer imported value\n\treturn imported;\n}\n\n/**\n * Apply import with strategy\n */\nasync function applyImport(importData: ExportData, options: ImportOptions, conflicts: Conflict[]): Promise<ImportResult> {\n\tconst result: ImportResult = {\n\t\tsuccess: true,\n\t\timported: 0,\n\t\tskipped: 0,\n\t\tmerged: 0,\n\t\terrors: [],\n\t\tconflicts\n\t};\n\n\tconst db = getDb();\n\n\tif (!db) {\n\t\tresult.success = false;\n\t\tresult.errors.push({\n\t\t\tkey: 'database',\n\t\t\tmessage: 'Database connection not available',\n\t\t\tcode: 'DB_ERROR'\n\t\t});\n\t\treturn result;\n\t}\n\n\t// Apply settings\n\tif (importData.settings) {\n\t\tfor (const [key, value] of Object.entries(importData.settings)) {\n\t\t\tconst conflict = conflicts.find((c) => c.key === key);\n\n\t\t\tif (conflict) {\n\t\t\t\t// Handle based on strategy\n\t\t\t\tif (options.strategy === 'skip') {\n\t\t\t\t\tlogger.debug(`Skipping conflicted setting: ${key}`);\n\t\t\t\t\tresult.skipped++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (options.strategy === 'merge') {\n\t\t\t\t\t// Intelligent merge\n\t\t\t\t\tconst mergedValue = mergeValues(conflict.current, conflict.import);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait db.systemPreferences.set(key, mergedValue, 'system');\n\t\t\t\t\t\tresult.merged++;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tresult.errors.push({\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error',\n\t\t\t\t\t\t\tcode: 'MERGE_FAILED'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresult.success = false;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No conflict or overwrite strategy\n\t\t\ttry {\n\t\t\t\tawait db.systemPreferences.set(key, value, 'system');\n\t\t\t\tresult.imported++;\n\t\t\t} catch (error) {\n\t\t\t\tresult.errors.push({\n\t\t\t\t\tkey,\n\t\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error',\n\t\t\t\t\tcode: 'IMPORT_FAILED'\n\t\t\t\t});\n\t\t\t\tresult.success = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply collections\n\tif (importData.collections) {\n\t\tfor (const collection of importData.collections) {\n\t\t\t// TODO: Import schema if needed (currently assuming schema exists or is handled separately)\n\n\t\t\tif (collection.documents && collection.documents.length > 0) {\n\t\t\t\t// Use the existing import logic logic but adapted for this structure\n\t\t\t\t// For now, we'll do a simple insert/update loop similar to importData\n\t\t\t\tif (!dbAdapter) {\n\t\t\t\t\tlogger.error('Database adapter not available for collection import');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet importedCount = 0;\n\t\t\t\tlet errorCount = 0;\n\n\t\t\t\tfor (const doc of collection.documents) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Check if exists\n\t\t\t\t\t\tconst existing = await dbAdapter.crud.findOne(`collection_${collection.id}`, { _id: doc._id as DatabaseId });\n\n\t\t\t\t\t\tif (existing.success && existing.data) {\n\t\t\t\t\t\t\tif (options.strategy === 'overwrite') {\n\t\t\t\t\t\t\t\tawait dbAdapter.crud.update(`collection_${collection.id}`, doc._id as DatabaseId, doc);\n\t\t\t\t\t\t\t\timportedCount++;\n\t\t\t\t\t\t\t} else if (options.strategy === 'merge') {\n\t\t\t\t\t\t\t\t// Simple merge for now\n\t\t\t\t\t\t\t\tconst merged = { ...existing.data, ...doc };\n\t\t\t\t\t\t\t\tawait dbAdapter.crud.update(`collection_${collection.id}`, doc._id as DatabaseId, merged);\n\t\t\t\t\t\t\t\timportedCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If skip, do nothing\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait dbAdapter.crud.insert(`collection_${collection.id}`, doc);\n\t\t\t\t\t\t\timportedCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terrorCount++;\n\t\t\t\t\t\tlogger.error(`Failed to import document in ${collection.name}`, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlogger.info(`Imported ${importedCount} documents for ${collection.name} with ${errorCount} errors`);\n\t\t\t\tresult.imported += importedCount;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Invalidate cache and reload after successful import\n\tif (result.success) {\n\t\tinvalidateSettingsCache();\n\t\tconst { loadSettingsFromDB } = await import('@shared/database/db');\n\t\tawait loadSettingsFromDB();\n\t\tlogger.info('Settings cache invalidated and reloaded after import');\n\t}\n\n\tlogger.info('Import completed', {\n\t\timported: result.imported,\n\t\tskipped: result.skipped,\n\t\tmerged: result.merged,\n\t\terrors: result.errors.length\n\t});\n\n\treturn result;\n}\n\n/**\n * Log import to audit trail\n */\nasync function logImport(userId: string, metadata: ExportMetadata, result: ImportResult): Promise<void> {\n\tlogger.info('Import audit log', {\n\t\tuserId,\n\t\timport_id: metadata.export_id,\n\t\timported_at: new Date().toISOString(),\n\t\tsuccess: result.success,\n\t\timported: result.imported,\n\t\tskipped: result.skipped,\n\t\tmerged: result.merged,\n\t\terrors: result.errors.length\n\t});\n\n\t// TODO: Store audit log in database\n\t// This would typically go to a dedicated audit_logs collection\n}\n\n/**\n * Import full system configuration\n * POST /api/import/full\n *\n * Imports settings and optionally collections with validation and conflict resolution.\n * Supports three strategies: skip, overwrite, merge.\n * Can run in dry-run mode for validation only.\n *\n * Permissions: config:settings:write (or admin)\n */\nexport const POST: RequestHandler = async ({ locals, request }) => {\n\t// Check authentication\n\tif (!locals.user) {\n\t\treturn json({ error: 'Unauthorized' }, { status: 401 });\n\t}\n\n\ttry {\n\t\t// Parse request body\n\t\tconst body = await request.json();\n\t\tconst importData: ExportData = body.data;\n\t\tconst options: ImportOptions = body.options || {};\n\n\t\t// Default options\n\t\tconst importOptions: ImportOptions = {\n\t\t\tstrategy: options.strategy || 'skip',\n\t\t\tdryRun: options.dryRun ?? false,\n\t\t\tvalidateOnly: options.validateOnly ?? false,\n\t\t\tsensitivePassword: options.sensitivePassword\n\t\t};\n\n\t\t// Handle encrypted sensitive data\n\t\tif (importData.hasSensitiveData && importData.encryptedSensitive) {\n\t\t\tif (!importOptions.sensitivePassword) {\n\t\t\t\treturn json(\n\t\t\t\t\t{\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: 'Password required',\n\t\t\t\t\t\tmessage: 'This import contains encrypted sensitive data. Please provide the password.'\n\t\t\t\t\t},\n\t\t\t\t\t{ status: 400 }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Decrypt sensitive data\n\t\t\t\tconst decryptedSensitive = decryptSensitiveData(importData.encryptedSensitive, importOptions.sensitivePassword);\n\n\t\t\t\t// Merge decrypted sensitive data back into settings\n\t\t\t\timportData.settings = {\n\t\t\t\t\t...importData.settings,\n\t\t\t\t\t...decryptedSensitive\n\t\t\t\t};\n\n\t\t\t\tlogger.info(`Decrypted ${Object.keys(decryptedSensitive).length} sensitive settings`);\n\t\t\t} catch (decryptError) {\n\t\t\t\treturn json(\n\t\t\t\t\t{\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: 'Decryption failed',\n\t\t\t\t\t\tmessage: decryptError instanceof Error ? decryptError.message : 'Failed to decrypt sensitive data'\n\t\t\t\t\t},\n\t\t\t\t\t{ status: 400 }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Step 1: Validate import data structure\n\t\tconst validation = await validateImportData(importData);\n\n\t\tif (!validation.valid) {\n\t\t\treturn json(\n\t\t\t\t{\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terrors: validation.errors,\n\t\t\t\t\twarnings: validation.warnings\n\t\t\t\t},\n\t\t\t\t{ status: 400 }\n\t\t\t);\n\t\t}\n\n\t\t// If validate only, return validation result\n\t\tif (importOptions.validateOnly) {\n\t\t\treturn json({\n\t\t\t\tsuccess: true,\n\t\t\t\tvalid: true,\n\t\t\t\terrors: validation.errors,\n\t\t\t\twarnings: validation.warnings\n\t\t\t});\n\t\t}\n\n\t\t// Step 2: Detect conflicts\n\t\tconst conflicts = await detectConflicts(importData);\n\n\t\t// If dry run, return conflicts without applying\n\t\tif (importOptions.dryRun) {\n\t\t\treturn json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdryRun: true,\n\t\t\t\tconflicts,\n\t\t\t\tvalidation\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Apply import with conflict resolution\n\t\tconst result: ImportResult = await applyImport(importData, importOptions, conflicts);\n\n\t\t// Step 4: Log import for audit trail\n\t\tawait logImport(locals.user._id, importData.metadata, result);\n\n\t\t// Return result\n\t\treturn json(\n\t\t\t{\n\t\t\t\tsuccess: result.success,\n\t\t\t\timported: result.imported,\n\t\t\t\tskipped: result.skipped,\n\t\t\t\tmerged: result.merged,\n\t\t\t\tconflicts: result.conflicts,\n\t\t\t\terrors: result.errors,\n\t\t\t\twarnings: validation.warnings,\n\t\t\t\tmetadata: importData.metadata\n\t\t\t},\n\t\t\t{ status: result.success ? 200 : 207 } // 207 Multi-Status if partial success\n\t\t);\n\t} catch (error) {\n\t\tlogger.error('Import error:', error);\n\t\treturn json(\n\t\t\t{\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Import failed',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t},\n\t\t\t{ status: 500 }\n\t\t);\n\t}\n};\n"],"names":[],"mappings":"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"}