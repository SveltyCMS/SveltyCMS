{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../../../shared/utils/src/password.ts","../../../../../../../../src/routes/api/user/login/+server.ts"],"sourcesContent":["/**\n * @file src/utils/password.ts\n * @description Centralized password hashing and verification utilities\n *\n * QUANTUM COMPUTING SECURITY:\n * ==========================\n * This module uses Argon2id, which is inherently quantum-resistant:\n *\n * - Memory-hard algorithm: Quantum computers don't have memory advantages\n * - 64 MB per hash: Limits quantum computer parallelization\n * - Grover's algorithm ineffective: No speedup for memory-bound operations\n * - Secure until 2045+: Strong resistance against both classical and quantum attacks\n *\n * This module provides a single source of truth for all password operations\n * to ensure consistency across the entire application.\n *\n * @see https://csrc.nist.gov/projects/post-quantum-cryptography\n */\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n/**\n * Argon2id configuration - Quantum-resistant password hashing\n *\n * SECURITY RATIONALE:\n * - Memory (64 MB): Makes attacks expensive even with quantum computers\n * - Time (3 iterations): Adds computational cost without degrading UX\n * - Parallelism (4 threads): Optimized for modern multi-core CPUs\n * - Type (argon2id): Hybrid mode resistant to both side-channel and GPU attacks\n *\n * QUANTUM RESISTANCE:\n * Quantum computers excel at computation but are limited by:\n * 1. Limited qubits (can't allocate 64 MB per hash)\n * 2. Memory access patterns (not parallelizable by quantum algorithms)\n * 3. Grover's algorithm only helps with computation, not memory operations\n *\n * This makes Argon2id secure against quantum attacks for decades to come.\n */\nconst ARGON2_CONFIG = {\n\tmemory: 65536, // 64 MB - Quantum-resistant memory requirement\n\ttime: 3, // 3 iterations - Computational complexity\n\tparallelism: 4, // 4 parallel threads - CPU optimization\n\ttype: 2 // argon2id (hybrid: side-channel + GPU resistant)\n} as const;\n\n/**\n * Hash a password using argon2id with quantum-resistant parameters\n *\n * SECURITY FEATURES:\n * - Argon2id: Winner of Password Hashing Competition (2015)\n * - Memory-hard: 64 MB per hash (resists GPU/ASIC/quantum attacks)\n * - Quantum-resistant: No known quantum speedup for memory-bound algorithms\n * - Salt: Automatically generated per password (prevents rainbow tables)\n *\n * QUANTUM RESISTANCE:\n * Unlike computational algorithms vulnerable to Grover's algorithm,\n * memory-hard algorithms like Argon2 maintain full security because:\n * - Quantum computers have limited qubits (can't store 64 MB per hash)\n * - Memory access patterns aren't parallelizable\n * - No quantum advantage for memory-bound operations\n *\n * @param password - The plain text password to hash\n * @returns Promise<string> - The hashed password in PHC format\n * @throws Error if hashing fails\n */\nexport async function hashPassword(password: string): Promise<string> {\n\ttry {\n\t\tconst argon2 = await import('argon2');\n\n\t\tconst hashedPassword = await argon2.hash(password, {\n\t\t\tmemoryCost: ARGON2_CONFIG.memory,\n\t\t\ttimeCost: ARGON2_CONFIG.time,\n\t\t\tparallelism: ARGON2_CONFIG.parallelism,\n\t\t\ttype: argon2.argon2id\n\t\t});\n\n\t\tlogger.trace('Password hashed successfully');\n\t\treturn hashedPassword;\n\t} catch (error) {\n\t\tlogger.error('Failed to hash password:', error);\n\t\tthrow new Error('Password hashing failed');\n\t}\n}\n\n/**\n * Verify a password against a hash using constant-time comparison\n *\n * SECURITY FEATURES:\n * - Timing-safe: Prevents timing attacks (comparison time is constant)\n * - Automatic parameter extraction: Uses stored salt, memory, time settings\n * - Quantum-resistant: Argon2 verification maintains quantum resistance\n *\n * @param hashedPassword - The stored hash to verify against (PHC format)\n * @param plainPassword - The plain text password to verify\n * @returns Promise<boolean> - True if password matches, false otherwise\n */\nexport async function verifyPassword(hashedPassword: string, plainPassword: string): Promise<boolean> {\n\ttry {\n\t\tconst argon2 = await import('argon2');\n\n\t\tconst isValid = await argon2.verify(hashedPassword, plainPassword);\n\n\t\tlogger.trace('Password verification completed', { isValid });\n\t\treturn isValid;\n\t} catch (error) {\n\t\tlogger.error('Password verification failed:', error);\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if a password hash needs rehashing for enhanced security\n *\n * USE CASES:\n * - Security parameter upgrades (e.g., increase memory from 64 MB to 128 MB)\n * - Algorithm migration (e.g., future post-quantum algorithms)\n * - Legacy hash format detection\n *\n * QUANTUM MIGRATION:\n * While Argon2id is quantum-resistant, this function will be useful when:\n * - Increasing parameters for high-security applications\n * - Migrating to hybrid classical+post-quantum schemes (2030+)\n * - Detecting legacy hashes that need upgrading\n *\n * @param hashedPassword - The stored password hash\n * @returns Promise<boolean> - True if rehashing is needed\n */\nexport async function needsRehashing(hashedPassword: string): Promise<boolean> {\n\ttry {\n\t\tconst argon2 = await import('argon2');\n\n\t\t// Check if the hash uses our current secure parameters\n\t\t// argon2.needsRehash will return true if the hash doesn't match our current settings\n\t\treturn argon2.needsRehash(hashedPassword, {\n\t\t\tmemoryCost: ARGON2_CONFIG.memory,\n\t\t\ttimeCost: ARGON2_CONFIG.time,\n\t\t\tparallelism: ARGON2_CONFIG.parallelism\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Failed to check if password needs rehashing:', error);\n\t\t// If we can't check, assume it needs rehashing for safety\n\t\treturn true;\n\t}\n}\n\n/**\n * Get the current argon2 configuration for reference\n *\n * SECURITY PARAMETERS:\n * - memory: 65536 KiB (64 MB) - Makes attacks expensive\n * - time: 3 iterations - Computational cost\n * - parallelism: 4 threads - CPU optimization\n * - type: 2 (argon2id) - Hybrid security mode\n *\n * QUANTUM RESISTANCE:\n * These parameters provide strong quantum resistance because:\n * - 64 MB memory requirement limits quantum parallelization\n * - Memory-hard algorithms resist Grover's algorithm\n * - Secure for 15-30+ years against quantum computers\n *\n * FUTURE ENHANCEMENTS (2030+):\n * Consider increasing parameters for ultra-high security:\n * - memory: 131072 KiB (128 MB)\n * - time: 5 iterations\n * This would extend quantum resistance even further.\n *\n * @returns The current secure argon2 configuration\n */\nexport function getPasswordConfig() {\n\treturn { ...ARGON2_CONFIG };\n}\n","/**\n * @file src/routes/api/user/login/+server.ts\n * @description Quantum-resistant user authentication API endpoint.\n *\n * QUANTUM COMPUTING SECURITY:\n * ===========================\n * This endpoint uses quantum-resistant cryptography:\n * - Password verification: Argon2id (memory-hard, resists quantum speedup)\n * - Session tokens: AES-256-GCM (128-bit quantum security)\n * - No public-key crypto: Avoids RSA/ECC vulnerability to Shor's algorithm\n *\n * Security Timeline: Secure against quantum computers for 15-30+ years\n *\n * This endpoint handles user authentication by:\n * - Validating user credentials (email and password) within the scope of the current tenant\n * - Checking if the user account is blocked\n * - Creating a new session tagged with the tenant ID and setting a secure cookie\n *\n * Features:\n * - Quantum-resistant password verification using Argon2id\n * - Safeguard against blocked user login\n * - Prevents already authenticated users from logging in again\n * - Generic error messages prevent user enumeration\n * - Robust error handling and logging\n *\n * @see /docs/architecture/quantum-security.mdx for security details\n */\n\nimport { error, json, type HttpError } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\n\n// Auth\nimport { auth } from '@shared/database/db';\n\n// System logger\nimport { logger } from '@shared/utils/logger.server';\n\n// Password utility\nimport { verifyPassword } from '@shared/utils/password';\n\nexport const POST: RequestHandler = async ({ request, cookies, locals }) => {\n\t// The main try...catch block is for unexpected server errors (e.g., DB connection fails).\n\t// Expected client errors (like 401) are handled by `throw error()`, which SvelteKit catches.\n\ttry {\n\t\tconst { user: existingUser, tenantId } = locals; // Destructure user and tenantId\n\n\t\tif (!auth) {\n\t\t\tlogger.error('Authentication system is not initialized.');\n\t\t\tthrow error(500, 'Internal Server Error: Auth system not initialized');\n\t\t}\n\n\t\t// In multi-tenant mode, a tenantId is required for login.\n\t\tif (getPrivateSettingSync('MULTI_TENANT') && !tenantId) {\n\t\t\tlogger.error('Login attempt failed: Tenant ID is missing in a multi-tenant setup.');\n\t\t\tthrow error(400, 'Could not identify the tenant for this request.');\n\t\t} // Prevent an already authenticated user from trying to log in again.\n\n\t\tif (existingUser) {\n\t\t\tlogger.warn('Authenticated user attempted to log in again.', { userId: existingUser._id });\n\t\t\tthrow error(400, 'You are already authenticated.');\n\t\t}\n\n\t\tconst { email, password } = await request.json();\n\n\t\tif (!email || !password) {\n\t\t\tthrow error(400, 'Email and password are required.');\n\t\t}\n\n\t\t// --- MULTI-TENANCY: Scope user lookup to the current tenant ---\n\t\tconst userLookupCriteria: { email: string; tenantId?: string } = { email };\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tuserLookupCriteria.tenantId = tenantId;\n\t\t}\n\t\tconst user = await auth.getUserByEmail(userLookupCriteria); // **SECURITY**: Use a generic error message for both non-existent users and wrong passwords.\n\t\t// This prevents \"user enumeration\" attacks.\n\n\t\tif (!user || !user.password) {\n\t\t\tlogger.warn(`Login attempt failed: User not found or password not set for email: ${email}`, { tenantId });\n\t\t\tthrow error(401, 'Invalid credentials.');\n\t\t} // **SECURITY**: Check if the user account is blocked.\n\n\t\tif (user.blocked) {\n\t\t\tlogger.warn(`Blocked user attempted to log in: ${email}`, { userId: user._id, tenantId });\n\t\t\tthrow error(403, 'Your account has been suspended. Please contact support.');\n\t\t}\n\n\t\t// QUANTUM-RESISTANT PASSWORD VERIFICATION\n\t\t// Uses Argon2id: Memory-hard algorithm that resists quantum speedup\n\t\t// - 64 MB memory per verification limits quantum parallelization\n\t\t// - Grover's algorithm provides no advantage for memory-bound operations\n\t\t// - Secure against quantum computers for 15-30+ years\n\t\tconst isValidPassword = await verifyPassword(user.password, password);\n\n\t\tif (!isValidPassword) {\n\t\t\tlogger.warn(`Login attempt failed: Invalid password for user: ${email}`, { userId: user._id, tenantId });\n\t\t\tthrow error(401, 'Invalid credentials.');\n\t\t}\n\n\t\t// Credentials are valid, create a session.\n\t\t// The expiration should ideally come from a central config.\n\n\t\tconst session = await auth.createSession({\n\t\t\tuser_id: user._id,\n\t\t\t...(getPrivateSettingSync('MULTI_TENANT') && { tenantId }), // Add tenantId to the session\n\t\t\texpires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() as import('@shared/database/dbInterface').ISODateString // 24-hour session\n\t\t}); // Cache user in session store\n\n\t\tconst sessionCookie = auth.createSessionCookie(session._id);\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tcookies.set(sessionCookie.name, sessionCookie.value, sessionCookie.attributes as any);\n\n\t\tlogger.info(`User logged in successfully: ${user.email}`, { userId: user._id, tenantId });\n\n\t\treturn json({ success: true, message: 'Login successful.' });\n\t} catch (err) {\n\t\t// This block now only catches unexpected errors or deliberate `throw error()` calls.\n\t\tconst httpError = err as HttpError;\n\t\tconst status = httpError.status || 500;\n\t\tconst message = httpError.body?.message || 'An unexpected error occurred during login.'; // We don't log 4xx errors as \"errors\" because they are expected client-side issues.\n\n\t\tif (status >= 500) {\n\t\t\tlogger.error('Internal server error during login:', {\n\t\t\t\terror: message,\n\t\t\t\tstack: err instanceof Error ? err.stack : undefined,\n\t\t\t\tstatus\n\t\t\t});\n\t\t} // Re-throw the error so SvelteKit can format the final response.\n\t\t// Or return a JSON response for API clients.\n\n\t\treturn json({ success: false, message }, { status });\n\t}\n};\n"],"names":["error","logger"],"mappings":";;;;;AAiGA,eAAsB,eAAe,gBAAwB,eAAyC;AACrG,MAAI;AACH,UAAM,SAAS,MAAM,OAAO,QAAQ;AAEpC,UAAM,UAAU,MAAM,OAAO,OAAO,gBAAgB,aAAa;AAEjE,WAAO,MAAM,mCAAmC,EAAE,QAAA,CAAS;AAC3D,WAAO;AAAA,EACR,SAASA,QAAO;AACf,WAAO,MAAM,iCAAiCA,MAAK;AACnD,WAAO;AAAA,EACR;AACD;ACpEO,MAAM,OAAuB,OAAO,EAAE,SAAS,SAAS,aAAa;AAG3E,MAAI;AACH,UAAM,EAAE,MAAM,cAAc,SAAA,IAAa;AAEzC,QAAI,CAAC,MAAM;AACVC,eAAO,MAAM,2CAA2C;AACxD,YAAM,MAAM,KAAK,oDAAoD;AAAA,IACtE;AAGA,QAAI,sBAAsB,cAAc,KAAK,CAAC,UAAU;AACvDA,eAAO,MAAM,qEAAqE;AAClF,YAAM,MAAM,KAAK,iDAAiD;AAAA,IACnE;AAEA,QAAI,cAAc;AACjBA,eAAO,KAAK,iDAAiD,EAAE,QAAQ,aAAa,KAAK;AACzF,YAAM,MAAM,KAAK,gCAAgC;AAAA,IAClD;AAEA,UAAM,EAAE,OAAO,SAAA,IAAa,MAAM,QAAQ,KAAA;AAE1C,QAAI,CAAC,SAAS,CAAC,UAAU;AACxB,YAAM,MAAM,KAAK,kCAAkC;AAAA,IACpD;AAGA,UAAM,qBAA2D,EAAE,MAAA;AACnE,QAAI,sBAAsB,cAAc,GAAG;AAC1C,yBAAmB,WAAW;AAAA,IAC/B;AACA,UAAM,OAAO,MAAM,KAAK,eAAe,kBAAkB;AAGzD,QAAI,CAAC,QAAQ,CAAC,KAAK,UAAU;AAC5BA,eAAO,KAAK,uEAAuE,KAAK,IAAI,EAAE,UAAU;AACxG,YAAM,MAAM,KAAK,sBAAsB;AAAA,IACxC;AAEA,QAAI,KAAK,SAAS;AACjBA,eAAO,KAAK,qCAAqC,KAAK,IAAI,EAAE,QAAQ,KAAK,KAAK,UAAU;AACxF,YAAM,MAAM,KAAK,0DAA0D;AAAA,IAC5E;AAOA,UAAM,kBAAkB,MAAM,eAAe,KAAK,UAAU,QAAQ;AAEpE,QAAI,CAAC,iBAAiB;AACrBA,eAAO,KAAK,oDAAoD,KAAK,IAAI,EAAE,QAAQ,KAAK,KAAK,UAAU;AACvG,YAAM,MAAM,KAAK,sBAAsB;AAAA,IACxC;AAKA,UAAM,UAAU,MAAM,KAAK,cAAc;AAAA,MACxC,SAAS,KAAK;AAAA,MACd,GAAI,sBAAsB,cAAc,KAAK,EAAE,SAAA;AAAA;AAAA,MAC/C,SAAS,IAAI,KAAK,KAAK,IAAA,IAAQ,KAAK,KAAK,KAAK,GAAI,EAAE,YAAA;AAAA;AAAA,IAAY,CAChE;AAED,UAAM,gBAAgB,KAAK,oBAAoB,QAAQ,GAAG;AAE1D,YAAQ,IAAI,cAAc,MAAM,cAAc,OAAO,cAAc,UAAiB;AAEpFA,aAAO,KAAK,gCAAgC,KAAK,KAAK,IAAI,EAAE,QAAQ,KAAK,KAAK,SAAA,CAAU;AAExF,WAAO,KAAK,EAAE,SAAS,MAAM,SAAS,qBAAqB;AAAA,EAC5D,SAAS,KAAK;AAEb,UAAM,YAAY;AAClB,UAAM,SAAS,UAAU,UAAU;AACnC,UAAM,UAAU,UAAU,MAAM,WAAW;AAE3C,QAAI,UAAU,KAAK;AAClBA,eAAO,MAAM,uCAAuC;AAAA,QACnD,OAAO;AAAA,QACP,OAAO,eAAe,QAAQ,IAAI,QAAQ;AAAA,QAC1C;AAAA,MAAA,CACA;AAAA,IACF;AAGA,WAAO,KAAK,EAAE,SAAS,OAAO,WAAW,EAAE,QAAQ;AAAA,EACpD;AACD;"}