{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../../src/routes/api/collections/[collectionId]/import/+server.ts"],"sourcesContent":["/**\n * @file src/routes/api/collections/[collectionId]/import/+server.ts\n * @description API endpoint for importing data into a specific collection\n *\n * Features:\n * - Import data into specific collection\n * - Support for JSON and CSV formats\n * - Data validation and error reporting\n * - Batch processing for large datasets\n * - Permission-based access control\n *\n * Usage:\n * POST /api/collections/{collectionId}/import\n * Body: { data: [...], format: 'json|csv', options: {...} }\n */\n\nimport { error, json } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\n\n// Database adapter\nimport { dbAdapter } from '@shared/database/db';\n\n// Content Management\nimport { contentManager } from '@content/ContentManager';\nimport type { CollectionEntry, Schema } from '@cms-types';\n\n// System Logger\nimport { logger } from '@shared/utils/logger.server';\n\ninterface ImportOptions {\n\toverwrite?: boolean;\n\tvalidate?: boolean;\n\tskipInvalid?: boolean;\n\tbatchSize?: number;\n\tcsvHeaders?: string[];\n\tcsvDelimiter?: string;\n}\n\nexport const POST: RequestHandler = async ({ params, request, locals }) => {\n\tconst startTime = performance.now();\n\tconst { collectionId } = params;\n\n\ttry {\n\t\tif (!locals.user) {\n\t\t\tthrow error(401, 'Unauthorized');\n\t\t}\n\n\t\t// Get collection schema\n\t\tconst schema = await contentManager.getCollection(collectionId);\n\n\t\tif (!schema) {\n\t\t\tthrow error(404, `Collection '${collectionId}' not found`);\n\t\t}\n\n\t\t// Parse request body\n\t\tconst body = await request.json();\n\t\tconst { data, format = 'json', options = {} } = body;\n\n\t\tif (!data) {\n\t\t\tthrow error(400, 'No data provided for import');\n\t\t}\n\n\t\t// Validate and parse options\n\t\tconst importOptions: ImportOptions = {\n\t\t\toverwrite: options.overwrite ?? false,\n\t\t\tvalidate: options.validate ?? true,\n\t\t\tskipInvalid: options.skipInvalid ?? true,\n\t\t\tbatchSize: options.batchSize ?? 100,\n\t\t\tcsvHeaders: options.csvHeaders,\n\t\t\tcsvDelimiter: options.csvDelimiter ?? ','\n\t\t};\n\n\t\tlogger.info(`Starting import into collection ${collectionId}`, {\n\t\t\tuserId: locals.user._id,\n\t\t\tformat,\n\t\t\tdataLength: Array.isArray(data) ? data.length : 'unknown',\n\t\t\toptions: importOptions\n\t\t});\n\n\t\t// Process data based on format\n\t\tlet entries: Record<string, unknown>[];\n\n\t\tif (format === 'csv') {\n\t\t\tentries = parseCSVData(data, importOptions);\n\t\t} else {\n\t\t\tentries = Array.isArray(data) ? data : [data];\n\t\t}\n\n\t\t// Import the entries\n\t\tconst result = await importEntries(`collection_${schema._id}`, entries, schema, importOptions);\n\n\t\tconst duration = performance.now() - startTime;\n\n\t\tlogger.info(`Collection import completed for ${collectionId}`, {\n\t\t\tuserId: locals.user._id,\n\t\t\timported: result.imported,\n\t\t\tskipped: result.skipped,\n\t\t\terrors: result.errors.length,\n\t\t\tduration: `${duration.toFixed(2)}ms`\n\t\t});\n\n\t\treturn json({\n\t\t\tsuccess: result.errors.length === 0 || (result.imported > 0 && importOptions.skipInvalid),\n\t\t\tcollection: collectionId,\n\t\t\timported: result.imported,\n\t\t\tskipped: result.skipped,\n\t\t\terrors: result.errors,\n\t\t\tduration,\n\t\t\tmessage:\n\t\t\t\tresult.errors.length === 0\n\t\t\t\t\t? `Successfully imported ${result.imported} entries`\n\t\t\t\t\t: `Import completed with ${result.errors.length} errors. ${result.imported} entries imported, ${result.skipped} skipped.`\n\t\t});\n\t} catch (err) {\n\t\tconst duration = performance.now() - startTime;\n\t\tconst errorMsg = err instanceof Error ? err.message : 'Unknown error';\n\t\tlogger.error(`Collection import failed for ${collectionId}`, {\n\t\t\tuserId: locals.user?._id,\n\t\t\terror: errorMsg,\n\t\t\tduration: `${duration.toFixed(2)}ms`\n\t\t});\n\n\t\tif (typeof err === 'object' && err !== null && 'status' in err && 'body' in err) {\n\t\t\tthrow err;\n\t\t}\n\n\t\tthrow error(500, `Import failed: ${errorMsg}`);\n\t}\n};\n\n/**\n * Parse CSV data into array of objects\n */\nfunction parseCSVData(csvData: string, options: ImportOptions): CollectionEntry[] {\n\tconst lines = csvData.split('\\n').filter((line) => line.trim());\n\n\tif (lines.length === 0) {\n\t\treturn [];\n\t}\n\n\t// Get headers\n\tconst headers = options.csvHeaders || parseCSVLine(lines[0], options.csvDelimiter);\n\tconst dataStartIndex = options.csvHeaders ? 0 : 1;\n\n\tconst entries = [];\n\n\tfor (let i = dataStartIndex; i < lines.length; i++) {\n\t\tconst values = parseCSVLine(lines[i], options.csvDelimiter);\n\n\t\tif (values.length !== headers.length) {\n\t\t\tlogger.warn(`CSV line ${i + 1} has ${values.length} values but expected ${headers.length}`);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst entry: Record<string, string> = {};\n\t\theaders.forEach((header, index) => {\n\t\t\tentry[header.trim()] = values[index]?.trim() || '';\n\t\t});\n\n\t\tentries.push(entry);\n\t}\n\n\treturn entries;\n}\n\n/**\n * Parse a single CSV line respecting quoted values\n */\nfunction parseCSVLine(line: string, delimiter: string = ','): string[] {\n\tconst values = [];\n\tlet current = '';\n\tlet inQuotes = false;\n\n\tfor (let i = 0; i < line.length; i++) {\n\t\tconst char = line[i];\n\n\t\tif (char === '\"') {\n\t\t\tif (inQuotes && line[i + 1] === '\"') {\n\t\t\t\t// Escaped quote\n\t\t\t\tcurrent += '\"';\n\t\t\t\ti++; // Skip next quote\n\t\t\t} else {\n\t\t\t\t// Toggle quote state\n\t\t\t\tinQuotes = !inQuotes;\n\t\t\t}\n\t\t} else if (char === delimiter && !inQuotes) {\n\t\t\t// Field separator\n\t\t\tvalues.push(current);\n\t\t\tcurrent = '';\n\t\t} else {\n\t\t\tcurrent += char;\n\t\t}\n\t}\n\n\t// Add final value\n\tvalues.push(current);\n\n\treturn values;\n}\n\nasync function importEntries(collectionName: string, entries: CollectionEntry[], schema: Schema, options: ImportOptions) {\n\tconst result: {\n\t\timported: number;\n\t\tskipped: number;\n\t\terrors: Array<{ index: number; error: string; entry: CollectionEntry }>;\n\t} = {\n\t\timported: 0,\n\t\tskipped: 0,\n\t\terrors: []\n\t};\n\n\t// Process entries in batches\n\tconst batchSize = options.batchSize || 100;\n\n\tfor (let i = 0; i < entries.length; i += batchSize) {\n\t\tconst batch = entries.slice(i, i + batchSize);\n\n\t\tfor (let j = 0; j < batch.length; j++) {\n\t\t\tconst entry = batch[j];\n\t\t\tconst entryIndex = i + j;\n\n\t\t\ttry {\n\t\t\t\t// Validate entry if validation is enabled\n\t\t\t\tif (options.validate) {\n\t\t\t\t\tconst validationResult = validateEntry(entry, schema);\n\t\t\t\t\tif (!validationResult.isValid) {\n\t\t\t\t\t\tif (options.skipInvalid) {\n\t\t\t\t\t\t\tresult.skipped++;\n\t\t\t\t\t\t\tlogger.debug(`Skipped invalid entry at index ${entryIndex}`, {\n\t\t\t\t\t\t\t\tcollection: collectionName,\n\t\t\t\t\t\t\t\terrors: validationResult.errors\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.errors.push({\n\t\t\t\t\t\t\t\tindex: entryIndex,\n\t\t\t\t\t\t\t\terror: `Validation failed: ${validationResult.errors.join(', ')}`,\n\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prepare entry data\n\t\t\t\tconst entryData = {\n\t\t\t\t\t...entry,\n\t\t\t\t\t// Remove potential conflicting fields\n\t\t\t\t\t_id: undefined,\n\t\t\t\t\t__v: undefined,\n\t\t\t\t\t// Ensure metadata\n\t\t\t\t\tcreatedAt: entry.createdAt || new Date().toISOString(),\n\t\t\t\t\tupdatedAt: new Date().toISOString(),\n\t\t\t\t\tstatus: entry.status || 'draft'\n\t\t\t\t};\n\n\t\t\t\t// Check for existing entry\n\t\t\t\tif (!dbAdapter) {\n\t\t\t\t\tthrow new Error('Database adapter not initialized');\n\t\t\t\t}\n\n\t\t\t\tlet existingEntry = null;\n\t\t\t\tif (entry._id || entry.id) {\n\t\t\t\t\tconst searchId = entry._id || entry.id;\n\t\t\t\t\tconst searchResult = await dbAdapter.crud.findOne(collectionName, {\n\t\t\t\t\t\t_id: searchId\n\t\t\t\t\t} as any);\n\t\t\t\t\tif (searchResult.success && searchResult.data) {\n\t\t\t\t\t\texistingEntry = searchResult.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle existing entries\n\t\t\t\tif (existingEntry) {\n\t\t\t\t\tif (options.overwrite) {\n\t\t\t\t\t\tconst updateResult = await dbAdapter.crud.update(collectionName, existingEntry._id, entryData);\n\n\t\t\t\t\t\tif (updateResult.success) {\n\t\t\t\t\t\t\tresult.imported++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.errors.push({\n\t\t\t\t\t\t\t\tindex: entryIndex,\n\t\t\t\t\t\t\t\terror: `Failed to update: ${updateResult.error}`,\n\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.skipped++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Create new entry - omit system fields that are auto-generated\n\t\t\t\t\tconst { _id, createdAt, updatedAt, ...insertData } = entryData;\n\t\t\t\t\tconst createResult = await dbAdapter.crud.insert(collectionName, insertData as any);\n\n\t\t\t\t\tif (createResult.success) {\n\t\t\t\t\t\tresult.imported++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.errors.push({\n\t\t\t\t\t\t\tindex: entryIndex,\n\t\t\t\t\t\t\terror: `Failed to create: ${createResult.error}`,\n\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (entryError) {\n\t\t\t\tresult.errors.push({\n\t\t\t\t\tindex: entryIndex,\n\t\t\t\t\terror: entryError instanceof Error ? entryError.message : 'Unknown error',\n\t\t\t\t\tentry\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Validate entry against schema\n */\nfunction validateEntry(entry: CollectionEntry, schema: Schema): { isValid: boolean; errors: string[] } {\n\tconst errors: string[] = [];\n\n\tif (!entry || typeof entry !== 'object') {\n\t\terrors.push('Entry must be an object');\n\t\treturn { isValid: false, errors };\n\t}\n\n\t// Check required fields\n\tif (schema.fields) {\n\t\tfor (const field of schema.fields) {\n\t\t\t// Handle both FieldInstance and WidgetPlaceholder types\n\t\t\tconst fieldDef = typeof field === 'object' && field !== null && 'db_fieldName' in field ? field : null;\n\t\t\tif (fieldDef && 'required' in fieldDef && fieldDef.required && 'db_fieldName' in fieldDef) {\n\t\t\t\tconst fieldName = String(fieldDef.db_fieldName);\n\t\t\t\tif (!entry[fieldName]) {\n\t\t\t\t\tconst label = 'label' in fieldDef ? fieldDef.label : fieldName;\n\t\t\t\t\terrors.push(`Required field '${label || fieldName}' is missing`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tisValid: errors.length === 0,\n\t\terrors\n\t};\n}\n"],"names":[],"mappings":"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"}