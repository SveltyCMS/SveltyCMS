{"version":3,"file":"state.js","sources":["../../../../../../shared/stores/src/system/config.ts","../../../../../../shared/stores/src/system/metrics.ts","../../../../../../shared/stores/src/system/state.ts"],"sourcesContent":["/**\n * @file src/stores/system/config.ts\n * @description Configuration and initial state for the system state machine.\n */\n\nimport type { ServicePerformanceMetrics, SystemStateStore, AnomalyThresholds } from './types';\n\n// --- Core Constants ---\nexport const DEFAULT_SYSTEM_READY_TIMEOUT = 10000; // 10 seconds\nexport const CALIBRATION_CHECK_INTERVAL = 10; // Calibrate after every 10 health checks\nexport const MAX_STATE_TRANSITIONS_TO_KEEP = 50; // Max history for state transitions\n\n// --- Service Baseline Performance ---\n// Used for intelligent timeout calculations on first run.\nexport const SERVICE_BASELINE_TIMES = {\n\tdatabase: 500, // DB connection is usually fast\n\tauth: 50, // Auth initialization is nearly instant\n\tcache: 200, // Cache/media setup\n\tcontentManager: 300, // Content loading\n\tthemeManager: 200, // Theme loading\n\twidgets: 150 // Widget store initialization\n} as const;\n\n// --- Default Anomaly Thresholds ---\n// These are the initial values before self-calibration kicks in.\nexport const DEFAULT_ANOMALY_THRESHOLDS: AnomalyThresholds = {\n\tmaxStartupTime: 5000, // 5 seconds default\n\tmaxShutdownTime: 2000, // 2 seconds default\n\tmaxConsecutiveFailures: 3,\n\tminUptimePercentage: 95,\n\tcalibrationCount: 0\n};\n\n// --- Initial State Objects ---\n\n// Initial metrics for a new service.\nexport const initialServiceMetrics: ServicePerformanceMetrics = {\n\thealthCheckCount: 0,\n\tfailureCount: 0,\n\trestartCount: 0,\n\tconsecutiveFailures: 0,\n\tuptimePercentage: 100,\n\tstateTimings: {\n\t\tstartup: { count: 0, trend: 'unknown' },\n\t\tshutdown: { count: 0, trend: 'unknown' },\n\t\tidle: { count: 0, totalTime: 0 },\n\t\tactive: { count: 0, totalTime: 0 }\n\t},\n\tanomalyThresholds: { ...DEFAULT_ANOMALY_THRESHOLDS }\n};\n\n// Initial state for the entire system store.\nexport const initialState: SystemStateStore = {\n\toverallState: 'IDLE',\n\tservices: {\n\t\tdatabase: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tauth: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tcache: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tcontentManager: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\tthemeManager: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) },\n\t\twidgets: { status: 'initializing', message: 'Not initialized', metrics: structuredClone(initialServiceMetrics) }\n\t},\n\tperformanceMetrics: {\n\t\ttotalInitializations: 0,\n\t\tsuccessfulInitializations: 0,\n\t\tfailedInitializations: 0,\n\t\tstateTransitions: []\n\t}\n};\n","/**\n * @file src/stores/system/metrics.ts\n * @description Performance metrics, anomaly detection, and reporting for the system state.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type { Writable } from 'svelte/store';\nimport type { SystemStateStore, ServiceHealth, AnomalyDetection, ServiceName } from './types';\n\n/**\n * Track state timing (startup/shutdown) and update metrics\n */\nexport function trackStateTransition(\n\tserviceName: keyof SystemStateStore['services'],\n\tfromState: ServiceHealth,\n\ttoState: ServiceHealth,\n\tduration: number,\n\tstore: Writable<SystemStateStore>\n): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst stateTimings = { ...service.metrics.stateTimings };\n\n\t\t// Track startup (initializing ‚Üí healthy)\n\t\tif (fromState === 'initializing' && toState === 'healthy') {\n\t\t\tconst startup = { ...stateTimings.startup };\n\t\t\tstartup.count++;\n\t\t\tstartup.lastTime = duration;\n\n\t\t\t// Update statistics\n\t\t\tif (!startup.avgTime) {\n\t\t\t\tstartup.avgTime = duration;\n\t\t\t\tstartup.minTime = duration;\n\t\t\t\tstartup.maxTime = duration;\n\t\t\t} else {\n\t\t\t\tconst prevAvg = startup.avgTime;\n\t\t\t\tstartup.avgTime = (startup.avgTime * (startup.count - 1) + duration) / startup.count;\n\t\t\t\tstartup.minTime = Math.min(startup.minTime ?? duration, duration);\n\t\t\t\tstartup.maxTime = Math.max(startup.maxTime ?? duration, duration);\n\n\t\t\t\t// Determine trend (comparing to previous average)\n\t\t\t\tif (duration < prevAvg * 0.9) {\n\t\t\t\t\tstartup.trend = 'improving';\n\t\t\t\t} else if (duration > prevAvg * 1.1) {\n\t\t\t\t\tstartup.trend = 'degrading';\n\t\t\t\t} else {\n\t\t\t\t\tstartup.trend = 'stable';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstateTimings.startup = startup;\n\t\t}\n\n\t\t// Track shutdown (healthy ‚Üí unhealthy or healthy ‚Üí idle)\n\t\tif (fromState === 'healthy' && (toState === 'unhealthy' || toState === 'initializing')) {\n\t\t\tconst shutdown = { ...stateTimings.shutdown };\n\t\t\tshutdown.count++;\n\t\t\tshutdown.lastTime = duration;\n\n\t\t\tif (!shutdown.avgTime) {\n\t\t\t\tshutdown.avgTime = duration;\n\t\t\t\tshutdown.minTime = duration;\n\t\t\t\tshutdown.maxTime = duration;\n\t\t\t} else {\n\t\t\t\tconst prevAvg = shutdown.avgTime;\n\t\t\t\tshutdown.avgTime = (shutdown.avgTime * (shutdown.count - 1) + duration) / shutdown.count;\n\t\t\t\tshutdown.minTime = Math.min(shutdown.minTime ?? duration, duration);\n\t\t\t\tshutdown.maxTime = Math.max(shutdown.maxTime ?? duration, duration);\n\n\t\t\t\t// Determine trend\n\t\t\t\tif (duration < prevAvg * 0.9) {\n\t\t\t\t\tshutdown.trend = 'improving';\n\t\t\t\t} else if (duration > prevAvg * 1.1) {\n\t\t\t\t\tshutdown.trend = 'degrading';\n\t\t\t\t} else {\n\t\t\t\t\tshutdown.trend = 'stable';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstateTimings.shutdown = shutdown;\n\t\t}\n\n\t\tservice.metrics.stateTimings = stateTimings;\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Self-calibrate anomaly thresholds based on historical performance\n */\nexport function calibrateAnomalyThresholds(serviceName: keyof SystemStateStore['services'], store: Writable<SystemStateStore>): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst metrics = service.metrics;\n\t\tconst thresholds = { ...metrics.anomalyThresholds };\n\n\t\t// Only calibrate if we have enough data (at least 5 startups)\n\t\tif (metrics.stateTimings.startup.count < 5) {\n\t\t\tlogger.debug(`Skipping calibration for ${String(serviceName)} - insufficient data (${metrics.stateTimings.startup.count} startups)`);\n\t\t\treturn current;\n\t\t}\n\n\t\t// Calibrate startup threshold (use 3x average or 1.5x max, whichever is larger)\n\t\tif (metrics.stateTimings.startup.avgTime && metrics.stateTimings.startup.maxTime) {\n\t\t\tconst avgBased = metrics.stateTimings.startup.avgTime * 3;\n\t\t\tconst maxBased = metrics.stateTimings.startup.maxTime * 1.5;\n\t\t\tthresholds.maxStartupTime = Math.max(avgBased, maxBased);\n\t\t}\n\n\t\t// Calibrate shutdown threshold\n\t\tif (metrics.stateTimings.shutdown.avgTime && metrics.stateTimings.shutdown.maxTime) {\n\t\t\tconst avgBased = metrics.stateTimings.shutdown.avgTime * 3;\n\t\t\tconst maxBased = metrics.stateTimings.shutdown.maxTime * 1.5;\n\t\t\tthresholds.maxShutdownTime = Math.max(avgBased, maxBased);\n\t\t}\n\n\t\t// Calibrate failure threshold based on reliability\n\t\tif (metrics.uptimePercentage > 99) {\n\t\t\tthresholds.maxConsecutiveFailures = 2; // Stricter for highly reliable services\n\t\t} else if (metrics.uptimePercentage > 95) {\n\t\t\tthresholds.maxConsecutiveFailures = 3;\n\t\t} else {\n\t\t\tthresholds.maxConsecutiveFailures = 5; // More lenient for less reliable services\n\t\t}\n\n\t\t// Adjust uptime threshold based on historical performance\n\t\tconst actualUptime = metrics.uptimePercentage;\n\t\tif (actualUptime > 99) {\n\t\t\tthresholds.minUptimePercentage = 98; // Expect high reliability to continue\n\t\t} else if (actualUptime > 95) {\n\t\t\tthresholds.minUptimePercentage = 90; // More realistic expectations\n\t\t} else {\n\t\t\tthresholds.minUptimePercentage = 80; // Lower bar for struggling services\n\t\t}\n\n\t\tthresholds.lastCalibrated = Date.now();\n\t\tthresholds.calibrationCount++;\n\n\t\tservice.metrics.anomalyThresholds = thresholds;\n\n\t\tlogger.info(`üéØ Calibrated anomaly thresholds for ${String(serviceName)}`, {\n\t\t\tmaxStartup: `${thresholds.maxStartupTime.toFixed(0)}ms`,\n\t\t\tmaxShutdown: `${thresholds.maxShutdownTime.toFixed(0)}ms`,\n\t\t\tmaxFailures: thresholds.maxConsecutiveFailures,\n\t\t\tminUptime: `${thresholds.minUptimePercentage}%`,\n\t\t\tcalibrationCount: thresholds.calibrationCount\n\t\t});\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Detect anomalies and notify if something is wrong\n */\nexport function detectAnomalies(serviceName: keyof SystemStateStore['services'], state: SystemStateStore): AnomalyDetection[] {\n\tconst service = state.services[serviceName];\n\tconst metrics = service.metrics;\n\tconst thresholds = metrics.anomalyThresholds;\n\tconst anomalies: AnomalyDetection[] = [];\n\n\t// Check startup time\n\tif (metrics.stateTimings.startup.lastTime && metrics.stateTimings.startup.lastTime > thresholds.maxStartupTime) {\n\t\tconst excessPercent = (metrics.stateTimings.startup.lastTime / thresholds.maxStartupTime - 1) * 100;\n\t\tanomalies.push({\n\t\t\ttype: 'slow_startup',\n\t\t\tseverity: excessPercent > 100 ? 'critical' : excessPercent > 50 ? 'high' : 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} startup is slower than expected`,\n\t\t\tdetails: {\n\t\t\t\tactual: `${metrics.stateTimings.startup.lastTime.toFixed(0)}ms`,\n\t\t\t\tthreshold: `${thresholds.maxStartupTime.toFixed(0)}ms`,\n\t\t\t\texcess: `${excessPercent.toFixed(0)}%`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check shutdown time\n\tif (metrics.stateTimings.shutdown.lastTime && metrics.stateTimings.shutdown.lastTime > thresholds.maxShutdownTime) {\n\t\tanomalies.push({\n\t\t\ttype: 'slow_shutdown',\n\t\t\tseverity: 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} shutdown is slower than expected`,\n\t\t\tdetails: {\n\t\t\t\tactual: `${metrics.stateTimings.shutdown.lastTime.toFixed(0)}ms`,\n\t\t\t\tthreshold: `${thresholds.maxShutdownTime.toFixed(0)}ms`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check consecutive failures\n\tif (metrics.consecutiveFailures >= thresholds.maxConsecutiveFailures) {\n\t\tanomalies.push({\n\t\t\ttype: 'consecutive_failures',\n\t\t\tseverity: metrics.consecutiveFailures >= thresholds.maxConsecutiveFailures * 2 ? 'critical' : 'high',\n\t\t\tmessage: `Service ${String(serviceName)} has ${metrics.consecutiveFailures} consecutive failures`,\n\t\t\tdetails: {\n\t\t\t\tfailures: metrics.consecutiveFailures,\n\t\t\t\tthreshold: thresholds.maxConsecutiveFailures.toString()\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check uptime percentage\n\tif (metrics.uptimePercentage < thresholds.minUptimePercentage) {\n\t\tanomalies.push({\n\t\t\ttype: 'low_uptime',\n\t\t\tseverity: metrics.uptimePercentage < thresholds.minUptimePercentage * 0.8 ? 'high' : 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} uptime is below threshold`,\n\t\t\tdetails: {\n\t\t\t\tuptime: `${metrics.uptimePercentage.toFixed(1)}%`,\n\t\t\t\tthreshold: `${thresholds.minUptimePercentage}%`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check performance trend\n\tif (metrics.stateTimings.startup.trend === 'degrading' && metrics.stateTimings.startup.count > 10) {\n\t\tanomalies.push({\n\t\t\ttype: 'degrading_performance',\n\t\t\tseverity: 'medium',\n\t\t\tmessage: `Service ${String(serviceName)} performance is degrading over time`,\n\t\t\tdetails: {\n\t\t\t\ttrend: metrics.stateTimings.startup.trend,\n\t\t\t\tavgTime: `${metrics.stateTimings.startup.avgTime?.toFixed(0)}ms`,\n\t\t\t\tlastTime: `${metrics.stateTimings.startup.lastTime?.toFixed(0)}ms`\n\t\t\t}\n\t\t});\n\t}\n\n\t// Log anomalies\n\tif (anomalies.length > 0) {\n\t\tanomalies.forEach((anomaly) => {\n\t\t\tif (anomaly.severity === 'critical' || anomaly.severity === 'high') {\n\t\t\t\tlogger.error(`üö® ${anomaly.message}`, anomaly.details);\n\t\t\t} else {\n\t\t\t\tlogger.warn(`‚ö†Ô∏è ${anomaly.message}`, anomaly.details);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn anomalies;\n}\n\n/**\n * Update uptime percentage based on health checks\n */\nexport function updateUptimeMetrics(serviceName: ServiceName, store: Writable<SystemStateStore>): void {\n\tstore.update((current) => {\n\t\tconst service = { ...current.services[serviceName] };\n\t\tconst metrics = service.metrics;\n\n\t\t// Calculate uptime percentage\n\t\tif (metrics.healthCheckCount > 0) {\n\t\t\tconst healthyChecks = metrics.healthCheckCount - metrics.failureCount;\n\t\t\tmetrics.uptimePercentage = (healthyChecks / metrics.healthCheckCount) * 100;\n\t\t}\n\n\t\tservice.metrics = metrics;\n\n\t\treturn {\n\t\t\t...current,\n\t\t\tservices: {\n\t\t\t\t...current.services,\n\t\t\t\t[serviceName]: service\n\t\t\t}\n\t\t};\n\t});\n}\n","/**\n * @file src/stores/system/state.ts\n * @description Core state management for the SveltyCMS system.\n */\n\nimport { writable, derived, get } from 'svelte/store';\nimport type { Writable, Readable } from 'svelte/store';\nimport { logger } from '@shared/utils/logger';\nimport type { SystemStateStore, SystemState, ServiceHealth, ServiceStatus, ServicePerformanceMetrics, ServiceName } from './types';\nimport { initialState } from './config';\nimport { updateUptimeMetrics, trackStateTransition, calibrateAnomalyThresholds, detectAnomalies } from './metrics';\n\n// Create the writable store\nexport const systemStateStore: Writable<SystemStateStore> = writable(initialState);\n\n/**\n * Centralized helper for transitioning a service's state and updating metrics.\n * This reduces code duplication and ensures consistent state transitions.\n */\nfunction transitionServiceState(\n\tstate: SystemStateStore,\n\tserviceName: keyof SystemStateStore['services'],\n\tnewStatus: ServiceHealth,\n\tmessage: string,\n\terror?: string\n): SystemStateStore {\n\tconst now = Date.now();\n\tconst service = state.services[serviceName];\n\tconst metrics: ServicePerformanceMetrics = { ...service.metrics };\n\n\t// Track initialization completion\n\tif (newStatus === 'healthy' && service.status === 'initializing' && metrics.initializationStartedAt) {\n\t\tconst duration = now - metrics.initializationStartedAt;\n\t\tmetrics.initializationCompletedAt = now;\n\t\tmetrics.initializationDuration = duration;\n\n\t\t// Update running statistics with EMA (Exponential Moving Average)\n\t\tconst alpha = 2 / (metrics.healthCheckCount + 1); // Smoothing factor\n\t\tif (!metrics.averageInitTime) {\n\t\t\tmetrics.averageInitTime = duration;\n\t\t\tmetrics.minInitTime = duration;\n\t\t\tmetrics.maxInitTime = duration;\n\t\t} else {\n\t\t\tmetrics.averageInitTime = alpha * duration + (1 - alpha) * metrics.averageInitTime;\n\t\t\tmetrics.minInitTime = Math.min(metrics.minInitTime ?? duration, duration);\n\t\t\tmetrics.maxInitTime = Math.max(metrics.maxInitTime ?? duration, duration);\n\t\t}\n\n\t\tlogger.info(`‚úì Service ${serviceName} initialized in ${duration}ms`, {\n\t\t\taverage: metrics.averageInitTime.toFixed(2),\n\t\t\tmin: metrics.minInitTime,\n\t\t\tmax: metrics.maxInitTime\n\t\t});\n\n\t\tmetrics.consecutiveFailures = 0;\n\t}\n\n\t// Track failures - increment on every unhealthy status\n\tif (newStatus === 'unhealthy') {\n\t\tmetrics.consecutiveFailures++;\n\t\tmetrics.failureCount++;\n\n\t\t// Log only on transition to unhealthy\n\t\tif (service.status !== 'unhealthy') {\n\t\t\tmetrics.lastFailureAt = now;\n\t\t\tlogger.warn(`Service ${serviceName} became unhealthy (failure #${metrics.failureCount}, consecutive: ${metrics.consecutiveFailures})`, {\n\t\t\t\terror\n\t\t\t});\n\t\t}\n\t}\n\n\t// Track recovery\n\tif (newStatus === 'healthy' && service.status === 'unhealthy') {\n\t\tlogger.info(`‚úì Service ${serviceName} recovered from failure`);\n\t\tmetrics.consecutiveFailures = 0;\n\t}\n\n\t// Update health check timestamp\n\tmetrics.healthCheckCount++;\n\tmetrics.lastHealthCheckAt = now;\n\n\tconst updatedState: SystemStateStore = {\n\t\t...state,\n\t\tservices: {\n\t\t\t...state.services,\n\t\t\t[serviceName]: {\n\t\t\t\tstatus: newStatus,\n\t\t\t\tmessage,\n\t\t\t\tlastChecked: now,\n\t\t\t\t...(error && { error }),\n\t\t\t\tmetrics\n\t\t\t}\n\t\t},\n\t\tlastStateChange: now\n\t};\n\n\t// Derive the new overall system state from the updated service statuses\n\tconst derivedState = deriveOverallState(updatedState.services);\n\tupdatedState.overallState = derivedState;\n\n\t// Track successful initialization if state auto-derived to READY from INITIALIZING\n\tif (derivedState === 'READY' && state.overallState === 'INITIALIZING' && state.performanceMetrics.totalInitializations > 0) {\n\t\tconst duration = state.initializationStartedAt ? now - state.initializationStartedAt : 0;\n\t\tupdatedState.performanceMetrics = {\n\t\t\t...state.performanceMetrics,\n\t\t\tsuccessfulInitializations: state.performanceMetrics.successfulInitializations + 1,\n\t\t\tlastInitDuration: duration\n\t\t};\n\t\tlogger.info(`‚úì System auto-transitioned to READY (initialization completed in ${duration}ms)`);\n\t}\n\n\treturn updatedState;\n}\n\n/**\n * Start tracking initialization for a service\n */\nexport function startServiceInitialization(serviceName: keyof SystemStateStore['services']): void {\n\tconst now = Date.now();\n\tsystemStateStore.update((state) => {\n\t\tconst service = state.services[serviceName];\n\t\treturn {\n\t\t\t...state,\n\t\t\tservices: {\n\t\t\t\t...state.services,\n\t\t\t\t[serviceName]: {\n\t\t\t\t\t...service,\n\t\t\t\t\tstatus: 'initializing' as ServiceHealth,\n\t\t\t\t\tmetrics: {\n\t\t\t\t\t\t...service.metrics,\n\t\t\t\t\t\tinitializationStartedAt: now,\n\t\t\t\t\t\trestartCount: service.metrics.restartCount + (service.metrics.initializationStartedAt ? 1 : 0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * Update a specific service's health status with performance tracking\n */\nexport function updateServiceHealth(serviceName: keyof SystemStateStore['services'], status: ServiceHealth, message: string, error?: string): void {\n\t// Use the centralized transition helper\n\tsystemStateStore.update((state) => transitionServiceState(state, serviceName, status, message, error));\n\n\t// --- Post-transition side effects ---\n\n\t// Update uptime metrics after state change\n\tupdateUptimeMetrics(serviceName, systemStateStore);\n\n\t// Track state transition timing if status changed\n\tconst updatedService = getSystemState().services[serviceName];\n\tif (status === 'healthy' && updatedService.metrics.initializationDuration) {\n\t\tconst duration = updatedService.metrics.initializationDuration;\n\t\ttrackStateTransition(serviceName, 'initializing', 'healthy', duration, systemStateStore);\n\t}\n\n\t// Auto-calibrate thresholds periodically (every 10 health checks)\n\tconst currentMetrics = updatedService.metrics;\n\tif (currentMetrics.healthCheckCount > 0 && currentMetrics.healthCheckCount % 10 === 0) {\n\t\tcalibrateAnomalyThresholds(serviceName, systemStateStore);\n\t}\n\n\t// Detect and report anomalies\n\tconst anomalies = detectAnomalies(serviceName, getSystemState());\n\n\t// You can integrate with notification system here\n\tif (anomalies.length > 0 && anomalies.some((a) => a.severity === 'critical' || a.severity === 'high')) {\n\t\t// TODO: Integrate with notification system (email, Slack, etc.)\n\t\tlogger.error(`üö® ${anomalies.length} anomal${anomalies.length > 1 ? 'ies' : 'y'} detected for ${serviceName}`);\n\t}\n}\n\n/**\n * Set the overall system state with transition tracking\n */\nexport function setSystemState(state: SystemState, reason?: string): void {\n\tconst now = Date.now();\n\n\tsystemStateStore.update((current) => {\n\t\tconst transition = {\n\t\t\tfrom: current.overallState,\n\t\t\tto: state,\n\t\t\ttimestamp: now,\n\t\t\t...(reason && { reason })\n\t\t};\n\n\t\t// Keep last 50 transitions for analysis\n\t\tconst stateTransitions = [...current.performanceMetrics.stateTransitions, transition].slice(-50);\n\n\t\t// Track initialization metrics\n\t\tconst performanceMetrics = { ...current.performanceMetrics, stateTransitions };\n\n\t\tif (state === 'INITIALIZING' && current.overallState !== 'INITIALIZING') {\n\t\t\tperformanceMetrics.totalInitializations++;\n\t\t}\n\n\t\tif (state === 'READY' && current.overallState !== 'READY' && performanceMetrics.totalInitializations > 0) {\n\t\t\tconst duration = current.initializationStartedAt ? now - current.initializationStartedAt : 0;\n\t\t\tperformanceMetrics.successfulInitializations++;\n\t\t\tperformanceMetrics.lastInitDuration = duration;\n\n\t\t\t// Update running statistics\n\t\t\tif (!performanceMetrics.averageTotalInitTime) {\n\t\t\t\tperformanceMetrics.averageTotalInitTime = duration;\n\t\t\t\tperformanceMetrics.minTotalInitTime = duration;\n\t\t\t\tperformanceMetrics.maxTotalInitTime = duration;\n\t\t\t} else {\n\t\t\t\tconst count = performanceMetrics.successfulInitializations;\n\t\t\t\tperformanceMetrics.averageTotalInitTime = (performanceMetrics.averageTotalInitTime * (count - 1) + duration) / count;\n\t\t\t\tperformanceMetrics.minTotalInitTime = Math.min(performanceMetrics.minTotalInitTime ?? duration, duration);\n\t\t\t\tperformanceMetrics.maxTotalInitTime = Math.max(performanceMetrics.maxTotalInitTime ?? duration, duration);\n\t\t\t}\n\n\t\t\tlogger.info(`üöÄ System initialization completed in ${duration}ms`, {\n\t\t\t\taverage: performanceMetrics.averageTotalInitTime.toFixed(2),\n\t\t\t\tmin: performanceMetrics.minTotalInitTime,\n\t\t\t\tmax: performanceMetrics.maxTotalInitTime,\n\t\t\t\tsuccessRate: `${((performanceMetrics.successfulInitializations / performanceMetrics.totalInitializations) * 100).toFixed(1)}%`\n\t\t\t});\n\t\t}\n\n\t\tif (state === 'FAILED' && current.overallState === 'INITIALIZING') {\n\t\t\tperformanceMetrics.failedInitializations++;\n\t\t}\n\n\t\tlogger.info(`System state changed: ${current.overallState} ‚Üí ${state}`, { reason });\n\n\t\treturn {\n\t\t\t...current,\n\t\t\toverallState: state,\n\t\t\tlastStateChange: now,\n\t\t\tperformanceMetrics,\n\t\t\t...(state === 'INITIALIZING' && { initializationStartedAt: now }),\n\t\t\t...(state === 'READY' && current.initializationStartedAt && { initializationCompletedAt: now })\n\t\t};\n\t});\n}\n\n// Derive overall system state from individual service statuses\nfunction deriveOverallState(services: SystemStateStore['services']): SystemState {\n\tconst criticalServices = ['database', 'auth'] as const;\n\tconst nonCriticalServices = ['cache', 'contentManager', 'themeManager'] as const;\n\n\t// Check if any critical service is unhealthy\n\tconst criticalUnhealthy = criticalServices.some((service) => services[service].status === 'unhealthy');\n\tif (criticalUnhealthy) {\n\t\treturn 'FAILED';\n\t}\n\n\t// Check if any critical service is still initializing\n\tconst criticalInitializing = criticalServices.some((service) => services[service].status === 'initializing');\n\tif (criticalInitializing) {\n\t\treturn 'INITIALIZING';\n\t}\n\n\t// Check if any non-critical service is unhealthy\n\tconst nonCriticalUnhealthy = nonCriticalServices.some((service) => services[service].status === 'unhealthy');\n\tif (nonCriticalUnhealthy) {\n\t\treturn 'DEGRADED';\n\t}\n\n\t// All critical services are healthy\n\treturn 'READY';\n}\n\n// Get the current system state (synchronous)\nexport function getSystemState(): SystemStateStore {\n\treturn get(systemStateStore);\n}\n\n// Check if the system is ready (synchronous)\nexport function isSystemReady(): boolean {\n\tconst state = getSystemState();\n\treturn state.overallState === 'READY' || state.overallState === 'DEGRADED';\n}\n\n// Check if a specific service is healthy (synchronous)\nexport function isServiceHealthy(serviceName: ServiceName): boolean {\n\tconst state = getSystemState();\n\treturn state.services[serviceName].status === 'healthy';\n}\n\n// Reset system state to IDLE (used for shutdown or reinitialization)\nexport function resetSystemState(): void {\n\tlogger.info('Resetting system state to IDLE');\n\tsystemStateStore.set({\n\t\t...structuredClone(initialState),\n\t\tlastStateChange: Date.now()\n\t});\n}\n\n// Get a readable store for the system state (for Svelte components)\nexport const systemState: Readable<SystemStateStore> = derived(systemStateStore, ($state) => $state);\n\n// Get a readable store for just the overall state (for simple checks)\nexport const overallState: Readable<SystemState> = derived(systemStateStore, ($state) => $state.overallState);\n\n// --- Granular Derived Stores for Improved Reactivity ---\n\n/**\n * A derived store that returns true if the system is in a ready or degraded state.\n * Ideal for use in UI components to show/hide content based on system readiness.\n */\nexport const isReady: Readable<boolean> = derived(overallState, ($s) => $s === 'READY' || $s === 'DEGRADED');\n\n/**\n * A derived store that returns true if the system is currently initializing.\n */\nexport const isInitializing: Readable<boolean> = derived(overallState, ($s) => $s === 'INITIALIZING');\n\n/**\n * A derived store that returns true if the system has failed.\n */\nexport const isFailed: Readable<boolean> = derived(overallState, ($s) => $s === 'FAILED');\n\n/**\n * A derived store that returns true if the system is in a degraded state.\n */\nexport const isDegraded: Readable<boolean> = derived(overallState, ($s) => $s === 'DEGRADED');\n\n/**\n * A derived store containing the status of all individual services.\n */\nexport const servicesStatus: Readable<SystemStateStore['services']> = derived(systemState, ($s) => $s.services);\n\n/**\n * Individual derived stores for each service's status.\n * This allows components to subscribe to only the service they care about.\n */\nexport const databaseStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.database);\nexport const authStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.auth);\nexport const cacheStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.cache);\nexport const contentManagerStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.contentManager);\nexport const themeManagerStatus: Readable<ServiceStatus> = derived(servicesStatus, ($s) => $s.themeManager);\n"],"names":[],"mappings":"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"}