{"version":3,"file":"db.js","sources":["../../../../../../shared/database/src/auth/constants.ts","../../../../../../shared/database/src/auth/index.ts","../../../../../../shared/database/src/auth/sessionManager.ts","../../../../../../shared/database/src/db.ts"],"sourcesContent":["/**\n * @file src/databases/auth/constants.ts\n * @description Authentication constants that are safe to import on both client and server\n *\n * This file contains constants that don't depend on server-side modules\n * and can be safely imported in client-side code.\n */\n\nexport const SESSION_COOKIE_NAME = 'auth_sessions';\n\nexport function generateRandomToken(length: number = 32): string {\n\tconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\tlet result = '';\n\tfor (let i = 0; i < length; i++) {\n\t\tresult += chars.charAt(Math.floor(Math.random() * chars.length));\n\t}\n\treturn result;\n}\n\nexport function generateTokenWithExpiry(expirationMinutes: number = 60): { token: string; expires: Date } {\n\treturn {\n\t\ttoken: generateRandomToken(),\n\t\texpires: new Date(Date.now() + expirationMinutes * 60 * 1000)\n\t};\n}\n","/**\n * @file src/databases/auth/index.ts\n * @description Quantum-resistant authentication and authorization system with multi-tenant support.\n *\n * QUANTUM COMPUTING SECURITY:\n * ===========================\n * This authentication system is designed for quantum resistance:\n * - Argon2id password hashing (memory-hard, quantum-resistant)\n * - AES-256-GCM session encryption (128-bit quantum security)\n * - No RSA/ECC public-key cryptography (vulnerable to Shor's algorithm)\n * - Secure for 15-30+ years against quantum computers\n *\n * This consolidated module handles:\n * - User authentication and session management, scoped by tenant\n * - Role-based access control with admin override\n * - Permission checking with simplified logic\n * - Token management, scoped by tenant\n *\n * @see /docs/architecture/quantum-security.mdx for detailed security analysis\n */\n\nimport { dev } from '$app/environment';\nimport { error } from '@sveltejs/kit';\n\nimport type { DatabaseAdapter, DatabaseResult } from '@shared/database/dbInterface';\nimport type { ISODateString } from '@cms-types/content';\nimport type { Permission, Role, Session, SessionStore, Token, User } from './types';\n\nimport { corePermissions } from './corePermissions';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\nimport { dateToISODateString } from '@shared/utils/dateUtils';\n\n// Import global settings service for DB-based configuration\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\n\nexport {\n\tcheckPermissions,\n\tgetRolePermissionsWithRoles as checkRolePermissions,\n\tgetAllPermissions,\n\tgetPermissionById,\n\tgetPermissionConfig,\n\thasPermissionWithRoles as hasPermission,\n\thasPermissionByAction,\n\tisAdminRoleWithRoles,\n\tpermissionConfigs,\n\tpermissions,\n\tregisterPermission,\n\tvalidateUserPermission\n} from './permissions';\n\n// Note: TOTP functions are server-only and should be imported from './totp' directly\n// to avoid bundling Node.js crypto module in client-side code.\n// Use: import { generateTOTPSecret, ... } from '@shared/database/auth/totp';\n\n// Note: TwoFactorAuthService is server-only and should be imported from './twoFactorAuth' directly\n// to avoid bundling Node.js crypto module in client-side code.\n// Use: import { TwoFactorAuthService, ... } from '@shared/database/auth/twoFactorAuth';\n\nexport type { TwoFactorSetupResponse, TwoFactorVerificationResult } from './twoFactorAuthTypes';\n\nexport type { Permission, PermissionAction, PermissionType, Role, RolePermissions, Session, SessionStore, Token, User } from './types';\n\n// Export safe constants\nexport { generateRandomToken, generateTokenWithExpiry, SESSION_COOKIE_NAME } from './constants';\n\n// Import for internal use\nimport { SESSION_COOKIE_NAME } from './constants';\n\n// Import shared crypto utilities with Argon2\nimport { hashPassword as cryptoHashPassword, verifyPassword as cryptoVerifyPassword } from '@shared/utils/crypto';\n\n// Import caching\nimport { cacheService } from '@shared/database/CacheService';\n\n// Main Auth class\nexport class Auth {\n\tprivate db: DatabaseAdapter;\n\tprivate sessionStore: SessionStore;\n\tprivate permissions: Permission[] = [...corePermissions];\n\n\tconstructor(db: DatabaseAdapter, sessionStore: SessionStore) {\n\t\tthis.db = db;\n\t\tthis.sessionStore = sessionStore;\n\t}\n\n\tpublic get authInterface(): DatabaseAdapter['auth'] {\n\t\treturn this.db.auth;\n\t}\n\n\t// Combined Performance-Optimized Methods (wrapper for db.auth methods)\n\tasync createUserAndSession(\n\t\tuserData: Partial<User>,\n\t\tsessionData: { expires: ISODateString; tenantId?: string }\n\t): Promise<DatabaseResult<{ user: User; session: Session }>> {\n\t\treturn this.db.auth.createUserAndSession(userData, sessionData);\n\t}\n\n\tasync deleteUserAndSessions(user_id: string, tenantId?: string): Promise<DatabaseResult<{ deletedUser: boolean; deletedSessionCount: number }>> {\n\t\treturn this.db.auth.deleteUserAndSessions(user_id, tenantId);\n\t}\n\n\tasync blockUsers(userIds: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\treturn this.db.auth.blockUsers(userIds, tenantId);\n\t}\n\n\tasync unblockUsers(userIds: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\treturn this.db.auth.unblockUsers(userIds, tenantId);\n\t}\n\n\t// Permission management\n\n\tgetPermissions(): Permission[] {\n\t\treturn this.permissions;\n\t}\n\n\taddPermission(permission: Permission): void {\n\t\tconst exists = this.permissions.some((p) => p._id === permission._id);\n\t\tif (!exists) {\n\t\t\tthis.permissions.push(permission);\n\t\t}\n\t}\n\n\t// User management\n\n\tasync createUser(userData: Partial<User>, oauth: boolean = false): Promise<User> {\n\t\ttry {\n\t\t\tconst { email, password, tenantId } = userData;\n\n\t\t\tif (!email || (!oauth && !password)) {\n\t\t\t\tthrow error(400, 'Email and password are required');\n\t\t\t}\n\n\t\t\tif (getPrivateSettingSync('MULTI_TENANT') && !tenantId) {\n\t\t\t\tthrow error(400, 'Tenant ID is required in multi-tenant mode');\n\t\t\t}\n\n\t\t\tconst normalizedEmail = email.toLowerCase();\n\t\t\tlet hashedPassword: string | undefined;\n\t\t\tif (!oauth && password) {\n\t\t\t\thashedPassword = await cryptoHashPassword(password);\n\t\t\t}\n\n\t\t\tconst result = await this.db.auth.createUser({ ...userData, email: normalizedEmail, password: hashedPassword });\n\t\t\tif (!result || !result.success || !result.data || !result.data._id) {\n\t\t\t\tthrow error(500, 'User creation failed');\n\t\t\t}\n\t\t\treturn result.data;\n\t\t} catch (err) {\n\t\t\tconst errMsg = err instanceof Error ? err.message : String(err);\n\t\t\tthrow error(500, `Failed to create user: ${errMsg}`);\n\t\t}\n\t}\n\n\tasync getUserById(user_id: string, tenantId?: string): Promise<User | null> {\n\t\t// No caching - getUserById is fast enough and avoids cache invalidation complexity\n\t\t// Session cache already stores user data for authenticated requests\n\t\tconst result = (await this.db.auth.getUserById(user_id, tenantId)) as unknown;\n\t\tif (result && typeof result === 'object' && result !== null && 'success' in (result as Record<string, unknown>)) {\n\t\t\tconst r = result as DatabaseResult<User | null>;\n\t\t\tif (r.success && r.data) {\n\t\t\t\treturn r.data;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn (result as User | null) ?? null;\n\t}\n\tasync getUserByEmail(criteria: { email: string; tenantId?: string }): Promise<User | null> {\n\t\t// No caching - getUserByEmail is only used during login/registration\n\t\t// Caching here adds complexity without significant performance benefit\n\t\tconst result = (await this.db.auth.getUserByEmail(criteria)) as unknown;\n\n\t\tif (result && typeof result === 'object' && result !== null && 'success' in (result as Record<string, unknown>)) {\n\t\t\tconst r = result as DatabaseResult<User | null>;\n\n\t\t\tif (r.success === true) {\n\t\t\t\tconst userData = 'data' in r ? (r as { data: User | null }).data : null;\n\t\t\t\t// No caching - not needed for login/registration flows\n\t\t\t\treturn userData ?? null;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn (result as User | null) ?? null;\n\t}\n\tasync updateUser(userId: string, updates: Partial<User>, tenantId?: string): Promise<void> {\n\t\tconst result = await this.db.auth.updateUserAttributes(userId, updates, tenantId);\n\t\tif (!result || !result.success) {\n\t\t\tthrow error(500, 'Failed to update user');\n\t\t}\n\n\t\t// No cache invalidation needed - we removed user-by-id and user-by-email caching\n\t\t// Session cache is the only cache, and it's invalidated by updateUserAttributes API\n\t}\n\n\tasync deleteUser(user_id: string, tenantId?: string): Promise<void> {\n\t\t// Get user first to clear email cache\n\t\tconst user = await this.getUserById(user_id, tenantId);\n\n\t\tconst result = await this.db.auth.deleteUser(user_id, tenantId);\n\t\tif (!result || !result.success) {\n\t\t\tthrow error(500, 'Failed to delete user');\n\t\t}\n\n\t\t// Invalidate all caches for this user\n\t\tconst cacheKey = `user:id:${user_id}`;\n\t\tawait cacheService.delete(cacheKey, tenantId);\n\n\t\tif (user?.email) {\n\t\t\tconst emailCacheKey = `user:email:${user.email.toLowerCase()}`;\n\t\t\tawait cacheService.delete(emailCacheKey, tenantId);\n\t\t}\n\t}\n\tasync getAllUsers(options?: { filter?: { tenantId?: string } }): Promise<User[]> {\n\t\tconst result = await this.db.auth.getAllUsers(options);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\treturn [];\n\t}\n\n\tasync getUserCount(filter?: { tenantId?: string }): Promise<number> {\n\t\tconst result = await this.db.auth.getUserCount(filter);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tasync createSession(sessionData: { user_id: string; expires: ISODateString; tenantId?: string }): Promise<Session> {\n\t\tconst sr = (await this.db.auth.createSession(sessionData)) as unknown;\n\t\tlet session: Session | null = null;\n\t\tif (sr && typeof sr === 'object' && sr !== null && 'success' in (sr as Record<string, unknown>)) {\n\t\t\tconst sessionResult = sr as DatabaseResult<Session>;\n\t\t\tif (!sessionResult || !sessionResult.success) {\n\t\t\t\tthrow error(500, 'Session creation failed');\n\t\t\t}\n\t\t\tsession = sessionResult.data;\n\t\t} else {\n\t\t\tsession = sr as Session;\n\t\t}\n\n\t\tif (!session) throw error(500, 'Session creation failed');\n\n\t\tconst ur = (await this.db.auth.getUserById(sessionData.user_id, sessionData.tenantId)) as unknown;\n\t\tlet user: User | null = null;\n\t\tif (ur && typeof ur === 'object' && ur !== null && 'success' in (ur as Record<string, unknown>)) {\n\t\t\tconst userResult = ur as DatabaseResult<User | null>;\n\t\t\tif (userResult && userResult.success && userResult.data) {\n\t\t\t\tuser = userResult.data;\n\t\t\t}\n\t\t} else {\n\t\t\tuser = (ur as User) ?? null;\n\t\t}\n\n\t\tif (!user) {\n\t\t\tthrow error(404, `User not found for ID: ${sessionData.user_id}`);\n\t\t}\n\n\t\tawait this.sessionStore.set(session._id, user, sessionData.expires);\n\t\treturn session;\n\t}\n\n\tasync validateSession(session_id: string): Promise<User | null> {\n\t\tconst result = await this.db.auth.validateSession(session_id);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync destroySession(session_id: string): Promise<void> {\n\t\tawait this.db.auth.deleteSession(session_id);\n\t\tawait this.sessionStore.delete(session_id);\n\t}\n\n\tasync getSessionTokenData(session_id: string): Promise<{ expiresAt: ISODateString; user_id: string } | null> {\n\t\tconst result = await this.db.auth.getSessionTokenData(session_id);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync rotateToken(oldToken: string, expires: ISODateString): Promise<string> {\n\t\tif (!this.db.auth.rotateToken) throw error(500, 'Token rotation not supported');\n\t\tconst result = await this.db.auth.rotateToken(oldToken, expires);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\tthrow error(500, 'Token rotation failed');\n\t}\n\n\tasync getAllRoles(tenantId?: string): Promise<Role[]> {\n\t\treturn this.db.auth.getAllRoles(tenantId);\n\t}\n\n\tasync getAllTokens(filter?: { tenantId?: string }): Promise<DatabaseResult<Token[]>> {\n\t\tconst result = await this.db.auth.getAllTokens(filter);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Create a token for a user.\n\t * @param tokenData - Token creation data including user_id, expires, type, and optional tenantId\n\t * @returns The created token string\n\t */\n\tasync createToken(tokenData: { user_id: string; expires: ISODateString; type: string; tenantId?: string }): Promise<string> {\n\t\t// Get user email (required for token creation)\n\t\tconst user = await this.getUserById(tokenData.user_id, tokenData.tenantId);\n\t\tif (!user) throw new Error('User not found');\n\n\t\tconst result = await this.db.auth.createToken({\n\t\t\tuser_id: tokenData.user_id,\n\t\t\temail: user.email.toLowerCase(),\n\t\t\texpires: tokenData.expires,\n\t\t\ttype: tokenData.type,\n\t\t\ttenantId: tokenData.tenantId\n\t\t});\n\n\t\tif (typeof result === 'string') return result;\n\t\tif (result && result.success && typeof result.data === 'string') return result.data;\n\t\tif (result && !result.success && result.error?.message) throw new Error(result.error.message);\n\t\tthrow new Error('Failed to create token');\n\t}\n\n\t// Token management wrappers for interface completeness\n\tasync updateToken(token_id: string, tokenData: Partial<Token>, tenantId?: string): Promise<Token> {\n\t\tconst result = await this.db.auth.updateToken(token_id, tokenData, tenantId);\n\t\tif (result && result.success) return result.data;\n\t\tthrow error(500, !result || result.success ? 'Failed to update token' : result.message || 'Failed to update token');\n\t}\n\n\tasync deleteTokens(token_ids: string[], tenantId?: string): Promise<{ deletedCount: number }> {\n\t\tconst result = await this.db.auth.deleteTokens(token_ids, tenantId);\n\t\tif (result && result.success) return result.data;\n\t\tthrow error(500, !result || result.success ? 'Failed to delete tokens' : result.message || 'Failed to delete tokens');\n\t}\n\n\tasync blockTokens(token_ids: string[], tenantId?: string): Promise<{ modifiedCount: number }> {\n\t\tconst result = await this.db.auth.blockTokens(token_ids, tenantId);\n\t\tif (result && result.success) return result.data;\n\t\tthrow error(500, !result || result.success ? 'Failed to block tokens' : result.message || 'Failed to block tokens');\n\t}\n\n\tasync unblockTokens(token_ids: string[], tenantId?: string): Promise<{ modifiedCount: number }> {\n\t\tconst result = await this.db.auth.unblockTokens(token_ids, tenantId);\n\t\tif (result && result.success) return result.data;\n\t\tthrow error(500, !result || result.success ? 'Failed to unblock tokens' : result.message || 'Failed to unblock tokens');\n\t}\n\n\tasync getTokenByValue(token: string, tenantId?: string): Promise<Token | null> {\n\t\tconst result = await this.db.auth.getTokenByValue(token, tenantId);\n\t\tif (result && result.success) return result.data;\n\t\tthrow error(500, !result || result.success ? 'Failed to get token' : result.message || 'Failed to get token');\n\t}\n\n\tasync validateToken(token: string, user_id?: string, type: string = 'access', tenantId?: string): Promise<{ success: boolean; message: string }> {\n\t\tconst result = await this.db.auth.validateToken(token, user_id, type, tenantId);\n\t\tif (result && result.success && result.data) {\n\t\t\treturn { success: true, message: result.data.message ?? 'Token validated' };\n\t\t}\n\t\treturn { success: false, message: !result || result.success ? 'Token validation failed' : result.message || 'Token validation failed' };\n\t}\n\n\tasync validateRegistrationToken(token: string, tenantId?: string): Promise<{ isValid: boolean; message: string; details?: Token }> {\n\t\tconst result = await this.db.auth.validateToken(token, undefined, 'user-invite', tenantId);\n\t\tif (result && result.success && result.data) {\n\t\t\tconst tokenResult = await this.db.auth.getTokenByValue(token, tenantId);\n\t\t\tconst tokenDoc = tokenResult && tokenResult.success ? tokenResult.data : null;\n\t\t\treturn { isValid: true, message: result.data.message, details: tokenDoc ?? undefined };\n\t\t} else {\n\t\t\treturn { isValid: false, message: !result || result.success ? 'Token validation failed' : result.message || 'Token validation failed' };\n\t\t}\n\t}\n\n\tasync consumeToken(token: string, user_id?: string, type: string = 'access', tenantId?: string): Promise<{ status: boolean; message: string }> {\n\t\tconst result = await this.db.auth.consumeToken(token, user_id, type, tenantId);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\treturn { status: false, message: !result || result.success ? 'Failed to consume token' : result.message || 'Failed to consume token' };\n\t}\n\n\tasync consumeRegistrationToken(token: string, tenantId?: string): Promise<{ status: boolean; message: string }> {\n\t\tconst result = await this.db.auth.consumeToken(token, undefined, 'user-invite', tenantId);\n\t\tif (result && result.success && result.data) {\n\t\t\treturn result.data;\n\t\t} else {\n\t\t\treturn { status: false, message: !result || result.success ? 'Failed to consume token' : result.message || 'Failed to consume token' };\n\t\t}\n\t}\n\n\tasync authenticate(email: string, password: string, tenantId?: string): Promise<{ user: User; sessionId: string } | null> {\n\t\ttry {\n\t\t\tconst user = await this.getUserByEmail({ email, tenantId });\n\t\t\tif (!user) {\n\t\t\t\tlogger.debug('User not found for authentication', { email, tenantId });\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!user.password) {\n\t\t\t\tlogger.debug('User has no password field', { email, tenantId, userId: user._id });\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst isValid = await cryptoVerifyPassword(password, user.password);\n\n\t\t\tlogger.debug('Password verification result', { email, isValid });\n\n\t\t\tif (!isValid) {\n\t\t\t\tlogger.warn('Password authentication failed', { email });\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst expiresAt = dateToISODateString(new Date(Date.now() + 24 * 60 * 60 * 1000)); // 24 hours\n\t\t\tconst session = await this.createSession({ user_id: user._id, expires: expiresAt, tenantId });\n\n\t\t\tawait this.sessionStore.set(session._id, user, expiresAt);\n\n\t\t\treturn { user, sessionId: session._id };\n\t\t} catch (err) {\n\t\t\tlogger.error(`Authentication error: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync logOut(session_id: string): Promise<void> {\n\t\tawait this.destroySession(session_id);\n\t}\n\n\tasync checkUser(fields: { user_id?: string; email?: string; tenantId?: string }): Promise<User | null> {\n\t\tif (fields.email) {\n\t\t\tconst result = await this.db.auth.getUserByEmail({ email: fields.email, tenantId: fields.tenantId });\n\t\t\tif (result && result.success) {\n\t\t\t\treturn result.data;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else if (fields.user_id) {\n\t\t\tconst result = await this.db.auth.getUserById(fields.user_id, fields.tenantId);\n\t\t\tif (result && result.success) {\n\t\t\t\treturn result.data;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync updateUserAttributes(user_id: string, attributes: Partial<User>, tenantId?: string): Promise<User> {\n\t\tif (attributes.password && typeof window === 'undefined') {\n\t\t\tattributes.password = await cryptoHashPassword(attributes.password);\n\t\t}\n\t\tif (attributes.email === null) {\n\t\t\tattributes.email = undefined;\n\t\t}\n\t\tconst result = await this.db.auth.updateUserAttributes(user_id, attributes, tenantId);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\tthrow error(500, 'Failed to update user attributes');\n\t}\n\n\tcreateSessionCookie(sessionId: string): { name: string; value: string; attributes: unknown } {\n\t\treturn {\n\t\t\tname: SESSION_COOKIE_NAME,\n\t\t\tvalue: sessionId,\n\t\t\tattributes: {\n\t\t\t\thttpOnly: true,\n\t\t\t\tsecure: !dev,\n\t\t\t\tsameSite: 'strict',\n\t\t\t\tmaxAge: 24 * 60 * 60,\n\t\t\t\tpath: '/'\n\t\t\t}\n\t\t};\n\t}\n\n\tasync invalidateAllUserSessions(user_id: string, tenantId?: string): Promise<void> {\n\t\tawait this.db.auth.invalidateAllUserSessions(user_id, tenantId);\n\t}\n\n\tasync getActiveSessions(user_id: string, tenantId?: string): Promise<{ success: boolean; data: Session[]; message?: string }> {\n\t\ttry {\n\t\t\tconst result = await this.db.auth.getActiveSessions(user_id, tenantId);\n\t\t\tif (result && result.success) {\n\t\t\t\treturn { success: true, data: result.data };\n\t\t\t}\n\t\t\treturn { success: false, data: [], message: 'Failed to retrieve active sessions' };\n\t\t} catch (err) {\n\t\t\tlogger.error(`Error getting active sessions: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn { success: false, data: [], message: err instanceof Error ? err.message : 'Unknown error' };\n\t\t}\n\t}\n\n\tasync getAllActiveSessions(tenantId?: string): Promise<{ success: boolean; data: Session[]; message?: string }> {\n\t\ttry {\n\t\t\tconst result = await this.db.auth.getAllActiveSessions(tenantId);\n\t\t\tif (result && result.success) {\n\t\t\t\treturn { success: true, data: result.data };\n\t\t\t}\n\t\t\treturn { success: false, data: [], message: 'Failed to retrieve all active sessions' };\n\t\t} catch (err) {\n\t\t\tlogger.error(`Error getting all active sessions: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn { success: false, data: [], message: err instanceof Error ? err.message : 'Unknown error' };\n\t\t}\n\t}\n\n\tasync updateUserPassword(email: string, password: string, tenantId?: string): Promise<{ status: boolean; message?: string }> {\n\t\tconst user = await this.getUserByEmail({ email, tenantId });\n\t\tif (!user) {\n\t\t\treturn { status: false, message: 'User not found' };\n\t\t}\n\t\tconst hashedPassword = await cryptoHashPassword(password);\n\t\tawait this.updateUser(user._id, { password: hashedPassword }, tenantId);\n\t\treturn { status: true };\n\t}\n}\n\n// Utility functions for backwards compatibility and convenience\n// All password operations use quantum-resistant Argon2id\n\n/**\n * Hash a password using quantum-resistant Argon2id\n *\n * SECURITY: Uses Argon2id with memory-hard properties that resist quantum speedup\n * @param password - Plain text password to hash\n * @returns Promise resolving to hashed password\n */\nexport async function hashPassword(password: string): Promise<string> {\n\treturn cryptoHashPassword(password);\n}\n\n/**\n * Verify password against hash using constant-time comparison\n *\n * SECURITY: Timing-safe verification prevents side-channel attacks\n * @param password - Plain text password to verify\n * @param hash - Hashed password to compare against\n * @returns Promise resolving to true if password matches\n */\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n\treturn cryptoVerifyPassword(password, hash);\n}\n","/**\n * @file src/databases/auth/sessionCleanup.ts\n * @description Session persistence management\n *\n * This module provides a unified session management system that works with both Redis and in-memory storage.\n *\n * Multi-Tenancy Note:\n * This session store is a generic key-value store where the key is a globally unique session ID.\n * It is inherently multi-tenant safe because the data it stores (the User object) contains the\n * tenantId. The responsibility for checking the tenantId of the retrieved user lies with the\n * calling code (e.g., the server hooks).\n *\n * Key features:\n * - Automatic fallback from Redis to in-memory storage\n * - Simple interface for session management\n * - Compatible with the new simplified auth system\n */\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Auth\nimport type { User, ISODateString } from '@shared/database/dbInterface';\nimport { isoDateStringToDate } from '@shared/utils/dateUtils';\nimport type { SessionStore } from './types';\n\n// Redis client interface to avoid direct dependency on a specific Redis library\ninterface RedisLike {\n\tget(key: string): Promise<string | null>;\n\tsetex(key: string, seconds: number, value: string): Promise<void>;\n\tdel(...keys: string[]): Promise<number>;\n\tkeys(pattern: string): Promise<string[]>;\n\tquit?(): Promise<void>;\n}\n\n// In-memory session storage as fallback\nclass InMemorySessionManager implements SessionStore {\n\tprivate sessions: Map<string, { user: User; expiresAt: Date }> = new Map();\n\n\tasync get(session_id: string): Promise<User | null> {\n\t\tconst session = this.sessions.get(session_id);\n\t\tif (!session) return null; // Check if session has expired\n\n\t\tif (new Date() > session.expiresAt) {\n\t\t\tthis.sessions.delete(session_id);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn session.user;\n\t}\n\n\tasync set(session_id: string, user: User, expiration: ISODateString): Promise<void> {\n\t\tconst expirationDate = isoDateStringToDate(expiration);\n\t\tthis.sessions.set(session_id, { user, expiresAt: expirationDate });\n\t}\n\n\tasync delete(session_id: string): Promise<void> {\n\t\tthis.sessions.delete(session_id);\n\t}\n\n\tasync deletePattern(pattern: string): Promise<number> {\n\t\tlet deletedCount = 0;\n\t\tconst regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n\n\t\tfor (const [sessionId] of this.sessions) {\n\t\t\tif (regex.test(sessionId)) {\n\t\t\t\tthis.sessions.delete(sessionId);\n\t\t\t\tdeletedCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn deletedCount;\n\t}\n\n\tasync validateWithDB(session_id: string, dbValidationFn: (session_id: string) => Promise<User | null>): Promise<User | null> {\n\t\t// For in-memory store, check memory first, then validate with DB if not found\n\t\tconst memoryUser = await this.get(session_id);\n\t\tif (memoryUser) {\n\t\t\treturn memoryUser;\n\t\t}\n\n\t\t// If not in memory, try DB validation\n\t\tconst dbUser = await dbValidationFn(session_id);\n\t\tif (dbUser) {\n\t\t\t// Cache the user in memory for future access (assuming 1 hour expiration)\n\t\t\tconst expiration = new Date(Date.now() + 60 * 60 * 1000).toISOString() as ISODateString;\n\t\t\tawait this.set(session_id, dbUser, expiration);\n\t\t}\n\t\treturn dbUser;\n\t}\n\n\tasync close(): Promise<void> {\n\t\tthis.sessions.clear();\n\t} // Cleanup expired sessions\n\n\tcleanup(): void {\n\t\tconst now = new Date();\n\t\tfor (const [sessionId, session] of this.sessions) {\n\t\t\tif (now > session.expiresAt) {\n\t\t\t\tthis.sessions.delete(sessionId);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Redis session manager (optional)\nclass RedisSessionManager implements SessionStore {\n\tprivate redisClient: RedisLike | null;\n\tprivate fallbackManager: InMemorySessionManager;\n\n\tconstructor(redisClient?: RedisLike) {\n\t\tthis.redisClient = redisClient || null;\n\t\tthis.fallbackManager = new InMemorySessionManager();\n\t}\n\n\tasync get(session_id: string): Promise<User | null> {\n\t\ttry {\n\t\t\tif (this.redisClient) {\n\t\t\t\tconst sessionData = await this.redisClient.get(session_id);\n\t\t\t\tif (sessionData) {\n\t\t\t\t\tconst parsed = JSON.parse(sessionData); // Check expiration\n\t\t\t\t\tif (new Date() > new Date(parsed.expiresAt)) {\n\t\t\t\t\t\tawait this.redisClient.del(session_id);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn parsed.user;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Redis session get failed, falling back to memory: ${err instanceof Error ? err.message : String(err)}`);\n\t\t} // Fallback to in-memory manager\n\n\t\treturn await this.fallbackManager.get(session_id);\n\t}\n\n\tasync set(session_id: string, user: User, expiration: ISODateString): Promise<void> {\n\t\tconst expirationDate = isoDateStringToDate(expiration);\n\t\tconst sessionData = { user, expiresAt: expirationDate };\n\n\t\ttry {\n\t\t\tif (this.redisClient) {\n\t\t\t\tconst ttlSeconds = Math.floor((expirationDate.getTime() - Date.now()) / 1000);\n\t\t\t\tif (ttlSeconds > 0) {\n\t\t\t\t\tawait this.redisClient.setex(session_id, ttlSeconds, JSON.stringify(sessionData));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Redis session set failed, falling back to memory: ${err instanceof Error ? err.message : String(err)}`);\n\t\t} // Fallback to in-memory manager\n\n\t\tawait this.fallbackManager.set(session_id, user, expiration);\n\t}\n\n\tasync delete(session_id: string): Promise<void> {\n\t\ttry {\n\t\t\tif (this.redisClient) {\n\t\t\t\tawait this.redisClient.del(session_id);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Redis session delete failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t} // Also delete from fallback manager\n\n\t\tawait this.fallbackManager.delete(session_id);\n\t}\n\n\tasync deletePattern(pattern: string): Promise<number> {\n\t\tlet deletedCount = 0;\n\n\t\ttry {\n\t\t\tif (this.redisClient) {\n\t\t\t\tconst keys = await this.redisClient.keys(pattern);\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tdeletedCount = await this.redisClient.del(...keys);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Redis pattern delete failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t} // Also delete from fallback manager\n\n\t\tconst fallbackDeleted = await this.fallbackManager.deletePattern(pattern);\n\t\treturn deletedCount + fallbackDeleted;\n\t}\n\n\tasync close(): Promise<void> {\n\t\ttry {\n\t\t\tif (this.redisClient && typeof this.redisClient.quit === 'function') {\n\t\t\t\tawait this.redisClient.quit();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(`Redis close failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t}\n\n\t\tawait this.fallbackManager.close();\n\t}\n\n\tasync validateWithDB(session_id: string, dbValidationFn: (session_id: string) => Promise<User | null>): Promise<User | null> {\n\t\t// Try to get from Redis/memory first\n\t\tconst cachedUser = await this.get(session_id);\n\t\tif (cachedUser) {\n\t\t\treturn cachedUser;\n\t\t}\n\n\t\t// If not cached, validate with database\n\t\tconst dbUser = await dbValidationFn(session_id);\n\t\tif (dbUser) {\n\t\t\t// Cache the validated user (assuming 1 hour expiration)\n\t\t\tconst expiration = new Date(Date.now() + 60 * 60 * 1000).toISOString() as ISODateString;\n\t\t\tawait this.set(session_id, dbUser, expiration);\n\t\t}\n\t\treturn dbUser;\n\t}\n}\n\n// Factory function to create the appropriate session manager\nexport function createSessionManager(redisClient?: RedisLike): SessionStore {\n\tif (redisClient) {\n\t\tlogger.info('Creating Redis session manager with in-memory fallback');\n\t\treturn new RedisSessionManager(redisClient);\n\t} else {\n\t\tlogger.info('Creating in-memory session manager');\n\t\treturn new InMemorySessionManager();\n\t}\n}\n\n// Export the manager classes for direct use if needed\nexport { InMemorySessionManager, RedisSessionManager };\n\n// Legacy aliases for backward compatibility\nexport { InMemorySessionManager as InMemorySessionStore, RedisSessionManager as RedisSessionStore };\n\n// Default session manager instance\nlet defaultManager: SessionStore | null = null;\n\nexport function getDefaultSessionManager(): SessionStore {\n\tif (!defaultManager) {\n\t\tdefaultManager = createSessionManager();\n\t}\n\treturn defaultManager;\n}\n\nexport function setDefaultSessionManager(manager: SessionStore): void {\n\tdefaultManager = manager;\n}\n\n// Legacy aliases for backward compatibility\nexport const getDefaultSessionStore = getDefaultSessionManager;\nexport const setDefaultSessionStore = setDefaultSessionManager;\n\n// Session cleanup utility\nexport function startSessionCleanup(manager: SessionStore, intervalMs: number = 60000): NodeJS.Timeout {\n\treturn setInterval(() => {\n\t\tif (manager instanceof InMemorySessionManager) {\n\t\t\tmanager.cleanup();\n\t\t} // Redis handles TTL automatically, so no cleanup needed\n\t}, intervalMs);\n}\n","/**\n * @file src/databases/db.ts\n * @description\n * Database and authentication initialization and management module.\n *\n * This module is responsible for:\n * - Loading and initializing database and authentication adapters based on the configured DB_TYPE\n * - Establishing database connections with a retry mechanism\n * - Managing initialization of authentication models, media models, and collection models\n * - Setting up default roles and permissions\n * Multi-Tenancy Note:\n * This file handles the one-time global startup of the server. Tenant-specific\n * data scoping is handled by the API endpoints and server hooks that use the\n * initialized services from this module.\n */\n\nimport { building, browser } from '$app/environment';\n\n// Handle private config that might not exist during setup\nlet privateEnv: InferOutput<typeof privateConfigSchema> | null = null;\n\n// Function to load private config when needed (SERVER-ONLY)\nasync function loadPrivateConfig(forceReload = false) {\n\t// CRITICAL: Never run in browser - this function uses Node.js APIs\n\tif (browser) {\n\t\treturn null;\n\t}\n\n\tif (privateEnv && !forceReload) return privateEnv;\n\n\ttry {\n\t\tlogger.debug('Loading @config/private configuration...');\n\t\tlet module;\n\n\t\t// Check if running in test mode via environment variable\n\t\tconst isTestMode = typeof process !== 'undefined' && process.env?.TEST_MODE;\n\n\t\tif (isTestMode) {\n\t\t\tconst pathUtil = await import('path');\n\t\t\tlet workspaceRoot = process.cwd();\n\t\t\tif (\n\t\t\t\tworkspaceRoot.endsWith('apps/setup') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/setup/') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/cms') ||\n\t\t\t\tworkspaceRoot.endsWith('apps/cms/')\n\t\t\t) {\n\t\t\t\tworkspaceRoot = pathUtil.resolve(workspaceRoot, '../../');\n\t\t\t}\n\t\t\tconst configPath = pathUtil.resolve(workspaceRoot, 'config/private.test.ts');\n\t\t\tmodule = await import(/* @vite-ignore */ configPath);\n\t\t} else {\n\t\t\tmodule = await import('@config/private');\n\t\t}\n\n\t\tprivateEnv = module.privateEnv;\n\t\tlogger.debug('Private config loaded successfully', {\n\t\t\thasConfig: !!privateEnv,\n\t\t\tdbType: privateEnv?.DB_TYPE,\n\t\t\tdbHost: privateEnv?.DB_HOST ? '***' : 'missing'\n\t\t});\n\t\treturn privateEnv;\n\t} catch (error) {\n\t\t// Private config doesn't exist during setup - this is expected\n\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t});\n\t\treturn null;\n\t}\n}\n// Function to clear private config cache (used after setup completion)\nexport function clearPrivateConfigCache(keepPrivateEnv = false) {\n\tlogger.debug('Clearing private config cache and initialization promises', {\n\t\tkeepPrivateEnv,\n\t\thadPrivateEnv: !!privateEnv\n\t});\n\tif (!keepPrivateEnv) {\n\t\tprivateEnv = null;\n\t}\n\tadaptersLoaded = false;\n\t_dbInitPromise = null;\n\tinitializationPromise = null;\n\tlogger.debug('Private config cache and initialization promises cleared', {\n\t\tprivateEnvCleared: !keepPrivateEnv\n\t});\n}\n\n// Auth\nimport { Auth } from '@shared/database/auth';\nimport { getDefaultSessionStore } from '@shared/database/auth/sessionManager';\n// Adapters Interfaces\nimport type { DatabaseAdapter } from './dbInterface';\n\n// Settings loader\nimport { privateConfigSchema, publicConfigSchema } from '@shared/database/schemas';\nimport { invalidateSettingsCache, setSettingsCache, getPublicSetting } from '@shared/services/settingsService';\nimport { safeParse, type InferOutput } from 'valibot';\n\n// Type definition for private config schema\n\n// Theme\nimport { DEFAULT_THEME, ThemeManager } from '@shared/database/themeManager';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// System State Management\n// Using dynamic imports to break circular dependency while still updating actual system state\nlet _systemStateModule: typeof import('@shared/stores/system') | null = null;\n\nasync function loadSystemStateModule() {\n\tif (!_systemStateModule) {\n\t\t_systemStateModule = await import('@shared/stores/system');\n\t}\n\treturn _systemStateModule;\n}\n\nconst setSystemState = async (status: string, message: string) => {\n\tlogger.debug(`[SystemState] ${status}: ${message}`);\n\ttry {\n\t\tconst mod = await loadSystemStateModule();\n\t\tmod.setSystemState(status as any, message);\n\t} catch (err) {\n\t\tlogger.warn('Failed to update system state:', err);\n\t}\n};\n\nconst updateServiceHealth = async (service: string, status: string, message?: string, error?: string) => {\n\tlogger.debug(`[ServiceHealth] ${service} ${status}: ${message}`);\n\ttry {\n\t\tconst mod = await loadSystemStateModule();\n\t\tmod.updateServiceHealth(service as any, status as any, message || '', error);\n\t} catch (err) {\n\t\tlogger.warn('Failed to update service health:', err);\n\t}\n};\n\nconst waitForServiceHealthy = async () => true;\n\n// Widget Store - Dynamic import to avoid circular dependency\n// import { widgetStoreActions } from '@shared/stores/widgetStore.svelte';\n\n// State Variables\nexport let dbAdapter: DatabaseAdapter | null = null; // Database adapter\n\nexport let auth: Auth | null = null; // Authentication instance\nexport let isConnected = false; // Database connection state (primarily for external checks if needed)\nlet isInitialized = false; // Initialization state\nlet initializationPromise: Promise<void> | null = null; // Initialization promise\n\n/**\n * Get the in-memory private config if available.\n * Returns null if config hasn't been loaded yet (e.g., during setup).\n * Used by settingsService to avoid filesystem imports when config is already in memory.\n */\nexport function getPrivateEnv(): InferOutput<typeof privateConfigSchema> | null {\n\treturn privateEnv;\n}\n\n// Create a proper Promise for lazy initialization\nlet _dbInitPromise: Promise<void> | null = null;\nexport function getDbInitPromise(forceInit = false): Promise<void> {\n\tif (!_dbInitPromise || forceInit) {\n\t\t_dbInitPromise = initializeOnRequest(forceInit);\n\t}\n\treturn _dbInitPromise;\n}\n// Export a lazy Promise that will be initialized on first access (prevents browser execution)\nexport const dbInitPromise = browser ? Promise.resolve() : getDbInitPromise();\nlet adaptersLoaded = false; // Internal flag\n\n/**\n * Loads all settings from the database and populates the in-memory cache.\n * This function should only be called from a server-side context.\n */\n// Extract setting keys directly from schemas (single source of truth)\n// These are cached to avoid rebuilding arrays on every call\n\n// Infrastructure keys that come from config file, not database\nconst INFRASTRUCTURE_KEYS = new Set([\n\t'DB_TYPE',\n\t'DB_HOST',\n\t'DB_PORT',\n\t'DB_NAME',\n\t'DB_USER',\n\t'DB_PASSWORD',\n\t'DB_RETRY_ATTEMPTS',\n\t'DB_RETRY_DELAY',\n\t'DB_POOL_SIZE',\n\t'JWT_SECRET_KEY',\n\t'ENCRYPTION_KEY',\n\t'MULTI_TENANT'\n]);\n\nconst KNOWN_PUBLIC_KEYS = Object.keys(publicConfigSchema.entries);\nconst KNOWN_PRIVATE_KEYS = Object.keys(privateConfigSchema.entries).filter((key) => !INFRASTRUCTURE_KEYS.has(key));\n\nexport async function loadSettingsFromDB() {\n\ttry {\n\t\t// logger.debug('Loading settings from database...');\n\n\t\t// Check if database adapter is available\n\t\tif (!dbAdapter || !dbAdapter.systemPreferences) {\n\t\t\tlogger.warn('Database adapter not available during settings load. Using empty cache.');\n\t\t\tawait invalidateSettingsCache();\n\t\t\treturn;\n\t\t}\n\n\t\t// Load both public and private settings in parallel (not sequential)\n\t\tconst [settingsResult, privateDynResult] = await Promise.all([\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PUBLIC_KEYS, 'system'),\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PRIVATE_KEYS, 'system')\n\t\t]);\n\n\t\tif (!settingsResult.success) {\n\t\t\tlogger.error('Failed to load settings from database:', settingsResult.error);\n\t\t\tlogger.error('Settings keys attempted:', KNOWN_PUBLIC_KEYS);\n\t\t\tlogger.error('Database adapter status:', {\n\t\t\t\thasAdapter: !!dbAdapter,\n\t\t\t\thasSystemPrefs: !!dbAdapter?.systemPreferences,\n\t\t\t\thasGetMany: !!dbAdapter?.systemPreferences?.getMany\n\t\t\t});\n\t\t\tthrow new Error(`Could not load settings from DB: ${settingsResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\tconst settings = settingsResult.data || {};\n\t\tconst privateDynamic = privateDynResult.success ? privateDynResult.data || {} : {};\n\n\t\t// If no settings exist (initial setup), use empty objects and skip validation\n\t\tif (Object.keys(settings).length === 0) {\n\t\t\tlogger.info('No settings found in database (initial setup). Using empty cache.');\n\t\t\t// During initial setup, bypass validation by calling invalidateSettingsCache\n\t\t\t// which sets empty cache without validation\n\t\t\tawait invalidateSettingsCache();\n\t\t\treturn;\n\t\t}\n\n\t\t// All system settings are public in the current implementation\n\t\tconst publicSettings: Record<string, unknown> = settings;\n\t\tconst databasePrivateSettings: Record<string, unknown> = {};\n\n\t\t// Get private config settings (infrastructure settings)\n\t\t// Prefer in-memory config (set by initializeWithConfig) over filesystem import\n\t\t// This eliminates unnecessary file I/O and Vite cache dependency\n\t\tlet privateConfig: InferOutput<typeof privateConfigSchema>;\n\t\tif (privateEnv) {\n\t\t\t// Use in-memory config when available (post-setup, zero-restart mode)\n\t\t\tlogger.debug('Using in-memory private config (bypassing filesystem)');\n\t\t\tprivateConfig = privateEnv;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t// Fall back to filesystem import (normal startup)\n\t\t\t\tlogger.debug('Loading private config from filesystem');\n\t\t\t\tlet imported;\n\t\t\t\tconst isTestMode = typeof process !== 'undefined' && process.env?.TEST_MODE;\n\t\t\t\tif (isTestMode) {\n\t\t\t\t\tconst path = '@config/private.test';\n\t\t\t\t\timported = await import(/* @vite-ignore */ path);\n\t\t\t\t} else {\n\t\t\t\t\timported = await import('@config/private');\n\t\t\t\t}\n\t\t\t\tprivateConfig = imported.privateEnv;\n\t\t\t} catch (error) {\n\t\t\t\t// Private config doesn't exist during setup - this is expected\n\t\t\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge private config file settings with database private settings\n\t\t// Private config contains infrastructure settings (DB_*, JWT_*, ENCRYPTION_*)\n\t\t// Database contains application private settings (SMTP_*, GOOGLE_*, etc.)\n\t\tconst privateSettings = {\n\t\t\t...privateConfig, // Infrastructure settings from config (in-memory or file)\n\t\t\t...databasePrivateSettings // Application settings from database\n\t\t};\n\n\t\t// Validate and parse the settings against the schemas\n\t\tconst parsedPublic = safeParse(publicConfigSchema, publicSettings);\n\t\tconst parsedPrivate = safeParse(privateConfigSchema, privateSettings);\n\n\t\t// If validation fails, it might be during setup with incomplete settings\n\t\t// In this case, just use empty cache to allow setup to continue\n\t\tif (!parsedPublic.success || !parsedPrivate.success) {\n\t\t\tlogger.debug('Settings validation failed during startup - likely first run or setup mode');\n\t\t\tif (!parsedPublic.success) {\n\t\t\t\tlogger.debug('Public settings validation issues:', parsedPublic.issues);\n\t\t\t}\n\t\t\tif (!parsedPrivate.success) {\n\t\t\t\tlogger.debug('Private settings validation issues:', parsedPrivate.issues);\n\t\t\t}\n\n\t\t\t// Clear invalid settings from database (silent cleanup)\n\t\t\ttry {\n\t\t\t\tlogger.debug('Clearing invalid settings from database...');\n\t\t\t\tif (dbAdapter && dbAdapter.systemPreferences && typeof dbAdapter.systemPreferences.deleteMany === 'function') {\n\t\t\t\t\tawait dbAdapter.systemPreferences.deleteMany([]);\n\t\t\t\t\tlogger.debug('Invalid settings cleared successfully');\n\t\t\t\t}\n\t\t\t} catch (clearError) {\n\t\t\t\tlogger.debug('Failed to clear invalid settings:', clearError);\n\t\t\t}\n\n\t\t\tawait invalidateSettingsCache();\n\t\t\tlogger.info('Settings validation failed - system will run with defaults until settings are configured');\n\t\t\treturn; // Return without throwing - allow system to continue in setup mode\n\t\t}\n\n\t\t// Populate the cache with validated settings, merging dynamic private flags into unified cache\n\t\tconst mergedPrivate = { ...(parsedPrivate.output as Record<string, unknown>), ...privateDynamic } as InferOutput<typeof privateConfigSchema>;\n\t\tawait setSettingsCache(mergedPrivate, parsedPublic.output);\n\n\t\tlogger.info('âœ… System settings loaded and cached from database.');\n\t} catch (error) {\n\t\tlogger.error('Failed to load settings from database:', error);\n\t\t// Don't throw - invalidate cache and continue with defaults\n\t\tawait invalidateSettingsCache();\n\t\tlogger.warn('Settings load failed - system will continue with default configuration');\n\t}\n}\n\n// Load database and authentication adapters with resilience\nasync function loadAdapters() {\n\tif (adaptersLoaded && dbAdapter) {\n\t\tlogger.debug('Adapters already loaded, skipping');\n\t\treturn;\n\t}\n\n\t// Use privateEnv if already set (from initializeWithConfig), otherwise load from Vite\n\tlogger.debug('Loading adapters - checking privateEnv', {\n\t\thasPrivateEnv: !!privateEnv,\n\t\tdbType: privateEnv?.DB_TYPE\n\t});\n\n\tconst config = privateEnv || (await loadPrivateConfig(false));\n\n\t// If no DB_TYPE is provided in the config (even if it's the temporary setup config),\n\t// log a warning and return, but don't prematurely exit if DB_TYPE *is* defined.\n\tif (!config?.DB_TYPE) {\n\t\tlogger.debug('No DB_TYPE in config; cannot load adapters. Skipping adapter loading during setup.', { config });\n\t\t// Set health to unhealthy and return without throwing to allow setup flow\n\t\tupdateServiceHealth('database', 'unhealthy', 'No DB_TYPE in config', 'Missing database configuration');\n\t\treturn;\n\t}\n\n\tlogger.debug(`ðŸ”Œ Loading ${config.DB_TYPE} adapters...`);\n\n\t// Use DatabaseResilience for adapter loading (handles transient import failures)\n\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\tconst resilience = getDatabaseResilience({\n\t\tmaxAttempts: 3, // Retry adapter loading up to 3 times\n\t\tinitialDelayMs: 500,\n\t\tbackoffMultiplier: 2,\n\t\tmaxDelayMs: 5000,\n\t\tjitterMs: 200\n\t});\n\n\ttry {\n\t\tawait resilience.executeWithRetry(async () => {\n\t\t\tswitch (config.DB_TYPE) {\n\t\t\t\tcase 'mongodb':\n\t\t\t\tcase 'mongodb+srv': {\n\t\t\t\t\tlogger.debug('Importing MongoDB adapter...');\n\t\t\t\t\tconst mongoAdapterModule = await import('./mongodb/mongoDBAdapter');\n\t\t\t\t\tif (!mongoAdapterModule || !mongoAdapterModule.MongoDBAdapter) {\n\t\t\t\t\t\tthrow new Error('MongoDBAdapter is not exported correctly from mongoDBAdapter.ts');\n\t\t\t\t\t}\n\t\t\t\t\tconst { MongoDBAdapter } = mongoAdapterModule;\n\t\t\t\t\tdbAdapter = new MongoDBAdapter() as unknown as DatabaseAdapter;\n\n\t\t\t\t\tlogger.debug('MongoDB adapter created');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'mariadb': {\n\t\t\t\t\tlogger.debug('Importing MariaDB adapter...');\n\t\t\t\t\tconst mariadbAdapterModule = await import('./mariadb/mariadbAdapter');\n\t\t\t\t\tif (!mariadbAdapterModule || !mariadbAdapterModule.MariaDBAdapter) {\n\t\t\t\t\t\tthrow new Error('MariaDBAdapter is not exported correctly from mariadbAdapter.ts');\n\t\t\t\t\t}\n\t\t\t\t\tconst { MariaDBAdapter } = mariadbAdapterModule;\n\t\t\t\t\tdbAdapter = new MariaDBAdapter() as unknown as DatabaseAdapter;\n\n\t\t\t\t\tlogger.debug('MariaDB adapter created');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.error(`Unsupported DB_TYPE: ${config.DB_TYPE}. Supported types: mongodb, mongodb+srv, mariadb`);\n\t\t\t\t\tthrow new Error(`Unsupported DB_TYPE: ${config.DB_TYPE}. Supported types: mongodb, mongodb+srv, mariadb`);\n\t\t\t}\n\t\t}, 'Database Adapter Loading');\n\n\t\tadaptersLoaded = true;\n\t\tlogger.debug('All adapters loaded successfully');\n\t} catch (err) {\n\t\tconst message = `Error loading adapters: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message);\n\t\tadaptersLoaded = false; // Ensure flag is reset on error\n\t\t// Re-throwing here will cause the initializationPromise to reject\n\t\tthrow new Error(message);\n\t}\n}\n\n// Initialize default theme\nasync function initializeDefaultTheme(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize themes: dbAdapter is not available.');\n\ttry {\n\t\t// Check if theme exists before writing (avoid unnecessary DB operation)\n\t\tconst existingThemes = await dbAdapter.themes.getAllThemes();\n\t\tconst themeExists = existingThemes.some((t) => t.name === DEFAULT_THEME.name && t.isDefault);\n\n\t\tif (!themeExists) {\n\t\t\tawait dbAdapter.themes.storeThemes([DEFAULT_THEME]);\n\t\t\tlogger.debug('Default SveltyCMS theme initialized');\n\t\t}\n\t\t// Skip logging if theme already exists (save 1-2ms)\n\t} catch (err) {\n\t\t// Log but don't fail - theme initialization is not critical for system startup\n\t\tlogger.warn(`Theme initialization issue: ${err instanceof Error ? err.message : String(err)}`);\n\t}\n}\n\n// Initialize ThemeManager\nasync function initializeThemeManager(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize ThemeManager: dbAdapter is not available.');\n\ttry {\n\t\tlogger.debug('Initializing ThemeManager...');\n\t\tconst themeManager = ThemeManager.getInstance();\n\t\tawait themeManager.initialize(dbAdapter);\n\t} catch (err) {\n\t\tconst message = `Error initializing ThemeManager: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n\n// Initialize the media folder\nasync function initializeMediaFolder(): Promise<void> {\n\t// During setup, MEDIA_FOLDER might not be loaded yet, so use fallback\n\tconst mediaFolderPath = (await getPublicSetting('MEDIA_FOLDER')) || './mediaFolder';\n\tif (building) return;\n\tconst fs = await import('node:fs/promises');\n\ttry {\n\t\t// Fast stat() check, skip debug logging overhead\n\t\tawait fs.stat(mediaFolderPath);\n\t\t// Folder exists, skip logging for speed\n\t} catch {\n\t\t// If the folder does not exist, create it\n\t\tlogger.info(`Creating media folder: ${mediaFolderPath}`);\n\t\tawait fs.mkdir(mediaFolderPath, { recursive: true });\n\t}\n}\n\n// Initialize virtual folders using DatabaseResilience\nasync function initializeVirtualFolders(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize virtual folders: dbAdapter is not available.');\n\tif (!dbAdapter.systemVirtualFolder) {\n\t\tlogger.warn('systemVirtualFolder adapter not available, skipping initialization.');\n\t\treturn;\n\t}\n\n\t// Use DatabaseResilience for automatic retry with exponential backoff\n\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\tconst resilience = getDatabaseResilience();\n\n\tawait resilience.executeWithRetry(async () => {\n\t\tif (!dbAdapter) throw new Error('dbAdapter is null');\n\t\t// Verify the connection is still active before querying\n\t\tif (dbAdapter.isConnected && !dbAdapter.isConnected()) {\n\t\t\tthrow new Error('Database connection lost - reconnection required');\n\t\t}\n\n\t\tconst systemVirtualFoldersResult = await dbAdapter.systemVirtualFolder.getAll();\n\n\t\tif (!systemVirtualFoldersResult.success) {\n\t\t\tconst error = systemVirtualFoldersResult.error;\n\t\t\tlet errorMessage = 'Unknown error';\n\n\t\t\tif (error instanceof Error) {\n\t\t\t\terrorMessage = error.message;\n\t\t\t} else if (error && typeof error === 'object' && 'message' in error) {\n\t\t\t\terrorMessage = String((error as { message: unknown }).message);\n\t\t\t} else if (error) {\n\t\t\t\terrorMessage = String(error);\n\t\t\t}\n\n\t\t\tthrow new Error(`Failed to get virtual folders: ${errorMessage}`);\n\t\t}\n\n\t\tconst systemVirtualFolders = systemVirtualFoldersResult.data;\n\n\t\tif (systemVirtualFolders.length === 0) {\n\t\t\t// Create default virtual folder\n\t\t\tconst defaultMediaFolder = (await getPublicSetting('MEDIA_FOLDER')) || 'mediaFolder';\n\t\t\tconst creationResult = await dbAdapter.systemVirtualFolder.create({\n\t\t\t\tname: defaultMediaFolder,\n\t\t\t\tpath: defaultMediaFolder,\n\t\t\t\torder: 0,\n\t\t\t\ttype: 'folder' as const\n\t\t\t});\n\n\t\t\tif (!creationResult.success) {\n\t\t\t\tconst error = creationResult.error;\n\t\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\t\tthrow new Error(`Failed to create root virtual folder: ${errorMessage}`);\n\t\t\t}\n\t\t}\n\t}, 'Virtual Folders Initialization');\n}\n\n// Initialize adapters (instant validation only)\nasync function initializeRevisions(): Promise<void> {\n\tif (!dbAdapter) throw new Error('Cannot initialize revisions: dbAdapter is not available.');\n\t// Instant no-op validation (revisions are lazy-loaded on first use)\n}\n\n// Core Initialization Logic\nasync function initializeSystem(forceReload = false, skipSetupCheck = false): Promise<void> {\n\t// Prevent re-initialization\n\tif (isInitialized) {\n\t\tlogger.debug('System already initialized. Skipping.');\n\t\treturn;\n\t}\n\n\tconst systemStartTime = performance.now();\n\tlogger.info('Starting SvelteCMS System Initialization...');\n\n\t// Set system state to INITIALIZING\n\tawait setSystemState('INITIALIZING', 'Starting system initialization');\n\n\ttry {\n\t\t// Step 1: Check for setup mode (skip if called from initializeWithConfig)\n\t\tlet privateConfig: InferOutput<typeof privateConfigSchema> | null;\n\t\tif (skipSetupCheck) {\n\t\t\t// When called from initializeWithConfig, privateEnv is already set - don't reload\n\t\t\tlogger.debug('Skipping private config load - using pre-set configuration');\n\t\t\tprivateConfig = privateEnv;\n\t\t} else {\n\t\t\t// Normal initialization flow - load from Vite\n\t\t\tprivateConfig = await loadPrivateConfig(forceReload);\n\t\t}\n\n\t\t// Ensure we have valid config before proceeding\n\t\tif (!privateConfig || !privateConfig.DB_TYPE) {\n\t\t\tlogger.info('Private config not available â€“ running in setup mode (skipping full initialization).');\n\t\t\tawait setSystemState('IDLE', 'Running in setup mode');\n\t\t\treturn;\n\t\t}\n\n\t\t// Step 2: Load Adapters & Connect to DB\n\t\tupdateServiceHealth('database', 'initializing', 'Loading database adapter...');\n\t\tawait loadAdapters();\n\t\tif (!dbAdapter) {\n\t\t\tupdateServiceHealth('database', 'unhealthy', 'Database adapter failed to load');\n\t\t\tthrow new Error('Database adapter failed to load.');\n\t\t}\n\n\t\tlet connectionString: string;\n\t\tif (privateConfig.DB_TYPE === 'mongodb') {\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mongodb://${authPart}${privateConfig.DB_HOST}:${privateConfig.DB_PORT}/${privateConfig.DB_NAME}${hasAuth ? '?authSource=admin' : ''}`;\n\t\t\tlogger.debug(`Connecting to MongoDB...`);\n\t\t} else if (privateConfig.DB_TYPE === 'mongodb+srv') {\n\t\t\t// MongoDB Atlas connection string\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mongodb+srv://${authPart}${privateConfig.DB_HOST}/${privateConfig.DB_NAME}?retryWrites=true&w=majority`;\n\t\t\tlogger.debug(`Connecting to MongoDB Atlas (SRV)...`);\n\t\t} else if (privateConfig.DB_TYPE === 'mariadb') {\n\t\t\t// MariaDB connection string\n\t\t\tconst hasAuth = privateConfig.DB_USER && privateConfig.DB_PASSWORD;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(privateConfig.DB_USER!)}:${encodeURIComponent(privateConfig.DB_PASSWORD!)}@` : '';\n\t\t\tconnectionString = `mysql://${authPart}${privateConfig.DB_HOST}:${privateConfig.DB_PORT}/${privateConfig.DB_NAME}`;\n\t\t\tlogger.debug(`Connecting to MariaDB...`);\n\t\t} else {\n\t\t\tconnectionString = '';\n\t\t}\n\n\t\t//  Run connection + model setup in parallel (overlapping I/O)\n\t\tconst step2And3StartTime = performance.now();\n\t\tconst [connectionResult] = await Promise.all([\n\t\t\tdbAdapter.connect(connectionString),\n\t\t\t// Step 3: Setup Core Database Models (runs in parallel with connection)\n\t\t\t// Models can be set up while connection is establishing\n\t\t\t(async () => {\n\t\t\t\t// Small delay to ensure connection is in progress before model setup\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 10));\n\t\t\t\treturn Promise.all([dbAdapter.media?.setupMediaModels(), dbAdapter.widgets?.setupWidgetModels(), dbAdapter.themes?.setupThemeModels()]);\n\t\t\t})()\n\t\t]);\n\n\t\tif (!connectionResult.success) {\n\t\t\tupdateServiceHealth(\n\t\t\t\t'database',\n\t\t\t\t'unhealthy',\n\t\t\t\t`Connection failed: ${connectionResult.error?.message || 'Unknown error'}`,\n\t\t\t\tconnectionResult.error?.message\n\t\t\t);\n\t\t\tthrow new Error(`Database connection failed: ${connectionResult.error?.message || 'Unknown error'}`);\n\t\t}\n\t\tisConnected = true;\n\t\tupdateServiceHealth('database', 'healthy', 'Database connected successfully');\n\n\t\tconst step2And3Time = performance.now() - step2And3StartTime;\n\t\tlogger.info(`Steps 1-2: DB connected & adapters loaded in ${step2And3Time.toFixed(2)}ms`);\n\t\tlogger.info(`Step 3: Database models setup in ${step2And3Time.toFixed(2)}ms (âš¡ parallelized with connection)`);\n\n\t\t// Step 4: Pre-load Server-Side Services\n\t\t// WidgetRegistryService and ContentManager are moved to AFTER Step 5 to ensure dependencies (Settings, Widgets) are ready.\n\t\tlogger.info('Step 4: Skipping eager ContentManager init (moved to Step 6)');\n\n\t\t// Step 5: Initialize Critical Components (optimized for speed)\n\t\tlogger.debug('Starting Step 5: Critical components initialization...');\n\t\tconst step5StartTime = performance.now();\n\n\t\t// Auth (fast, required immediately)\n\t\tlogger.debug('Initializing Auth service...');\n\t\tupdateServiceHealth('auth', 'initializing', 'Initializing authentication service...');\n\t\tif (!dbAdapter) {\n\t\t\tlogger.error('Cannot initialize Auth: dbAdapter is null');\n\t\t\tthrow new Error('Database adapter not initialized');\n\t\t}\n\t\tauth = new Auth(dbAdapter, getDefaultSessionStore());\n\t\tif (!auth) {\n\t\t\tlogger.error('Auth constructor returned null/undefined');\n\t\t\tupdateServiceHealth('auth', 'unhealthy', 'Auth initialization failed');\n\t\t\tthrow new Error('Auth initialization failed');\n\t\t}\n\t\tlogger.debug('Auth service initialized successfully');\n\t\tupdateServiceHealth('auth', 'healthy', 'Authentication service ready');\n\n\t\t// Settings (required for app configuration)\n\t\tlogger.debug('Loading settings from database...');\n\t\tconst settingsStartTime = performance.now();\n\t\tawait loadSettingsFromDB();\n\t\tconst settingsTime = performance.now() - settingsStartTime;\n\t\tlogger.debug(`Settings loaded in ${settingsTime.toFixed(2)}ms`);\n\n\t\tconst authTime = performance.now() - step5StartTime;\n\n\t\t// Run slow I/O operations in parallel\n\t\tlogger.debug('Starting parallel I/O operations...');\n\t\tconst parallelStartTime = performance.now();\n\t\tupdateServiceHealth('cache', 'initializing', 'Initializing media, revisions, and themes...');\n\t\tupdateServiceHealth('themeManager', 'initializing', 'Initializing theme manager...');\n\n\t\t// Collect timings for all parallel operations\n\t\tlet mediaTime = 0,\n\t\t\trevisionsTime = 0,\n\t\t\tvirtualFoldersTime = 0,\n\t\t\tthemesTime = 0,\n\t\t\twidgetsTime = 0;\n\n\t\tawait Promise.all([\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeMediaFolder();\n\t\t\t\tmediaTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeRevisions();\n\t\t\t\trevisionsTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeVirtualFolders();\n\t\t\t\tvirtualFoldersTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tawait initializeDefaultTheme();\n\t\t\t\tawait initializeThemeManager();\n\t\t\t\tupdateServiceHealth('themeManager', 'healthy', 'Theme manager initialized');\n\t\t\t\tthemesTime = performance.now() - t;\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\tconst t = performance.now();\n\t\t\t\tupdateServiceHealth('widgets', 'initializing', 'Initializing widget store...');\n\t\t\t\t// Dynamic import to avoid circular dependency with client bundle\n\t\t\t\tconst { widgets } = await import('@shared/stores/widgetStore.svelte');\n\t\t\t\tawait widgets.initialize(undefined, dbAdapter);\n\t\t\t\tupdateServiceHealth('widgets', 'healthy', 'Widget store initialized');\n\t\t\t\twidgetsTime = performance.now() - t;\n\t\t\t})()\n\t\t]);\n\n\t\tupdateServiceHealth('cache', 'healthy', 'Media, revisions, and virtual folders initialized');\n\n\t\tconst parallelTime = performance.now() - parallelStartTime;\n\t\tlogger.info(\n\t\t\t`Parallel I/O completed in ${parallelTime.toFixed(2)}ms (Media: ${mediaTime.toFixed(2)}ms, Revisions: ${revisionsTime.toFixed(2)}ms, Virtual Folders: ${virtualFoldersTime.toFixed(2)}ms, Themes: ${themesTime.toFixed(2)}ms, Widgets: ${widgetsTime.toFixed(2)}ms)`\n\t\t);\n\n\t\tconst step5Time = performance.now() - step5StartTime;\n\t\tlogger.info(\n\t\t\t`Step 5: Critical components initialized in ${step5Time.toFixed(2)}ms (Auth: ${authTime.toFixed(2)}ms, Settings: ${settingsTime.toFixed(2)}ms)`\n\t\t);\n\n\t\t// Step 6: Application-level services (like ContentManager) are now initialized\n\t\t// in the application hooks (apps/cms/src/hooks.server.ts) after DB is ready.\n\t\tlogger.info('Step 5: Database and core components initialized.');\n\n\t\t// --- Demo Mode Cleanup Service ---\n\t\tif (privateConfig?.DEMO) {\n\t\t\timport('@shared/utils/demoCleanup').then(({ cleanupExpiredDemoTenants }) => {\n\t\t\t\tlogger.info('ðŸ§¹ Demo Cleanup Service initialized (Interval: 5m, TTL: 60m)');\n\t\t\t\t// Run immediately on startup\n\t\t\t\tcleanupExpiredDemoTenants();\n\t\t\t\t// Run every 5 minutes\n\t\t\t\tsetInterval(cleanupExpiredDemoTenants, 5 * 60 * 1000);\n\t\t\t});\n\t\t}\n\n\t\tisInitialized = true;\n\n\t\t// Explicitly set system state to READY after all services are initialized\n\t\tawait setSystemState('READY', 'All critical services initialized successfully');\n\n\t\tconst totalTime = performance.now() - systemStartTime;\n\t\tlogger.info(`ðŸš€ System initialization completed successfully in ${totalTime.toFixed(2)}ms!`);\n\t} catch (err) {\n\t\tconst message = `CRITICAL: System initialization failed: ${err instanceof Error ? err.message : String(err)}`;\n\t\tlogger.error(message, err);\n\t\tisInitialized = false; // Reset initialization flag on error\n\t\tisConnected = false; // Reset connection flag on error\n\t\tauth = null; // Reset auth on error\n\t\tawait setSystemState('FAILED', message);\n\t\tthrow new Error(message);\n\t}\n}\n\n// --- Status & Reinitialization Helpers ---\n\n/**\n * Minimal initialization for setup mode - ONLY connects to database\n * Does NOT initialize any services (auth, themes, content, etc.)\n * Used by setup wizard to perform database operations\n */\nexport async function initializeForSetup(dbConfig: {\n\ttype: string;\n\thost: string;\n\tport: number;\n\tname: string;\n\tuser?: string;\n\tpassword?: string;\n}): Promise<{ success: boolean; error?: string }> {\n\ttry {\n\t\tlogger.info('Initializing minimal database connection for setup mode...');\n\n\t\t// Load the appropriate adapter\n\t\tif (!adaptersLoaded) {\n\t\t\tawait loadAdapters();\n\t\t}\n\n\t\tif (!dbAdapter) {\n\t\t\treturn { success: false, error: 'Failed to load database adapter' };\n\t\t}\n\n\t\t// Build connection string\n\t\tlet connectionString: string;\n\t\tif (dbConfig.type === 'mongodb') {\n\t\t\tconst hasAuth = dbConfig.user && dbConfig.password;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(dbConfig.user!)}:${encodeURIComponent(dbConfig.password!)}@` : '';\n\t\t\tconnectionString = `mongodb://${authPart}${dbConfig.host}:${dbConfig.port}/${dbConfig.name}${hasAuth ? '?authSource=admin' : ''}`;\n\t\t} else if (dbConfig.type === 'mariadb') {\n\t\t\tconst hasAuth = dbConfig.user && dbConfig.password;\n\t\t\tconst authPart = hasAuth ? `${encodeURIComponent(dbConfig.user!)}:${encodeURIComponent(dbConfig.password!)}@` : '';\n\t\t\tconnectionString = `mysql://${authPart}${dbConfig.host}:${dbConfig.port}/${dbConfig.name}`;\n\t\t} else {\n\t\t\treturn { success: false, error: `Database type '${dbConfig.type}' not supported yet` };\n\t\t}\n\n\t\t// Connect to database\n\t\tconst connectionResult = await dbAdapter.connect(connectionString);\n\t\tif (!connectionResult.success) {\n\t\t\treturn { success: false, error: connectionResult.error?.message || 'Connection failed' };\n\t\t}\n\n\t\tisConnected = true;\n\t\tlogger.info('âœ… Minimal database connection established for setup');\n\t\treturn { success: true };\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\tlogger.error('Failed to initialize database for setup:', message);\n\t\treturn { success: false, error: message };\n\t}\n}\n\n/**\n * Initializes the system on the first non-setup request.\n * This prevents the server from trying to connect to the DB during setup.\n */\nexport function initializeOnRequest(forceInit = false): Promise<void> {\n\t// CRITICAL: Never run in browser - this is server-only initialization\n\tif (browser) {\n\t\treturn Promise.resolve();\n\t}\n\n\tconst isBuildProcess = typeof process !== 'undefined' && process.argv?.some((arg) => ['build', 'check'].includes(arg));\n\n\tif (!building && !isBuildProcess) {\n\t\tif (!initializationPromise || forceInit) {\n\t\t\tlogger.debug('Creating system initialization promise...');\n\n\t\t\tinitializationPromise = (async () => {\n\t\t\t\t// Check if private config exists and is valid\n\t\t\t\tconst privateConfig = await loadPrivateConfig(forceInit);\n\t\t\t\tif (!privateConfig || !privateConfig.DB_TYPE || !privateConfig.DB_HOST) {\n\t\t\t\t\tlogger.info('Private config not available â€“ skipping initialization (setup mode)');\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\t// Private config exists - run full initialization\n\t\t\t\tlogger.info('Private config found, starting full system initialization');\n\t\t\t\treturn initializeSystem(forceInit);\n\t\t\t})();\n\n\t\t\tinitializationPromise.catch((err) => {\n\t\t\t\tlogger.error(`Initialization failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\t\tlogger.error('Clearing initialization promise to allow retry');\n\t\t\t\tinitializationPromise = null;\n\t\t\t\t_dbInitPromise = null;\n\t\t\t});\n\t\t}\n\t} else if (!initializationPromise) {\n\t\tlogger.debug('Skipping system initialization during build process.');\n\t\tinitializationPromise = Promise.resolve();\n\t}\n\treturn initializationPromise;\n}\n\nexport async function getSystemStatus() {\n\tconst basicStatus = {\n\t\tinitialized: isInitialized,\n\t\tconnected: isConnected,\n\t\tauthReady: !!auth,\n\t\tinitializing: !!initializationPromise && !isInitialized\n\t};\n\n\t// If not connected, return basic status without health check\n\tif (!isConnected || !dbAdapter) {\n\t\treturn basicStatus;\n\t}\n\n\ttry {\n\t\t// Get database health metrics using DatabaseResilience\n\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\tconst resilience = getDatabaseResilience();\n\n\t\t// Perform health check with database ping\n\t\tconst healthResult = await resilience.healthCheck(async () => {\n\t\t\tif (!dbAdapter) throw new Error('dbAdapter is null');\n\t\t\tconst start = Date.now();\n\t\t\t// Ping the database by running a lightweight query\n\t\t\tif (dbAdapter.isConnected && dbAdapter.isConnected()) {\n\t\t\t\treturn Date.now() - start;\n\t\t\t}\n\t\t\tthrow new Error('Database not connected');\n\t\t});\n\n\t\t// Get resilience metrics for additional insights\n\t\tconst metrics = resilience.getMetrics();\n\n\t\treturn {\n\t\t\t...basicStatus,\n\t\t\thealth: {\n\t\t\t\thealthy: healthResult.healthy,\n\t\t\t\tlatency: healthResult.latency,\n\t\t\t\tmessage: healthResult.message\n\t\t\t},\n\t\t\tmetrics: {\n\t\t\t\ttotalRetries: metrics.totalRetries,\n\t\t\t\tsuccessfulRetries: metrics.successfulRetries,\n\t\t\t\tfailedRetries: metrics.failedRetries,\n\t\t\t\ttotalReconnections: metrics.totalReconnections,\n\t\t\t\tsuccessfulReconnections: metrics.successfulReconnections,\n\t\t\t\tconnectionUptime: metrics.connectionUptime,\n\t\t\t\taverageRecoveryTime: Math.round(metrics.averageRecoveryTime)\n\t\t\t}\n\t\t};\n\t} catch (error) {\n\t\t// If health check fails, return basic status with error\n\t\treturn {\n\t\t\t...basicStatus,\n\t\t\thealth: {\n\t\t\t\thealthy: false,\n\t\t\t\tlatency: -1,\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Health check failed'\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport function getAuth() {\n\treturn auth;\n}\n\nexport async function reinitializeSystem(force = false, waitForAuth = true): Promise<{ status: string; error?: string }> {\n\tif (isInitialized && !force) {\n\t\treturn { status: 'already-initialized' };\n\t}\n\n\t// If force is true, clear any existing initialization promise and reload config\n\tif (force) {\n\t\tlogger.info('Force reinitialization requested - clearing existing initialization promise and reloading config');\n\t\tinitializationPromise = null;\n\t\tisInitialized = false;\n\t\tisConnected = false;\n\t\tauth = null;\n\t\t// Force reload private config\n\t\tawait loadPrivateConfig(true);\n\t\t// Reset system state\n\t\tawait setSystemState('IDLE', 'Preparing for reinitialization');\n\t}\n\n\tif (initializationPromise) {\n\t\treturn { status: 'initialization-in-progress' };\n\t}\n\n\ttry {\n\t\tlogger.info(`Manual reinitialization requested${force ? ' (force)' : ''}${!waitForAuth ? ' (skip auth wait)' : ''}`);\n\t\tinitializationPromise = initializeSystem(force);\n\t\tawait initializationPromise;\n\n\t\t// Optionally wait for auth service to be ready (skip during setup to avoid blocking)\n\t\tif (waitForAuth) {\n\t\t\tlogger.info('Waiting for auth service to become available after reinitialization...');\n\t\t\tconst authReady = await waitForServiceHealthy('auth', { timeoutMs: 3000 }); // Reduced from 10s to 3s\n\t\t\tif (!authReady) {\n\t\t\t\tlogger.warn('Auth service not ready after timeout, but will continue');\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.info('Skipping auth readiness wait (setup mode)');\n\t\t}\n\n\t\treturn { status: 'initialized' };\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\t// Clear the failed promise so retries are possible\n\t\tinitializationPromise = null;\n\t\treturn { status: 'failed', error: message };\n\t}\n}\n\n/**\n * Initialize system with provided configuration (in-memory) - MOST EFFICIENT\n * This is the recommended method for zero-restart setup completion.\n * Bypasses filesystem completely by accepting configuration in memory.\n *\n * Use this during setup completion to avoid:\n * - Vite module cache issues\n * - Filesystem read operations\n * - Double initialization\n *\n * @param config - Complete private environment configuration\n * @returns Promise with initialization status\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function initializeWithConfig(config: any): Promise<{ status: string; error?: string }> {\n\ttry {\n\t\tlogger.info('ðŸš€ Initializing system with provided configuration (bypassing Vite cache & filesystem)...');\n\n\t\t// CRITICAL: Set config in memory BEFORE initialization\n\t\tprivateEnv = config;\n\n\t\t// Clear any existing initialization state\n\t\tinitializationPromise = null;\n\t\tisInitialized = false;\n\t\tisConnected = false;\n\t\tauth = null;\n\t\tawait setSystemState('IDLE', 'Preparing for initialization with in-memory config');\n\n\t\tlogger.debug('In-memory config set successfully', {\n\t\t\tDB_TYPE: config.DB_TYPE,\n\t\t\tDB_HOST: config.DB_HOST ? '***' : 'missing',\n\t\t\thasJWT: !!config.JWT_SECRET_KEY,\n\t\t\thasEncryption: !!config.ENCRYPTION_KEY\n\t\t});\n\n\t\t// Initialize system with in-memory config\n\t\t// skipSetupCheck = true tells initializeSystem to use privateEnv instead of importing\n\t\tinitializationPromise = initializeSystem(false, true);\n\t\tawait initializationPromise;\n\n\t\tlogger.info('âœ… System initialized successfully with in-memory config (zero-restart)');\n\t\treturn { status: 'success' };\n\t} catch (error) {\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\tlogger.error('Failed to initialize with in-memory config:', errorMessage);\n\t\tinitializationPromise = null;\n\t\tprivateEnv = null; // Clear failed config\n\t\tawait setSystemState('FAILED', `Initialization failed: ${errorMessage}`);\n\t\treturn { status: 'failed', error: errorMessage };\n\t}\n}\n\n/**\n * Initialize system by loading private.ts from filesystem (bypasses Vite cache).\n * LEGACY METHOD - Use initializeWithConfig() for better performance when config is already in memory.\n *\n * Use this during setup when private.ts was just created on filesystem but hasn't been\n * loaded by Vite yet due to module caching.\n *\n * @returns Promise with initialization status\n */\nexport async function initializeWithFreshConfig(): Promise<{ status: string; error?: string }> {\n\t// Clear any existing initialization\n\tlogger.info('Initializing system with fresh config from filesystem (bypassing Vite cache)...');\n\tinitializationPromise = null;\n\tisInitialized = false;\n\tisConnected = false;\n\tauth = null;\n\tprivateEnv = null; // Clear cache to force reload\n\tawait setSystemState('IDLE', 'Preparing for initialization with fresh config');\n\n\ttry {\n\t\t// Force reload private.ts from filesystem (bypasses Vite's module cache)\n\t\tconst freshConfig = await loadPrivateConfig(true);\n\n\t\tif (!freshConfig || !freshConfig.DB_TYPE) {\n\t\t\tthrow new Error('Failed to load private config from filesystem');\n\t\t}\n\n\t\tlogger.debug('Fresh config loaded from filesystem', {\n\t\t\tDB_TYPE: freshConfig.DB_TYPE,\n\t\t\tDB_HOST: freshConfig.DB_HOST ? '***' : 'missing',\n\t\t\thasJWT: !!freshConfig.JWT_SECRET_KEY,\n\t\t\thasEncryption: !!freshConfig.ENCRYPTION_KEY\n\t\t});\n\n\t\t// Now call initializeSystem - it will use the freshly loaded config\n\t\tinitializationPromise = initializeSystem(false, true); // skipSetupCheck = true\n\t\tawait initializationPromise;\n\n\t\tlogger.info('âœ… System initialized successfully with fresh config');\n\t\treturn { status: 'initialized' };\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tlogger.error('Failed to initialize with fresh config:', message);\n\t\tinitializationPromise = null;\n\t\tprivateEnv = null; // Clear failed config\n\t\treturn { status: 'failed', error: message };\n\t}\n}\n\n/**\n * Get the current database adapter instance\n * @returns The database adapter or null if not initialized\n */\nexport function getDb(): DatabaseAdapter | null {\n\treturn dbAdapter;\n}\n\n/**\n * Initialize a database connection for seeding purposes\n * @param dbConfig Database configuration\n */\nexport async function initConnection(dbConfig: {\n\ttype: string;\n\thost: string;\n\tport: string;\n\tname: string;\n\tuser?: string;\n\tpassword?: string;\n}): Promise<void> {\n\t// For seeding, we need to create a temporary adapter instance\n\t// This is a simplified version that works with the existing MongoDB setup\n\n\tif (!dbConfig || !dbConfig.type) {\n\t\tthrow new Error('Database configuration is required');\n\t}\n\n\tif (dbConfig.type !== 'mongodb') {\n\t\tthrow new Error(`Database type '${dbConfig.type}' is not supported for seeding yet`);\n\t}\n\n\ttry {\n\t\t// Import MongoDB adapter\n\t\tconst { MongoDBAdapter } = await import('./mongodb/mongoDBAdapter');\n\n\t\t// Create a new adapter instance for seeding\n\t\tconst tempAdapter = new MongoDBAdapter();\n\n\t\t// Build connection string like the test endpoint does\n\t\tconst { buildDatabaseConnectionString } = await import('@shared/utils/database');\n\t\tconst connectionString = buildDatabaseConnectionString({\n\t\t\ttype: dbConfig.type as 'mongodb' | 'mongodb+srv',\n\t\t\thost: dbConfig.host,\n\t\t\tport: Number(dbConfig.port),\n\t\t\tname: dbConfig.name,\n\t\t\tuser: dbConfig.user ?? '',\n\t\t\tpassword: dbConfig.password ?? ''\n\t\t});\n\t\tconst isAtlas = connectionString.startsWith('mongodb+srv://');\n\n\t\tconst options = {\n\t\t\tuser: dbConfig.user || undefined,\n\t\t\tpass: dbConfig.password || undefined,\n\t\t\tdbName: dbConfig.name,\n\t\t\tauthSource: isAtlas ? undefined : 'admin',\n\t\t\tretryWrites: true,\n\t\t\tserverSelectionTimeoutMS: 15000,\n\t\t\tmaxPoolSize: 1 // Use a minimal pool for seeding\n\t\t};\n\n\t\t// Connect using the custom connection string and options\n\t\tconst connectResult = await tempAdapter.connect(connectionString, options);\n\t\tif (!connectResult.success) {\n\t\t\tthrow new Error(`Database connection failed: ${connectResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\t// Set this as the global adapter for seeding\n\t\tdbAdapter = tempAdapter as unknown as DatabaseAdapter;\n\n\t\tlogger.info('Database connection initialized for seeding');\n\t} catch (error) {\n\t\tlogger.error('Failed to initialize database connection for seeding:', error);\n\t\tthrow error;\n\t}\n}\n"],"names":["db","cryptoHashPassword","cryptoVerifyPassword","SESSION_COOKIE_NAME","error"],"mappings":"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"}