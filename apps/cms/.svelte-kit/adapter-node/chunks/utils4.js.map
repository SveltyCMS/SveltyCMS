{"version":3,"file":"utils4.js","sources":["../../../../src/content/utils.ts"],"sourcesContent":["/**\n * @file src/content/utils.ts\n * @description Helper functions for Content\n *\n * Structure:\n * - constructNestedStructure: Converts a flat list of content nodes into a nested structure\n * - constructContentPaths: Converts a nested structure into a flat list of content nodes\n * - generateCategoryNodesFromPaths: Extracts category nodes from a flat list of content nodes\n *\n * Module Processing:\n * - processModule: Extracts schema from module content\n *\n * Widget Utilities:\n * - resolveWidgetPlaceholder: Resolves a widget placeholder\n */\nimport { widgetRegistryService } from '@shared/services/WidgetRegistryService';\nimport { logger } from '@shared/utils/logger';\nimport type { ContentNode, MinimalContentNode, Schema } from './types';\n\n// An extended version of ContentNode for UI purposes that includes children.\nexport interface ExtendedContentNode extends ContentNode {\n\tpath?: string;\n\tchildren?: ExtendedContentNode[];\n}\n\nexport function constructNestedStructure(contentStructure: ContentNode[]): ExtendedContentNode[] {\n\tconst nodeMap = new Map<string, ExtendedContentNode>();\n\tconst byParent: Record<string, ExtendedContentNode[]> = {};\n\tconst ROOT_KEY = '__root__';\n\n\t// Step 1: Convert to ExtendedContentNode and group by parentId\n\tfor (const node of contentStructure) {\n\t\tconst nested: ExtendedContentNode = { ...node, path: '', children: [] };\n\t\tnodeMap.set(node._id, nested);\n\t\tconst parentKey = node.parentId ?? ROOT_KEY;\n\t\tif (!byParent[parentKey]) byParent[parentKey] = [];\n\t\tbyParent[parentKey].push(nested);\n\t}\n\n\tconst result: ExtendedContentNode[] = [];\n\tconst rootNodes = byParent[ROOT_KEY] ?? [];\n\n\t// Step 2: DFS using a stack to build the tree\n\tconst stack: { node: ExtendedContentNode; parentPath: string }[] = [];\n\tfor (const root of rootNodes) {\n\t\troot.path = `/${root.name}`;\n\t\tresult.push(root);\n\t\tstack.push({ node: root, parentPath: '' });\n\t}\n\n\twhile (stack.length > 0) {\n\t\tconst { node } = stack.pop()!;\n\t\tconst children = byParent[node._id] ?? [];\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\n\t\t\tconst child = children[i];\n\t\t\tchild.path = `${node.path}/${child.name}`;\n\t\t\tnode.children!.push(child);\n\t\t\tstack.push({ node: child, parentPath: node.path ?? '' });\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function generateCategoryNodesFromPaths(files: Schema[]): Map<string, MinimalContentNode> {\n\tconst folders = new Map<string, MinimalContentNode>();\n\n\tfor (const file of files) {\n\t\tif (!file.path) continue;\n\t\tconst parts = file.path.split('/').filter(Boolean);\n\t\tlet path = '';\n\t\tfor (let i = 0; i < parts.length - 1; i++) {\n\t\t\tconst name = parts[i];\n\t\t\tpath = `${path}/${name}`;\n\t\t\tif (!folders.has(path)) {\n\t\t\t\tfolders.set(path, { name, path, nodeType: 'category' });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn folders;\n}\n\nexport function constructContentPaths(contentStructure: ContentNode[]): Record<string, ContentNode> {\n\tconst byParent: Record<string, ContentNode[]> = {};\n\tconst result: Record<string, ContentNode> = {};\n\n\tfor (const node of contentStructure) {\n\t\tconst parentKey = node.parentId ?? '__root__';\n\t\tif (!byParent[parentKey]) byParent[parentKey] = [];\n\t\tbyParent[parentKey].push(node);\n\t}\n\n\tconst stack: { node: ContentNode; path: string }[] = [];\n\tconst rootNodes = byParent['__root__'] ?? [];\n\tfor (const root of rootNodes) {\n\t\tstack.push({ node: root, path: `/${root.name}` });\n\t}\n\n\twhile (stack.length > 0) {\n\t\tconst { node, path } = stack.pop()!;\n\t\tresult[path] = { ...node };\n\n\t\tconst children = byParent[node._id] ?? [];\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\n\t\t\tconst child = children[i];\n\t\t\tstack.push({ node: child, path: `${path}/${child.name}` });\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport async function processModule(content: string): Promise<{ schema?: Schema } | null> {\n\ttry {\n\t\tconst exportMatch = content.match(/export\\s+const\\s+schema\\s*=\\s*/);\n\t\tif (!exportMatch) {\n\t\t\tlogger.warn('No schema export found in module');\n\t\t\treturn null;\n\t\t}\n\n\t\tconst startIdx = exportMatch.index! + exportMatch[0].length;\n\t\tlet braceCount = 0;\n\t\tlet inString = false;\n\t\tlet stringChar = '';\n\t\tlet endIdx = startIdx;\n\n\t\tfor (let i = startIdx; i < content.length; i++) {\n\t\t\tconst char = content[i];\n\t\t\tconst prevChar = i > 0 ? content[i - 1] : '';\n\n\t\t\tif ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n\t\t\t\tif (!inString) {\n\t\t\t\t\tinString = true;\n\t\t\t\t\tstringChar = char;\n\t\t\t\t} else if (char === stringChar) {\n\t\t\t\t\tinString = false;\n\t\t\t\t\tstringChar = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inString) {\n\t\t\t\tif (char === '{') braceCount++;\n\t\t\t\tif (char === '}') braceCount--;\n\n\t\t\t\tif (braceCount === 0 && char === '}') {\n\t\t\t\t\tendIdx = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst schemaContent = content.substring(startIdx, endIdx);\n\t\tif (!schemaContent || schemaContent.trim() === '') {\n\t\t\tlogger.warn('Could not extract schema content');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Widgets are registered during server startup in hooks.server.ts\n\t\tconst widgetsMap = widgetRegistryService.getAllWidgets();\n\n\t\tif (widgetsMap.size === 0) {\n\t\t\tlogger.warn('WidgetRegistryService not initialized yet. Cannot process module.');\n\t\t\treturn null;\n\t\t}\n\n\t\tconst widgetsObject = Object.fromEntries(widgetsMap.entries());\n\n\t\tconst moduleContent = `\n\t\t\treturn (function() {\n\t\t\t\tconst widgets = globalThis.widgets;\n\t\t\t\tconst schema = ${schemaContent};\n\t\t\t\treturn schema;\n\t\t\t})();\n\t\t`;\n\n\t\tif (typeof globalThis !== 'undefined') {\n\t\t\t(globalThis as { widgets?: Record<string, unknown> }).widgets = widgetsObject;\n\t\t}\n\n\t\tconst moduleFunc = new Function(moduleContent);\n\t\tconst result = moduleFunc();\n\n\t\tif (typeof globalThis !== 'undefined') {\n\t\t\tdelete (globalThis as { widgets?: Record<string, unknown> }).widgets;\n\t\t}\n\n\t\tif (result && typeof result === 'object' && 'fields' in result && '_id' in result) {\n\t\t\tlogger.trace(`Processed collection: ${result._id}`);\n\t\t\treturn { schema: result as Schema };\n\t\t}\n\n\t\tlogger.warn(`Module processed but no fields or _id found. Result type: ${typeof result}`);\n\t\treturn null;\n\t} catch (err) {\n\t\tconst errorMessage = err instanceof Error ? err.message : String(err);\n\t\tlogger.error('Failed to process module:', { error: errorMessage, stack: err instanceof Error ? err.stack : undefined });\n\t\treturn null;\n\t}\n}\n"],"names":[],"mappings":";;AA+DO,SAAS,+BAA+B,OAAkD;AAChG,QAAM,8BAAc,IAAA;AAEpB,aAAW,QAAQ,OAAO;AACzB,QAAI,CAAC,KAAK,KAAM;AAChB,UAAM,QAAQ,KAAK,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO;AACjD,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AAC1C,YAAM,OAAO,MAAM,CAAC;AACpB,aAAO,GAAG,IAAI,IAAI,IAAI;AACtB,UAAI,CAAC,QAAQ,IAAI,IAAI,GAAG;AACvB,gBAAQ,IAAI,MAAM,EAAE,MAAM,MAAM,UAAU,YAAY;AAAA,MACvD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAgCA,eAAsB,cAAc,SAAsD;AACzF,MAAI;AACH,UAAM,cAAc,QAAQ,MAAM,gCAAgC;AAClE,QAAI,CAAC,aAAa;AACjB,aAAO,KAAK,kCAAkC;AAC9C,aAAO;AAAA,IACR;AAEA,UAAM,WAAW,YAAY,QAAS,YAAY,CAAC,EAAE;AACrD,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,aAAa;AACjB,QAAI,SAAS;AAEb,aAAS,IAAI,UAAU,IAAI,QAAQ,QAAQ,KAAK;AAC/C,YAAM,OAAO,QAAQ,CAAC;AACtB,YAAM,WAAW,IAAI,IAAI,QAAQ,IAAI,CAAC,IAAI;AAE1C,WAAK,SAAS,OAAO,SAAS,OAAO,SAAS,QAAQ,aAAa,MAAM;AACxE,YAAI,CAAC,UAAU;AACd,qBAAW;AACX,uBAAa;AAAA,QACd,WAAW,SAAS,YAAY;AAC/B,qBAAW;AACX,uBAAa;AAAA,QACd;AAAA,MACD;AAEA,UAAI,CAAC,UAAU;AACd,YAAI,SAAS,IAAK;AAClB,YAAI,SAAS,IAAK;AAElB,YAAI,eAAe,KAAK,SAAS,KAAK;AACrC,mBAAS,IAAI;AACb;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,UAAM,gBAAgB,QAAQ,UAAU,UAAU,MAAM;AACxD,QAAI,CAAC,iBAAiB,cAAc,KAAA,MAAW,IAAI;AAClD,aAAO,KAAK,kCAAkC;AAC9C,aAAO;AAAA,IACR;AAGA,UAAM,aAAa,sBAAsB,cAAA;AAEzC,QAAI,WAAW,SAAS,GAAG;AAC1B,aAAO,KAAK,mEAAmE;AAC/E,aAAO;AAAA,IACR;AAEA,UAAM,gBAAgB,OAAO,YAAY,WAAW,SAAS;AAE7D,UAAM,gBAAgB;AAAA;AAAA;AAAA,qBAGH,aAAa;AAAA;AAAA;AAAA;AAKhC,QAAI,OAAO,eAAe,aAAa;AACrC,iBAAqD,UAAU;AAAA,IACjE;AAEA,UAAM,aAAa,IAAI,SAAS,aAAa;AAC7C,UAAM,SAAS,WAAA;AAEf,QAAI,OAAO,eAAe,aAAa;AACtC,aAAQ,WAAqD;AAAA,IAC9D;AAEA,QAAI,UAAU,OAAO,WAAW,YAAY,YAAY,UAAU,SAAS,QAAQ;AAClF,aAAO,MAAM,yBAAyB,OAAO,GAAG,EAAE;AAClD,aAAO,EAAE,QAAQ,OAAA;AAAA,IAClB;AAEA,WAAO,KAAK,6DAA6D,OAAO,MAAM,EAAE;AACxF,WAAO;AAAA,EACR,SAAS,KAAK;AACb,UAAM,eAAe,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG;AACpE,WAAO,MAAM,6BAA6B,EAAE,OAAO,cAAc,OAAO,eAAe,QAAQ,IAAI,QAAQ,OAAA,CAAW;AACtH,WAAO;AAAA,EACR;AACD;"}