{"version":3,"file":"ConfigService.js","sources":["../../../../../../shared/services/src/ConfigService.ts"],"sourcesContent":["/**\n * @file shared/services/src/ConfigService.ts\n * @description Service layer for handling all configuration synchronization logic.\n */\n\n// Node.js imports removed for browser compatibility\n// import fs from 'fs/promises';\n// import { createWriteStream } from 'fs';\n// import path from 'path';\nimport { createChecksum } from '@shared/utils/crypto';\nimport { logger } from '@shared/utils/logger';\nimport type { IContentManager, ConfigEntity, ConfigSyncStatus } from '@cms-types';\n\nclass ConfigService {\n\tprivate contentManager: IContentManager | null = null;\n\n\t/** Sets the content manager implementation (injected from app side) */\n\tpublic setContentManager(manager: IContentManager): void {\n\t\tthis.contentManager = manager;\n\t}\n\n\t/** Returns current sync status between filesystem and database. */\n\tpublic async getStatus(): Promise<ConfigSyncStatus> {\n\t\tconst { dbAdapter } = await import('@shared/database/db');\n\t\tlogger.debug('Fetching configuration sync status...');\n\t\tconst [source, active] = await Promise.all([this.getSourceState(), this.getActiveState()]);\n\n\t\tconst changes = this.compareStates(source, active);\n\t\tconst unmetRequirements = await this.checkForUnmetRequirements(source);\n\n\t\treturn {\n\t\t\tstatus: changes.new.length > 0 || changes.updated.length > 0 || changes.deleted.length > 0 ? 'changes_detected' : 'in_sync',\n\t\t\tchanges,\n\t\t\tunmetRequirements\n\t\t};\n\t}\n\n\tpublic async performExport({ uuids }: { uuids?: string[] } = {}): Promise<{ dirPath: string }> {\n\t\tlogger.info('Exporting configuration...');\n\t\tconst path = await import('path');\n\t\tconst fs = await import('fs/promises');\n\t\tconst exportDir = path.resolve(process.cwd(), 'config/backup', `export_${Date.now()}`);\n\t\tawait fs.mkdir(exportDir, { recursive: true });\n\n\t\tconst [collections] = await Promise.all([Promise.resolve([])]);\n\t\tconst entities = { collections };\n\n\t\tawait Promise.all(\n\t\t\tObject.entries(entities).map(async ([key, list]) => {\n\t\t\t\tconst filtered = uuids?.length ? (list as Array<{ uuid: string }>).filter((i) => uuids.includes(i.uuid)) : (list as Array<unknown>);\n\t\t\t\tconst filePath = path.join(exportDir, `${key}.json`);\n\t\t\t\tif (filtered.length > 10000) {\n\t\t\t\t\tconst { createWriteStream } = await import('fs');\n\t\t\t\t\tconst stream = createWriteStream(filePath);\n\t\t\t\t\tstream.write('[\\n');\n\t\t\t\t\tfor (let i = 0; i < filtered.length; i++) {\n\t\t\t\t\t\tstream.write(JSON.stringify(filtered[i], null, 2));\n\t\t\t\t\t\tif (i < filtered.length - 1) stream.write(',\\n');\n\t\t\t\t\t}\n\t\t\t\t\tstream.write('\\n]');\n\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\tstream.end(resolve);\n\t\t\t\t\t\tstream.on('error', reject);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait fs.writeFile(filePath, JSON.stringify(filtered, null, 2));\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tlogger.info(`Configuration exported to ${exportDir}`);\n\t\treturn { dirPath: exportDir };\n\t}\n\n\tpublic async performImport(options: { changes?: { new: ConfigEntity[]; updated: ConfigEntity[]; deleted: ConfigEntity[] } } = {}) {\n\t\tlogger.info('Performing configuration import...');\n\t\tlet changes = options.changes;\n\n\t\tif (!changes) {\n\t\t\tconst status = await this.getStatus();\n\t\t\tchanges = status.changes;\n\t\t}\n\n\t\tlogger.info('Perfoming import...');\n\t\tconst { dbAdapter } = await import('@shared/database/db');\n\n\t\tif (!dbAdapter) throw new Error('Database adapter not available.');\n\n\t\tconst toUpsert = [...changes.new, ...changes.updated];\n\t\tfor (const item of toUpsert) {\n\t\t\tif (item.type === 'collection') {\n\t\t\t\ttry {\n\t\t\t\t\tawait dbAdapter.crud.upsert('collections', { name: item.name } as any, item.entity as any);\n\t\t\t\t\tlogger.info(`Imported collection: ${item.name}`);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error(`Failed to import collection ${item.name}:`, err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of changes.deleted) {\n\t\t\tif (item.type === 'collection') {\n\t\t\t\ttry {\n\t\t\t\t\tawait dbAdapter.crud.delete('collections', item.uuid as any);\n\t\t\t\t\tlogger.info(`Deleted collection: ${item.name}`);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error(`Failed to delete collection ${item.name}:`, err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.info('Configuration import completed.');\n\t}\n\n\tprivate async getSourceState(): Promise<Map<string, ConfigEntity>> {\n\t\tconst state = new Map<string, ConfigEntity>();\n\t\tif (!this.contentManager) {\n\t\t\tlogger.warn('ConfigService: getSourceState called but contentManager not set. Returning empty state.');\n\t\t\treturn state;\n\t\t}\n\n\t\tawait this.contentManager.initialize();\n\t\tconst collections = await this.contentManager.getCollections();\n\t\tfor (const collection of collections) {\n\t\t\tif (!collection._id || !collection.name) continue;\n\t\t\tconst hash = createChecksum(collection);\n\t\t\tstate.set(collection._id, {\n\t\t\t\tuuid: collection._id,\n\t\t\t\ttype: 'collection',\n\t\t\t\tname: collection.name,\n\t\t\t\thash,\n\t\t\t\tentity: collection as unknown as Record<string, unknown>\n\t\t\t});\n\t\t}\n\n\t\treturn state;\n\t}\n\n\tprivate async getActiveState(): Promise<Map<string, ConfigEntity>> {\n\t\tconst { dbAdapter } = await import('@shared/database/db');\n\t\tif (!dbAdapter) throw new Error('Database adapter not available.');\n\t\tconst state = new Map<string, ConfigEntity>();\n\n\t\ttry {\n\t\t\tconst collectionsResult = await dbAdapter.crud.findMany('collections', {});\n\n\t\t\tif (collectionsResult.success && Array.isArray(collectionsResult.data)) {\n\t\t\t\tfor (const collection of collectionsResult.data as any[]) {\n\t\t\t\t\tif (!collection._id || !collection.name) continue;\n\t\t\t\t\tconst hash = createChecksum(collection);\n\t\t\t\t\tstate.set(collection._id, {\n\t\t\t\t\t\tuuid: collection._id,\n\t\t\t\t\t\ttype: 'collection',\n\t\t\t\t\t\tname: collection.name,\n\t\t\t\t\t\thash,\n\t\t\t\t\t\tentity: collection\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to fetch active state from DB:', err);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\tprivate compareStates(source: Map<string, ConfigEntity>, active: Map<string, ConfigEntity>) {\n\t\tconst result = { new: [], updated: [], deleted: [] } as {\n\t\t\tnew: ConfigEntity[];\n\t\t\tupdated: ConfigEntity[];\n\t\t\tdeleted: ConfigEntity[];\n\t\t};\n\n\t\tfor (const [uuid, s] of source.entries()) {\n\t\t\tconst a = active.get(uuid);\n\t\t\tif (!a) result.new.push(s);\n\t\t\telse if (s.hash !== a.hash) result.updated.push(s);\n\t\t}\n\t\tfor (const [uuid, a] of active.entries()) {\n\t\t\tif (!source.has(uuid)) result.deleted.push(a);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async checkForUnmetRequirements(source: Map<string, ConfigEntity>): Promise<Array<{ key: string; value?: unknown }>> {\n\t\tconst { dbAdapter } = await import('@shared/database/db');\n\t\tif (!dbAdapter?.systemPreferences) throw new Error('System preferences adapter unavailable.');\n\n\t\tconst unmet: Array<{ key: string; value?: unknown }> = [];\n\t\tfor (const { entity } of source.values()) {\n\t\t\tif (!Array.isArray(entity._requiredSettings)) continue;\n\n\t\t\tfor (const req of entity._requiredSettings) {\n\t\t\t\tconst result = await dbAdapter.systemPreferences.get(req.key, 'system');\n\t\t\t\tif (!result.success || !result.data) unmet.push(req);\n\t\t\t}\n\t\t}\n\n\t\treturn [...new Map(unmet.map((i) => [i.key, i])).values()];\n\t}\n}\n\nexport const configService = new ConfigService();\nexport type { ConfigEntity, ConfigSyncStatus };\n"],"names":[],"mappings":"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"}