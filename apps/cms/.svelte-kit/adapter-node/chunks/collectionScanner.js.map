{"version":3,"file":"collectionScanner.js","sources":["../../../../src/content/collectionScanner.ts"],"sourcesContent":["/**\n * @file src/content/collectionScanner.ts\n * @description Standalone collection scanner for use during setup\n *\n * This module provides a simplified collection scanning function that can be used\n * during system setup without requiring the full ContentManager or global dbAdapter.\n *\n * ## Usage Contexts:\n * 1. **Setup Process** - Scans collections during initial system setup (`/api/setup/seed`)\n * 2. **Production Runtime** - Optimized filesystem scanning for better performance (`src/content/index.ts`)\n * 3. **Build Time** - Development-time collection scanning (Vite plugin)\n *\n * ## Testing:\n * This module is tested indirectly through:\n * - **Setup API Tests** (`tests/bun/api/setup.test.ts`) - Tests the seed endpoint which uses scanCompiledCollections\n * - **Integration Tests** - Runtime usage is tested through collection-related integration tests\n *\n * Direct unit testing is complex because processModule() requires WidgetRegistryService initialization,\n * which depends on Vite's import.meta.glob (not available in test environment).\n *\n * NOTE: This is SERVER-ONLY code that uses Node.js fs module.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { processModule } from './utils';\nimport type { Schema } from './types';\n\n/**\n * Recursively scans a directory for .js files.\n * Uses path.join for cross-platform compatibility.\n */\nasync function recursivelyGetFiles(dir: string): Promise<string[]> {\n\tconst entries = await fs.readdir(dir, { withFileTypes: true });\n\n\tconst files = await Promise.all(\n\t\tentries.map(async (entry) => {\n\t\t\tconst fullPath = path.join(dir, entry.name);\n\n\t\t\tif (entry.isDirectory()) {\n\t\t\t\treturn recursivelyGetFiles(fullPath);\n\t\t\t} else if (entry.isFile() && entry.name.endsWith('.js')) {\n\t\t\t\treturn [fullPath];\n\t\t\t}\n\t\t\treturn [];\n\t\t})\n\t);\n\n\treturn files.flat();\n}\n\n/**\n * Extracts a clean content path relative to the collections folder.\n * Ensures the result always uses forward slashes '/' for database consistency.\n */\nfunction extractCollectionPath(fullPath: string, baseDir: string): string {\n\t// Get relative path: e.g., \"subfolder/myCollection.js\" or \"subfolder\\myCollection.js\"\n\tconst relative = path.relative(baseDir, fullPath);\n\n\t// Remove extension\n\tconst withoutExt = relative.replace(/\\.js$/, '');\n\n\t// Normalize separators to forward slashes (essential for DB consistency across OS)\n\tconst normalized = withoutExt.split(path.sep).join('/');\n\n\t// Ensure leading slash\n\treturn normalized.startsWith('/') ? normalized : `/${normalized}`;\n}\n\n/**\n * Scans the compiledCollections directory and returns all collection schemas.\n * This is a standalone version that doesn't require ContentManager or dbAdapter.\n *\n * @returns Array of collection schemas found in the filesystem\n */\nexport async function scanCompiledCollections(): Promise<Schema[]> {\n\tconst envDir = process.env.COLLECTIONS_DIR || process.env.COLLECTIONS_FOLDER || import.meta.env.VITE_COLLECTIONS_FOLDER || 'compiledCollections';\n\n\t// Resolve to absolute path to ensure we look in the project root\n\tconst compiledDirectoryPath = path.resolve(process.cwd(), envDir);\n\n\ttry {\n\t\tawait fs.access(compiledDirectoryPath);\n\t} catch {\n\t\tlogger.trace(`Compiled collections directory not found at: ${compiledDirectoryPath}. Assuming fresh start.`);\n\t\treturn [];\n\t}\n\n\t// Get only relevant JS files\n\tconst files = await recursivelyGetFiles(compiledDirectoryPath);\n\n\t// Process files in parallel\n\tconst schemaPromises: Promise<Schema | null>[] = files.map(async (filePath) => {\n\t\ttry {\n\t\t\tconst content = await fs.readFile(filePath, 'utf-8');\n\t\t\tconst moduleData = await processModule(content);\n\n\t\t\tif (!moduleData?.schema) return null;\n\n\t\t\tconst schema = moduleData.schema as Schema;\n\n\t\t\t// Generate clean path relative to the root collection folder\n\t\t\tconst collectionPath = extractCollectionPath(filePath, compiledDirectoryPath);\n\n\t\t\t// Use file name as fallback name if schema doesn't provide one\n\t\t\tconst fileName = path.basename(filePath, '.js');\n\n\t\t\treturn {\n\t\t\t\t...schema,\n\t\t\t\t_id: schema._id!, // The _id from the file is the source of truth\n\t\t\t\tpath: collectionPath, // Directory structure determines path\n\t\t\t\tname: schema.name || fileName,\n\t\t\t\ttenantId: schema.tenantId ?? undefined\n\t\t\t} as Schema;\n\t\t} catch (error) {\n\t\t\tlogger.warn(`Could not process collection file: ${filePath}`, error);\n\t\t\treturn null;\n\t\t}\n\t});\n\n\tconst results = await Promise.all(schemaPromises);\n\tconst schemas = results.filter((s): s is Schema => s !== null);\n\n\tlogger.trace(`Scanned ${schemas.length} collection schemas from filesystem.`);\n\treturn schemas;\n}\n"],"names":[],"mappings":";;;;AAiCA,eAAe,oBAAoB,KAAgC;AAClE,QAAM,UAAU,MAAM,GAAG,QAAQ,KAAK,EAAE,eAAe,MAAM;AAE7D,QAAM,QAAQ,MAAM,QAAQ;AAAA,IAC3B,QAAQ,IAAI,OAAO,UAAU;AAC5B,YAAM,WAAW,KAAK,KAAK,KAAK,MAAM,IAAI;AAE1C,UAAI,MAAM,eAAe;AACxB,eAAO,oBAAoB,QAAQ;AAAA,MACpC,WAAW,MAAM,OAAA,KAAY,MAAM,KAAK,SAAS,KAAK,GAAG;AACxD,eAAO,CAAC,QAAQ;AAAA,MACjB;AACA,aAAO,CAAA;AAAA,IACR,CAAC;AAAA,EAAA;AAGF,SAAO,MAAM,KAAA;AACd;AAMA,SAAS,sBAAsB,UAAkB,SAAyB;AAEzE,QAAM,WAAW,KAAK,SAAS,SAAS,QAAQ;AAGhD,QAAM,aAAa,SAAS,QAAQ,SAAS,EAAE;AAG/C,QAAM,aAAa,WAAW,MAAM,KAAK,GAAG,EAAE,KAAK,GAAG;AAGtD,SAAO,WAAW,WAAW,GAAG,IAAI,aAAa,IAAI,UAAU;AAChE;AAQA,eAAsB,0BAA6C;AAClE,QAAM,SAAS,QAAQ,IAAI,mBAAmB,QAAQ,IAAI,sBAAsB;AAGhF,QAAM,wBAAwB,KAAK,QAAQ,QAAQ,IAAA,GAAO,MAAM;AAEhE,MAAI;AACH,UAAM,GAAG,OAAO,qBAAqB;AAAA,EACtC,QAAQ;AACP,WAAO,MAAM,gDAAgD,qBAAqB,yBAAyB;AAC3G,WAAO,CAAA;AAAA,EACR;AAGA,QAAM,QAAQ,MAAM,oBAAoB,qBAAqB;AAG7D,QAAM,iBAA2C,MAAM,IAAI,OAAO,aAAa;AAC9E,QAAI;AACH,YAAM,UAAU,MAAM,GAAG,SAAS,UAAU,OAAO;AACnD,YAAM,aAAa,MAAM,cAAc,OAAO;AAE9C,UAAI,CAAC,YAAY,OAAQ,QAAO;AAEhC,YAAM,SAAS,WAAW;AAG1B,YAAM,iBAAiB,sBAAsB,UAAU,qBAAqB;AAG5E,YAAM,WAAW,KAAK,SAAS,UAAU,KAAK;AAE9C,aAAO;AAAA,QACN,GAAG;AAAA,QACH,KAAK,OAAO;AAAA;AAAA,QACZ,MAAM;AAAA;AAAA,QACN,MAAM,OAAO,QAAQ;AAAA,QACrB,UAAU,OAAO,YAAY;AAAA,MAAA;AAAA,IAE/B,SAAS,OAAO;AACf,aAAO,KAAK,sCAAsC,QAAQ,IAAI,KAAK;AACnE,aAAO;AAAA,IACR;AAAA,EACD,CAAC;AAED,QAAM,UAAU,MAAM,QAAQ,IAAI,cAAc;AAChD,QAAM,UAAU,QAAQ,OAAO,CAAC,MAAmB,MAAM,IAAI;AAE7D,SAAO,MAAM,WAAW,QAAQ,MAAM,sCAAsC;AAC5E,SAAO;AACR;"}