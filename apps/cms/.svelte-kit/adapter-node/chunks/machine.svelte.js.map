{"version":3,"file":"machine.svelte.js","sources":["../../../../../../node_modules/@skeletonlabs/skeleton-svelte/dist/internal/create-context.js","../../../../../../node_modules/@zag-js/svelte/dist/normalize-props.js","../../../../../../node_modules/@zag-js/svelte/dist/merge-props.js","../../../../../../node_modules/@zag-js/svelte/dist/bindable.svelte.js","../../../../../../node_modules/@zag-js/svelte/dist/refs.svelte.js","../../../../../../node_modules/@zag-js/svelte/dist/track.svelte.js","../../../../../../node_modules/@zag-js/svelte/dist/machine.svelte.js"],"sourcesContent":["import { getContext, setContext } from 'svelte';\nexport function createContext(defaultValue) {\n    const key = Symbol();\n    return {\n        key,\n        consume() {\n            return getContext(key) || defaultValue;\n        },\n        provide(value) {\n            return setContext(key, value);\n        },\n    };\n}\n","import { createNormalizer } from \"@zag-js/types\";\nconst propMap = {\n    className: \"class\",\n    defaultChecked: \"checked\",\n    defaultValue: \"value\",\n    htmlFor: \"for\",\n    onBlur: \"onfocusout\",\n    onChange: \"oninput\",\n    onFocus: \"onfocusin\",\n    onDoubleClick: \"ondblclick\",\n};\nexport function toStyleString(style) {\n    let string = \"\";\n    for (let key in style) {\n        /**\n         * Ignore null and undefined values.\n         */\n        const value = style[key];\n        if (value === null || value === undefined)\n            continue;\n        /**\n         * Convert camelCase to kebab-case except for CSS custom properties.\n         */\n        if (!key.startsWith(\"--\"))\n            key = key.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n        string += `${key}:${value};`;\n    }\n    return string;\n}\nconst preserveKeys = new Set(\"viewBox,className,preserveAspectRatio,fillRule,clipPath,clipRule,strokeWidth,strokeLinecap,strokeLinejoin,strokeDasharray,strokeDashoffset,strokeMiterlimit\".split(\",\"));\nfunction toSvelteProp(key) {\n    if (key in propMap)\n        return propMap[key];\n    if (preserveKeys.has(key))\n        return key;\n    return key.toLowerCase();\n}\nfunction toSveltePropValue(key, value) {\n    if (key === \"style\" && typeof value === \"object\")\n        return toStyleString(value);\n    return value;\n}\nexport const normalizeProps = createNormalizer((props) => {\n    const normalized = {};\n    for (const key in props) {\n        normalized[toSvelteProp(key)] = toSveltePropValue(key, props[key]);\n    }\n    return normalized;\n});\n","import { mergeProps as zagMergeProps } from \"@zag-js/core\";\nimport { toStyleString } from \"./normalize-props\";\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nconst serialize = (style) => {\n    const res = {};\n    let match;\n    while ((match = CSS_REGEX.exec(style))) {\n        res[match[1]] = match[2];\n    }\n    return res;\n};\nexport function mergeProps(...args) {\n    // Collect all class values (as-is, without conversion)\n    // Svelte 5.15+ supports ClassValue types (string | array | object) and handles\n    // the conversion internally using clsx. We collect them into an array and let\n    // Svelte's native class handling resolve them at render time.\n    // @see https://github.com/sveltejs/svelte/pull/14714\n    const classNames = [];\n    for (const props of args) {\n        if (!props)\n            continue;\n        if (\"class\" in props && props.class != null) {\n            classNames.push(props.class);\n        }\n    }\n    const merged = zagMergeProps(...args);\n    // Override class with our collected values\n    // If only one value, return as-is; if multiple, return as array\n    if (classNames.length > 0) {\n        merged.class = classNames.length === 1 ? classNames[0] : classNames;\n    }\n    if (\"style\" in merged) {\n        if (typeof merged.style === \"string\") {\n            merged.style = serialize(merged.style);\n        }\n        merged.style = toStyleString(merged.style);\n    }\n    return merged;\n}\n","import { identity, isFunction } from \"@zag-js/utils\";\nimport { flushSync, onDestroy, untrack } from \"svelte\";\nexport function bindable(props) {\n    const initial = props().defaultValue ?? props().value;\n    const eq = props().isEqual ?? Object.is;\n    let value = $state(initial);\n    const controlled = $derived(props().value !== undefined);\n    let valueRef = { current: untrack(() => value) };\n    let prevValue = { current: undefined };\n    $effect.pre(() => {\n        const v = controlled ? props().value : value;\n        valueRef = { current: v };\n        prevValue = { current: v };\n    });\n    const setValueFn = (v) => {\n        const next = isFunction(v) ? v(valueRef.current) : v;\n        const prev = prevValue.current;\n        if (props().debug) {\n            console.log(`[bindable > ${props().debug}] setValue`, { next, prev });\n        }\n        if (!controlled)\n            value = next;\n        if (!eq(next, prev)) {\n            props().onChange?.(next, prev);\n        }\n    };\n    function get() {\n        return (controlled ? props().value : value);\n    }\n    return {\n        initial,\n        ref: valueRef,\n        get,\n        set(val) {\n            const exec = props().sync ? flushSync : identity;\n            exec(() => setValueFn(val));\n        },\n        invoke(nextValue, prevValue) {\n            props().onChange?.(nextValue, prevValue);\n        },\n        hash(value) {\n            return props().hash?.(value) ?? String(value);\n        },\n    };\n}\nbindable.cleanup = (fn) => {\n    onDestroy(() => fn());\n};\nbindable.ref = (defaultValue) => {\n    let value = defaultValue;\n    return {\n        get: () => value,\n        set: (next) => {\n            value = next;\n        },\n    };\n};\n","export function useRefs(refs) {\n    const ref = { current: refs };\n    return {\n        get(key) {\n            return ref.current[key];\n        },\n        set(key, value) {\n            ref.current[key] = value;\n        },\n    };\n}\n","import { isEqual } from \"@zag-js/utils\";\nconst access = (value) => {\n    if (typeof value === \"function\")\n        return value();\n    return value;\n};\nexport const track = (deps, effect) => {\n    let prevDeps = [];\n    let isFirstRun = true;\n    $effect(() => {\n        if (isFirstRun) {\n            prevDeps = deps.map((d) => access(d));\n            isFirstRun = false;\n            return;\n        }\n        let changed = false;\n        for (let i = 0; i < deps.length; i++) {\n            if (!isEqual(prevDeps[i], access(deps[i]))) {\n                changed = true;\n                break;\n            }\n        }\n        if (changed) {\n            prevDeps = deps.map((d) => access(d));\n            effect();\n        }\n    });\n};\n","import { createScope, INIT_STATE, MachineStatus } from \"@zag-js/core\";\nimport { compact, ensure, isFunction, isString, toArray, warn } from \"@zag-js/utils\";\nimport { flushSync, onDestroy, onMount } from \"svelte\";\nimport { bindable } from \"./bindable.svelte\";\nimport { useRefs } from \"./refs.svelte\";\nimport { track } from \"./track.svelte\";\nfunction access(userProps) {\n    if (isFunction(userProps))\n        return userProps();\n    return userProps;\n}\nexport function useMachine(machine, userProps) {\n    const scope = $derived.by(() => {\n        const { id, ids, getRootNode } = access(userProps);\n        return createScope({ id, ids, getRootNode });\n    });\n    const debug = (...args) => {\n        if (machine.debug)\n            console.log(...args);\n    };\n    const props = $derived(machine.props?.({ props: compact(access(userProps)), scope }) ?? access(userProps));\n    const prop = useProp(() => props);\n    const context = machine.context?.({\n        prop,\n        bindable: bindable,\n        get scope() {\n            return scope;\n        },\n        flush: flush,\n        getContext() {\n            return ctx;\n        },\n        getComputed() {\n            return computed;\n        },\n        getRefs() {\n            return refs;\n        },\n        getEvent() {\n            return getEvent();\n        },\n    });\n    const ctx = {\n        get(key) {\n            return context?.[key].get();\n        },\n        set(key, value) {\n            context?.[key].set(value);\n        },\n        initial(key) {\n            return context?.[key].initial;\n        },\n        hash(key) {\n            const current = context?.[key].get();\n            return context?.[key].hash(current);\n        },\n    };\n    let effects = new Map();\n    let transitionRef = { current: null };\n    let previousEventRef = { current: null };\n    let eventRef = { current: { type: \"\" } };\n    const getEvent = () => ({\n        ...eventRef.current,\n        current() {\n            return eventRef.current;\n        },\n        previous() {\n            return previousEventRef.current;\n        },\n    });\n    const getState = () => ({\n        ...state,\n        hasTag(tag) {\n            const currentState = state.get();\n            return !!machine.states[currentState]?.tags?.includes(tag);\n        },\n        matches(...values) {\n            const currentState = state.get();\n            return values.includes(currentState);\n        },\n    });\n    const refs = useRefs(machine.refs?.({ prop, context: ctx }) ?? {});\n    const getParams = () => ({\n        state: getState(),\n        context: ctx,\n        event: getEvent(),\n        prop,\n        send,\n        action,\n        guard,\n        track,\n        refs,\n        computed,\n        flush,\n        scope,\n        choose,\n    });\n    const action = (keys) => {\n        const strs = isFunction(keys) ? keys(getParams()) : keys;\n        if (!strs)\n            return;\n        const fns = strs.map((s) => {\n            const fn = machine.implementations?.actions?.[s];\n            if (!fn)\n                warn(`[zag-js] No implementation found for action \"${JSON.stringify(s)}\"`);\n            return fn;\n        });\n        for (const fn of fns) {\n            fn?.(getParams());\n        }\n    };\n    const guard = (str) => {\n        if (isFunction(str))\n            return str(getParams());\n        return machine.implementations?.guards?.[str](getParams());\n    };\n    const effect = (keys) => {\n        const strs = isFunction(keys) ? keys(getParams()) : keys;\n        if (!strs)\n            return;\n        const fns = strs.map((s) => {\n            const fn = machine.implementations?.effects?.[s];\n            if (!fn)\n                warn(`[zag-js] No implementation found for effect \"${JSON.stringify(s)}\"`);\n            return fn;\n        });\n        const cleanups = [];\n        for (const fn of fns) {\n            const cleanup = fn?.(getParams());\n            if (cleanup)\n                cleanups.push(cleanup);\n        }\n        return () => cleanups.forEach((fn) => fn?.());\n    };\n    const choose = (transitions) => {\n        return toArray(transitions).find((t) => {\n            let result = !t.guard;\n            if (isString(t.guard))\n                result = !!guard(t.guard);\n            else if (isFunction(t.guard))\n                result = t.guard(getParams());\n            return result;\n        });\n    };\n    const computed = (key) => {\n        ensure(machine.computed, () => `[zag-js] No computed object found on machine`);\n        const fn = machine.computed[key];\n        return fn({\n            context: ctx,\n            event: getEvent(),\n            prop,\n            refs,\n            scope,\n            computed: computed,\n        });\n    };\n    const state = bindable(() => ({\n        defaultValue: machine.initialState({ prop }),\n        onChange(nextState, prevState) {\n            // compute effects: exit -> transition -> enter\n            // exit effects\n            if (prevState) {\n                const exitEffects = effects.get(prevState);\n                exitEffects?.();\n                effects.delete(prevState);\n            }\n            // exit actions\n            if (prevState) {\n                action(machine.states[prevState]?.exit);\n            }\n            // transition actions\n            action(transitionRef.current?.actions);\n            // enter effect\n            const cleanup = effect(machine.states[nextState]?.effects);\n            if (cleanup)\n                effects.set(nextState, cleanup);\n            // root entry actions\n            if (prevState === INIT_STATE) {\n                action(machine.entry);\n                const cleanup = effect(machine.effects);\n                if (cleanup)\n                    effects.set(INIT_STATE, cleanup);\n            }\n            // enter actions\n            action(machine.states[nextState]?.entry);\n        },\n    }));\n    let status = MachineStatus.NotStarted;\n    onMount(() => {\n        const started = status === MachineStatus.Started;\n        status = MachineStatus.Started;\n        debug(started ? \"rehydrating...\" : \"initializing...\");\n        state.invoke(state.initial, INIT_STATE);\n    });\n    onDestroy(() => {\n        debug(\"unmounting...\");\n        status = MachineStatus.Stopped;\n        effects.forEach((fn) => fn?.());\n        effects = new Map();\n        transitionRef.current = null;\n        action(machine.exit);\n    });\n    const send = (event) => {\n        if (status !== MachineStatus.Started)\n            return;\n        previousEventRef.current = eventRef.current;\n        eventRef.current = event;\n        let currentState = state.get();\n        // @ts-ignore\n        const transitions = machine.states[currentState].on?.[event.type] ?? machine.on?.[event.type];\n        const transition = choose(transitions);\n        if (!transition)\n            return;\n        // save current transition\n        transitionRef.current = transition;\n        const target = transition.target ?? currentState;\n        debug(\"transition\", event.type, transition.target || currentState, `(${transition.actions})`);\n        const changed = target !== currentState;\n        if (changed) {\n            // state change is high priority\n            state.set(target);\n        }\n        else if (transition.reenter && !changed) {\n            // reenter will re-invoke the current state\n            state.invoke(currentState, currentState);\n        }\n        else {\n            // call transition actions\n            action(transition.actions);\n        }\n    };\n    machine.watch?.(getParams());\n    return {\n        get state() {\n            return getState();\n        },\n        send,\n        context: ctx,\n        prop,\n        get scope() {\n            return scope;\n        },\n        refs,\n        computed,\n        get event() {\n            return getEvent();\n        },\n        getStatus: () => status,\n    };\n}\nfunction useProp(value) {\n    return function get(key) {\n        return value()[key];\n    };\n}\nfunction flush(fn) {\n    flushSync(() => {\n        queueMicrotask(() => fn());\n    });\n}\n"],"names":["zagMergeProps","untrack","flushSync","prevValue","value","cleanup"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}