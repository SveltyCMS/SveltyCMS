{"version":3,"file":"mongoDBUtils.js","sources":["../../../../../../shared/database/src/mongodb/methods/mongoDBUtils.ts"],"sourcesContent":["/**\n * @file src/databases/mongodb/methods/mongoDBUtils.ts\n * @description A comprehensive suite of shared utility functions for the MongoDB adapter.\n * This module provides robust, performant, and type-safe helpers for error handling,\n * data processing, performance monitoring, and intelligent caching.\n */\n\nimport type { DatabaseId } from '@cms-types/content';\nimport { logger } from '@shared/utils/logger.server';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { DatabaseError, PaginatedResult, PaginationOptions } from '../../dbInterface';\n\n// Pre-compiled regex for UUIDv4 validation (with or without dashes) for performance.\nconst ID_VALIDATION_REGEX = /^([0-9a-f]{32}|[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})$/i;\n\n// ===================================================================================\n// Error Handling\n// ===================================================================================\n\n/**\n * Creates a structured DatabaseError with consistent, detailed logging.\n * @param error The original error caught.\n * @param code A unique code for the error type (e.g., 'FETCH_FAILED').\n * @param message A human-readable message describing the error.\n * @returns A standardized DatabaseError object.\n */\nexport function createDatabaseError(error: unknown, code: string, message: string): DatabaseError {\n\tconst details = error instanceof Error ? error.message : String(error);\n\tconst stack = error instanceof Error ? error.stack : undefined;\n\n\t// Log with structured context for better diagnostics.\n\tlogger.error(`[${code}] ${message}`, { details, stack });\n\n\treturn { code, message, details, stack };\n}\n\n// ===================================================================================\n// ID & Naming Conventions\n// ===================================================================================\n\n/**\n * Generates a compact, dash-less UUID, ideal for database identifiers.\n */\nexport function generateId(): DatabaseId {\n\treturn uuidv4().replace(/-/g, '') as DatabaseId;\n}\n\n/**\n * Validates if a string is a UUIDv4 (with or without dashes).\n */\nexport function validateId(id: string): boolean {\n\treturn ID_VALIDATION_REGEX.test(id);\n}\n\n/**\n * Normalizes collection names according to the CMS's conventions.\n * - `media_` and `auth_` prefixes are preserved.\n * - All other names are prefixed with `collection_` unless already present.\n */\nexport function normalizeCollectionName(collection: string): string {\n\tif (collection.startsWith('media_') || collection.startsWith('auth_')) {\n\t\treturn collection;\n\t}\n\treturn collection.startsWith('collection_') ? collection : `collection_${collection}`;\n}\n\n// ===================================================================================\n// Data Processing & Transformation\n// ===================================================================================\n\n/**\n * Checks if a value is a Date-like object (i.e., has a .toISOString method).\n */\nexport function isDateLike(val: unknown): val is { toISOString: () => string } {\n\t// Using `!!val` handles null/undefined, and checking for the function is more robust\n\t// than `instanceof Date` as it supports date-like objects from other libraries.\n\treturn !!val && typeof (val as Date).toISOString === 'function';\n}\n\n/**\n * Recursively traverses an object or array and converts all Date-like values into ISO 8601 strings.\n * This is essential for ensuring consistent date serialization to and from the database.\n * @param data The data structure (object, array, primitive) to process.\n * @returns A deep copy of the data with all dates converted to strings.\n */\nfunction isObjectIdLike(val: unknown): val is { toHexString: () => string } {\n\tif (!val || typeof val !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst candidate = val as { toHexString?: unknown; _bsontype?: unknown };\n\tconst hasToHexString = typeof candidate.toHexString === 'function';\n\tconst bsonType = typeof candidate._bsontype === 'string' ? candidate._bsontype : undefined;\n\n\treturn hasToHexString && (!bsonType || bsonType === 'ObjectId' || bsonType === 'ObjectID');\n}\n\nexport function processDates<T>(data: T): T {\n\tif (!data) return data;\n\n\tif (isDateLike(data)) {\n\t\treturn data.toISOString() as unknown as T;\n\t}\n\n\tif (isObjectIdLike(data)) {\n\t\treturn data.toHexString() as unknown as T;\n\t}\n\n\tif (Array.isArray(data)) {\n\t\treturn data.map(processDates) as unknown as T;\n\t}\n\n\tif (typeof data === 'object') {\n\t\tconst result: Record<string, unknown> = {};\n\t\tfor (const key in data as Record<string, unknown>) {\n\t\t\t// Ensure we only process own properties.\n\t\t\tif (Object.prototype.hasOwnProperty.call(data, key)) {\n\t\t\t\tresult[key] = processDates((data as Record<string, unknown>)[key]);\n\t\t\t}\n\t\t}\n\t\treturn result as T;\n\t}\n\n\treturn data;\n}\n\n// ===================================================================================\n// Performance & Batching\n// ===================================================================================\n\n/**\n * A simple Least Recently Used (LRU) Cache to prevent memory leaks in long-running processes.\n */\nclass LRUCache<K, V> {\n\tprivate capacity: number;\n\tprivate cache: Map<K, V>;\n\n\tconstructor(capacity = 500) {\n\t\tthis.capacity = capacity;\n\t\tthis.cache = new Map<K, V>();\n\t}\n\n\tget(key: K): V | undefined {\n\t\tif (!this.cache.has(key)) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// Move to end to mark as recently used\n\t\tconst value = this.cache.get(key);\n\t\tif (value === undefined) return undefined;\n\t\tthis.cache.delete(key);\n\t\tthis.cache.set(key, value);\n\t\treturn value;\n\t}\n\n\tset(key: K, value: V): void {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.delete(key);\n\t\t} else if (this.cache.size >= this.capacity) {\n\t\t\t// Evict the least recently used item\n\t\t\tconst firstKey = this.cache.keys().next().value as K | undefined;\n\t\t\tif (firstKey !== undefined) {\n\t\t\t\tthis.cache.delete(firstKey);\n\t\t\t}\n\t\t}\n\t\tthis.cache.set(key, value);\n\t}\n}\n\nconst pathNormalizationCache = new LRUCache<string, string>(1000);\n\n/**\n * Normalizes file paths for cross-platform compatibility (e.g., converting '\\\\' to '/').\n * Uses an LRU cache for high-performance repeated operations.\n */\nexport const normalizePath = (path: string): string => {\n\tconst cached = pathNormalizationCache.get(path);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst normalized = path.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n\tpathNormalizationCache.set(path, normalized);\n\n\treturn normalized;\n};\n\n/**\n * A higher-order function that wraps an async operation to monitor its performance.\n * It logs warnings for slow operations, aiding in performance tuning.\n * @param operation A descriptive name for the operation being monitored.\n * @param fn The async function to execute and monitor.\n */\nexport const withPerformanceMonitoring = async <T>(operation: string, fn: () => Promise<T>): Promise<T> => {\n\tconst startTime = performance.now();\n\ttry {\n\t\tconst result = await fn();\n\t\tconst duration = performance.now() - startTime;\n\n\t\tif (duration > 1000) {\n\t\t\tlogger.warn(`Slow Operation: '${operation}' took ${duration.toFixed(2)}ms`);\n\t\t} else {\n\t\t\tlogger.debug(`Operation: '${operation}' took ${duration.toFixed(2)}ms`);\n\t\t}\n\t\treturn result;\n\t} catch (error) {\n\t\tconst duration = performance.now() - startTime;\n\t\tlogger.error(`Failed Operation: '${operation}' failed after ${duration.toFixed(2)}ms`, error);\n\t\tthrow error;\n\t}\n};\n\n/**\n * Creates an in-memory paginated result from an array of items.\n * @param items The full array of items to paginate\n * @param options Pagination options (page, pageSize)\n */\nexport function createPagination<T>(items: T[], options: PaginationOptions): PaginatedResult<T> {\n\tconst page = options.page || 1;\n\tconst pageSize = options.pageSize || 10;\n\tconst total = items.length;\n\tconst totalPages = Math.ceil(total / pageSize);\n\tconst startIndex = (page - 1) * pageSize;\n\tconst endIndex = Math.min(startIndex + pageSize, total);\n\n\treturn {\n\t\titems: items.slice(startIndex, endIndex),\n\t\tpage,\n\t\tpageSize,\n\t\ttotal,\n\t\thasNextPage: page < totalPages,\n\t\thasPreviousPage: page > 1\n\t};\n}\n"],"names":["uuidv4"],"mappings":"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"}