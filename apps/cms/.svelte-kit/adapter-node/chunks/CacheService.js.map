{"version":3,"file":"CacheService.js","sources":["../../../../../../shared/database/src/CacheService.ts"],"sourcesContent":["/**\n * @file src/databases/CacheService.ts\n * @description Unified caching service for the CMS (in-memory or Redis), with optional tenant-aware keys.\n *\n * Features:\n * - Dynamic cache store selection based on environment configuration\n * - In-memory caching for development and testing\n * - Redis caching for production\n * - Tenant-aware keys for multi-tenant environments\n */\n\n// Safe import for test environment\nlet browser = false;\ntry {\n\tconst appEnv = await import('$app/environment');\n\tbrowser = appEnv.browser;\n} catch {\n\t// Running in test environment or outside SvelteKit context\n\tbrowser = false;\n}\n\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport type { RedisClientType } from 'redis';\n// System Logger - use universal logger for client/server compatibility\nimport { logger } from '@shared/utils/logger';\nimport { CacheCategory } from './CacheCategory';\n\n// Cache config will be loaded lazily when cache is initialized\nlet CACHE_CONFIG: {\n\tUSE_REDIS: boolean;\n\tURL: string;\n\tPASSWORD?: string;\n\tRETRY_ATTEMPTS: number;\n\tRETRY_DELAY: number;\n} | null = null;\n\nfunction getCacheConfig() {\n\tif (!CACHE_CONFIG) {\n\t\tconst USE_REDIS = getPrivateSettingSync('USE_REDIS');\n\t\tconst REDIS_HOST = getPrivateSettingSync('REDIS_HOST');\n\t\tconst REDIS_PORT = getPrivateSettingSync('REDIS_PORT');\n\t\tconst REDIS_PASSWORD = getPrivateSettingSync('REDIS_PASSWORD');\n\n\t\tCACHE_CONFIG = {\n\t\t\tUSE_REDIS: USE_REDIS === true, // Ensure boolean type\n\t\t\tURL: `redis://${REDIS_HOST}:${REDIS_PORT}`,\n\t\t\tPASSWORD: REDIS_PASSWORD || undefined,\n\t\t\tRETRY_ATTEMPTS: 3,\n\t\t\tRETRY_DELAY: 2000\n\t\t};\n\t}\n\treturn CACHE_CONFIG;\n}\n\ninterface ICacheStore {\n\tinitialize(): Promise<void>;\n\tget<T>(key: string): Promise<T | null>;\n\tset<T>(key: string, value: T, ttlSeconds: number): Promise<void>;\n\tdelete(key: string | string[]): Promise<void>;\n\tclearByPattern(pattern: string): Promise<void>;\n\tdisconnect(): Promise<void>;\n\tgetClient(): RedisClientType | null;\n}\n\nclass InMemoryStore implements ICacheStore {\n\tprivate cache = new Map<string, { value: string; expiresAt: number }>();\n\tprivate isInitialized = false;\n\tprivate interval: ReturnType<typeof setInterval> | null = null;\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.isInitialized) return;\n\t\tthis.interval = setInterval(() => this.cleanup(), 60_000);\n\t\tthis.isInitialized = true;\n\t\tlogger.info('In-memory cache initialized.');\n\t}\n\n\tprivate cleanup() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, item] of this.cache.entries()) {\n\t\t\tif (item.expiresAt < now) this.cache.delete(key);\n\t\t}\n\t}\n\n\tasync get<T>(key: string): Promise<T | null> {\n\t\tconst item = this.cache.get(key);\n\t\tif (!item) return null;\n\t\tif (item.expiresAt < Date.now()) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn null;\n\t\t}\n\t\treturn JSON.parse(item.value) as T;\n\t}\n\n\tasync set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {\n\t\tconst expiresAt = Date.now() + ttlSeconds * 1000;\n\t\tthis.cache.set(key, { value: JSON.stringify(value), expiresAt });\n\t}\n\n\tasync delete(key: string | string[]): Promise<void> {\n\t\tconst keys = Array.isArray(key) ? key : [key];\n\t\tkeys.forEach((k) => this.cache.delete(k));\n\t}\n\n\tasync clearByPattern(pattern: string): Promise<void> {\n\t\tconst regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n\t\tfor (const key of this.cache.keys()) {\n\t\t\tif (regex.test(key)) this.cache.delete(key);\n\t\t}\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tthis.cache.clear();\n\t\tif (this.interval) clearInterval(this.interval);\n\t\tlogger.info('In-memory cache cleared.');\n\t}\n\n\tgetClient(): RedisClientType | null {\n\t\treturn null;\n\t}\n}\n\nclass RedisStore implements ICacheStore {\n\tprivate client: RedisClientType | null = null;\n\tprivate isInitialized = false;\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.isInitialized || browser) return;\n\t\tconst config = getCacheConfig();\n\t\tif (!config) {\n\t\t\tthrow new Error('Cache configuration is not available');\n\t\t}\n\n\t\t// Use DatabaseResilience for automatic retry with exponential backoff\n\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\tconst resilience = getDatabaseResilience({\n\t\t\tmaxAttempts: config.RETRY_ATTEMPTS,\n\t\t\tinitialDelayMs: config.RETRY_DELAY,\n\t\t\tbackoffMultiplier: 2,\n\t\t\tmaxDelayMs: 30000, // Max 30s delay\n\t\t\tjitterMs: 500\n\t\t});\n\n\t\tawait resilience.executeWithRetry(async () => {\n\t\t\tconst { createClient } = await import('redis');\n\t\t\tthis.client = createClient({ url: config.URL, password: config.PASSWORD });\n\t\t\tthis.client.on('error', (err) => logger.error('Redis Client Error', err));\n\t\t\tthis.client.on('reconnecting', () => logger.warn('Reconnecting to Redis...'));\n\t\t\tawait this.client.connect();\n\t\t\tthis.isInitialized = true;\n\t\t\tlogger.info('Redis client connected successfully.');\n\t\t}, 'Redis Connection');\n\t}\n\n\tprivate async ensureReady(): Promise<void> {\n\t\tif (!this.client || !this.isInitialized) {\n\t\t\tthrow new Error('Redis client is not initialized. Call initialize() first.');\n\t\t}\n\t\tif (!this.client.isOpen) {\n\t\t\tawait this.client.connect();\n\t\t}\n\t}\n\n\tasync get<T>(key: string): Promise<T | null> {\n\t\tawait this.ensureReady();\n\t\tconst value = await this.client!.get(key);\n\t\treturn value ? (JSON.parse(value) as T) : null;\n\t}\n\n\tasync set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tawait this.client!.set(key, JSON.stringify(value), { EX: ttlSeconds });\n\t}\n\n\tasync delete(key: string | string[]): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tif (Array.isArray(key)) await this.client!.del(key);\n\t\telse await this.client!.del(key);\n\t}\n\n\tasync clearByPattern(pattern: string): Promise<void> {\n\t\tawait this.ensureReady();\n\t\tlet cursor: string = '0';\n\t\tdo {\n\t\t\tconst result = await this.client!.scan(cursor, { MATCH: pattern, COUNT: 100 });\n\t\t\tcursor = result.cursor; // Redis returns cursor as string\n\t\t\tif (result.keys.length > 0) await this.client!.del(result.keys);\n\t\t} while (cursor !== '0');\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tif (this.client?.isOpen) await this.client.quit();\n\t\tthis.isInitialized = false;\n\t\tlogger.info('Redis connection closed.');\n\t}\n\n\tgetClient(): RedisClientType | null {\n\t\treturn this.client;\n\t}\n}\n\nclass CacheService {\n\tprivate static instance: CacheService;\n\tprivate store: ICacheStore;\n\tprivate initialized = false;\n\tprivate initPromise: Promise<void> | null = null;\n\tprivate prefetchPatterns: PrefetchPattern[] = [];\n\tprivate accessLog: Map<string, number[]> = new Map(); // Track access times for analytics\n\n\tprivate constructor() {\n\t\tconst config = getCacheConfig();\n\t\tthis.store = !browser && config.USE_REDIS ? new RedisStore() : new InMemoryStore();\n\t}\n\n\tstatic getInstance(): CacheService {\n\t\tif (!CacheService.instance) CacheService.instance = new CacheService();\n\t\treturn CacheService.instance;\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\tif (this.initialized) return;\n\t\tif (!this.initPromise) {\n\t\t\tthis.initPromise = this.store.initialize().then(() => {\n\t\t\t\tthis.initialized = true;\n\t\t\t});\n\t\t}\n\t\tawait this.initPromise;\n\t}\n\n\tprivate async ensureInitialized() {\n\t\tif (!this.initialized) {\n\t\t\tawait this.initialize();\n\t\t}\n\t}\n\n\tprivate generateKey(baseKey: string, tenantId?: string): string {\n\t\t// If the caller already supplied a fully-qualified tenant-prefixed key, respect it\n\t\tif (baseKey.startsWith('tenant:')) return baseKey;\n\t\tif (getPrivateSettingSync('MULTI_TENANT')) {\n\t\t\tconst tenant = tenantId || 'default';\n\t\t\treturn `tenant:${tenant}:${baseKey}`;\n\t\t}\n\t\treturn baseKey;\n\t}\n\n\t// Track cache access for analytics and predictive prefetching\n\tprivate trackAccess(key: string): void {\n\t\tconst now = Date.now();\n\t\tconst accesses = this.accessLog.get(key) || [];\n\t\taccesses.push(now);\n\n\t\t// Keep only last 100 accesses per key\n\t\tif (accesses.length > 100) {\n\t\t\taccesses.shift();\n\t\t}\n\n\t\tthis.accessLog.set(key, accesses);\n\t}\n\n\t// Check if a key should be predictively prefetched based on patterns\n\tprivate async checkPrefetch(key: string, tenantId?: string): Promise<void> {\n\t\tfor (const pattern of this.prefetchPatterns) {\n\t\t\tif (pattern.pattern.test(key)) {\n\t\t\t\tconst keysToFetch = pattern.prefetchKeys(key);\n\t\t\t\tif (keysToFetch.length > 0 && pattern.fetcher) {\n\t\t\t\t\t// Execute prefetch in background\n\t\t\t\t\tvoid this.executePrefetch(keysToFetch, pattern.fetcher, pattern.category, tenantId);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async executePrefetch(\n\t\tkeys: string[],\n\t\tfetcher: (keys: string[]) => Promise<Record<string, unknown>>,\n\t\tcategory?: CacheCategory,\n\t\ttenantId?: string\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// 1. Filter out keys that are already cached\n\t\t\tconst missingKeys: string[] = [];\n\t\t\tfor (const key of keys) {\n\t\t\t\t// const cached = await this.get(key, tenantId); // This tracks access, might skew analytics?\n\t\t\t\t// Actually, we should check existence without tracking access if possible, or just accept it.\n\t\t\t\t// For now, let's just fetch everything to be safe and ensure freshness,\n\t\t\t\t// or assume the fetcher is efficient.\n\t\t\t\t// Optimization: Check cache existence first.\n\t\t\t\tconst fullKey = this.generateKey(key, tenantId);\n\t\t\t\tconst exists = await this.store.get(fullKey); // Direct store access to avoid recursion/tracking\n\t\t\t\tif (!exists) {\n\t\t\t\t\tmissingKeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (missingKeys.length === 0) return;\n\n\t\t\tlogger.debug(`Prefetching ${missingKeys.length} missing keys`);\n\n\t\t\t// 2. Fetch data\n\t\t\tconst dataMap = await fetcher(missingKeys);\n\n\t\t\t// 3. Cache data\n\t\t\tconst ttl = category ? getCategoryTTL(category) : REDIS_TTL_S;\n\t\t\tfor (const [key, value] of Object.entries(dataMap)) {\n\t\t\t\tawait this.set(key, value, ttl, tenantId, category);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.warn('Predictive prefetch failed:', error);\n\t\t}\n\t}\n\n\tasync get<T>(baseKey: string, tenantId?: string, _category?: CacheCategory): Promise<T | null> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\n\t\t// Track access\n\t\tthis.trackAccess(key);\n\n\t\t// Check for predictive prefetch opportunities\n\t\tvoid this.checkPrefetch(key, tenantId);\n\n\t\treturn this.store.get<T>(key);\n\t}\n\n\tasync set<T>(baseKey: string, value: T, ttlSeconds: number, tenantId?: string, category?: CacheCategory): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\n\t\t// Use category-specific TTL if category provided and no explicit TTL\n\t\tconst finalTTL = category && ttlSeconds === 0 ? getCategoryTTL(category) : ttlSeconds;\n\n\t\tawait this.store.set<T>(key, value, finalTTL);\n\t}\n\n\t// Set with automatic category-based TTL\n\tasync setWithCategory<T>(baseKey: string, value: T, category: CacheCategory, tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst key = this.generateKey(baseKey, tenantId);\n\t\tconst ttl = getCategoryTTL(category);\n\t\tawait this.store.set<T>(key, value, ttl);\n\t}\n\n\tasync delete(baseKey: string | string[], tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst keys = Array.isArray(baseKey) ? baseKey.map((k) => this.generateKey(k, tenantId)) : this.generateKey(baseKey, tenantId);\n\t\tawait this.store.delete(keys);\n\t}\n\n\tasync clearByPattern(pattern: string, tenantId?: string): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tconst keyPattern = this.generateKey(pattern, tenantId);\n\t\tawait this.store.clearByPattern(keyPattern);\n\t}\n\n\t/**\n\t * Warm cache with critical data\n\t * Useful for preloading frequently accessed data on startup\n\t */\n\tasync warmCache(config: WarmCacheConfig): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tlogger.info(`Warming cache for ${config.keys.length} keys in category ${config.category || 'default'}`);\n\n\t\ttry {\n\t\t\tconst data = await config.fetcher();\n\t\t\tconst ttl = config.category ? getCategoryTTL(config.category) : REDIS_TTL_S;\n\n\t\t\tfor (const key of config.keys) {\n\t\t\t\tawait this.set(key, data, ttl, config.tenantId, config.category);\n\t\t\t}\n\n\t\t\tlogger.info(`Cache warmed successfully for ${config.keys.length} keys`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Cache warming failed:', error);\n\t\t}\n\t}\n\n\t/**\n\t * Register a predictive prefetch pattern\n\t * When a key matching the pattern is accessed, related keys will be prefetched\n\t */\n\tregisterPrefetchPattern(pattern: PrefetchPattern): void {\n\t\tthis.prefetchPatterns.push(pattern);\n\t\tlogger.info(`Registered prefetch pattern: ${pattern.pattern.source}`);\n\t}\n\n\t// Get cache access analytics\n\tgetAccessAnalytics(key: string): { count: number; avgInterval: number; lastAccess: number } | null {\n\t\tconst accesses = this.accessLog.get(key);\n\t\tif (!accesses || accesses.length === 0) return null;\n\n\t\tconst count = accesses.length;\n\t\tconst lastAccess = accesses[accesses.length - 1];\n\n\t\t// Calculate average interval between accesses\n\t\tlet totalInterval = 0;\n\t\tfor (let i = 1; i < accesses.length; i++) {\n\t\t\ttotalInterval += accesses[i] - accesses[i - 1];\n\t\t}\n\t\tconst avgInterval = accesses.length > 1 ? totalInterval / (accesses.length - 1) : 0;\n\n\t\treturn { count, avgInterval, lastAccess };\n\t}\n\n\t/**\n\t * Get recommended TTL based on access patterns\n\t * Returns recommended TTL in seconds\n\t */\n\tgetRecommendedTTL(key: string): number | null {\n\t\tconst analytics = this.getAccessAnalytics(key);\n\t\tif (!analytics) return null;\n\n\t\t// If accessed frequently (avgInterval < 1 minute), use longer TTL\n\t\tif (analytics.avgInterval < 60000) {\n\t\t\treturn 600; // 10 minutes\n\t\t}\n\n\t\t// If accessed moderately (1-5 minutes), use medium TTL\n\t\tif (analytics.avgInterval < 300000) {\n\t\t\treturn 300; // 5 minutes\n\t\t}\n\n\t\t// Otherwise use short TTL\n\t\treturn 180; // 3 minutes\n\t}\n\n\t/**\n\t * Invalidate all cached data to force refresh\n\t * Useful when TTL settings are changed via the settings UI\n\t */\n\tasync invalidateAll(): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t\tlogger.info('ðŸ”„ Invalidating all cache entries due to configuration change');\n\n\t\t// For in-memory cache, we can just clear everything\n\t\tif (this.store instanceof InMemoryStore) {\n\t\t\tawait this.store.disconnect();\n\t\t\tawait this.store.initialize();\n\t\t} else if (this.store instanceof RedisStore) {\n\t\t\t// For Redis, clear by pattern (all keys)\n\t\t\tawait this.store.clearByPattern('*');\n\t\t}\n\n\t\tlogger.info('âœ… Cache invalidated successfully');\n\t}\n\n\t/**\n\t * Get current TTL configuration for all categories\n\t * Useful for displaying in admin UI\n\t */\n\tgetCurrentTTLConfig(): Record<string, number> {\n\t\treturn {\n\t\t\tschema: getCategoryTTL(CacheCategory.SCHEMA),\n\t\t\twidget: getCategoryTTL(CacheCategory.WIDGET),\n\t\t\ttheme: getCategoryTTL(CacheCategory.THEME),\n\t\t\tcontent: getCategoryTTL(CacheCategory.CONTENT),\n\t\t\tmedia: getCategoryTTL(CacheCategory.MEDIA),\n\t\t\tsession: getCategoryTTL(CacheCategory.SESSION),\n\t\t\tuser: getCategoryTTL(CacheCategory.USER),\n\t\t\tapi: getCategoryTTL(CacheCategory.API)\n\t\t};\n\t}\n\n\tgetRedisClient(): RedisClientType | null {\n\t\treturn this.store.getClient();\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tawait this.store.disconnect();\n\t}\n}\n\nexport const cacheService = CacheService.getInstance();\n\n// Helper functions to get dynamic TTLs from database settings\n// These allow runtime changes without server restart\n\n/**\n * Get SESSION cache TTL from database settings\n * @returns TTL in seconds (default: 86400 = 24 hours)\n */\nexport function getSessionCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.SESSION);\n}\n\n/**\n * Get USER permissions cache TTL from database settings\n * @returns TTL in seconds (default: 60 = 1 minute)\n */\nexport function getUserPermCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.USER);\n}\n\n/**\n * Get API response cache TTL from database settings\n * @returns TTL in seconds (default: 300 = 5 minutes)\n */\nexport function getApiCacheTTL(): number {\n\treturn getCategoryTTL(CacheCategory.API);\n}\n\n// Legacy exports for backward compatibility - now use dynamic values\n// Millisecond versions\nexport const SESSION_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // Default: 24 hours\nexport const USER_PERM_CACHE_TTL_MS = 60 * 1000; // Default: 1 minute\nexport const USER_COUNT_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes (not dynamically configured yet)\nexport const API_CACHE_TTL_MS = 5 * 60 * 1000; // Default: 5 minutes\n// Second versions - use getter functions for dynamic values\nexport const SESSION_CACHE_TTL_S = Math.ceil(SESSION_CACHE_TTL_MS / 1000);\nexport const USER_PERM_CACHE_TTL_S = Math.ceil(USER_PERM_CACHE_TTL_MS / 1000);\nexport const USER_COUNT_CACHE_TTL_S = Math.ceil(USER_COUNT_CACHE_TTL_MS / 1000);\nexport const API_CACHE_TTL_S = Math.ceil(API_CACHE_TTL_MS / 1000);\n// Generic Redis TTL\nexport const REDIS_TTL_S = 300; // 5 minutes in seconds for Redis\n\n/**\n * Cache category TTLs - Configurable via database settings\n * Defaults are used if not configured in the database\n */\n// CacheCategory enum now imported from ./CacheCategory.ts\n\n// Default TTLs (in seconds) if not configured in database\nconst DEFAULT_CATEGORY_TTLS: Record<CacheCategory, number> = {\n\t[CacheCategory.SCHEMA]: 600, // 10 minutes - schemas change rarely\n\t[CacheCategory.WIDGET]: 600, // 10 minutes - widget configs are relatively stable\n\t[CacheCategory.THEME]: 300, // 5 minutes - themes may update occasionally\n\t[CacheCategory.CONTENT]: 180, // 3 minutes - content updates frequently\n\t[CacheCategory.MEDIA]: 300, // 5 minutes - media metadata is fairly stable\n\t[CacheCategory.SESSION]: 86400, // 24 hours - user sessions\n\t[CacheCategory.USER]: 60, // 1 minute - user permissions (frequently checked)\n\t[CacheCategory.API]: 300 // 5 minutes - API responses\n};\n\n/**\n * Gets the TTL for a specific cache category\n * Checks database settings first (dynamically), falls back to defaults\n * This allows users to change TTLs via the settings UI without restarting\n */\nfunction getCategoryTTL(category: CacheCategory): number {\n\t// Map category to config key\n\tconst configKey = `CACHE_TTL_${category.toUpperCase()}` as\n\t\t| 'CACHE_TTL_SCHEMA'\n\t\t| 'CACHE_TTL_WIDGET'\n\t\t| 'CACHE_TTL_THEME'\n\t\t| 'CACHE_TTL_CONTENT'\n\t\t| 'CACHE_TTL_MEDIA'\n\t\t| 'CACHE_TTL_SESSION'\n\t\t| 'CACHE_TTL_USER'\n\t\t| 'CACHE_TTL_API';\n\n\ttry {\n\t\t// Try to get from dynamic settings (allows runtime changes)\n\t\tconst configuredTTL = getPrivateSettingSync(configKey);\n\n\t\tif (typeof configuredTTL === 'number' && configuredTTL > 0) {\n\t\t\treturn configuredTTL;\n\t\t}\n\t} catch (error) {\n\t\t// If settings not loaded yet, fall through to defaults\n\t\tlogger.debug(`Failed to get TTL for ${category}, using default:`, error);\n\t}\n\n\t// Fall back to default TTL\n\treturn DEFAULT_CATEGORY_TTLS[category];\n}\n\n// Interface for cache warming configuration\ninterface WarmCacheConfig {\n\tkeys: string[];\n\tfetcher: () => Promise<unknown>;\n\tcategory?: CacheCategory;\n\ttenantId?: string;\n}\n\n// Interface for predictive prefetch configuration\ninterface PrefetchPattern {\n\tpattern: RegExp;\n\tprefetchKeys: (matchedKey: string) => string[];\n\tfetcher?: (keys: string[]) => Promise<Record<string, unknown>>; // Function to fetch data for keys\n\tcategory?: CacheCategory;\n}\n"],"names":[],"mappings":"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"}