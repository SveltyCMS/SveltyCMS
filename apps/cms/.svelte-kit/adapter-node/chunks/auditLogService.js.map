{"version":3,"file":"auditLogService.js","sources":["../../../../../../shared/services/src/auditLogService.ts"],"sourcesContent":["/**\n * @file shared/services/src/auditLogService.ts\n * @description Audit Log Service for tracking security-critical events\n *\n * This service provides enterprise-grade audit logging for all sensitive operations\n * within the SveltyCMS platform. It ensures compliance, security monitoring, and\n * forensic capabilities.\n *\n * Features:\n * - Immutable audit trail\n * - Structured logging with consistent schema\n * - Performance optimized with minimal overhead\n * - Queryable logs for security analysis\n * - Integration with existing logger infrastructure\n * - Uses agnostic database interface for compatibility\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type { DatabaseId, BaseEntity, DatabaseResult, IDBAdapter } from '@shared/database/dbInterface';\n// Get the database adapter instance\nasync function getDbAdapter(): Promise<IDBAdapter> {\n\tconst { dbAdapter } = await import('@shared/database/db');\n\tif (!dbAdapter) {\n\t\tthrow new Error('Database adapter not initialized. Please ensure the database is connected.');\n\t}\n\treturn dbAdapter;\n}\n\n// Additional types for the service\ntype AuditDetails = Record<string, string | number | boolean | null | undefined>;\n\n// Audit log entry interface extending BaseEntity\nexport interface AuditLogEntry extends Omit<BaseEntity, 'id' | 'created_at'> {\n\tid?: DatabaseId;\n\teventType: AuditEventType;\n\tseverity: AuditSeverity;\n\tactorId: DatabaseId | null; // User who performed the action\n\tactorEmail?: string; // For easier querying\n\tactorRole?: string;\n\ttargetId?: DatabaseId | null; // What was affected\n\ttargetType?: string; // 'user', 'token', 'collection', etc.\n\taction: string; // Human-readable action description\n\tdetails: AuditDetails; // Additional context data\n\tipAddress?: string;\n\tuserAgent?: string;\n\tsessionId?: string;\n\ttimestamp: string;\n\tcorrelationId?: string; // For tracking related events\n\tresult: 'success' | 'failure' | 'partial';\n\terrorDetails?: string; // If result is failure\n}\n\n// Enum for audit event types\nexport enum AuditEventType {\n\t// Authentication events\n\tUSER_LOGIN = 'user_login',\n\tUSER_LOGOUT = 'user_logout',\n\tUSER_LOGIN_FAILED = 'user_login_failed',\n\tPASSWORD_CHANGE = 'password_change',\n\tPASSWORD_RESET = 'password_reset',\n\tTWO_FACTOR_ENABLED = 'two_factor_enabled',\n\tTWO_FACTOR_DISABLED = 'two_factor_disabled',\n\n\t// User management events\n\tUSER_CREATED = 'user_created',\n\tUSER_UPDATED = 'user_updated',\n\tUSER_DELETED = 'user_deleted',\n\tUSER_ROLE_CHANGED = 'user_role_changed',\n\tUSER_STATUS_CHANGED = 'user_status_changed',\n\n\t// Token management events\n\tTOKEN_CREATED = 'token_created',\n\tTOKEN_UPDATED = 'token_updated',\n\tTOKEN_DELETED = 'token_deleted',\n\tTOKEN_USED = 'token_used',\n\tTOKEN_MISUSE = 'token_misuse',\n\n\t// Data events\n\tDATA_EXPORT = 'data_export',\n\tDATA_IMPORT = 'data_import',\n\tDATA_DELETION = 'data_deletion',\n\n\t// Security events\n\tUNAUTHORIZED_ACCESS = 'unauthorized_access',\n\tPRIVILEGE_ESCALATION = 'privilege_escalation',\n\tDATA_BREACH_ATTEMPT = 'data_breach_attempt',\n\tSUSPICIOUS_ACTIVITY = 'suspicious_activity'\n}\n\n// Severity levels for audit events\nexport type AuditSeverity = 'low' | 'medium' | 'high' | 'critical';\n\n// Query options for audit logs\nexport interface AuditQueryOptions {\n\teventTypes?: AuditEventType[];\n\tactorId?: DatabaseId;\n\ttargetId?: DatabaseId;\n\tseverity?: AuditSeverity;\n\tstartDate?: string;\n\tendDate?: string;\n\tlimit?: number;\n\toffset?: number;\n}\n\n// Statistics interface\nexport interface AuditStatistics {\n\ttotalEvents: number;\n\teventsByType: Record<string, number>;\n\teventsBySeverity: Record<AuditSeverity, number>;\n\teventsByResult: Record<'success' | 'failure' | 'partial', number>;\n\tperiod: {\n\t\tstart: string;\n\t\tend: string;\n\t};\n}\n\n/**\n * Comprehensive audit logging service with enterprise-grade features\n */\nexport class AuditLogService {\n\tprivate readonly collectionName = 'auditLogs';\n\n\tconstructor() {\n\t\tthis.initializeIndexes();\n\t}\n\n\t/**\n\t * Log a security-critical event\n\t */\n\tasync logEvent(entry: Omit<AuditLogEntry, 'timestamp' | 'id' | 'created_at' | 'updated_at'>): Promise<void> {\n\t\ttry {\n\t\t\tconst db = await getDbAdapter();\n\t\t\tconst auditEntry: Omit<AuditLogEntry, 'id'> & { created_at?: string; updated_at?: string } = {\n\t\t\t\t...entry,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tcreated_at: new Date().toISOString(),\n\t\t\t\tupdated_at: new Date().toISOString()\n\t\t\t};\n\n\t\t\tconst result = await db.crud.insert<AuditLogEntry>(this.collectionName, auditEntry);\n\n\t\t\tif (!result.success) {\n\t\t\t\tlogger.error('Failed to log audit event', {\n\t\t\t\t\teventType: entry.eventType,\n\t\t\t\t\terror: result.error\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Log high-severity events to console as well\n\t\t\tif (entry.severity === 'high' || entry.severity === 'critical') {\n\t\t\t\tlogger.warn(`AUDIT: ${entry.eventType} by ${entry.actorEmail || 'unknown'}`, {\n\t\t\t\t\taction: entry.action,\n\t\t\t\t\ttargetType: entry.targetType,\n\t\t\t\t\ttargetId: entry.targetId,\n\t\t\t\t\tresult: entry.result\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to log audit event', { error, eventType: entry.eventType });\n\t\t}\n\t}\n\n\t/**\n\t * Query audit logs with filtering\n\t */\n\tasync queryLogs(options: AuditQueryOptions = {}): Promise<DatabaseResult<AuditLogEntry[]>> {\n\t\ttry {\n\t\t\tconst db = await getDbAdapter();\n\t\t\tconst filters: Record<string, unknown> = {};\n\n\t\t\tif (options.eventTypes?.length) {\n\t\t\t\tfilters.eventType = { $in: options.eventTypes };\n\t\t\t}\n\n\t\t\tif (options.actorId) {\n\t\t\t\tfilters.actorId = options.actorId;\n\t\t\t}\n\n\t\t\tif (options.targetId) {\n\t\t\t\tfilters.targetId = options.targetId;\n\t\t\t}\n\n\t\t\tif (options.severity) {\n\t\t\t\tfilters.severity = options.severity;\n\t\t\t}\n\n\t\t\tif (options.startDate || options.endDate) {\n\t\t\t\tfilters.timestamp = {};\n\t\t\t\tif (options.startDate) {\n\t\t\t\t\t(filters.timestamp as Record<string, unknown>).$gte = options.startDate;\n\t\t\t\t}\n\t\t\t\tif (options.endDate) {\n\t\t\t\t\t(filters.timestamp as Record<string, unknown>).$lte = options.endDate;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = await db.crud.findMany<AuditLogEntry>(this.collectionName, filters, {\n\t\t\t\tlimit: options.limit || 100,\n\t\t\t\toffset: options.offset || 0\n\t\t\t});\n\n\t\t\tif (!result.success) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Sort in memory since findMany doesn't support sort option\n\t\t\tconst sortedData = [...result.data].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n\t\t\treturn { success: true, data: sortedData };\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to query audit logs', { error, options });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to query audit logs',\n\t\t\t\terror: { code: 'QUERY_FAILED', message: 'Failed to query audit logs' }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get audit statistics for dashboard\n\tasync getStatistics(days: number = 30): Promise<DatabaseResult<AuditStatistics>> {\n\t\ttry {\n\t\t\tconst db = await getDbAdapter();\n\t\t\tconst startDate = new Date();\n\t\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t\tconst pipeline = [\n\t\t\t\t{\n\t\t\t\t\t$match: {\n\t\t\t\t\t\ttimestamp: { $gte: startDate.toISOString() }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t$group: {\n\t\t\t\t\t\t_id: {\n\t\t\t\t\t\t\teventType: '$eventType',\n\t\t\t\t\t\t\tseverity: '$severity',\n\t\t\t\t\t\t\tresult: '$result'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcount: { $sum: 1 }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tconst result = await db.crud.aggregate<{ _id: { eventType: string; severity: string; result: string }; count: number }>(\n\t\t\t\tthis.collectionName,\n\t\t\t\tpipeline\n\t\t\t);\n\n\t\t\tif (!result.success) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Failed to get audit statistics',\n\t\t\t\t\terror: { code: 'STATS_FAILED', message: 'Failed to get audit statistics' }\n\t\t\t\t};\n\t\t\t} // Process aggregation results into statistics\n\t\t\tconst stats: AuditStatistics = {\n\t\t\t\ttotalEvents: 0,\n\t\t\t\teventsByType: {},\n\t\t\t\teventsBySeverity: { low: 0, medium: 0, high: 0, critical: 0 },\n\t\t\t\teventsByResult: { success: 0, failure: 0, partial: 0 },\n\t\t\t\tperiod: { start: startDate.toISOString(), end: new Date().toISOString() }\n\t\t\t};\n\n\t\t\tresult.data?.forEach((item) => {\n\t\t\t\tstats.totalEvents += item.count;\n\n\t\t\t\t// Count by event type\n\t\t\t\tstats.eventsByType[item._id.eventType] = (stats.eventsByType[item._id.eventType] || 0) + item.count;\n\n\t\t\t\t// Count by severity\n\t\t\t\tstats.eventsBySeverity[item._id.severity as AuditSeverity] += item.count;\n\n\t\t\t\t// Count by result\n\t\t\t\tstats.eventsByResult[item._id.result as 'success' | 'failure' | 'partial'] += item.count;\n\t\t\t});\n\n\t\t\treturn { success: true, data: stats };\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to get audit statistics', { error });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to get audit statistics',\n\t\t\t\terror: { code: 'STATS_FAILED', message: 'Failed to get audit statistics' }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get recent suspicious activities\n\tasync getSuspiciousActivities(limit: number = 50): Promise<DatabaseResult<AuditLogEntry[]>> {\n\t\tconst suspiciousEventTypes: AuditEventType[] = [\n\t\t\tAuditEventType.USER_LOGIN_FAILED,\n\t\t\tAuditEventType.TOKEN_MISUSE,\n\t\t\tAuditEventType.UNAUTHORIZED_ACCESS,\n\t\t\tAuditEventType.PRIVILEGE_ESCALATION,\n\t\t\tAuditEventType.DATA_BREACH_ATTEMPT,\n\t\t\tAuditEventType.SUSPICIOUS_ACTIVITY\n\t\t];\n\n\t\treturn this.queryLogs({\n\t\t\teventTypes: suspiciousEventTypes,\n\t\t\tlimit,\n\t\t\tseverity: 'high'\n\t\t});\n\t}\n\n\t// Clean up old audit logs based on retention policy\n\tasync cleanupOldLogs(retentionDays: number = 365): Promise<void> {\n\t\ttry {\n\t\t\tconst db = await getDbAdapter();\n\t\t\tconst cutoffDate = new Date();\n\t\t\tcutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n\t\t\t// Note: We need to cast because deleteMany expects Partial<BaseEntity>\n\t\t\t// but we're filtering on AuditLogEntry's timestamp field\n\t\t\tconst result = await db.crud.deleteMany(this.collectionName, {\n\t\t\t\ttimestamp: cutoffDate.toISOString()\n\t\t\t} as Partial<BaseEntity>);\n\n\t\t\tif (result.success && result.data && result.data.deletedCount > 0) {\n\t\t\t\tlogger.info(`Cleaned up ${result.data.deletedCount} old audit log entries`, {\n\t\t\t\t\tcutoffDate: cutoffDate.toISOString(),\n\t\t\t\t\tretentionDays\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to cleanup old audit logs', { error, retentionDays });\n\t\t}\n\t}\n\n\t// Initialize database indexes for optimal performance\n\tprivate async initializeIndexes(): Promise<void> {\n\t\ttry {\n\t\t\t// Note: Index creation will be handled by the database adapter\n\t\t\t// This is a placeholder for when the adapter supports index creation\n\t\t\tlogger.debug('Audit log service initialized');\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to initialize audit log indexes', { error });\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const auditLogService = new AuditLogService();\n\n// Export convenience functions\nexport const logAuditEvent = auditLogService.logEvent.bind(auditLogService);\nexport const queryAuditLogs = auditLogService.queryLogs.bind(auditLogService);\nexport const getAuditStatistics = auditLogService.getStatistics.bind(auditLogService);\nexport const getSuspiciousActivities = auditLogService.getSuspiciousActivities.bind(auditLogService);\n"],"names":[],"mappings":"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"}