{"version":3,"file":"mongoDBAdapter.js","sources":["../../../../../../shared/database/src/mongodb/models/draft.ts","../../../../../../shared/database/src/mongodb/models/revision.ts","../../../../../../shared/database/src/mongodb/models/media.ts","../../../../../../shared/database/src/mongodb/models/systemPreferences.ts","../../../../../../shared/database/src/mongodb/models/widget.ts","../../../../../../shared/database/src/mongodb/models/systemVirtualFolder.ts","../../../../../../shared/database/src/mongodb/models/authUser.ts","../../../../../../shared/database/src/mongodb/models/authSession.ts","../../../../../../shared/database/src/mongodb/methods/authMethods.ts","../../../../../../shared/database/src/mongodb/methods/collectionMethods.ts","../../../../../../shared/database/src/mongodb/methods/crudMethods.ts","../../../../../../shared/database/src/mongodb/methods/normalizeId.ts","../../../../../../shared/database/src/mongodb/methods/contentMethods.ts","../../../../../../shared/database/src/mongodb/methods/mediaMethods.ts","../../../../../../shared/database/src/mongodb/methods/systemMethods.ts","../../../../../../shared/database/src/mongodb/methods/systemVirtualFolderMethods.ts","../../../../../../shared/database/src/mongodb/methods/themeMethods.ts","../../../../../../shared/database/src/mongodb/methods/websiteTokenMethods.ts","../../../../../../shared/database/src/mongodb/methods/widgetMethods.ts","../../../../../../shared/database/src/mongodb/MongoQueryBuilder.ts","../../../../../../shared/database/src/mongodb/methods/authComposition.ts","../../../../../../shared/database/src/mongodb/mongoDBAdapter.ts"],"sourcesContent":["/**\n * @file src/databases/mongodb/models/draft.ts\n * @description MongoDB schema and model for Drafts.\n *\n * This module defines a schema and model for Drafts in the MongoDB database.\n * A Draft is a version of a document that is not yet published.\n *\n * Features:\n * - Defines a schema for Drafts\n * - Defines a model for Drafts\n * - Defines static methods for Drafts\n * - Defines indexes for Drafts\n */\n\nimport mongoose, { Schema } from 'mongoose';\nimport type { Model } from 'mongoose';\nimport type { ContentDraft, DatabaseResult } from '@shared/database/dbInterface';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\nimport type { DatabaseId } from '@cms-types/content';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Define the Draft schema\nexport const draftSchema = new Schema<ContentDraft>(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // Auto-generate UUID for new drafts\n\t\tcontentId: { type: String, required: true }, //ContentId of the draft\n\t\tdata: { type: Schema.Types.Mixed, required: true }, // Content of the draft\n\t\tversion: { type: Number, default: 1 }, // Version number for drafts, starting at 1\n\t\tstatus: { type: String, enum: ['draft', 'review', 'archived'], default: 'draft' }, // Status options from ContentDraft\n\t\tauthorId: { type: String, required: true } // Changed to String type in schema\n\t\t// Note: createdAt and updatedAt are handled by timestamps: true\n\t},\n\t{\n\t\ttimestamps: true, // Enable timestamps for createdAt and updatedAt\n\t\tcollection: 'content_drafts',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// --- Indexes ---\n// Compound indexes for common query patterns (50-80% performance boost)\ndraftSchema.index({ contentId: 1, version: -1 }); // Latest draft version for content\ndraftSchema.index({ authorId: 1, status: 1, updatedAt: -1 }); // Author's drafts by status\ndraftSchema.index({ status: 1, updatedAt: -1 }); // Draft management queries\ndraftSchema.index({ contentId: 1, status: 1, updatedAt: -1 }); // Content draft workflow\ndraftSchema.index({ authorId: 1, createdAt: -1 }); // Author's recent drafts\n\n// Static methods\ndraftSchema.statics = {\n\t//Get drafts for a specific content ID\n\tasync getDraftsForContent(contentId: string): Promise<DatabaseResult<ContentDraft[]>> {\n\t\ttry {\n\t\t\tconst drafts = await this.find({ contentId }).lean().exec();\n\t\t\treturn { success: true, data: drafts };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to retrieve drafts for content ID: ${contentId}`;\n\t\t\tlogger.error(`Error retrieving drafts for content ID: ${contentId}: ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DRAFT_FETCH_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t//Bulk delete drafts for a list of content IDs\n\tasync bulkDeleteDraftsForContent(contentIds: string[]): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteMany({ contentId: { $in: contentIds } }).exec();\n\t\t\tlogger.info(`Bulk deleted ${result.deletedCount} drafts for content IDs: ${contentIds.join(', ')}`);\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to bulk delete drafts';\n\t\t\tlogger.error(`Error bulk deleting drafts for content IDs: ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DRAFT_BULK_DELETE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Create a new draft\n\tasync createDraft(draftData: Omit<ContentDraft, '_id' | 'createdAt' | 'updatedAt'>): Promise<DatabaseResult<ContentDraft>> {\n\t\ttry {\n\t\t\t// No need to manually add _id, Mongoose will auto-generate it via schema default\n\t\t\tconst newDraft = await this.create(draftData);\n\t\t\treturn { success: true, data: newDraft.toObject() as unknown as ContentDraft };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to create draft';\n\t\t\tlogger.error(`Error creating draft: ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'DRAFT_CREATE_ERROR', message, details: error }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Update a draft by its ID\n\tasync updateDraft(draftId: DatabaseId, updateData: Partial<ContentDraft>): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// Mongoose timestamps: true automatically updates updatedAt\n\t\t\tconst result = await this.updateOne({ _id: draftId }, { $set: updateData }).exec();\n\t\t\tif (result.modifiedCount === 0) {\n\t\t\t\tconst message = `Draft with ID \"${draftId}\" not found or no changes applied.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'DRAFT_UPDATE_NOT_FOUND',\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Draft \"${draftId}\" updated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to update draft \"${draftId}\"`;\n\t\t\tlogger.error(`Error updating draft \"${draftId}\": ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DRAFT_UPDATE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Delete a draft by its ID\n\tasync deleteDraft(draftId: DatabaseId): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteOne({ _id: draftId }).exec();\n\t\t\tif (result.deletedCount === 0) {\n\t\t\t\tconst message = `Draft with ID \"${draftId}\" not found.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'DRAFT_DELETE_NOT_FOUND',\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Draft \"${draftId}\" deleted successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to delete draft \"${draftId}\"`;\n\t\t\tlogger.error(`Error deleting draft \"${draftId}\": ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DRAFT_DELETE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create and export the DraftModel\nexport const DraftModel = (mongoose.models?.Draft as Model<ContentDraft> | undefined) || mongoose.model<ContentDraft>('Draft', draftSchema);\n","/**\n * @file src/databases/mongodb/models/revision.ts\n * @description MongoDB schema and model for Revisions.\n *\n * This module defines a schema and model for Revisions in the MongoDB database.\n * A Revision is a version of a document that is not yet published.\n *\n * ### Features\n * - Schema definition with fields for contentId, data, version, commitMessage, authorId, and timestamps\n * - Indexes for efficient querying by contentId, version, authorId, and createdAt\n * - Static methods for common operations:\n *   - getRevisionHistory: Retrieve revision history for a specific content ID\n *   - bulkDeleteRevisionsForContent: Bulk delete revisions for a list of content IDs\n */\n\nimport mongoose, { Schema } from 'mongoose';\nimport type { Model } from 'mongoose';\nimport type { ContentRevision, DatabaseResult } from '@shared/database/dbInterface';\nimport type { DatabaseId } from '@cms-types/content';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\nimport { toISOString } from '@shared/utils/dateUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Define the Revision schema\nexport const revisionSchema = new Schema<ContentRevision>(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // Auto-generate UUID for new revisions\n\t\tcontentId: { type: String, required: true }, // Renamed to contentId, DatabaseId of content\n\t\tdata: { type: Schema.Types.Mixed, required: true }, // Content of the revision\n\t\tversion: { type: Number, required: true }, // Version number of the revision\n\t\tcommitMessage: String, // Optional commit message for the revision\n\t\tauthorId: { type: String, required: true } // DatabaseId of author\n\t\t// Note: createdAt and updatedAt are handled by timestamps: true\n\t},\n\t{\n\t\ttimestamps: true, // Enable timestamps for createdAt and updatedAt\n\t\tcollection: 'content_revisions',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// --- Indexes ---\n// Compound indexes for common query patterns (50-80% performance boost)\nrevisionSchema.index({ contentId: 1, version: -1, createdAt: -1 }); // Revision history (most common)\nrevisionSchema.index({ authorId: 1, createdAt: -1 }); // User's revision activity\nrevisionSchema.index({ contentId: 1, authorId: 1, createdAt: -1 }); // Content-author revision tracking\nrevisionSchema.index({ createdAt: -1 }); // Recent revisions across all content\n// TTL index: Auto-delete old revisions after 90 days (optional - adjust as needed)\n// revisionSchema.index({ createdAt: 1 }, { expireAfterSeconds: 7776000 }); // 90 days\n\n// Static methods\nrevisionSchema.statics = {\n\t// Get revision history for a content ID\n\tasync getRevisionHistory(contentId: string): Promise<DatabaseResult<ContentRevision[]>> {\n\t\ttry {\n\t\t\tconst revisions = await this.find({ contentId })\n\t\t\t\t.sort({ version: -1, createdAt: -1 }) // Sort by version and date descending\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\t\t\treturn { success: true, data: revisions };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to retrieve revision history for content ID: ${contentId}`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error retrieving revision history for content ID: ${contentId}: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'REVISION_HISTORY_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Bulk delete revisions for a list of content IDs\n\tasync bulkDeleteRevisionsForContent(contentIds: string[]): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteMany({ contentId: { $in: contentIds } }).exec();\n\t\t\tlogger.info(`Bulk deleted ${result.deletedCount} revisions for content IDs: ${contentIds.join(', ')}`);\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to bulk delete revisions';\n\t\t\tlogger.error(`Error bulk deleting revisions for content IDs: ${error instanceof Error ? error.message : String(error)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'REVISION_BULK_DELETE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Create a new revision\n\tasync createRevision(revisionData: Omit<ContentRevision, '_id' | 'createdAt' | 'updatedAt'>): Promise<DatabaseResult<ContentRevision>> {\n\t\ttry {\n\t\t\t// No need to manually add _id, Mongoose will auto-generate it via schema default\n\t\t\tconst newRevision = await this.create(revisionData);\n\t\t\t// Convert Mongoose document to plain object with proper types\n\t\t\tconst revisionObj = newRevision.toObject();\n\n\t\t\tconst revisionWithISODates: ContentRevision = {\n\t\t\t\t_id: revisionObj._id as DatabaseId,\n\t\t\t\tcontentId: revisionObj.contentId as DatabaseId,\n\t\t\t\tdata: revisionObj.data,\n\t\t\t\tversion: revisionObj.version,\n\t\t\t\tcommitMessage: revisionObj.commitMessage,\n\t\t\t\tauthorId: revisionObj.authorId as DatabaseId,\n\t\t\t\tcreatedAt: toISOString(revisionObj.createdAt),\n\t\t\t\tupdatedAt: toISOString(revisionObj.updatedAt)\n\t\t\t};\n\t\t\treturn { success: true, data: revisionWithISODates };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to create revision';\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error creating revision: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'REVISION_CREATE_ERROR', message, details: error }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Update a revision by its ID\n\tasync updateRevision(revisionId: DatabaseId, updateData: Partial<ContentRevision>): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// Mongoose timestamps: true automatically updates updatedAt\n\t\t\tconst result = await this.updateOne({ _id: revisionId }, { $set: updateData }).exec();\n\t\t\tif (result.modifiedCount === 0) {\n\t\t\t\tconst message = `Revision with ID \"${revisionId}\" not found or no changes applied.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'REVISION_UPDATE_NOT_FOUND',\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Revision \"${revisionId}\" updated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to update revision \"${revisionId}\"`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error updating revision \"${revisionId}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'REVISION_UPDATE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Delete a revision by its ID\n\tasync deleteRevision(revisionId: DatabaseId): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteOne({ _id: revisionId }).exec();\n\t\t\tif (result.deletedCount === 0) {\n\t\t\t\tconst message = `Revision with ID \"${revisionId}\" not found.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'REVISION_DELETE_NOT_FOUND',\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Revision \"${revisionId}\" deleted successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to delete revision \"${revisionId}\"`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error deleting revision \"${revisionId}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'REVISION_DELETE_ERROR',\n\t\t\t\t\tmessage,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create and export the RevisionModel\nexport const RevisionModel =\n\t(mongoose.models?.Revision as Model<ContentRevision> | undefined) || mongoose.model<ContentRevision>('Revision', revisionSchema);\n","/**\n * @file src/databases/mongodb/models/media.ts\n * @description MongoDB schema and model for Media.\n *\n * This module defines a schema and model for media files in the CMS.\n * Media files include images, videos, documents, and other file types.\n *\n * Features:\n * - UUID as per dbInterface.ts\n * - Hash for media\n * - Filename for media\n * - Original filename for media\n * - Path to the media file\n * - Size of the media file\n * - Mime type of the media file\n * - Folder paths/ids as strings\n * - Thumbnails for images\n * - Metadata for media files\n * - Created by user ID\n * - Updated by user ID\n * - CreatedAt ISODate type\n * - UpdatedAt ISODate type\n */\n\nimport mongoose, { Schema } from 'mongoose';\nimport type { Model } from 'mongoose';\nimport type { MediaItem, DatabaseResult, IDBAdapter } from '@shared/database/dbInterface';\nimport type { DatabaseId } from '@cms-types/content';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\nimport { nowISODateString, toISOString } from '@shared/utils/dateUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Define interface for MongoDB document\nexport interface IMedia extends Document, Omit<MediaItem, '_id'> {\n\t_id: string;\n}\n\n// Media schema\nexport const mediaSchema = new Schema<MediaItem>(\n\t{\n\t\t_id: {\n\t\t\ttype: String,\n\t\t\trequired: true,\n\t\t\tdefault: () => generateId() // Use UUID instead of ObjectId\n\t\t},\n\t\t// UUID as per dbInterface.ts\n\t\thash: { type: String, required: true }, // Hash for media\n\t\tfilename: { type: String, required: true }, // Filename for media\n\t\toriginalFilename: String, // Original filename for media\n\t\tpath: { type: String, required: true }, // Path to the media file\n\t\tsize: { type: Number, required: true }, // Size of the media file\n\t\tmimeType: { type: String, required: true }, // Mime type of the media file\n\t\tfolderId: { type: String, default: null }, // Folder paths/ids as strings\n\t\tthumbnails: { type: Schema.Types.Mixed, default: {} }, // Thumbnails for images\n\t\tmetadata: {\n\t\t\twidth: Number,\n\t\t\theight: Number,\n\t\t\tduration: Number, // Duration for videos/audio\n\t\t\tcodec: String, // Codec used for media file\n\t\t\tformat: String, // Format of the media file\n\t\t\ttype: mongoose.Schema.Types.Mixed // Allow additional metadata fields via [key: string]: unknown\n\t\t},\n\t\tcreatedBy: { type: String, required: true }, // Created by user ID\n\t\tupdatedBy: { type: String, required: true }, // Updated by user ID\n\t\tcreatedAt: { type: String, default: () => nowISODateString() }, // CreatedAt ISODate type\n\t\tupdatedAt: { type: String, default: () => nowISODateString() } // UpdatedAt ISODate type\n\t},\n\t{\n\t\ttimestamps: true,\n\t\tcollection: 'system_media',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// --- Indexes ---\n// Single field indexes\nmediaSchema.index({ filename: 1 });\nmediaSchema.index({ hash: 1 }, { unique: true }); // Unique hash for deduplication\n\n// Compound indexes for common query patterns (50-80% performance boost)\nmediaSchema.index({ folderId: 1, createdAt: -1 }); // Folder browsing\nmediaSchema.index({ createdBy: 1, createdAt: -1 }); // User's media library\nmediaSchema.index({ mimeType: 1, createdAt: -1 }); // Filter by file type\nmediaSchema.index({ updatedAt: -1 }); // Recent media\nmediaSchema.index({ folderId: 1, mimeType: 1 }); // Folder + type filtering\nmediaSchema.index({ filename: 'text', originalFilename: 'text' }); // Full-text search on filenames\n\n// Fetch all media files using DatabaseAdapter's crud.findMany\nexport async function fetchAllMedia(databaseAdapter: IDBAdapter): Promise<DatabaseResult<MediaItem[]>> {\n\ttry {\n\t\tconst result = await databaseAdapter.crud.findMany<MediaItem>('media', {});\n\t\tif (result.success) {\n\t\t\treturn { success: true, data: result.data };\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t} catch (error) {\n\t\tconst message = 'Failed to fetch all media files';\n\t\tconst err = error as Error;\n\t\tlogger.error(`Error fetching all media files: ${err.message}`);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage,\n\t\t\terror: {\n\t\t\t\tcode: 'MEDIA_FETCH_ALL_ERROR',\n\t\t\t\tmessage: 'Failed to fetch all media files',\n\t\t\t\tdetails: error\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Static methods\nmediaSchema.statics = {\n\t// Get media by filename\n\tasync getMediaByFilename(filename: string): Promise<DatabaseResult<MediaItem | null>> {\n\t\ttry {\n\t\t\tconst mediaItem = (await this.findOne({ filename }).lean().exec()) as MediaItem | null;\n\t\t\treturn { success: true, data: mediaItem };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to retrieve media item by filename: ${filename}`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error retrieving media item by filename: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'MEDIA_GET_BY_FILENAME_ERROR',\n\t\t\t\t\tmessage: `Failed to retrieve media item by filename: ${filename}`\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Get media items by folder ID\n\tasync getMediaByFolderId(folderId?: string): Promise<DatabaseResult<MediaItem[]>> {\n\t\ttry {\n\t\t\tconst query: Record<string, unknown> = folderId ? { folderId } : {};\n\t\t\tconst mediaItems = (await this.find(query).lean().exec()) as MediaItem[];\n\t\t\treturn { success: true, data: mediaItems };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to retrieve media items for folder ID: ${folderId || 'root'}`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error retrieving media items by folder ID: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'MEDIA_GET_BY_FOLDER_ERROR',\n\t\t\t\t\tmessage: `Failed to retrieve media items for folder ID: ${folderId || 'root'}`\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Bulk delete media items by folder ID\n\tasync bulkDeleteMediaByFolderId(folderIds: string[]): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteMany({ folderId: { $in: folderIds } }).exec();\n\t\t\tlogger.info(`Bulk deleted ${result.deletedCount} media items for folder IDs: ${folderIds.join(', ')}`);\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to bulk delete media items';\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error bulk deleting media items by folder IDs: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'MEDIA_BULK_DELETE_ERROR',\n\t\t\t\t\tmessage: 'Failed to bulk delete media items',\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Upload a new media file\n\tasync uploadMedia(mediaData: Omit<MediaItem, '_id' | 'createdAt' | 'updatedAt'>): Promise<DatabaseResult<MediaItem>> {\n\t\ttry {\n\t\t\tconst newMedia = await this.create({ ...mediaData, _id: generateId() });\n\t\t\t// Convert Mongoose document to MediaItem with proper types\n\t\t\tconst mediaObj = newMedia.toObject();\n\t\t\tconst mediaWithISODates: MediaItem = {\n\t\t\t\t_id: mediaObj._id,\n\t\t\t\tfilename: mediaObj.filename,\n\t\t\t\toriginalFilename: mediaObj.originalFilename,\n\t\t\t\thash: mediaObj.hash,\n\t\t\t\tpath: mediaObj.path,\n\t\t\t\tsize: mediaObj.size,\n\t\t\t\tmimeType: mediaObj.mimeType,\n\t\t\t\tfolderId: mediaObj.folderId,\n\t\t\t\tthumbnails: mediaObj.thumbnails,\n\t\t\t\tmetadata: mediaObj.metadata,\n\t\t\t\tcreatedBy: mediaObj.createdBy,\n\t\t\t\tupdatedBy: mediaObj.updatedBy,\n\t\t\t\tcreatedAt: toISOString(mediaObj.createdAt),\n\t\t\t\tupdatedAt: toISOString(mediaObj.updatedAt)\n\t\t\t};\n\t\t\treturn { success: true, data: mediaWithISODates };\n\t\t} catch (error) {\n\t\t\tconst message = 'Failed to upload media';\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error uploading media: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'MEDIA_UPLOAD_ERROR', message, details: error }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Delete a media item by its ID\n\tasync deleteMedia(mediaId: DatabaseId): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteOne({ _id: mediaId }).exec();\n\t\t\tif (result.deletedCount === 0) {\n\t\t\t\tconst message = `Media item with ID \"${mediaId}\" not found.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'MEDIA_DELETE_NOT_FOUND',\n\t\t\t\t\t\tmessage: `Media item with ID \"${mediaId}\" not found.`\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Media item \"${mediaId}\" deleted successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to delete media item \"${mediaId}\"`;\n\t\t\tconst err = error as Error;\n\t\t\tlogger.error(`Error deleting media item \"${mediaId}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'MEDIA_DELETE_ERROR',\n\t\t\t\t\tmessage: `Failed to delete media item \"${mediaId}\"`,\n\t\t\t\t\tdetails: error\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create and export the MediaModel\nexport const MediaModel = (mongoose.models?.MediaItem as Model<MediaItem> | undefined) || mongoose.model<MediaItem>('MediaItem', mediaSchema);\n","/**\n * @file src/databases/mongodb/models/systemPreferences.ts\n * @description MongoDB schema and model for System Preferences, supporting user-specific dashboard layouts.\n *\n * ### Features\n * - Schema definition with fields for userId, layoutId, layout structure, scope, and timestamps\n * - Indexes for efficient querying by userId, layoutId, and scope\n * - Static methods for common operations:\n *   - getPreferenceByLayout: Retrieve preferences for a specific user and layout\n *   - setPreference: Create or update preferences with optional widget validation\n *   - validateLayoutWidgets: Ensure widgets in a layout are active\n *   - deletePreferencesByUser: Remove all preferences for a given user\n *\n * The model ensures data integrity and provides utility methods for managing system preferences.\n */\n\nimport type { DashboardWidgetConfig, Layout, SystemPreferencesDocument } from '@cms-types/content';\nimport type { DatabaseResult } from '@shared/database/dbInterface';\nimport type { Model } from 'mongoose';\nimport mongoose, { Schema } from 'mongoose';\nimport { nowISODateString } from '@shared/utils/dateUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\ninterface SystemPreferencesModelType extends Model<SystemPreferencesDocument> {\n\tgetPreferenceByLayout(userId: string, layoutId: string): Promise<DatabaseResult<Layout | null>>;\n\tsetPreference(\n\t\tuserId: string,\n\t\tlayoutId: string,\n\t\tlayout: Layout,\n\t\toptions?: {\n\t\t\tvalidateWidgets?: boolean;\n\t\t\tgetActiveWidgets?: () => Promise<string[]>;\n\t\t}\n\t): Promise<DatabaseResult<{ layout: Layout; warnings?: string[] }>>;\n\tvalidateLayoutWidgets(layout: Layout, activeWidgets: string[]): { layout: Layout; warnings: string[] };\n\tdeletePreferencesByUser(userId: string): Promise<DatabaseResult<number>>;\n}\n\n// Widget schema aligned with +server.ts\nconst WidgetSchema = new Schema<DashboardWidgetConfig>(\n\t{\n\t\tid: { type: String, required: true, unique: true },\n\t\tcomponent: { type: String, required: true },\n\t\tlabel: { type: String, required: true },\n\t\ticon: { type: String, required: true },\n\t\tsize: {\n\t\t\tw: { type: Number, required: true },\n\t\t\th: { type: Number, required: true }\n\t\t},\n\t\tsettings: { type: Schema.Types.Mixed, default: {} },\n\t\tgridPosition: { type: Number, required: false }, // Optional to match TypeScript types\n\t\torder: { type: Number, required: false } // Optional order field used by dashboard\n\t},\n\t{ _id: false }\n);\n\n// Layout schema\nconst LayoutSchema = new Schema({\n\tid: { type: String, required: true },\n\tname: { type: String, required: true },\n\tpreferences: { type: [WidgetSchema], default: [] }\n});\n\nconst SystemPreferencesSchema = new Schema(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // UUID as per dbInterface.ts\n\t\tuserId: { type: String, ref: 'auth_users', required: false }, // Optional userId for user-scoped preferences\n\t\tlayoutId: { type: String, required: false }, // Optional layout identifier\n\t\tlayout: { type: LayoutSchema, required: false }, // Optional structured layout data\n\t\tpreferences: { type: Schema.Types.Mixed, default: {} }, // Generic key-value preferences\n\t\tscope: { type: String, enum: ['user', 'system', 'widget'], default: 'user' }, // Scope of the preference\n\t\tcreatedAt: { type: String, default: () => nowISODateString() },\n\t\tupdatedAt: { type: String, default: () => nowISODateString() }\n\t},\n\t{\n\t\ttimestamps: true,\n\t\tcollection: 'system_preferences',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// Indexes\nSystemPreferencesSchema.index({ userId: 1, layoutId: 1, scope: 1 }, { unique: true }); // Unique per user and layout\nSystemPreferencesSchema.index({ scope: 1, userId: 1 }); // Index for scope and userId queries\nSystemPreferencesSchema.index({ scope: 1 }); // Index for scope-based queries\n\n// Static methods\nSystemPreferencesSchema.statics = {\n\t// Get preference by layoutId and userId\n\tasync getPreferenceByLayout(userId: string, layoutId: string): Promise<DatabaseResult<Layout | null>> {\n\t\ttry {\n\t\t\tconst query: any = { userId, layoutId, scope: 'user' };\n\t\t\tconst doc = await this.findOne(query).lean().exec();\n\t\t\tif (!doc) {\n\t\t\t\tlogger.debug(`No preference found for userId: ${userId}, layoutId: ${layoutId}`);\n\t\t\t\treturn { success: true, data: null };\n\t\t\t}\n\t\t\tlogger.debug(`Retrieved system preference for userId: ${userId}, layoutId: ${layoutId}`);\n\t\t\treturn { success: true, data: doc.layout };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to retrieve preference for userId: ${userId}, layoutId: ${layoutId}`;\n\t\t\tlogger.error(`Error retrieving system preference for userId: ${userId}, layoutId: ${layoutId}`, error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'PREFERENCE_GET_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Set preference for a specific layout with optional widget validation\n\tasync setPreference(\n\t\tuserId: string,\n\t\tlayoutId: string,\n\t\tlayout: Layout,\n\t\toptions?: {\n\t\t\tvalidateWidgets?: boolean;\n\t\t\tgetActiveWidgets?: () => Promise<string[]>;\n\t\t}\n\t): Promise<DatabaseResult<{ layout: Layout; warnings?: string[] }>> {\n\t\ttry {\n\t\t\tlet finalLayout = layout;\n\t\t\tconst warnings: string[] = [];\n\n\t\t\t// Widget validation if requested and function provided\n\t\t\tif (options?.validateWidgets && options?.getActiveWidgets) {\n\t\t\t\tconst activeWidgets = await options.getActiveWidgets();\n\t\t\t\tconst validatedResult = (this as unknown as SystemPreferencesModelType).validateLayoutWidgets(layout, activeWidgets);\n\t\t\t\tfinalLayout = validatedResult.layout;\n\t\t\t\twarnings.push(...validatedResult.warnings);\n\t\t\t}\n\n\t\t\tconst query: any = { userId, layoutId, scope: 'user' };\n\t\t\t// The _id for the document should be a combination of userId and layoutId for uniqueness\n\t\t\tconst documentId = `${userId}_${layoutId}`;\n\t\t\tawait this.updateOne(query, { $set: { layout: finalLayout, _id: documentId } }, { upsert: true }).exec();\n\t\t\tlogger.debug(`Set system preference for userId: ${userId}, layoutId: ${layoutId}`);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { layout: finalLayout, warnings: warnings.length > 0 ? warnings : undefined }\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to set preference for userId: ${userId}, layoutId: ${layoutId}`;\n\t\t\tlogger.error(`Error setting system preference for userId: ${userId}, layoutId: ${layoutId}`, error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'PREFERENCE_SET_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\n\t// Validate widgets in a layout\n\tvalidateLayoutWidgets(layout: Layout, activeWidgets: string[]): { layout: Layout; warnings: string[] } {\n\t\tconst warnings: string[] = [];\n\t\tconst validatedPreferences: DashboardWidgetConfig[] = [];\n\n\t\tfor (const widget of layout.preferences) {\n\t\t\tif (!activeWidgets.includes(widget.component)) {\n\t\t\t\twarnings.push(`Widget '${widget.component}' is not active, removing from layout`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalidatedPreferences.push(widget);\n\t\t}\n\n\t\treturn {\n\t\t\tlayout: {\n\t\t\t\t...layout,\n\t\t\t\tpreferences: validatedPreferences\n\t\t\t},\n\t\t\twarnings\n\t\t};\n\t},\n\n\t// Delete preferences for a user\n\tasync deletePreferencesByUser(userId: string): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst result = await this.deleteMany({ userId, scope: 'user' }).exec();\n\t\t\tlogger.info(`Deleted ${result.deletedCount} system preferences for userId: ${userId}`);\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to delete preferences for userId: ${userId}`;\n\t\t\tlogger.error(`Error deleting system preferences for userId: ${userId}`, error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'PREFERENCE_DELETE_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create and export the SystemPreferencesModel\nexport const SystemPreferencesModel =\n\t(mongoose.models?.SystemPreferences as unknown as SystemPreferencesModelType | undefined) ||\n\t(mongoose.model<SystemPreferencesDocument>('SystemPreferences', SystemPreferencesSchema) as unknown as SystemPreferencesModelType);\n","/**\n * @file src/databases/mongodb/models/widget.ts\n * @description MongoDB schema and model for Widgets.\n *\n * This module defines a schema and model for widgets in the CMS.\n * Widgets are reusable components that can be placed in different areas of the site\n *\n * ### Features\n * - Schema definition with fields for name, isActive, instances, dependencies, and timestamps\n * - Indexes for efficient querying by isActive and name\n * - Static methods for common operations:\n *   - getAllWidgets: Retrieve all widgets\n *   - getActiveWidgets: Retrieve names of active widgets\n *   - activateWidget: Activate a widget by name\n *   - deactivateWidget: Deactivate a widget by name\n *   - updateWidget: Update a widget's configuration\n *   - updateWidgetInstance: Atomically update a specific widget instance configuration\n */\n\nimport mongoose, { Schema } from 'mongoose';\nimport type { Model } from 'mongoose';\nimport type { Widget, DatabaseResult } from '@shared/database/dbInterface';\nimport { nowISODateString } from '@shared/utils/dateUtils';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\n// Widget schema\nexport const widgetSchema = new Schema<Widget>(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // UUID primary key\n\t\tname: { type: String, required: true, unique: true }, // Unique name for the widget\n\t\tisActive: { type: Boolean, default: false }, // Whether the widget is globally active\n\t\tinstances: {\n\t\t\ttype: Schema.Types.Mixed, // Structured configurations (supports atomic updates via dot notation)\n\t\t\tdefault: {}\n\t\t},\n\t\tdependencies: [String], // Widget identifiers of dependencies\n\t\tcreatedAt: { type: String, default: () => nowISODateString() },\n\t\tupdatedAt: { type: String, default: () => nowISODateString() }\n\t},\n\t{\n\t\ttimestamps: true,\n\t\tcollection: 'system_widgets',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false // Disable Mongoose auto-ObjectId generation\n\t}\n);\n\n// --- Indexes ---\n// Compound indexes for common query patterns\nwidgetSchema.index({ isActive: 1, name: 1 }); // Active widget lookup\n// Note: Unique index on 'name' is already created by the 'unique: true' field option (line 20)\nwidgetSchema.index({ isActive: 1, updatedAt: -1 }); // Recently modified active widgets\n\n// Static methods\nwidgetSchema.statics = {\n\t// Get all widgets.\n\tasync getAllWidgets(): Promise<DatabaseResult<Widget[]>> {\n\t\ttry {\n\t\t\tconst widgets = await this.find().lean().exec();\n\t\t\treturn { success: true, data: widgets };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = 'Failed to fetch widgets';\n\t\t\tlogger.error(`Error fetching all widgets: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'WIDGET_FETCH_ERROR', message }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Get active widgets.\n\tasync getActiveWidgets(): Promise<DatabaseResult<string[]>> {\n\t\ttry {\n\t\t\tconst widgets = await this.find({ isActive: true }, 'name').lean().exec();\n\t\t\tconst activeWidgetNames = widgets.map((widget: Widget) => widget.name);\n\t\t\treturn { success: true, data: activeWidgetNames };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = 'Failed to fetch active widgets';\n\t\t\tlogger.error(`Error fetching active widgets: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'ACTIVE_WIDGETS_FETCH_ERROR', message }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Activate a widget by its name\n\tasync activateWidget(widgetName: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// Check if widget exists first\n\t\t\tconst widget = await this.findOne({ name: widgetName }).exec();\n\t\t\tif (!widget) {\n\t\t\t\tconst message = `Widget \"${widgetName}\" not found in database.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: { code: 'WIDGET_NOT_FOUND', message }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If already active, return success (idempotent operation)\n\t\t\tif (widget.isActive) {\n\t\t\t\tlogger.info(`Widget \"${widgetName}\" is already active.`);\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t}\n\n\t\t\t// Activate the widget\n\t\t\tawait this.updateOne({ name: widgetName }, { $set: { isActive: true, updatedAt: nowISODateString() } }).exec();\n\t\t\tlogger.info(`Widget \"${widgetName}\" activated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = `Failed to activate widget \"${widgetName}\"`;\n\t\t\tlogger.error(`Error activating widget \"${widgetName}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'WIDGET_ACTIVATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Deactivate a widget by its name\n\tasync deactivateWidget(widgetName: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// Check if widget exists first\n\t\t\tconst widget = await this.findOne({ name: widgetName }).exec();\n\t\t\tif (!widget) {\n\t\t\t\tconst message = `Widget \"${widgetName}\" not found in database.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: { code: 'WIDGET_NOT_FOUND', message }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If already inactive, return success (idempotent operation)\n\t\t\tif (!widget.isActive) {\n\t\t\t\tlogger.info(`Widget \"${widgetName}\" is already inactive.`);\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t}\n\n\t\t\t// Deactivate the widget\n\t\t\tawait this.updateOne({ name: widgetName }, { $set: { isActive: false, updatedAt: nowISODateString() } }).exec();\n\t\t\tlogger.info(`Widget \"${widgetName}\" deactivated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = `Failed to deactivate widget \"${widgetName}\"`;\n\t\t\tlogger.error(`Error deactivating widget \"${widgetName}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'WIDGET_DEACTIVATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Update a widget's configuration\n\tasync updateWidget(widgetName: string, updateData: Partial<Widget>): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst result = await this.updateOne({ name: widgetName }, { $set: { ...updateData, updatedAt: nowISODateString() } }).exec();\n\t\t\tif (result.modifiedCount === 0) {\n\t\t\t\tconst message = `Widget \"${widgetName}\" not found or no changes applied.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: { code: 'WIDGET_NOT_FOUND', message }\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.info(`Widget \"${widgetName}\" updated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = `Failed to update widget \"${widgetName}\"`;\n\t\t\tlogger.error(`Error updating widget \"${widgetName}\": ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'WIDGET_UPDATE_ERROR', message }\n\t\t\t};\n\t\t}\n\t},\n\n\t// Atomically update a specific widget instance configuration\n\t// Example: updateWidgetInstance('myWidget', 'dashboard-header', { color: 'blue', size: 'large' })\n\tasync updateWidgetInstance(widgetName: string, instanceId: string, instanceConfig: Record<string, unknown>): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// Use dot notation to atomically update a specific instance without fetching/parsing/writing\n\t\t\t// This prevents race conditions and is much more efficient\n\t\t\tconst result = await this.updateOne(\n\t\t\t\t{ name: widgetName },\n\t\t\t\t{\n\t\t\t\t\t$set: {\n\t\t\t\t\t\t[`instances.${instanceId}`]: instanceConfig,\n\t\t\t\t\t\tupdatedAt: nowISODateString()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t).exec();\n\n\t\t\tif (result.matchedCount === 0) {\n\t\t\t\tconst message = `Widget \"${widgetName}\" not found.`;\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: { code: 'WIDGET_NOT_FOUND', message }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlogger.info(`Widget \"${widgetName}\" instance \"${instanceId}\" updated successfully.`);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst message = `Failed to update widget instance \"${instanceId}\" for widget \"${widgetName}\"`;\n\t\t\tlogger.error(`Error updating widget instance: ${err.message}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'WIDGET_INSTANCE_UPDATE_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create and export the Widget model\nexport const WidgetModel = (mongoose.models?.Widget as Model<Widget> | undefined) || mongoose.model<Widget>('Widget', widgetSchema);\n","/**\n * @file src/databases/mongodb/models/systemVirtualFolder.ts\n * @description MongoDB schema and model for System Virtual Folders.\n *\n * This module defines a schema and model for virtual folders in the system.\n * Virtual folders are used to organize content in a hierarchical structure.\n *\n * ### Features\n * - Schema definition with fields for folder properties\n * - Indexes for efficient querying\n * - Static methods for common operations:\n *   - createVirtualFolder: Create a new virtual folder\n *   - getAllVirtualFolders: Retrieve all virtual folders\n *   - getVirtualFolderByPath: Fetch a folder by its path\n *   - getVirtualFolderChildren: Get children of a virtual folder\n *   - bulkUpdateFolderOrder: Update the order of multiple folders\n *   - exists: Check if a folder with a given path exists\n *   - updateVirtualFolder: Update properties of a virtual folder\n *   - deleteVirtualFolder: Delete a virtual folder and its children\n *\n * The model ensures data integrity and provides utility methods for managing virtual folders.\n */\nimport mongoose, { Schema } from 'mongoose';\nimport type { Model } from 'mongoose';\nimport type { SystemVirtualFolder, DatabaseResult } from '@shared/database/dbInterface';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\nimport { nowISODateString } from '@shared/utils/dateUtils';\n\nimport { getErrorMessage } from '@shared/utils/errorHandling';\n\n// System Logger\nimport { logger } from '@shared/utils/logger.server';\n\n// System virtual folder schema\nexport const systemVirtualFolderSchema = new Schema<SystemVirtualFolder>(\n\t{\n\t\t_id: { type: String, required: true, default: () => generateId() }, // UUID primary key\n\t\tname: { type: String, required: true },\n\t\tpath: { type: String, required: true, unique: true },\n\t\tparentId: { type: String, ref: 'SystemVirtualFolder' }, // Reference to parent folder\n\t\ticon: { type: String, default: 'bi:folder' },\n\t\torder: { type: Number, default: 0 },\n\t\ttype: { type: String, enum: ['folder', 'collection'], required: true },\n\t\tmetadata: Schema.Types.Mixed,\n\t\tcreatedAt: { type: String, default: () => nowISODateString() },\n\t\tupdatedAt: { type: String, default: () => nowISODateString() }\n\t},\n\t{\n\t\ttimestamps: true,\n\t\tcollection: 'system_virtual_folders',\n\t\tstrict: true, // Enforce strict schema validation\n\t\t_id: false, // Disable Mongoose auto-ObjectId generation\n\t\tstatics: {\n\t\t\tasync createVirtualFolder(folder: SystemVirtualFolder): Promise<DatabaseResult<SystemVirtualFolder>> {\n\t\t\t\ttry {\n\t\t\t\t\t// First check if folder with same path already exists\n\t\t\t\t\tconst existingFolder = await this.findOne({ path: folder.path ?? `/${folder.name}` });\n\t\t\t\t\tif (existingFolder) {\n\t\t\t\t\t\tconst message = 'Folder with this path already exists';\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_DUPLICATE',\n\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\tdetails: { path: folder.path ?? `/${folder.name}` }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newFolder = new this({\n\t\t\t\t\t\t...folder,\n\t\t\t\t\t\t_id: folder._id, // Ensure _id is set after spread to avoid duplication warning\n\t\t\t\t\t\tpath: folder.path ?? `/${folder.name}`,\n\t\t\t\t\t\ttype: 'folder'\n\t\t\t\t\t});\n\t\t\t\t\tawait newFolder.save();\n\t\t\t\t\treturn { success: true, data: newFolder };\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// Handle duplicate key error specifically\n\t\t\t\t\tif (typeof error === 'object' && error !== null && 'code' in error && (error as { code: number }).code === 11000) {\n\t\t\t\t\t\tconst message = 'Folder with this path already exists';\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_DUPLICATE',\n\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\tdetails: { path: folder.path ?? `/${folder.name}` }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tconst message = 'Failed to create virtual folder';\n\t\t\t\t\tlogger.error(`Error creating virtual folder: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_CREATE_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync getAllVirtualFolders(): Promise<DatabaseResult<SystemVirtualFolder[]>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst folders = (await this.find({}).lean().exec()) as SystemVirtualFolder[];\n\t\t\t\t\treturn { success: true, data: folders };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = 'Failed to retrieve virtual folders';\n\t\t\t\t\tlogger.error(`Error retrieving virtual folders: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_GET_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Get virtual folder by path\n\t\t\tasync getVirtualFolderByPath(path: string): Promise<DatabaseResult<SystemVirtualFolder | null>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst folder = (await this.findOne({ path }).lean().exec()) as SystemVirtualFolder | null;\n\t\t\t\t\tif (!folder) {\n\t\t\t\t\t\treturn { success: true, data: null }; // Explicitly return null for \"not found\" case\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug(`Retrieved virtual folder by path: ${path}`);\n\t\t\t\t\treturn { success: true, data: folder };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = `Failed to retrieve virtual folder for path: ${path}`;\n\t\t\t\t\tlogger.error(`Error retrieving virtual folder by path: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_GET_ERROR',\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Get children of a virtual folder\n\t\t\tasync getVirtualFolderChildren(parentPath: string): Promise<DatabaseResult<SystemVirtualFolder[]>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst folders = (await this.find({ path: { $regex: `^${parentPath}/[^/]+$` } })\n\t\t\t\t\t\t.sort({ order: 1 })\n\t\t\t\t\t\t.lean()\n\t\t\t\t\t\t.exec()) as SystemVirtualFolder[];\n\t\t\t\t\tlogger.debug(`Retrieved children for virtual folder path: ${parentPath}`);\n\t\t\t\t\treturn { success: true, data: folders };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = `Failed to retrieve children for path: ${parentPath}`;\n\t\t\t\t\tlogger.error(`Error retrieving virtual folder children: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_CHILDREN_ERROR',\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Bulk update folder order\n\t\t\tasync bulkUpdateFolderOrder(parentId: string, orderUpdates: Array<{ path: string; order: number }>): Promise<DatabaseResult<number>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst bulkOps = orderUpdates.map((update) => ({\n\t\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\t\tfilter: { path: update.path, parentId: parentId },\n\t\t\t\t\t\t\tupdate: { $set: { order: update.order } }\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tconst result = await this.bulkWrite(bulkOps as any);\n\t\t\t\t\tlogger.info(`Updated order for ${result.modifiedCount} virtual folders under parent: ${parentId}`);\n\t\t\t\t\treturn { success: true, data: result.modifiedCount };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = 'Failed to bulk update folder order';\n\t\t\t\t\tlogger.error(`Error bulk updating virtual folder order: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_ORDER_UPDATE_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Check if folder with given path exists\n\t\t\tasync exists(path: string): Promise<DatabaseResult<boolean>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst count = await this.countDocuments({ path });\n\t\t\t\t\treturn { success: true, data: count > 0 };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = 'Failed to check folder existence';\n\t\t\t\t\tlogger.error(`Error checking folder existence: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_CHECK_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Update a virtual folder\n\t\t\tasync updateVirtualFolder(folderId: string, updateData: Partial<SystemVirtualFolder>): Promise<DatabaseResult<SystemVirtualFolder>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst folder = await this.findByIdAndUpdate(folderId, { $set: updateData }, { new: true }).lean().exec();\n\t\t\t\t\tif (!folder) {\n\t\t\t\t\t\tconst message = 'Folder not found';\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_NOT_FOUND',\n\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn { success: true, data: folder as SystemVirtualFolder };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = 'Failed to update virtual folder';\n\t\t\t\t\tlogger.error(`Error updating virtual folder: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_UPDATE_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}, // Delete a virtual folder and its children recursively\n\t\t\tasync deleteVirtualFolder(folderId: string): Promise<DatabaseResult<void>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst folder = await this.findById(folderId).lean().exec();\n\t\t\t\t\tif (!folder) {\n\t\t\t\t\t\treturn { success: true, data: undefined }; // Already deleted\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find all children and grandchildren recursively based on path\n\t\t\t\t\tconst children = await this.find({ path: { $regex: `^${folder.path}/` } })\n\t\t\t\t\t\t.lean()\n\t\t\t\t\t\t.exec();\n\t\t\t\t\tconst folderIdsToDelete = [folder._id, ...children.map((c: SystemVirtualFolder) => c._id)];\n\n\t\t\t\t\tawait this.deleteMany({ _id: { $in: folderIdsToDelete } });\n\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = 'Failed to delete virtual folder';\n\t\t\t\t\tlogger.error(`Error deleting virtual folder: ${getErrorMessage(error)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'VIRTUAL_FOLDER_DELETE_ERROR',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tdetails: error\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n);\n\n// Indexes\nsystemVirtualFolderSchema.index({ parentId: 1 });\nsystemVirtualFolderSchema.index({ type: 1 });\nsystemVirtualFolderSchema.index({ order: 1 });\n\n// Create and export the SystemVirtualFolderModel\nexport const SystemVirtualFolderModel =\n\t(mongoose.models?.SystemVirtualFolder as Model<SystemVirtualFolder> | undefined) ||\n\tmongoose.model<SystemVirtualFolder>('SystemVirtualFolder', systemVirtualFolderSchema);\n","/**\n * @file src/auth/mongoDBAuth/userAdapter.ts\n * @description MongoDB adapter for user-related operations.\n *\n * This module provides functionality to:\n * - Create, update, delete, and retrieve users\n * - Manage user schemas and models\n * - Handle user authentication and permissions\n *\n * Features:\n * - CRUD operations for users\n * - User schema definition\n * - User-role and user-permission associations\n * - Password hashing and verification\n * - Integration with MongoDB through Mongoose\n *\n * Usage:\n * Utilized by the auth system to manage user accounts in a MongoDB database\n */\n\nimport { getPrivateSettingSync } from '@shared/services/settingsService';\nimport type { Model } from 'mongoose';\nimport mongoose, { Schema } from 'mongoose';\n\n// Adapter\nimport { getAllPermissions } from '@shared/database/auth/permissions';\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\n\n// Types\nimport type { Permission, Role, User } from '@shared/database/auth';\nimport type { DatabaseResult, PaginationOption } from '@shared/database/dbInterface';\n\n// System Logging\nimport { logger } from '@shared/utils/logger';\n\n// Define the User schema\nexport const UserSchema = new Schema(\n\t{\n\t\t_id: { type: String, required: true }, // UUID as primary key\n\t\temail: { type: String, required: true, unique: true }, // User's email, required field\n\t\ttenantId: { type: String, index: true }, // Tenant identifier for multi-tenancy, indexed for performance\n\t\tpassword: { type: String }, // User's password, optional field\n\t\trole: { type: String, required: true }, // User's role, required field\n\t\tpermissions: [{ type: String }], // User-specific permissions as names, optional field\n\t\tusername: String, // User's username, optional field\n\t\tfirstName: String, // First name of the user\n\t\tlastName: String, // Last name of the user\n\t\tlocale: String, // Locale of the user\n\t\tavatar: String, // URL of the user's avatar, optional field\n\t\tlastAuthMethod: String, // Last authentication method used by the user, optional field\n\t\tlastActiveAt: { type: Date, default: Date.now }, // Last time the user was active as ISO string, optional field\n\t\texpiresAt: { type: Date }, // Expiration timestamp as ISO string, optional field\n\t\tisRegistered: Boolean, // Registration status of the user, optional field\n\t\tfailedAttempts: { type: Number, default: 0 }, // Number of failed login attempts, optional field\n\t\tblocked: Boolean, // Whether the user is blocked, optional field\n\t\tresetRequestedAt: { type: Date }, // Timestamp for when the user requested a password reset, optional field\n\t\tresetToken: String, // Token for resetting the user's password, optional field\n\t\tlockoutUntil: { type: Date }, // Timestamp for when the user is locked out, optional field\n\t\tis2FAEnabled: Boolean, // Whether the user has 2FA enabled, optional field\n\t\ttotpSecret: String, // TOTP secret for 2FA (base32 encoded), optional field\n\t\tbackupCodes: [String], // Array of hashed backup codes for 2FA recovery, optional field\n\t\tlast2FAVerification: { type: Date } // Timestamp of last successful 2FA verification, optional field\n\t},\n\t{\n\t\ttimestamps: true, // Automatically adds `createdAt` and `updatedAt` fields\n\t\tcollection: 'auth_users', // Explicitly set the collection name to match model registration\n\t\t_id: false // Disable auto ObjectId generation - we provide our own UUID\n\t}\n);\n\n// --- Indexes ---\n// Compound indexes for common query patterns (50-80% performance boost)\nUserSchema.index({ tenantId: 1, email: 1 }); // Multi-tenant user lookup (most common)\nUserSchema.index({ tenantId: 1, role: 1, blocked: 1 }); // Role-based queries per tenant\nUserSchema.index({ tenantId: 1, username: 1 }, { sparse: true }); // Username lookup (if exists)\nUserSchema.index({ tenantId: 1, lastActiveAt: -1 }); // Recent user activity queries\nUserSchema.index({ resetToken: 1 }, { sparse: true, expireAfterSeconds: 3600 }); // Password reset tokens (auto-cleanup after 1hr)\nUserSchema.index({ expiresAt: 1 }, { sparse: true, expireAfterSeconds: 0 }); // TTL for temporary users\nUserSchema.index({ lockoutUntil: 1 }, { sparse: true }); // Lockout management\nUserSchema.index({ role: 1, blocked: 1, isRegistered: 1 }); // Admin user management queries\nUserSchema.index({ email: 1, lastAuthMethod: 1 }); // Auth method tracking\n\n/**\n * UserAdapter class handles all user-related database operations.\n * This is a partial implementation that will be composed with other adapters.\n */\nexport class UserAdapter {\n\tprivate UserModel: Model<User>;\n\n\tconstructor() {\n\t\t// Force model recreation to ensure schema changes take effect\n\t\tif (mongoose.models?.auth_users) {\n\t\t\tdelete mongoose.models.auth_users;\n\t\t}\n\t\tthis.UserModel = mongoose.model<User>('auth_users', UserSchema);\n\t}\n\n\t// Create a new user\n\tasync createUser(userData: Partial<User>): Promise<DatabaseResult<User>> {\n\t\ttry {\n\t\t\t// Normalize email to lowercase if present\n\t\t\tconst normalizedUserData = {\n\t\t\t\t...userData,\n\t\t\t\temail: userData.email?.toLowerCase()\n\t\t\t};\n\n\t\t\t// Log exactly what we received (redacted)\n\t\t\tlogger.debug('UserAdapter.createUser received data:', {\n\t\t\t\t...normalizedUserData,\n\t\t\t\temail: '[REDACTED]',\n\t\t\t\tpassword: '[REDACTED]',\n\t\t\t\tavatar: `Avatar value: \"${normalizedUserData.avatar}\" (type: ${typeof normalizedUserData.avatar}, length: ${normalizedUserData.avatar?.length || 0})`\n\t\t\t});\n\n\t\t\t// Generate UUID for the user\n\t\t\tconst userId = generateId();\n\t\t\tconst user = new this.UserModel({ ...normalizedUserData, _id: userId }); // Log what the model contains before saving\n\t\t\tlogger.debug('UserModel before save:', {\n\t\t\t\temail: '[REDACTED]',\n\t\t\t\tavatar: `Model avatar: \"${user.avatar}\" (type: ${typeof user.avatar})`,\n\t\t\t\thasAvatar: !!user.avatar\n\t\t\t});\n\n\t\t\tawait user.save();\n\n\t\t\t// Log what was actually saved\n\t\t\tlogger.debug('User created and saved:', {\n\t\t\t\t_id: user._id,\n\t\t\t\temail: '[REDACTED]',\n\t\t\t\tavatar: `Saved avatar: \"${user.avatar}\" (type: ${typeof user.avatar})`,\n\t\t\t\tallFields: Object.keys(user.toObject())\n\t\t\t});\n\n\t\t\tconst savedUser = user.toObject();\n\t\t\tsavedUser._id = savedUser._id.toString();\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: savedUser as User\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.createUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, {\n\t\t\t\temail: '[REDACTED]',\n\t\t\t\terror: err,\n\t\t\t\tuserData: Object.keys(userData)\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'CREATE_USER_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Edit a user\n\tasync updateUserAttributes(user_id: string, userData: Partial<User>, tenantId?: string): Promise<DatabaseResult<User>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: user_id };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst user = await this.UserModel.findOneAndUpdate(filter, userData, { new: true }).lean();\n\n\t\t\tif (!user) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `User not found for ID: ${user_id} ${tenantId ? `in tenant: ${tenantId}` : ''}`,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'USER_NOT_FOUND',\n\t\t\t\t\t\tmessage: `User not found for ID: ${user_id} ${tenantId ? `in tenant: ${tenantId}` : ''}`\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tuser._id = user._id.toString();\n\t\t\t// Ensure permissions are strings\n\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\tuser.permissions = user.permissions.map((p) => String(p));\n\t\t\t}\n\t\t\tlogger.debug(`User attributes updated: ${user_id}`, { tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: user as User\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.updateUserAttributes: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'UPDATE_USER_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get all users with optional filtering, sorting, and pagination\n\tasync getAllUsers(options?: PaginationOption): Promise<DatabaseResult<User[]>> {\n\t\ttry {\n\t\t\tlet query = this.UserModel.find(options?.filter || {}).lean();\n\n\t\t\tif (options?.sort) {\n\t\t\t\tconst sortOptions: Record<string, 1 | -1> = {};\n\t\t\t\tif (Array.isArray(options.sort)) {\n\t\t\t\t\toptions.sort.forEach(([field, direction]) => {\n\t\t\t\t\t\tsortOptions[field] = direction === 'asc' ? 1 : -1;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tObject.entries(options.sort).forEach(([field, direction]) => {\n\t\t\t\t\t\tsortOptions[field] = direction === 'asc' ? 1 : -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tquery = query.sort(sortOptions);\n\t\t\t}\n\n\t\t\tif (typeof options?.offset === 'number') {\n\t\t\t\tquery = query.skip(options.offset);\n\t\t\t}\n\t\t\tif (typeof options?.limit === 'number') {\n\t\t\t\tquery = query.limit(options.limit);\n\t\t\t}\n\n\t\t\tconst users = await query.exec();\n\t\t\tconst mappedUsers = users.map((user) => {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\t// Ensure permissions are strings\n\t\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\t\tuser.permissions = user.permissions.map((p) => String(p));\n\t\t\t\t}\n\t\t\t\treturn user as User;\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: mappedUsers\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getAllUsers: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { options });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_ALL_USERS_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get the count of users\n\tasync getUserCount(filter?: Record<string, unknown>): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst count = await this.UserModel.countDocuments(filter || {});\n\t\t\tlogger.debug(`User count retrieved: ${count}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: count\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getUserCount: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { filter });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_USER_COUNT_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get users with a permission\n\tasync getUsersWithPermission(permissionName: string): Promise<DatabaseResult<User[]>> {\n\t\ttry {\n\t\t\tconst users = await this.UserModel.find({ permissions: permissionName }).lean();\n\t\t\tlogger.debug(`Users with permission ${permissionName} retrieved`);\n\t\t\tconst mappedUsers = users.map((user) => {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\t// Ensure permissions are strings\n\t\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\t\tuser.permissions = user.permissions.map((p) => String(p));\n\t\t\t\t}\n\t\t\t\treturn user as User;\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: mappedUsers\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getUsersWithPermission: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { permissionName });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_USERS_WITH_PERMISSION_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Assign a permission to a user\n\tasync assignPermissionToUser(user_id: string, permissionName: string): Promise<DatabaseResult<void>> {\n\t\tconst allPermissions = await getAllPermissions();\n\t\tconst permission = allPermissions.find((p) => p._id === permissionName);\n\t\tif (!permission) {\n\t\t\tlogger.warn(`Permission not found: ${permissionName}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Permission not found: ${permissionName}`,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'PERMISSION_NOT_FOUND',\n\t\t\t\t\tmessage: `Permission not found: ${permissionName}`\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, { $addToSet: { permissions: permissionName } });\n\t\t\tlogger.info(`Permission ${permissionName} assigned to user${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.assignPermissionToUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, permissionName });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'ASSIGN_PERMISSION_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Remove a permission from a user\n\tasync deletePermissionFromUser(user_id: string, permissionName: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, { $pull: { permissions: permissionName } });\n\t\t\tlogger.info(`Permission ${permissionName} removed from user ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.deletePermissionFromUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, permissionName });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DELETE_PERMISSION_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get permissions for a user\n\tasync getPermissionsForUser(user_id: string): Promise<DatabaseResult<Permission[]>> {\n\t\ttry {\n\t\t\tconst user = await this.UserModel.findById(user_id).lean();\n\t\t\tif (!user) {\n\t\t\t\tlogger.warn(`User not found: ${user_id}`);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tuser._id = user._id.toString();\n\t\t\tconst directPermissions = new Set(user.permissions || []);\n\t\t\tconst allPermissions = await getAllPermissions();\n\t\t\tconst userPermissions = allPermissions.filter((perm) => directPermissions.has(perm._id));\n\n\t\t\tconst uniquePermissions = Array.from(new Set(userPermissions.map((p) => p._id))).map((id) =>\n\t\t\t\tuserPermissions.find((p) => p._id === id)\n\t\t\t) as Permission[];\n\n\t\t\tlogger.debug(`Permissions retrieved for user: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: uniquePermissions\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getPermissionsForUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_PERMISSIONS_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Check if a user has a specific permission\n\tasync hasPermissionByAction(user_id: string, permissionName: string): Promise<DatabaseResult<boolean>> {\n\t\ttry {\n\t\t\tconst user = await this.UserModel.findById(user_id).lean();\n\t\t\tif (!user) {\n\t\t\t\tlogger.warn(`User not found: ${user_id}`);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tuser._id = user._id.toString();\n\t\t\tconst directPermissions = new Set(user.permissions || []);\n\t\t\tconst hasDirectPermission = directPermissions.has(permissionName);\n\t\t\tif (hasDirectPermission) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlogger.debug(`User ${user_id} does not have permission: ${permissionName}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: false\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.hasPermissionByAction: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, permissionName });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'HAS_PERMISSION_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Change user password\n\tasync changePassword(user_id: string, newPassword: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, { password: newPassword });\n\t\t\tlogger.info(`Password changed for user: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.changePassword: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'CHANGE_PASSWORD_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Block a user\n\tasync blockUser(user_id: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, {\n\t\t\t\tblocked: true,\n\t\t\t\tlockoutUntil: new Date() // Set lockoutUntil to current time\n\t\t\t});\n\t\t\tlogger.info(`User blocked: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.blockUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'BLOCK_USER_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Unblock a user\n\tasync unblockUser(user_id: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, {\n\t\t\t\tblocked: false,\n\t\t\t\tlockoutUntil: null // Clear lockoutUntil\n\t\t\t});\n\t\t\tlogger.info(`User unblocked: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.unblockUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'UNBLOCK_USER_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Block multiple users\n\tasync blockUsers(userIds: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: { $in: userIds } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst result = await this.UserModel.updateMany(filter, {\n\t\t\t\tblocked: true,\n\t\t\t\tlockoutUntil: new Date() // Set lockoutUntil to current time\n\t\t\t});\n\t\t\tlogger.info(`Users blocked: ${userIds.join(', ')}`, { tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { modifiedCount: result.modifiedCount }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.blockUsers: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { userIds, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'BLOCK_USERS_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Unblock multiple users\n\tasync unblockUsers(userIds: string[], tenantId?: string): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: { $in: userIds } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst result = await this.UserModel.updateMany(filter, {\n\t\t\t\tblocked: false,\n\t\t\t\tlockoutUntil: null // Clear lockoutUntil\n\t\t\t});\n\t\t\tlogger.info(`Users unblocked: ${userIds.join(', ')}`, { tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { modifiedCount: result.modifiedCount }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.unblockUsers: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { userIds, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'UNBLOCK_USERS_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Delete a user\n\tasync deleteUser(user_id: string, tenantId?: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: user_id };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tawait this.UserModel.findOneAndDelete(filter);\n\t\t\tlogger.info(`User deleted: ${user_id}`, { tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.deleteUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DELETE_USER_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Delete multiple users\n\tasync deleteUsers(userIds: string[], tenantId?: string): Promise<DatabaseResult<{ deletedCount: number }>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: { $in: userIds } };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst result = await this.UserModel.deleteMany(filter);\n\t\t\tlogger.info(`Users deleted: ${userIds.join(', ')}`, { tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { deletedCount: result.deletedCount }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.deleteUsers: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { userIds, tenantId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DELETE_USERS_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get a user by ID\n\tasync getUserById(user_id: string, tenantId?: string): Promise<DatabaseResult<User | null>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = { _id: user_id };\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst user = await this.UserModel.findOne(filter).lean();\n\t\t\tif (user) {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\t// Ensure permissions are strings (handle potential ObjectIds from legacy data)\n\t\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\t\tuser.permissions = user.permissions.map((p) => String(p));\n\t\t\t\t}\n\t\t\t\tlogger.debug(`User retrieved by ID: ${user_id}`, {\n\t\t\t\t\ttenantId: tenantId || 'none (single-tenant mode)'\n\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: user as User\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: null\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getUserById: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, {\n\t\t\t\tuser_id,\n\t\t\t\ttenantId: tenantId || 'none (single-tenant mode)'\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_USER_BY_ID_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} // Get a user by email\n\tasync getUserByEmail(criteria: { email: string; tenantId?: string }): Promise<DatabaseResult<User | null>> {\n\t\ttry {\n\t\t\tif (!criteria.email || typeof criteria.email !== 'string') {\n\t\t\t\tlogger.error('getUserByEmail called with invalid email:', { email: criteria.email, tenantId: criteria.tenantId });\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst normalizedEmail = criteria.email.toLowerCase();\n\t\t\tconst filter: Record<string, unknown> = { email: normalizedEmail };\n\t\t\tif (criteria.tenantId) {\n\t\t\t\tfilter.tenantId = criteria.tenantId;\n\t\t\t}\n\n\t\t\tconst user = await this.UserModel.findOne(filter).lean();\n\t\t\tif (user) {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\t// Ensure permissions are strings (handle potential ObjectIds from legacy data)\n\t\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\t\tuser.permissions = user.permissions.map((p) => String(p));\n\t\t\t\t}\n\t\t\t\tlogger.debug(`User retrieved by email:`, {\n\t\t\t\t\temail: '[REDACTED]',\n\t\t\t\t\ttenantId: criteria.tenantId || 'none (single-tenant mode)'\n\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: user as User\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: null\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getUserByEmail: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, {\n\t\t\t\temail: '[REDACTED]',\n\t\t\t\ttenantId: criteria.tenantId || 'none (single-tenant mode)'\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_USER_BY_EMAIL_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Assign a role to a user\n\tasync assignRoleToUser(user_id: string, role: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, { role });\n\t\t\tlogger.info(`Role ${role} assigned to user ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.assignRoleToUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, role });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'ASSIGN_ROLE_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Remove a role from a user\n\tasync removeRoleFromUser(user_id: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, { $unset: { role: '' } });\n\t\t\tlogger.info(`Role removed from user ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.removeRoleFromUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'REMOVE_ROLE_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get roles for a user\n\tasync getRolesForUser(user_id: string): Promise<DatabaseResult<Role[]>> {\n\t\ttry {\n\t\t\tconst user = await this.UserModel.findById(user_id).lean();\n\t\t\tif (!user || !user.role) {\n\t\t\t\tlogger.warn(`User or role not found for user ID: ${user_id}`);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tuser._id = user._id.toString();\n\t\t\t// Fetch the role from the file-based roles configuration\n\t\t\tconst role = getPrivateSettingSync('ROLES')?.find((r) => r._id === user.role);\n\t\t\tif (!role) {\n\t\t\t\tlogger.warn(`Role not found: ${user.role} for user ID: ${user_id}`);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlogger.debug(`Roles retrieved for user ID: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: [role]\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getRolesForUser: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_ROLES_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Fetch the last 5 users who logged in\n\tasync getRecentUserActivities(): Promise<DatabaseResult<User[]>> {\n\t\ttry {\n\t\t\tconst recentUsers = await this.UserModel.find({ lastActiveAt: { $ne: null } })\n\t\t\t\t.sort({ lastActiveAt: -1 })\n\t\t\t\t.limit(5)\n\t\t\t\t.select('email username lastActiveAt')\n\t\t\t\t.lean();\n\n\t\t\tlogger.debug('Retrieved recent user activities');\n\t\t\tconst mappedUsers = recentUsers.map((user) => {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\treturn user as User;\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: mappedUsers\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.getRecentUserActivities: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'GET_RECENT_ACTIVITIES_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Check user role\n\tasync checkUserRole(user_id: string, role_name: string): Promise<DatabaseResult<boolean>> {\n\t\ttry {\n\t\t\tconst user = await this.UserModel.findById(user_id).lean();\n\t\t\tif (user) {\n\t\t\t\tuser._id = user._id.toString();\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: user.role === role_name\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: false\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.checkUserRole: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, role_name });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'CHECK_USER_ROLE_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Update lastActiveAt\n\tasync updateLastActiveAt(user_id: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, {\n\t\t\t\tlastActiveAt: new Date()\n\t\t\t});\n\t\t\tlogger.debug(`Updated lastActiveAt for user: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.updateLastActiveAt: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'UPDATE_LAST_ACTIVE_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Set expiration date\n\tasync setUserExpiration(user_id: string, expirationDate: Date): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.UserModel.findByIdAndUpdate(user_id, {\n\t\t\t\texpiresAt: expirationDate\n\t\t\t});\n\t\t\tlogger.debug(`Set expiration date for user: ${user_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.setUserExpiration: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id, expirationDate });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'SET_USER_EXPIRATION_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// check if a user is expired\n\tasync isUserExpired(user_id: string): Promise<DatabaseResult<boolean>> {\n\t\ttry {\n\t\t\tconst user = await this.UserModel.findById(user_id).lean();\n\t\t\tif (user && user.expiresAt) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: new Date(user.expiresAt) < new Date()\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: false\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in UserAdapter.isUserExpired: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message, { user_id });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'IS_USER_EXPIRED_ERROR',\n\t\t\t\t\tmessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n}\n","/**\n * @file src/auth/mongoDBAuth/sessionAdapter.ts\n * @description MongoDB adapter for session-related operations.\n *\n * This module provides functionality to:\n * - Create, update, delete, and retrieve sessions\n * - Manage session schemas and models\n * - Handle session validation and expiration\n *\n * Features:\n * - CRUD operations for sessions\n * - Session schema definition\n * - Session expiration handling\n * - Integration with MongoDB through Mongoose\n *\n * Usage:\n * Utilized by the auth system to manage user sessions in a MongoDB database\n */\n\nimport { error } from '@sveltejs/kit';\nimport type { Model, Types } from 'mongoose';\nimport mongoose, { Schema } from 'mongoose';\n\n// Types\nimport type { DatabaseResult, ISODateString } from '@shared/database/dbInterface';\nimport type { Session, User } from '@shared/database/auth/types';\n\n// Utilities\nimport { generateId } from '@shared/database/mongodb/methods/mongoDBUtils';\nimport { toISOString } from '@shared/utils/dateUtils';\n\n// System Logging\nimport { logger } from '@shared/utils/logger';\n\n// Define the Session schema\nexport const SessionSchema = new Schema(\n\t{\n\t\t_id: { type: String, required: true }, // UUID as primary key\n\t\t// Index definitions have been removed from here to prevent duplication.\n\t\tuser_id: { type: String, required: true }, // User identifier\n\t\ttenantId: { type: String }, // Tenant identifier for multi-tenancy\n\t\texpires: { type: Date, required: true }, // Expiry timestamp - MUST be Date for TTL index\n\t\trotated: { type: Boolean, default: false }, // Flag to mark rotated sessions\n\t\trotatedTo: { type: String } // ID of the new session this was rotated to\n\t},\n\t{\n\t\ttimestamps: true, // Automatically adds createdAt and updatedAt as Date types\n\t\t_id: false // Disable auto ObjectId generation - we provide our own UUID\n\t}\n);\n\n// --- Indexes ---\n// TTL index: Automatically delete expired sessions (auto-cleanup)\nSessionSchema.index({ expires: 1 }, { expireAfterSeconds: 0 });\n\n// Compound indexes for common query patterns (50-80% performance boost)\nSessionSchema.index({ user_id: 1, expires: 1, rotated: 1 }); // User's active sessions\nSessionSchema.index({ tenantId: 1, user_id: 1, expires: 1 }); // Multi-tenant user sessions\nSessionSchema.index({ tenantId: 1, expires: 1, rotated: 1 }); // Tenant-wide session queries\nSessionSchema.index({ rotated: 1, expires: 1 }); // Find rotated/active sessions\nSessionSchema.index({ rotatedTo: 1 }, { sparse: true }); // Session rotation chain lookups (sparse is efficient)\n\n/**\n * SessionAdapter class handles all session-related database operations.\n * This is a partial implementation that will be composed with other adapters.\n */\nexport class SessionAdapter {\n\tprivate SessionModel: Model<Session>;\n\n\tconstructor() {\n\t\t// Delete existing model if it exists to force recreation with new schema\n\t\tif (mongoose.models?.auth_sessions) {\n\t\t\tdelete mongoose.models.auth_sessions;\n\t\t}\n\n\t\t// Create the Session model with the updated schema\n\t\tthis.SessionModel = mongoose.model<Session>('auth_sessions', SessionSchema);\n\n\t\t// Clean up old ObjectId-based sessions (migration)\n\t\tthis.migrateToUuidSessions().catch((err) => {\n\t\t\tlogger.warn('Failed to migrate sessions to UUID format', { error: err.message });\n\t\t});\n\t}\n\n\t// Migration: Remove old ObjectId-based sessions\n\tprivate async migrateToUuidSessions(): Promise<void> {\n\t\ttry {\n\t\t\t// Delete all sessions with ObjectId format (24-char hex strings)\n\t\t\t// UUID format is 32 chars without dashes\n\t\t\tconst result = await this.SessionModel.deleteMany({\n\t\t\t\t$or: [\n\t\t\t\t\t{ _id: { $type: 'objectId' } }, // MongoDB ObjectId type\n\t\t\t\t\t{ _id: { $regex: /^[0-9a-f]{24}$/ } } // 24-char hex string (ObjectId format)\n\t\t\t\t]\n\t\t\t});\n\n\t\t\tif (result.deletedCount && result.deletedCount > 0) {\n\t\t\t\tlogger.info(` Migrated sessions: Removed ${result.deletedCount} old ObjectId-based sessions`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// Non-critical error - old sessions will expire naturally\n\t\t\tlogger.debug('Session migration check completed', { error: err instanceof Error ? err.message : String(err) });\n\t\t}\n\t}\n\n\t// Validate token signature and claims\n\tasync validateToken(\n\t\ttoken: string,\n\t\tuser_id?: string,\n\t\t_type?: string,\n\t\ttenantId?: string\n\t): Promise<DatabaseResult<{ success: boolean; message: string; email?: string }>> {\n\t\ttry {\n\t\t\tconst session = await this.SessionModel.findById(token).lean();\n\t\t\tif (!session) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: { success: false, message: 'Session not found' }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if token is expired\n\t\t\tif (new Date(session.expires) <= new Date()) {\n\t\t\t\tawait this.SessionModel.findByIdAndDelete(token);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: { success: false, message: 'Session expired' }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Additional validation if user_id is provided\n\t\t\tif (user_id && session.user_id !== user_id) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: { success: false, message: 'Session does not match user' }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check tenant isolation if tenantId is provided\n\t\t\tif (tenantId && session.tenantId !== tenantId) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: { success: false, message: 'Session does not match tenant' }\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { success: true, message: 'Token is valid' }\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tlogger.error(`Token validation failed: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Token validation failed: ${err instanceof Error ? err.message : String(err)}`,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'VALIDATION_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Create a new session\n\tasync createSession(sessionData: { user_id: string; expires: ISODateString; tenantId?: string }): Promise<DatabaseResult<Session>> {\n\t\ttry {\n\t\t\t// Create the new session with UUID\n\t\t\tconst sessionId = generateId();\n\t\t\tconst session = new this.SessionModel({ ...sessionData, _id: sessionId });\n\t\t\tawait session.save();\n\t\t\tlogger.info(`Session created: ${sessionId} for user: ${sessionData.user_id}`);\n\t\t\tconst sessionObj = session.toObject();\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: this.formatSession(\n\t\t\t\t\tsessionObj as unknown as { [key: string]: unknown; _id: string | Types.ObjectId; user_id: string; expires: ISODateString }\n\t\t\t\t)\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.createSession: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'CREATE_SESSION_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Create a new session with options (optimized with atomic bulkWrite)\n\tasync createSessionWithOptions(\n\t\tsessionData: { user_id: string; expires: ISODateString; tenantId?: string },\n\t\toptions: { invalidateOthers?: boolean } = {}\n\t): Promise<Session> {\n\t\ttry {\n\t\t\t// Only invalidate all sessions if not explicitly skipped\n\t\t\tif (options.invalidateOthers !== false) {\n\t\t\t\t// Use bulkWrite for atomic operation: delete old sessions + insert new one\n\t\t\t\t// This is more efficient than separate deleteMany + insertOne calls\n\t\t\t\tconst now = new Date();\n\t\t\t\tconst filter: Record<string, unknown> = {\n\t\t\t\t\tuser_id: sessionData.user_id,\n\t\t\t\t\texpires: { $gt: now }, // Only delete active (non-expired) sessions\n\t\t\t\t\t$or: [\n\t\t\t\t\t\t{ rotated: { $ne: true } }, // Delete non-rotated sessions\n\t\t\t\t\t\t{ rotated: true, expires: { $lte: new Date(now.getTime() + 60000).toISOString() } } // Delete rotated sessions close to expiry\n\t\t\t\t\t]\n\t\t\t\t};\n\n\t\t\t\tif (sessionData.tenantId) {\n\t\t\t\t\tfilter.tenantId = sessionData.tenantId;\n\t\t\t\t}\n\n\t\t\t\t// Create new session document with UUID\n\t\t\t\tconst sessionId = generateId();\n\t\t\t\tconst newSession = new this.SessionModel({ ...sessionData, _id: sessionId });\n\n\t\t\t\t// Execute both operations atomically with bulkWrite\n\t\t\t\tawait this.SessionModel.bulkWrite([\n\t\t\t\t\t{\n\t\t\t\t\t\t// Step 1: Delete all existing active sessions for this user\n\t\t\t\t\t\tdeleteMany: {\n\t\t\t\t\t\t\tfilter\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t// Step 2: Insert the new session\n\t\t\t\t\t\tinsertOne: {\n\t\t\t\t\t\t\tdocument: newSession\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]);\n\n\t\t\t\tlogger.info(`Session created: ${sessionId} for user: ${sessionData.user_id}`);\n\n\t\t\t\t// Return the formatted session\n\t\t\t\treturn this.formatSession({\n\t\t\t\t\t_id: sessionId,\n\t\t\t\t\tuser_id: sessionData.user_id,\n\t\t\t\t\texpires: sessionData.expires,\n\t\t\t\t\ttenantId: sessionData.tenantId,\n\t\t\t\t\trotated: false\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Just create the new session without invalidating others\n\t\t\t\tconst sessionResult = await this.createSession(sessionData);\n\t\t\t\tif (!sessionResult.success) {\n\t\t\t\t\tthrow new Error(sessionResult.message);\n\t\t\t\t}\n\t\t\t\treturn sessionResult.data;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.createSessionWithOptions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\tthrow error(500, message);\n\t\t}\n\t}\n\n\t// Rotate token - create new session and gracefully transition from old one\n\tasync rotateToken(oldToken: string, expires: ISODateString): Promise<DatabaseResult<string>> {\n\t\ttry {\n\t\t\t// Get old session data\n\t\t\tconst oldSession = await this.SessionModel.findById(oldToken).lean();\n\t\t\tif (!oldSession) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `Session not found: ${oldToken}`,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'SESSION_NOT_FOUND',\n\t\t\t\t\t\tmessage: `Session not found: ${oldToken}`,\n\t\t\t\t\t\tstatusCode: 404\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if token is already expired\n\t\t\tif (new Date(oldSession.expires) <= new Date()) {\n\t\t\t\tlogger.warn(`Attempting to rotate expired session: ${oldToken}`);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `Cannot rotate expired session: ${oldToken}`,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'SESSION_EXPIRED',\n\t\t\t\t\t\tmessage: `Cannot rotate expired session: ${oldToken}`,\n\t\t\t\t\t\tstatusCode: 400\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Create new session using createSessionWithOptions to avoid invalidating all others\n\t\t\tconst newSession = await this.createSessionWithOptions(\n\t\t\t\t{\n\t\t\t\t\tuser_id: oldSession.user_id,\n\t\t\t\t\texpires,\n\t\t\t\t\ttenantId: oldSession.tenantId\n\t\t\t\t},\n\t\t\t\t{ invalidateOthers: false }\n\t\t\t);\n\n\t\t\t// Instead of immediately deleting old session, extend it for 5 minutes grace period\n\t\t\t// This prevents race conditions where cached references to old session cause failures\n\n\t\t\tconst graceExpiry = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes grace period\n\t\t\tawait this.SessionModel.findByIdAndUpdate(oldToken, {\n\t\t\t\texpires: graceExpiry,\n\t\t\t\t// Add a flag to mark this as a rotated session for cleanup\n\t\t\t\trotated: true,\n\t\t\t\trotatedTo: newSession._id\n\t\t\t});\n\n\t\t\tlogger.info(`Token rotated successfully - old: ${oldToken} (grace period until ${graceExpiry.toISOString()}), new: ${newSession._id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: newSession._id\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.rotateToken: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'ROTATE_TOKEN_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Update the expiry of an existing session\n\tasync updateSessionExpiry(session_id: string, newExpiry: Date): Promise<DatabaseResult<Session>> {\n\t\ttry {\n\t\t\tconst session = await this.SessionModel.findByIdAndUpdate(session_id, { expires: newExpiry }, { new: true }).lean();\n\t\t\tif (!session) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `Session not found: ${session_id}`,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'SESSION_NOT_FOUND',\n\t\t\t\t\t\tmessage: `Session not found: ${session_id}`,\n\t\t\t\t\t\tstatusCode: 404\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tlogger.debug('Session expiry updated', { session_id });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: this.formatSession(session as any)\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.updateSessionExpiry: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'UPDATE_SESSION_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Delete a session\n\tasync deleteSession(session_id: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tawait this.SessionModel.findByIdAndDelete(session_id);\n\t\t\tlogger.info(`Session deleted: ${session_id}`);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: undefined\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.deleteSession: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DELETE_SESSION_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Delete expired sessions (enhanced to clean up rotated sessions)\n\tasync deleteExpiredSessions(): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst now = new Date();\n\n\t\t\t// Delete all expired sessions (including rotated ones past grace period)\n\t\t\tconst result = await this.SessionModel.deleteMany({ expires: { $lte: now.toISOString() } });\n\n\t\t\tlogger.info('Expired sessions deleted', { deletedCount: result.deletedCount });\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result.deletedCount\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.deleteExpiredSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'DELETE_EXPIRED_SESSIONS_ERROR',\n\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t// Validate a session (optimized with MongoDB $lookup aggregation)\n\tasync validateSession(session_id: string): Promise<DatabaseResult<User | null>> {\n\t\ttry {\n\t\t\t// UUID validation (UUIDs are strings, not ObjectIds)\n\t\t\tif (!session_id || typeof session_id !== 'string' || session_id.length < 32) {\n\t\t\t\tlogger.warn('Invalid session ID format', { session_id });\n\t\t\t\treturn { success: true, data: null };\n\t\t\t}\n\n\t\t\t// DEBUG: Check if session exists in database\n\t\t\tconst sessionExists = await this.SessionModel.findById(session_id).lean();\n\t\t\tlogger.debug('Session lookup', {\n\t\t\t\tsession_id,\n\t\t\t\texists: !!sessionExists,\n\t\t\t\texpires: sessionExists?.expires,\n\t\t\t\texpired: sessionExists ? new Date(sessionExists.expires) <= new Date() : null\n\t\t\t});\n\n\t\t\t// Use MongoDB aggregation pipeline to join session and user in a single query\n\t\t\t// This replaces two sequential database calls with one optimized query\n\t\t\tconst results = await this.SessionModel.aggregate([\n\t\t\t\t// Stage 1: Find the session by its ID (UUID string)\n\t\t\t\t{ $match: { _id: session_id } },\n\t\t\t\t// Stage 2: Check for expiration\n\t\t\t\t{ $match: { expires: { $gt: new Date() } } },\n\t\t\t\t// Stage 3: \"Join\" with the auth_users collection (both using UUID strings)\n\t\t\t\t{\n\t\t\t\t\t$lookup: {\n\t\t\t\t\t\tfrom: 'auth_users',\n\t\t\t\t\t\tlocalField: 'user_id', // UUID string\n\t\t\t\t\t\tforeignField: '_id', // UUID string\n\t\t\t\t\t\tas: 'user'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Stage 4: Deconstruct the user array\n\t\t\t\t{ $unwind: { path: '$user', preserveNullAndEmptyArrays: false } },\n\t\t\t\t// Stage 5: Add rotation metadata to user object\n\t\t\t\t{\n\t\t\t\t\t$addFields: {\n\t\t\t\t\t\t'user._sessionRotated': '$rotated',\n\t\t\t\t\t\t'user._sessionRotatedTo': '$rotatedTo'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Stage 6: Make user the root document\n\t\t\t\t{ $replaceRoot: { newRoot: '$user' } }\n\t\t\t]);\n\n\t\t\tlogger.debug('Aggregation results', {\n\t\t\t\tsession_id,\n\t\t\t\tresultsCount: results.length,\n\t\t\t\thasUser: results.length > 0 && !!results[0]\n\t\t\t});\n\n\t\t\tif (results.length > 0) {\n\t\t\t\tconst user = results[0];\n\n\t\t\t\t// Log rotation status if applicable\n\t\t\t\tif (user._sessionRotated && user._sessionRotatedTo) {\n\t\t\t\t\tlogger.debug(`Session ${session_id} was rotated to ${user._sessionRotatedTo}, but still valid during grace period`);\n\t\t\t\t}\n\n\t\t\t\t// Remove session metadata from user object\n\t\t\t\tdelete user._sessionRotated;\n\t\t\t\tdelete user._sessionRotatedTo;\n\n\t\t\t\t// Normalize ID\n\t\t\t\tuser._id = user._id.toString();\n\n\t\t\t\t// Ensure permissions are strings\n\t\t\t\tif (user.permissions && Array.isArray(user.permissions)) {\n\t\t\t\t\tuser.permissions = user.permissions.map((p: unknown) => String(p));\n\t\t\t\t}\n\n\t\t\t\tlogger.debug('Session validated', { session_id });\n\t\t\t\treturn { success: true, data: user as User };\n\t\t\t}\n\n\t\t\t// If no results, the session is invalid, expired, or the user doesn't exist\n\t\t\t// Clean up the potentially invalid session\n\t\t\tawait this.SessionModel.findByIdAndDelete(session_id);\n\t\t\tlogger.warn('Session invalid or expired', { session_id });\n\t\t\treturn { success: true, data: null };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.validateSession: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'VALIDATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Invalidate all sessions for a user (enhanced to handle rotated sessions)\n\tasync invalidateAllUserSessions(user_id: string, tenantId?: string): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\tconst now = new Date();\n\t\t\tconst filter: Record<string, unknown> = {\n\t\t\t\tuser_id,\n\t\t\t\texpires: { $gt: now.toISOString() }, // Only delete active (non-expired) sessions\n\t\t\t\t$or: [\n\t\t\t\t\t{ rotated: { $ne: true } }, // Delete non-rotated sessions\n\t\t\t\t\t{ rotated: true, expires: { $lte: new Date(now.getTime() + 60000).toISOString() } } // Delete rotated sessions close to expiry\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst result = await this.SessionModel.deleteMany(filter);\n\t\t\tlogger.debug(\n\t\t\t\t`InvalidateAllUserSessions: Attempted to delete sessions for user_id=${user_id} at ${now.toISOString()}. Deleted count: ${result.deletedCount}`\n\t\t\t);\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.invalidateAllUserSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'INVALIDATION_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get active sessions for a user (enhanced to show rotation status)\n\tasync getActiveSessions(user_id: string, tenantId?: string): Promise<DatabaseResult<Session[]>> {\n\t\ttry {\n\t\t\tconst filter: Record<string, unknown> = {\n\t\t\t\tuser_id,\n\t\t\t\texpires: { $gt: new Date().toISOString() }\n\t\t\t};\n\n\t\t\tif (tenantId) {\n\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst sessions = await this.SessionModel.find(filter).lean();\n\t\t\tlogger.debug('Active sessions retrieved for user', { user_id, count: sessions.length });\n\t\t\treturn { success: true, data: sessions.map((session) => this.formatSession(session as any)) };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.getActiveSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'RETRIEVAL_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get all active sessions for all users (for online users widget)\n\tasync getAllActiveSessions(tenantId?: string): Promise<DatabaseResult<Session[]>> {\n\t\ttry {\n\t\t\tconst query: Record<string, unknown> = {\n\t\t\t\texpires: { $gt: new Date().toISOString() }\n\t\t\t};\n\n\t\t\t// If multi-tenant mode, filter by tenantId\n\t\t\tif (tenantId) {\n\t\t\t\tquery.tenantId = tenantId;\n\t\t\t}\n\n\t\t\tconst sessions = await this.SessionModel.find(query).lean();\n\t\t\tlogger.debug('All active sessions retrieved', { count: sessions.length, tenantId });\n\t\t\treturn { success: true, data: sessions.map((session) => this.formatSession(session as any)) };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.getAllActiveSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'RETRIEVAL_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Get session token metadata including expiration (enhanced to handle rotated sessions)\n\tasync getSessionTokenData(session_id: string): Promise<DatabaseResult<{ expiresAt: ISODateString; user_id: string } | null>> {\n\t\ttry {\n\t\t\tconst session = await this.SessionModel.findById(session_id).lean();\n\t\t\tif (!session) {\n\t\t\t\treturn { success: true, data: null };\n\t\t\t}\n\n\t\t\t// Check if token is expired\n\t\t\tif (new Date(session.expires) <= new Date()) {\n\t\t\t\tawait this.SessionModel.findByIdAndDelete(session_id);\n\t\t\t\treturn { success: true, data: null };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\texpiresAt: toISOString(session.expires),\n\t\t\t\t\tuser_id: session.user_id // Include user_id as required by authDBInterface\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconst message = `Failed to get token data: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'TOKEN_DATA_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\t// Clean up rotated sessions that have passed their grace period\n\tasync cleanupRotatedSessions(): Promise<DatabaseResult<number>> {\n\t\ttry {\n\t\t\tconst now = new Date();\n\t\t\tconst result = await this.SessionModel.deleteMany({\n\t\t\t\trotated: true,\n\t\t\t\texpires: { $lte: now.toISOString() }\n\t\t\t});\n\n\t\t\tif (result.deletedCount > 0) {\n\t\t\t\tlogger.info(`Cleaned up ${result.deletedCount} rotated sessions past grace period`);\n\t\t\t}\n\n\t\t\treturn { success: true, data: result.deletedCount };\n\t\t} catch (err) {\n\t\t\tconst message = `Error in SessionAdapter.cleanupRotatedSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\tlogger.error(message);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage,\n\t\t\t\terror: { code: 'CLEANUP_ERROR', message }\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate formatSession(session: {\n\t\t_id: Types.ObjectId | string;\n\t\tuser_id: string;\n\t\texpires: Date | ISODateString | string;\n\t\t[key: string]: unknown;\n\t}): Session {\n\t\treturn {\n\t\t\t...session,\n\t\t\t_id: typeof session._id === 'string' ? session._id : session._id.toString(),\n\t\t\texpires: toISOString(session.expires) // Convert to ISODateString\n\t\t} as Session;\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/authMethods.ts\n * @description Authentication model registration for the MongoDB adapter.\n * This class is responsible for idempotently registering auth-related Mongoose models.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type Mongoose from 'mongoose';\nimport { createDatabaseError } from './mongoDBUtils';\nimport { UserSchema } from '../models/authUser';\nimport { TokenSchema } from '../models/authToken';\nimport { SessionSchema } from '../models/authSession';\n\n/**\n * A dedicated class for registering authentication models with a Mongoose instance.\n * It uses Dependency Injection to allow for a testable, modular setup.\n */\nexport class MongoAuthModelRegistrar {\n\tprivate readonly mongoose: typeof Mongoose;\n\n\t/**\n\t * Constructs the model registrar.\n\t * @param {typeof Mongoose} mongooseInstance - The Mongoose instance to register models with.\n\t */\n\tconstructor(mongooseInstance: typeof Mongoose) {\n\t\tthis.mongoose = mongooseInstance;\n\t\tlogger.info('MongoAuthModelRegistrar initialized.');\n\t}\n\n\t/**\n\t * Registers authentication models (User, Token, Session).\n\t * This process is idempotent; it will not re-register models that already exist.\n\t * @throws {DatabaseError} If schemas cannot be imported or models fail to register.\n\t */\n\tasync setupAuthModels(): Promise<void> {\n\t\ttry {\n\t\t\t// Schemas are now statically imported at top of file\n\t\t\t// This avoids dynamic import warning and improves code splitting\n\n\t\t\t// Register each model using the private helper\n\t\t\tthis._registerModel('auth_users', UserSchema);\n\t\t\tthis._registerModel('auth_sessions', SessionSchema);\n\t\t\tthis._registerModel('auth_tokens', TokenSchema);\n\n\t\t\tlogger.info('Authentication models registered successfully.');\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'AUTH_MODEL_SETUP_FAILED', 'Failed to set up authentication models');\n\t\t}\n\t}\n\n\t/**\n\t * A private helper that checks for a model's existence before registering it.\n\t * @param {string} name - The name of the model.\n\t * @param {Mongoose.Schema} schema - The Mongoose schema for the model.\n\t */\n\tprivate _registerModel(name: string, schema: Mongoose.Schema): void {\n\t\t// Use the injected mongoose instance\n\t\tif (!this.mongoose.models[name]) {\n\t\t\tthis.mongoose.model(name, schema);\n\t\t\tlogger.debug(`Model '${name}' was registered`);\n\t\t} else {\n\t\t\tlogger.debug(`Model '${name}' already exists and was not re-registered`);\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/collectionMethods.ts\n * @description Dynamic model/schema registration and management for MongoDB collections.\n *\n * Responsibility: ONLY for dynamic model/schema creation, registration, and management.\n *\n * This module handles:\n * - Dynamic creation of Mongoose models from collection schemas\n * - Model registry/map for tracking registered models\n * - Model existence checks and retrieval\n * - Schema validation and field mapping\n *\n * Does NOT handle:\n * - CRUD operations (use crudMethods.ts)\n * - Content structure/drafts/revisions (use contentMethods.ts)\n */\n\nimport { logger } from '@shared/utils/logger';\nimport mongoose, { Schema as MongooseSchema, type Model } from 'mongoose';\nimport type { CollectionModel } from '../../dbInterface';\nimport type { Schema } from '@cms-types/content';\nimport { withCache, CacheCategory, invalidateCollectionCache } from './mongoDBCacheUtils';\nimport { nowISODateString } from '@shared/utils/dateUtils';\n\n/**\n * MongoCollectionMethods manages dynamic model creation and registration.\n *\n * This class is responsible for creating, registering, and managing\n * dynamic Mongoose models based on user-defined collection schemas.\n */\nexport class MongoCollectionMethods {\n\t// Internal registry of all dynamically created models\n\tprivate models = new Map<string, { model: Model<unknown>; wrapped: CollectionModel }>();\n\n\t/**\n\t * Gets a registered collection model by ID\n\t * Cached with 600s TTL since schemas rarely change\n\t */\n\tasync getModel(id: string): Promise<CollectionModel> {\n\t\treturn withCache(\n\t\t\t`schema:collection:${id}`,\n\t\t\tasync () => {\n\t\t\t\tconst entry = this.models.get(id);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tthrow new Error(`Collection model with id ${id} not found. Available: ${Array.from(this.models.keys()).join(', ')}`);\n\t\t\t\t}\n\t\t\t\treturn entry.wrapped;\n\t\t\t},\n\t\t\t{ category: CacheCategory.SCHEMA }\n\t\t);\n\t}\n\n\t/**\n\t * Creates or updates a dynamic collection model from a schema\n\t */\n\tasync createModel(schema: Schema): Promise<void> {\n\t\tconst collectionId = schema._id;\n\t\tif (!collectionId) {\n\t\t\tthrow new Error('Schema must have an _id field');\n\t\t}\n\n\t\tlogger.debug(`Creating/updating collection model for: ${collectionId}`);\n\n\t\t// Invalidate cache for this collection\n\t\tawait invalidateCollectionCache(`schema:collection:${collectionId}`);\n\n\t\tconst modelName = `collection_${collectionId}`;\n\n\t\t// Force delete existing model and registry entry to ensure clean slate\n\t\t// This is crucial for schema updates (e.g., ObjectId  String migration)\n\t\tif (this.models.has(collectionId)) {\n\t\t\tlogger.debug(`Removing existing model ${collectionId} for refresh...`);\n\t\t\tthis.models.delete(collectionId);\n\t\t}\n\n\t\t// Remove existing Mongoose model if present (for hot reload)\n\t\tif (mongoose.models[modelName]) {\n\t\t\tlogger.debug(`Deleting Mongoose model ${modelName} for refresh...`);\n\t\t\tdelete mongoose.models[modelName];\n\t\t}\n\n\t\t// Build schema definition from collection fields\n\t\t// Note: Using String type for _id to support UUID-based IDs instead of MongoDB ObjectIds\n\t\tconst schemaDefinition: Record<string, mongoose.SchemaDefinitionProperty> = {\n\t\t\t_id: { type: String, required: true },\n\t\t\tstatus: { type: String, default: 'draft' },\n\t\t\tcreatedAt: { type: String, default: () => nowISODateString() },\n\t\t\tupdatedAt: { type: String, default: () => nowISODateString() },\n\t\t\tcreatedBy: { type: MongooseSchema.Types.Mixed, ref: 'auth_users' },\n\t\t\tupdatedBy: { type: MongooseSchema.Types.Mixed, ref: 'auth_users' }\n\t\t};\n\n\t\t// Map collection fields to Mongoose schema\n\t\tif (schema.fields && Array.isArray(schema.fields)) {\n\t\t\tfor (const field of schema.fields) {\n\t\t\t\tif (typeof field === 'object' && field !== null) {\n\t\t\t\t\tconst fieldObj = field as Record<string, unknown>;\n\t\t\t\t\tconst fieldKey =\n\t\t\t\t\t\t(fieldObj.db_fieldName as string) ||\n\t\t\t\t\t\t(fieldObj.label\n\t\t\t\t\t\t\t? String(fieldObj.label)\n\t\t\t\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t\t\t\t.replace(/[^a-z0-9_]/g, '_')\n\t\t\t\t\t\t\t: null) ||\n\t\t\t\t\t\t(fieldObj.Name as string);\n\n\t\t\t\t\tif (!fieldKey) continue;\n\n\t\t\t\t\tschemaDefinition[fieldKey] = {\n\t\t\t\t\t\ttype: mongoose.Schema.Types.Mixed,\n\t\t\t\t\t\trequired: (fieldObj.required as boolean) || false,\n\t\t\t\t\t\tunique: (fieldObj.unique as boolean) || false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create Mongoose schema\n\t\t// Use _id: false to prevent auto-generation of ObjectId, then explicitly define _id as String\n\t\tconst mongooseSchema = new mongoose.Schema(schemaDefinition, {\n\t\t\t_id: false, // Disable auto ObjectId generation\n\t\t\tstrict: schema.strict !== false,\n\t\t\ttimestamps: false, // We handle timestamps explicitly with ISODateString\n\t\t\tcollection: modelName.toLowerCase()\n\t\t});\n\n\t\t// Create and register the model\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tconst model = mongoose.model(modelName, mongooseSchema) as any;\n\n\t\t// Wrap the model for the interface\n\t\tconst wrappedModel: CollectionModel = {\n\t\t\tfindOne: async (query) => {\n\t\t\t\tconst result = await model.findOne(query).lean().exec();\n\t\t\t\treturn result as Record<string, unknown> | null;\n\t\t\t},\n\t\t\taggregate: async (pipeline) => {\n\t\t\t\treturn await model.aggregate(pipeline as unknown as mongoose.PipelineStage[]).exec();\n\t\t\t}\n\t\t};\n\n\t\tthis.models.set(collectionId, { model, wrapped: wrappedModel });\n\t\tlogger.info(`Collection model created: ${collectionId} (${modelName})`);\n\n\t\t// Create database indexes for optimal query performance\n\t\tawait this.createIndexes(model, schema);\n\n\t\t// NOTE: Physical collection creation disabled\n\t\t// Using generic system_content_structure table for all collections instead of per-collection tables\n\t\t// This is more efficient and reduces database clutter\n\t\t// MongoDB will create collections lazily on first insert if needed\n\n\t\t// Create the physical collection in MongoDB if it doesn't exist\n\t\t// MongoDB creates collections lazily on first insert, but we want them to exist immediately\n\t\t/* DISABLED - Using system_content_structure instead\n\t\ttry {\n\t\t\tconst collectionExists = await this.collectionExists(modelName.toLowerCase());\n\t\t\tif (!collectionExists) {\n\t\t\t\tlogger.debug(`Creating physical collection: ${modelName} in database`);\n\t\t\t\tawait mongoose.connection.db?.createCollection(modelName.toLowerCase());\n\t\t\t\tlogger.info(` Physical collection created: ${modelName}`);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`Physical collection already exists: ${modelName}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Collection might already exist or database might not support it\n\t\t\t// This is not critical - MongoDB will create it on first insert\n\t\t\tlogger.warn(`Could not create physical collection ${modelName}: ${error instanceof Error ? error.message : String(error)}`);\n\t\t}\n\t\t*/\n\t}\n\n\t/**\n\t * Updates an existing collection model\n\t */\n\tasync updateModel(schema: Schema): Promise<void> {\n\t\t// Invalidate cache before updating\n\t\tif (schema._id) {\n\t\t\tawait invalidateCollectionCache(`schema:collection:${schema._id}`);\n\t\t}\n\t\t// For now, just recreate the model\n\t\tawait this.createModel(schema);\n\t}\n\n\t/**\n\t * Deletes a collection model\n\t */\n\tasync deleteModel(id: string): Promise<void> {\n\t\t// Invalidate cache before deleting\n\t\tawait invalidateCollectionCache(`schema:collection:${id}`);\n\n\t\tthis.models.delete(id);\n\t\tconst modelName = `collection_${id}`;\n\t\tif (mongoose.models[modelName]) {\n\t\t\tdelete mongoose.models[modelName];\n\t\t}\n\t\tlogger.info(`Collection model deleted: ${id}`);\n\t}\n\n\t/**\n\t * Checks if a collection exists in the database\n\t */\n\tasync collectionExists(collectionName: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst collections =\n\t\t\t\t(await mongoose.connection.db\n\t\t\t\t\t?.listCollections({\n\t\t\t\t\t\tname: collectionName.toLowerCase()\n\t\t\t\t\t})\n\t\t\t\t\t.toArray()) ?? [];\n\t\t\treturn collections.length > 0;\n\t\t} catch (error) {\n\t\t\tlogger.error(`Error checking collection existence: ${error}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the internal Mongoose model (for CRUD operations)\n\t */\n\tgetMongooseModel(id: string): Model<unknown> | null {\n\t\tconst entry = this.models.get(id);\n\t\treturn entry ? entry.model : null;\n\t}\n\n\t/**\n\t * Gets all registered model IDs\n\t */\n\tgetRegisteredModelIds(): string[] {\n\t\treturn Array.from(this.models.keys());\n\t}\n\n\t/**\n\t * Creates database indexes for optimal query performance\n\t *\n\t * This method creates indexes on:\n\t * - Common query fields (status, createdAt, updatedAt)\n\t * - Fields marked as unique or indexed in the schema\n\t * - Multi-tenant fields (tenantId)\n\t * - Sortable and filterable fields\n\t */\n\tprivate async createIndexes(model: Model<unknown>, schema: Schema): Promise<void> {\n\t\ttry {\n\t\t\tconst collectionId = schema._id;\n\t\t\tlogger.debug(`Creating indexes for collection: ${collectionId}`);\n\n\t\t\t// Essential indexes for all collections\n\t\t\tconst indexes: Array<{ fields: Record<string, 1 | -1>; options?: Record<string, unknown> }> = [\n\t\t\t\t// Primary sort/filter indexes\n\t\t\t\t{ fields: { status: 1 } },\n\t\t\t\t{ fields: { createdAt: -1 } },\n\t\t\t\t{ fields: { updatedAt: -1 } },\n\t\t\t\t{ fields: { createdBy: 1 } },\n\n\t\t\t\t// Compound indexes for common query patterns\n\t\t\t\t{ fields: { status: 1, createdAt: -1 } },\n\t\t\t\t{ fields: { status: 1, updatedAt: -1 } },\n\n\t\t\t\t// Multi-tenant support\n\t\t\t\t{ fields: { tenantId: 1 } },\n\t\t\t\t{ fields: { tenantId: 1, status: 1 } },\n\t\t\t\t{ fields: { tenantId: 1, createdAt: -1 } }\n\t\t\t];\n\n\t\t\t// Add indexes for fields marked as indexed or unique\n\t\t\tif (schema.fields && Array.isArray(schema.fields)) {\n\t\t\t\tfor (const field of schema.fields) {\n\t\t\t\t\tif (typeof field === 'object' && field !== null) {\n\t\t\t\t\t\tconst fieldObj = field as Record<string, unknown>;\n\t\t\t\t\t\tconst fieldKey =\n\t\t\t\t\t\t\t(fieldObj.db_fieldName as string) ||\n\t\t\t\t\t\t\t(fieldObj.label\n\t\t\t\t\t\t\t\t? String(fieldObj.label)\n\t\t\t\t\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t\t\t\t\t.replace(/[^a-z0-9_]/g, '_')\n\t\t\t\t\t\t\t\t: null) ||\n\t\t\t\t\t\t\t(fieldObj.Name as string);\n\n\t\t\t\t\t\tif (!fieldKey) continue;\n\n\t\t\t\t\t\t// Unique index\n\t\t\t\t\t\tif (fieldObj.unique) {\n\t\t\t\t\t\t\tindexes.push({\n\t\t\t\t\t\t\t\tfields: { [fieldKey]: 1 },\n\t\t\t\t\t\t\t\toptions: { unique: true, sparse: true }\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Regular index for searchable/filterable fields\n\t\t\t\t\t\tif (fieldObj.indexed || fieldObj.searchable || fieldObj.sortable) {\n\t\t\t\t\t\t\tindexes.push({ fields: { [fieldKey]: 1 } });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Text index for searchable text fields\n\t\t\t\t\t\tif (fieldObj.searchable && (fieldObj.type === 'text' || fieldObj.type === 'textarea')) {\n\t\t\t\t\t\t\tindexes.push({\n\t\t\t\t\t\t\t\tfields: { [fieldKey]: 'text' as unknown as 1 },\n\t\t\t\t\t\t\t\toptions: { default_language: 'english' }\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create all indexes\n\t\t\tconst collection = model.collection;\n\t\t\tfor (const index of indexes) {\n\t\t\t\ttry {\n\t\t\t\t\tawait collection.createIndex(index.fields, index.options || {});\n\t\t\t\t\tlogger.trace(`Created index on ${Object.keys(index.fields).join(', ')} for ${collectionId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Ignore duplicate index errors\n\t\t\t\t\tif ((error as Error).message.includes('already exists')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlogger.warn(`Failed to create index for ${collectionId}: ${error}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info(`Indexes created for collection: ${collectionId}`);\n\t\t} catch (error) {\n\t\t\tlogger.error(`Error creating indexes: ${error}`);\n\t\t\t// Don't throw - index creation failures shouldn't prevent model creation\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/crudMethods.ts\n * @description Generic, reusable CRUD operations for any MongoDB collection.\n *\n * Responsibility: ALL generic CRUD operations for any collection/model.\n *\n * This module provides:\n * - findOne, findMany, findByIds\n * - insert, update, upsert\n * - delete, deleteMany\n * - count, exists\n * - aggregate (for complex queries)\n * - Batch operations (upsertMany)\n *\n * Does NOT handle:\n * - Schema/model creation (use collectionMethods.ts)\n * - CMS-specific logic (use contentMethods.ts)\n * - Business rules or validation (handled by callers)\n *\n * This class is designed to be instantiated once per collection/model,\n * providing a clean, type-safe interface for all data operations.\n */\n\nimport { type Model, type PipelineStage, type UpdateQuery, mongo } from 'mongoose';\nimport type { BaseEntity, DatabaseId, QueryFilter } from '../../dbInterface';\nimport { createDatabaseError, generateId, processDates } from './mongoDBUtils';\nimport { nowISODateString } from '@shared/utils/dateUtils';\n\n/**\n * MongoCrudMethods provides generic CRUD operations for a Mongoose model.\n *\n * Each instance is tied to a specific model and provides all standard\n * database operations in a consistent, error-handled manner.\n *\n * @template T - The entity type (must extend BaseEntity)\n */\n\nexport class MongoCrudMethods<T extends BaseEntity> {\n\tpublic readonly model: Model<T>;\n\n\tconstructor(model: Model<T>) {\n\t\tthis.model = model;\n\t}\n\n\tasync findOne(query: QueryFilter<T>, options: { fields?: (keyof T)[] } = {}): Promise<T | null> {\n\t\ttry {\n\t\t\tconst result = await this.model.findOne(query, options.fields?.join(' ')).lean().exec();\n\t\t\tif (!result) return null;\n\t\t\treturn processDates(result) as T;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'FIND_ONE_ERROR', `Failed to find document in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync findById(id: DatabaseId): Promise<T | null> {\n\t\ttry {\n\t\t\tconst result = await this.model.findById(id).lean().exec();\n\t\t\tif (!result) return null;\n\t\t\treturn processDates(result) as T;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'FIND_BY_ID_ERROR', `Failed to find document by ID in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync findByIds(ids: DatabaseId[]): Promise<T[]> {\n\t\ttry {\n\t\t\tconst results = await this.model\n\t\t\t\t.find({ _id: { $in: ids } } as QueryFilter<T>)\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\t\t\treturn processDates(results) as T[];\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'FIND_BY_IDS_ERROR', `Failed to find documents by IDs in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync findMany(\n\t\tquery: QueryFilter<T>,\n\t\toptions: { limit?: number; skip?: number; sort?: { [key: string]: 'asc' | 'desc' | 1 | -1 }; fields?: (keyof T)[] } = {}\n\t): Promise<T[]> {\n\t\ttry {\n\t\t\tconst results = await this.model\n\t\t\t\t.find(query, options.fields?.join(' '))\n\t\t\t\t.sort(options.sort || {})\n\t\t\t\t.skip(options.skip ?? 0)\n\t\t\t\t.limit(options.limit ?? 0)\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\t\t\treturn processDates(results) as T[];\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'FIND_MANY_ERROR', `Failed to find documents in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync insert(data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>): Promise<T> {\n\t\ttry {\n\t\t\tconst doc = {\n\t\t\t\t...data,\n\t\t\t\t_id: generateId(),\n\t\t\t\tcreatedAt: nowISODateString(),\n\t\t\t\tupdatedAt: nowISODateString()\n\t\t\t} as unknown as T;\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\treturn ((await this.model.create(doc as any)) as any).toObject() as T;\n\t\t} catch (error) {\n\t\t\tif (error instanceof mongo.MongoServerError && error.code === 11000) {\n\t\t\t\tthrow createDatabaseError(error, 'DUPLICATE_KEY_ERROR', 'A document with the same unique key already exists.');\n\t\t\t}\n\t\t\tthrow createDatabaseError(error, 'INSERT_ERROR', `Failed to insert document into ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync insertMany(data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>[]): Promise<T[]> {\n\t\ttry {\n\t\t\tconst docs = data.map((d) => ({\n\t\t\t\t...d,\n\t\t\t\t_id: generateId(),\n\t\t\t\tcreatedAt: nowISODateString(),\n\t\t\t\tupdatedAt: nowISODateString()\n\t\t\t}));\n\t\t\tconst result = await this.model.insertMany(docs);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\treturn result.map((doc: any) => doc.toObject());\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'INSERT_MANY_ERROR', `Failed to insert many documents into ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync update(id: DatabaseId, data: UpdateQuery<T>): Promise<T | null> {\n\t\ttry {\n\t\t\tconst updateData = {\n\t\t\t\t...(data as object),\n\t\t\t\tupdatedAt: nowISODateString()\n\t\t\t};\n\t\t\tconst result = await this.model.findByIdAndUpdate(id, { $set: updateData }, { new: true }).lean().exec();\n\n\t\t\tif (!result) return null;\n\t\t\treturn processDates(result) as T;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'UPDATE_ERROR', `Failed to update document ${id} in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync upsert(query: QueryFilter<T>, data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>): Promise<T> {\n\t\ttry {\n\t\t\tconst result = await this.model\n\t\t\t\t.findOneAndUpdate(\n\t\t\t\t\tquery,\n\t\t\t\t\t{\n\t\t\t\t\t\t$set: { ...data, updatedAt: nowISODateString() },\n\t\t\t\t\t\t$setOnInsert: { _id: generateId(), createdAt: nowISODateString() }\n\t\t\t\t\t},\n\t\t\t\t\t{ new: true, upsert: true, runValidators: true }\n\t\t\t\t)\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\t\t\treturn processDates(result) as T;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'UPSERT_ERROR', `Failed to upsert document in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync delete(id: DatabaseId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst result = await this.model.deleteOne({ _id: id } as QueryFilter<T>);\n\t\t\treturn result.deletedCount > 0;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'DELETE_ERROR', `Failed to delete document ${id} from ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync updateMany(query: QueryFilter<T>, data: UpdateQuery<T>): Promise<{ modifiedCount: number; matchedCount: number }> {\n\t\ttry {\n\t\t\tconst updateData = {\n\t\t\t\t...(data as object),\n\t\t\t\tupdatedAt: nowISODateString()\n\t\t\t};\n\t\t\tconst result = await this.model.updateMany(query, { $set: updateData });\n\t\t\treturn {\n\t\t\t\tmodifiedCount: result.modifiedCount,\n\t\t\t\tmatchedCount: result.matchedCount\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'UPDATE_MANY_ERROR', `Failed to update multiple documents in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync deleteMany(query: QueryFilter<T>): Promise<{ deletedCount: number }> {\n\t\ttry {\n\t\t\tconst result = await this.model.deleteMany(query);\n\t\t\treturn { deletedCount: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'DELETE_MANY_ERROR', `Failed to delete documents from ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync upsertMany(\n\t\titems: Array<{ query: QueryFilter<T>; data: Omit<T, '_id' | 'createdAt' | 'updatedAt'> }>\n\t): Promise<{ upsertedCount: number; modifiedCount: number }> {\n\t\ttry {\n\t\t\tif (items.length === 0) return { upsertedCount: 0, modifiedCount: 0 };\n\n\t\t\tconst now = nowISODateString();\n\t\t\tconst operations = items.map((item) => ({\n\t\t\t\tupdateOne: {\n\t\t\t\t\tfilter: item.query as any,\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\t$set: { ...item.data, updatedAt: now },\n\t\t\t\t\t\t$setOnInsert: { _id: generateId(), createdAt: now }\n\t\t\t\t\t},\n\t\t\t\t\tupsert: true\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tconst result = await this.model.bulkWrite(operations as any);\n\t\t\treturn {\n\t\t\t\tupsertedCount: result.upsertedCount,\n\t\t\t\tmodifiedCount: result.modifiedCount\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'UPSERT_MANY_ERROR', `Failed to upsert documents in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync count(query: QueryFilter<T> = {}): Promise<number> {\n\t\ttry {\n\t\t\treturn await this.model.countDocuments(query);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'COUNT_ERROR', `Failed to count documents in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a document exists matching the given query.\n\t * Uses findOne with _id projection instead of exists() for faster execution.\n\t * MongoDB stops scanning as soon as it finds the first match, and projection reduces network overhead.\n\t */\n\tasync exists(query: QueryFilter<T>): Promise<boolean> {\n\t\ttry {\n\t\t\t// Use findOne with projection for optimal performance\n\t\t\t// Only fetches _id field, minimizing data transfer\n\t\t\tconst doc = await this.model.findOne(query, { _id: 1 }).lean().exec();\n\t\t\treturn !!doc;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'EXISTS_ERROR', `Failed to check for document existence in ${this.model.modelName}`);\n\t\t}\n\t}\n\n\tasync aggregate<R>(pipeline: PipelineStage[]): Promise<R[]> {\n\t\ttry {\n\t\t\treturn await this.model.aggregate<R>(pipeline).exec();\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'AGGREGATION_ERROR', `Aggregation failed in ${this.model.modelName}`);\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/normalizeId.ts\n * @description Shared helper for safely normalizing identifier-like values into strings.\n *\n * Optimized check order prioritizes most common cases (string, ObjectId) first.\n */\n\nimport type { Types } from 'mongoose';\n\n/**\n * Type guard for Mongoose ObjectId.\n * Checks both instanceof and duck-typing for maximum compatibility.\n */\nfunction isObjectId(value: unknown): value is Types.ObjectId {\n\tif (!value || typeof value !== 'object') return false;\n\t// Check for toHexString method (most reliable for ObjectId)\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\treturn typeof (value as any).toHexString === 'function';\n}\n\n/**\n * Safely normalizes various ID formats into strings.\n * Handles: string, ObjectId, number, object with _id/id properties, etc.\n *\n * @param id - The value to normalize\n * @returns A string representation or null if normalization fails\n */\nexport function normalizeId(id: unknown): string | null {\n\t// Fast path: null/undefined\n\tif (id === null || id === undefined) {\n\t\treturn null;\n\t}\n\n\t// Fast path: string (most common case after database reads)\n\tif (typeof id === 'string') {\n\t\treturn id;\n\t}\n\n\t// Fast path: Mongoose ObjectId (extremely common in MongoDB operations)\n\t// Check this BEFORE object property traversal\n\tif (isObjectId(id)) {\n\t\treturn (id as Types.ObjectId).toHexString();\n\t}\n\n\t// Handle primitive types that can be safely stringified\n\tif (typeof id === 'number' || typeof id === 'bigint' || typeof id === 'boolean') {\n\t\treturn String(id);\n\t}\n\n\t// Handle objects with nested ID properties\n\tif (typeof id === 'object') {\n\t\tconst candidate = id as Record<string, unknown> & {\n\t\t\tvalueOf?: () => unknown;\n\t\t\ttoString?: () => string;\n\t\t};\n\n\t\t// Check for _id property (common in MongoDB documents)\n\t\tif (candidate._id !== undefined) {\n\t\t\tconst nested = normalizeId(candidate._id);\n\t\t\tif (nested) {\n\t\t\t\treturn nested;\n\t\t\t}\n\t\t}\n\n\t\t// Check for id property (common in API responses)\n\t\tif (candidate.id !== undefined) {\n\t\t\tconst nested = normalizeId(candidate.id);\n\t\t\tif (nested) {\n\t\t\t\treturn nested;\n\t\t\t}\n\t\t}\n\n\t\t// Try valueOf() for wrapped primitives\n\t\tif (typeof candidate.valueOf === 'function') {\n\t\t\tconst value = candidate.valueOf();\n\t\t\tif (value && value !== id) {\n\t\t\t\tconst nested = normalizeId(value);\n\t\t\t\tif (nested) {\n\t\t\t\t\treturn nested;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Last resort: toString() (but avoid [object Object])\n\t\tif (typeof candidate.toString === 'function') {\n\t\t\tconst asString = candidate.toString();\n\t\t\tif (asString && asString !== '[object Object]') {\n\t\t\t\treturn asString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Final fallback\n\tconst fallback = String(id);\n\treturn fallback === '[object Object]' ? null : fallback;\n}\n","/**\n * @file src/databases/mongodb/methods/contentMethods.ts\n * @description CMS-specific content logic for structure trees, drafts, and revisions.\n *\n * Responsibility: ONLY for CMS-specific content workflows.\n *\n * This module handles:\n * - Content structure (menus, trees, hierarchies)\n * - Draft creation, management, and publishing workflows\n * - Revision history, tracking, and cleanup\n * - Content-specific batch operations\n *\n * Does NOT handle:\n * - Generic CRUD operations (use crudMethods.ts)\n * - Model/schema creation (use collectionMethods.ts)\n */\n\nimport type { ContentNode, DatabaseId } from '@cms-types/content';\nimport { logger } from '@shared/utils/logger';\nimport type {\n\tBaseEntity,\n\tContentDraft as DBContentDraft,\n\tContentRevision as DBContentRevision,\n\tPaginatedResult,\n\tPaginationOptions,\n\tQueryFilter\n} from '../../dbInterface';\nimport { MongoCrudMethods } from './crudMethods';\nimport { createDatabaseError, generateId } from './mongoDBUtils';\nimport { withCache, CacheCategory, invalidateCategoryCache } from './mongoDBCacheUtils';\nimport { normalizeId } from './normalizeId';\nexport { normalizeId } from './normalizeId';\n\n// Create local types that satisfy the BaseEntity constraint\ntype ContentDraft = DBContentDraft & BaseEntity;\ntype ContentRevision = DBContentRevision & BaseEntity;\n\n/**\n * Converts a flat array of content nodes into a nested tree.\n * This is a pure utility function that can be tested and reused outside MongoDB context.\n */\nexport function buildTree(nodes: ContentNode[]): ContentNode[] {\n\tconst nodeMap = new Map<string, ContentNode>();\n\tconst roots: ContentNode[] = [];\n\n\t// First pass: Create map with all nodes\n\tfor (const node of nodes) {\n\t\tconst nodeId = typeof node._id === 'string' ? node._id : String(node._id);\n\t\tnodeMap.set(nodeId, { ...node, children: [] });\n\t}\n\n\t// Second pass: Build the tree by linking children to parents\n\tfor (const node of nodeMap.values()) {\n\t\tif (node.parentId) {\n\t\t\tconst parentId = typeof node.parentId === 'string' ? node.parentId : String(node.parentId);\n\t\t\tconst parent = nodeMap.get(parentId);\n\t\t\tif (parent) {\n\t\t\t\tparent.children!.push(node);\n\t\t\t} else {\n\t\t\t\t// Parent not found, treat as root\n\t\t\t\tlogger.warn(`[buildTree] Parent ${parentId} not found for node ${node._id}, treating as root`);\n\t\t\t\troots.push(node);\n\t\t\t}\n\t\t} else {\n\t\t\t// No parentId, it's a root node\n\t\t\troots.push(node);\n\t\t}\n\t}\n\n\tlogger.trace(`[buildTree] Built tree with ${roots.length} root nodes from ${nodes.length} total nodes`);\n\treturn roots;\n}\n\n/**\n * MongoContentMethods manages CMS-specific content workflows.\n *\n * This class coordinates generic CRUD repositories to implement:\n * - Content structure management (trees, hierarchies)\n * - Draft workflows (create, publish, manage)\n * - Revision tracking (history, cleanup, restore)\n */\n\nexport class MongoContentMethods {\n\t// Repositories are injected for testability and code reuse\n\tprivate readonly nodesRepo: MongoCrudMethods<ContentNode>;\n\tprivate readonly draftsRepo: MongoCrudMethods<ContentDraft>;\n\tprivate readonly revisionsRepo: MongoCrudMethods<ContentRevision>;\n\n\t/**\n\t * Creates an instance of MongoContentMethods.\n\t * @param nodesRepo A repository for ContentNode operations.\n\t * @param draftsRepo A repository for ContentDraft operations.\n\t * @param revisionsRepo A repository for ContentRevision operations.\n\t */\n\tconstructor(\n\t\tnodesRepo: MongoCrudMethods<ContentNode>,\n\t\tdraftsRepo: MongoCrudMethods<ContentDraft>,\n\t\trevisionsRepo: MongoCrudMethods<ContentRevision>\n\t) {\n\t\tthis.nodesRepo = nodesRepo;\n\t\tthis.draftsRepo = draftsRepo;\n\t\tthis.revisionsRepo = revisionsRepo;\n\t\tlogger.trace('MongoContentMethods initialized with repositories.');\n\t}\n\n\t// ============================================================\n\t// Content Structure Methods\n\t// ============================================================\n\n\t/**\n\t * Retrieves the content structure as a flat list or a hierarchical tree.\n\t * Cached with 180s TTL since structure is frequently accessed for navigation/menus\n\t */\n\tasync getStructure(mode: 'flat' | 'nested' = 'flat', filter: Partial<ContentNode> = {}, bypassCache = false): Promise<ContentNode[]> {\n\t\t// Create cache key based on mode and filter\n\t\tconst filterKey = JSON.stringify(filter);\n\t\tconst cacheKey = `content:structure:${mode}:${filterKey}`;\n\n\t\tconst fetchData = async () => {\n\t\t\tconst nodes = await this.nodesRepo.findMany(filter);\n\t\t\tif (mode === 'flat') {\n\t\t\t\treturn nodes;\n\t\t\t}\n\n\t\t\t// Build the nested tree structure using the utility function\n\t\t\treturn buildTree(nodes);\n\t\t};\n\n\t\t// Bypass cache if requested (e.g., during sync operations)\n\t\tif (bypassCache) {\n\t\t\treturn fetchData();\n\t\t}\n\n\t\treturn withCache(cacheKey, fetchData, { category: CacheCategory.CONTENT });\n\t}\n\n\t// Atomically creates a new node or updates an existing one based on its path.\n\tasync upsertNodeByPath(nodeData: Omit<ContentNode, '_id' | 'createdAt' | 'updatedAt'>): Promise<ContentNode> {\n\t\ttry {\n\t\t\tconst { path, parentId } = nodeData;\n\n\t\t\t// Normalize parentId using safe helper to prevent [object Object] storage issues\n\t\t\tconst normalizedParentId = normalizeId(parentId);\n\n\t\t\tconst result = await this.nodesRepo.model\n\t\t\t\t.findOneAndUpdate(\n\t\t\t\t\t{ path },\n\t\t\t\t\t{\n\t\t\t\t\t\t$set: { ...nodeData, parentId: normalizedParentId, updatedAt: new Date() },\n\t\t\t\t\t\t$setOnInsert: { _id: generateId(), createdAt: new Date() }\n\t\t\t\t\t},\n\t\t\t\t\t{ new: true, upsert: true, runValidators: true }\n\t\t\t\t)\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\n\t\t\t// Invalidate content structure caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.CONTENT);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'NODE_UPSERT_ERROR', 'Failed to upsert content structure node.');\n\t\t}\n\t}\n\n\t/**\n\t * Updates multiple nodes in a single, efficient bulk operation.\n\t * Uses upsert to create nodes if they don't exist.\n\t * IMPORTANT: For collections, the _id from compiled files is used as the document _id\n\t * to ensure navigation and caching work correctly.\n\t */\n\tasync bulkUpdateNodes(updates: Array<{ path: string; changes: Partial<ContentNode> }>): Promise<{ modifiedCount: number }> {\n\t\tif (updates.length === 0) return { modifiedCount: 0 };\n\t\ttry {\n\t\t\tlogger.trace(`[bulkUpdateNodes] Processing ${updates.length} updates`);\n\t\t\tconst operations = updates.map(({ path, changes }) => {\n\t\t\t\t// Extract _id for potential use in $setOnInsert\n\t\t\t\tconst { _id, createdAt, ...safeChanges } = changes;\n\n\t\t\t\t// Normalize parentId to string using safe helper (handles ObjectId, string, null)\n\t\t\t\tconst normalizedChanges = { ...safeChanges } as Partial<ContentNode>;\n\t\t\t\tif ('parentId' in normalizedChanges) {\n\t\t\t\t\tconst originalParentId = normalizedChanges.parentId;\n\t\t\t\t\tconst normalizedParentId = normalizeId(originalParentId);\n\t\t\t\t\tif (normalizedParentId === null) {\n\t\t\t\t\t\tif (originalParentId !== null && originalParentId !== undefined) {\n\t\t\t\t\t\t\tlogger.warn(`[bulkUpdateNodes] Unable to safely normalize parentId for path=\"${path}\". Falling back to null value.`, {\n\t\t\t\t\t\t\t\tparentId: originalParentId\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnormalizedChanges.parentId = null as unknown as DatabaseId;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnormalizedChanges.parentId = normalizedParentId as DatabaseId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Build setOnInsert with _id if provided (for collections, use their UUID as document _id)\n\t\t\t\tconst setOnInsert: Record<string, unknown> = { createdAt: new Date() };\n\t\t\t\tif (_id) {\n\t\t\t\t\t// Use the provided _id (from compiled collection file) as the MongoDB document _id\n\t\t\t\t\tsetOnInsert._id = _id;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\tfilter: { path },\n\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t$set: { ...normalizedChanges, updatedAt: new Date() },\n\t\t\t\t\t\t\t$setOnInsert: setOnInsert\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupsert: true // Create the document if it doesn't exist\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\tlogger.trace(`[bulkUpdateNodes] Executing bulkWrite with ${operations.length} operations`);\n\t\t\tconst result = await this.nodesRepo.model.bulkWrite(operations as any);\n\t\t\tlogger.info(\n\t\t\t\t`[bulkUpdateNodes] Result: modified=${result.modifiedCount}, upserted=${result.upsertedCount}, total=${result.modifiedCount + result.upsertedCount}`\n\t\t\t);\n\n\t\t\t// Invalidate content structure caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.CONTENT);\n\n\t\t\treturn { modifiedCount: result.modifiedCount + result.upsertedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'NODE_BULK_UPDATE_ERROR', 'Failed to perform bulk update on nodes.');\n\t\t}\n\t}\n\n\t// Persists a full or partial content structure reorder using the efficient Model method.\n\tasync reorderStructure(items: Array<{ id: string; parentId: string | null; order: number; path: string }>): Promise<void> {\n\t\ttry {\n\t\t\t// Cast model to any to access the static method we added\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst result = await (this.nodesRepo.model as any).reorderStructure(items);\n\t\t\tif (!result.success) {\n\t\t\t\tthrow result.error || new Error(result.message);\n\t\t\t}\n\t\t\tawait invalidateCategoryCache(CacheCategory.CONTENT);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'NODE_REORDER_ERROR', 'Failed to reorder content structure.');\n\t\t}\n\t}\n\n\t/**\n\t * Fixes content nodes that have mismatched _id values.\n\t * This can happen when nodes were created before _id was properly set from compiled files.\n\t * For each node where the expected _id differs from the actual _id, delete and recreate.\n\t */\n\tasync fixMismatchedNodeIds(expectedNodes: Array<{ path: string; expectedId: string; changes: Partial<ContentNode> }>): Promise<{ fixed: number }> {\n\t\tif (expectedNodes.length === 0) return { fixed: 0 };\n\n\t\ttry {\n\t\t\tlet fixedCount = 0;\n\n\t\t\tfor (const { path, expectedId, changes } of expectedNodes) {\n\t\t\t\t// Find existing node by path\n\t\t\t\tconst existing = await this.nodesRepo.model.findOne({ path });\n\n\t\t\t\tif (existing) {\n\t\t\t\t\tconst existingId = normalizeId(existing._id);\n\t\t\t\t\tif (existingId !== expectedId) {\n\t\t\t\t\t\t// ID mismatch - delete and recreate with correct ID\n\t\t\t\t\t\tlogger.info(`[fixMismatchedNodeIds] Fixing node at path=\"${path}\": ${existingId}  ${expectedId}`);\n\t\t\t\t\t\tawait this.nodesRepo.model.deleteOne({ path });\n\t\t\t\t\t\tawait this.nodesRepo.model.insertOne({\n\t\t\t\t\t\t\t_id: expectedId,\n\t\t\t\t\t\t\t...(changes as any),\n\t\t\t\t\t\t\tcreatedAt: existing.createdAt || (new Date() as any),\n\t\t\t\t\t\t\tupdatedAt: new Date() as any\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfixedCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fixedCount > 0) {\n\t\t\t\tawait invalidateCategoryCache(CacheCategory.CONTENT);\n\t\t\t\tlogger.info(`[fixMismatchedNodeIds] Fixed ${fixedCount} nodes with mismatched IDs`);\n\t\t\t}\n\n\t\t\treturn { fixed: fixedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'NODE_FIX_IDS_ERROR', 'Failed to fix mismatched node IDs.');\n\t\t}\n\t}\n\n\t// ============================================================\n\t// Draft Methods\n\t// ============================================================\n\n\tasync createDraft(draft: Omit<ContentDraft, '_id' | 'createdAt' | 'updatedAt'>): Promise<ContentDraft> {\n\t\treturn this.draftsRepo.insert(draft);\n\t}\n\n\tasync getDraftsForContent(contentId: DatabaseId, options?: PaginationOptions): Promise<PaginatedResult<ContentDraft>> {\n\t\ttry {\n\t\t\tconst { page = 1, pageSize = 10 } = options || {};\n\t\t\tconst query = { contentId };\n\n\t\t\tconst [items, total] = await Promise.all([\n\t\t\t\tthis.draftsRepo.findMany(query, { skip: (page - 1) * pageSize, limit: pageSize }),\n\t\t\t\tthis.draftsRepo.count(query)\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\titems,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\tpageSize,\n\t\t\t\thasNextPage: page * pageSize < total,\n\t\t\t\thasPreviousPage: page > 1\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'DRAFT_FETCH_ERROR', 'Failed to fetch drafts for content.');\n\t\t}\n\t}\n\n\t// Publishes multiple drafts in a single batch operation.\n\tasync publishManyDrafts(draftIds: DatabaseId[]): Promise<{ modifiedCount: number }> {\n\t\tif (draftIds.length === 0) return { modifiedCount: 0 };\n\t\ttry {\n\t\t\tconst result = await this.draftsRepo.model.updateMany({ _id: { $in: draftIds } }, { $set: { status: 'published', publishedAt: new Date() } });\n\t\t\treturn { modifiedCount: result.modifiedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'DRAFT_BULK_PUBLISH_ERROR', 'Failed to publish drafts.');\n\t\t}\n\t}\n\n\t// ============================================================\n\t// Revision Methods\n\t// ============================================================\n\n\tasync createRevision(revision: Omit<ContentRevision, '_id' | 'createdAt'>): Promise<ContentRevision> {\n\t\treturn this.revisionsRepo.insert(revision);\n\t}\n\n\tasync getRevisionHistory(contentId: DatabaseId, options?: PaginationOptions): Promise<PaginatedResult<ContentRevision>> {\n\t\ttry {\n\t\t\tconst { page = 1, pageSize = 25 } = options || {};\n\t\t\tconst query = { contentId };\n\n\t\t\tconst [items, total] = await Promise.all([\n\t\t\t\tthis.revisionsRepo.model\n\t\t\t\t\t.find(query)\n\t\t\t\t\t.sort({ createdAt: -1 })\n\t\t\t\t\t.skip((page - 1) * pageSize)\n\t\t\t\t\t.limit(pageSize)\n\t\t\t\t\t.lean()\n\t\t\t\t\t.exec(),\n\t\t\t\tthis.revisionsRepo.count(query)\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\titems,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\tpageSize,\n\t\t\t\thasNextPage: page * pageSize < total,\n\t\t\t\thasPreviousPage: page > 1\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'REVISION_FETCH_ERROR', 'Failed to fetch revision history.');\n\t\t}\n\t}\n\n\t// Deletes old revisions for a piece of content, keeping only the specified number of recent ones.\n\tasync cleanupRevisions(contentId: DatabaseId, keepLatest: number): Promise<{ deletedCount: number }> {\n\t\ttry {\n\t\t\tconst revisionsToKeep = await this.revisionsRepo.model\n\t\t\t\t.find({ contentId })\n\t\t\t\t.sort({ createdAt: -1 })\n\t\t\t\t.limit(keepLatest)\n\t\t\t\t.select('_id')\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\n\t\t\tconst keepIds = revisionsToKeep.map((r: { _id: { toString(): string } }) => r._id.toString() as DatabaseId);\n\n\t\t\treturn this.revisionsRepo.deleteMany({\n\t\t\t\tcontentId,\n\t\t\t\t_id: { $nin: keepIds }\n\t\t\t} as QueryFilter<ContentRevision>);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'REVISION_CLEANUP_ERROR', 'Failed to cleanup old revisions.');\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/mediaMethods.ts\n * @description Media file management for the MongoDB adapter.\n * This implementation uses flat file storage with hash-based naming.\n * Files are physically organized in year/month folders on disk.\n * The database stores only metadata - no folder hierarchy.\n * Relies on Dependency Injection for testability.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type Mongoose from 'mongoose';\nimport type { DatabaseId, MediaItem, MediaMetadata, PaginatedResult, PaginationOptions } from '../../dbInterface';\nimport { mediaSchema, type IMedia } from '../models/media';\nimport { createDatabaseError } from './mongoDBUtils';\nimport { withCache, CacheCategory, invalidateCategoryCache } from './mongoDBCacheUtils';\n\n// Define model types for dependency injection\ntype MediaModelType = Mongoose.Model<IMedia>;\n\nexport class MongoMediaMethods {\n\tprivate readonly mediaModel: MediaModelType;\n\n\t/**\n\t * Constructs the MongoMediaMethods instance.\n\t * @param {MediaModelType} mediaModel - The Mongoose model for the 'media' collection.\n\t */\n\tconstructor(mediaModel: MediaModelType) {\n\t\tthis.mediaModel = mediaModel;\n\t\tlogger.debug('MongoMediaMethods initialized with media model.');\n\t}\n\n\t/**\n\t * Idempotently registers the required Mongoose models.\n\t * This should be called once during application startup.\n\t * @param {typeof Mongoose} mongooseInstance - The active Mongoose instance.\n\t */\n\tstatic registerModels(mongooseInstance: typeof Mongoose): void {\n\t\tif (!mongooseInstance.models['media']) {\n\t\t\tmongooseInstance.model('media', mediaSchema);\n\t\t\tlogger.debug(\"Model 'media' was registered.\");\n\t\t}\n\t}\n\n\t// ============================================================\n\t// File Operations\n\t// ============================================================\n\n\t/// Uploads multiple media files in a single, efficient batch operation\n\tasync uploadMany(files: Omit<MediaItem, '_id'>[]): Promise<MediaItem[]> {\n\t\ttry {\n\t\t\tconst result = await this.mediaModel.insertMany(files);\n\n\t\t\t// Invalidate media caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.MEDIA);\n\n\t\t\treturn result.map((doc) => doc.toObject() as unknown as MediaItem);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'MEDIA_UPLOAD_MANY_ERROR', 'Failed to upload media files');\n\t\t}\n\t}\n\n\t// Deletes multiple media files in a single batch operation\n\tasync deleteMany(fileIds: DatabaseId[]): Promise<{ deletedCount: number }> {\n\t\ttry {\n\t\t\tif (fileIds.length === 0) {\n\t\t\t\treturn { deletedCount: 0 };\n\t\t\t}\n\t\t\tconst result = await this.mediaModel.deleteMany({ _id: { $in: fileIds } });\n\n\t\t\t// Invalidate media caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.MEDIA);\n\n\t\t\treturn { deletedCount: result.deletedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'MEDIA_DELETE_MANY_ERROR', 'Failed to delete media files');\n\t\t}\n\t}\n\n\t// Updates metadata for a single file\n\tasync updateMetadata(fileId: DatabaseId, metadata: Partial<MediaMetadata>): Promise<MediaItem | null> {\n\t\ttry {\n\t\t\tconst updateData = Object.entries(metadata).reduce(\n\t\t\t\t(acc, [key, value]) => {\n\t\t\t\t\tacc[`metadata.${key}`] = value;\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{} as Record<string, unknown>\n\t\t\t);\n\n\t\t\tupdateData.updatedAt = new Date();\n\n\t\t\tconst result = await this.mediaModel.findByIdAndUpdate(fileId, { $set: updateData }, { new: true }).lean().exec();\n\n\t\t\t// Invalidate media caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.MEDIA);\n\n\t\t\treturn result as unknown as MediaItem | null;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'UPDATE_METADATA_ERROR', 'Failed to update metadata');\n\t\t}\n\t}\n\n\t// Moves multiple files to a different folder\n\tasync move(fileIds: DatabaseId[], targetFolderId?: DatabaseId): Promise<{ movedCount: number }> {\n\t\ttry {\n\t\t\tconst result = await this.mediaModel.updateMany({ _id: { $in: fileIds } }, { $set: { folderId: targetFolderId, updatedAt: new Date() } });\n\n\t\t\t// Invalidate media caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.MEDIA);\n\n\t\t\treturn { movedCount: result.modifiedCount };\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'MEDIA_MOVE_ERROR', 'Failed to move files');\n\t\t}\n\t}\n\n\t// Retrieves a paginated list of media files, optionally filtered by folder\n\tasync getFiles(folderId?: DatabaseId, options: PaginationOptions = {}): Promise<PaginatedResult<MediaItem>> {\n\t\tconst { page = 1, pageSize = 25, sortField = 'createdAt', sortDirection = 'desc' } = options;\n\t\tconst cacheKey = `media:files:${folderId || 'root'}:${page}:${pageSize}:${sortField}:${sortDirection}`;\n\n\t\treturn withCache(\n\t\t\tcacheKey,\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst query = folderId ? { folderId } : { folderId: { $in: [null, undefined] } }; // Root files\n\t\t\t\t\tconst skip = (page - 1) * pageSize;\n\t\t\t\t\tconst sort: Record<string, 1 | -1> = { [sortField]: sortDirection === 'asc' ? 1 : -1 };\n\n\t\t\t\t\tconst [items, total] = await Promise.all([\n\t\t\t\t\t\tthis.mediaModel\n\t\t\t\t\t\t\t.find(query as any)\n\t\t\t\t\t\t\t.sort(sort)\n\t\t\t\t\t\t\t.skip(skip)\n\t\t\t\t\t\t\t.limit(pageSize)\n\t\t\t\t\t\t\t.lean()\n\t\t\t\t\t\t\t.exec(),\n\t\t\t\t\t\tthis.mediaModel.countDocuments(query as any)\n\t\t\t\t\t]);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\titems: items as unknown as MediaItem[],\n\t\t\t\t\t\ttotal,\n\t\t\t\t\t\tpage,\n\t\t\t\t\t\tpageSize,\n\t\t\t\t\t\thasNextPage: page * pageSize < total,\n\t\t\t\t\t\thasPreviousPage: page > 1\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'GET_FILES_ERROR', 'Failed to fetch media files');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.MEDIA }\n\t\t);\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/systemMethods.ts\n * @description System preferences and settings management for MongoDB adapter.\n * This class uses dependency injection for models to enhance testability and modularity.\n */\n\nimport type { Model } from 'mongoose';\nimport { logger } from '@shared/utils/logger';\nimport type { SystemPreferencesDocument } from '@cms-types/content';\nimport type { DatabaseId } from '../../dbInterface';\nimport type { SystemSetting } from '../models/systemSetting';\nimport { createDatabaseError } from './mongoDBUtils';\n\n// Define model types for dependency injection\ntype SystemPreferencesModelType = Model<SystemPreferencesDocument>;\ntype SystemSettingModelType = Model<SystemSetting>;\n\nexport class MongoSystemMethods {\n\tprivate SystemPreferencesModel: SystemPreferencesModelType;\n\tprivate SystemSettingModel: SystemSettingModelType;\n\n\t/**\n\t * Constructs the MongoSystemMethods instance with injected models.\n\t * @param {SystemPreferencesModelType} systemPreferencesModel - The Mongoose model for system preferences.\n\t * @param {SystemSettingModelType} systemSettingModel - The Mongoose model for system settings.\n\t */\n\tconstructor(systemPreferencesModel: SystemPreferencesModelType, systemSettingModel: SystemSettingModelType) {\n\t\tthis.SystemPreferencesModel = systemPreferencesModel;\n\t\tthis.SystemSettingModel = systemSettingModel;\n\t\tlogger.trace('MongoSystemMethods initialized with models.');\n\t}\n\n\t// ============================================================\n\t// Generic Preference Methods (Database-Agnostic Interface)\n\t// ============================================================\n\n\t/**\n\t * Gets a single preference value by key.\n\t * Returns null if not found, throws an error on database failure.\n\t */\n\tasync get<T>(key: string, scope: 'user' | 'system' = 'system', userId?: DatabaseId): Promise<T | null> {\n\t\ttry {\n\t\t\tif (scope === 'system') {\n\t\t\t\tconst setting = await this.SystemSettingModel.findOne({ key }).lean();\n\t\t\t\treturn setting ? (setting.value as T) : null;\n\t\t\t}\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t}\n\t\t\tconst userPrefs = await this.SystemPreferencesModel.findOne(\n\t\t\t\t{ userId: userId.toString() },\n\t\t\t\t{ [`preferences.${key}`]: 1 } // Projection\n\t\t\t).lean<{ preferences: Record<string, T> }>();\n\n\t\t\treturn userPrefs?.preferences?.[key] ?? null;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_GET_ERROR', `Failed to get preference '${key}'`);\n\t\t}\n\t}\n\n\t// Sets a single preference value by key\n\tasync set<T>(key: string, value: T, scope: 'user' | 'system' = 'system', userId?: DatabaseId, category?: 'public' | 'private'): Promise<void> {\n\t\ttry {\n\t\t\tif (scope === 'system') {\n\t\t\t\tconst updateData: Record<string, unknown> = { value, updatedAt: new Date() };\n\t\t\t\tif (category) {\n\t\t\t\t\tupdateData.category = category;\n\t\t\t\t}\n\t\t\t\tawait this.SystemSettingModel.updateOne({ key }, { $set: updateData }, { upsert: true });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t}\n\n\t\t\tawait this.SystemPreferencesModel.updateOne(\n\t\t\t\t{ userId: userId.toString() },\n\t\t\t\t{ $set: { [`preferences.${key}`]: value }, updatedAt: new Date() },\n\t\t\t\t{ upsert: true }\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_SET_ERROR', `Failed to set preference '${key}'`);\n\t\t}\n\t}\n\n\t// Deletes a single preference by key\n\tasync delete(key: string, scope: 'user' | 'system' = 'system', userId?: DatabaseId): Promise<void> {\n\t\ttry {\n\t\t\tif (scope === 'system') {\n\t\t\t\tconst result = await this.SystemSettingModel.deleteOne({ key });\n\t\t\t\tif (result.deletedCount === 0) {\n\t\t\t\t\tlogger.warn(`System setting '${key}' not found for deletion.`);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t}\n\n\t\t\t// Use $unset for atomic removal of a field from the subdocument\n\t\t\tconst result = await this.SystemPreferencesModel.updateOne({ userId: userId.toString() }, { $unset: { [`preferences.${key}`]: '' } });\n\n\t\t\tif (result.modifiedCount === 0) {\n\t\t\t\tlogger.warn(`User preference '${key}' not found for user '${userId}' during deletion.`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_DELETE_ERROR', `Failed to delete preference '${key}'`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets multiple preference values in a single database call using $in operator.\n\t * 10x faster than sequential gets - one DB round-trip instead of N.\n\t */\n\tasync getMany<T>(keys: string[], scope: 'user' | 'system' = 'system', userId?: DatabaseId): Promise<Record<string, T>> {\n\t\ttry {\n\t\t\tif (keys.length === 0) return {};\n\n\t\t\tif (scope === 'system') {\n\t\t\t\t// Single query with $in operator for all keys at once\n\t\t\t\tlogger.trace(`Querying for ${keys.length} keys: ${keys.slice(0, 5).join(', ')}${keys.length > 5 ? '...' : ''}`);\n\t\t\t\tconst settings = await this.SystemSettingModel.find({ key: { $in: keys } }).lean();\n\t\t\t\tlogger.trace(`Found ${settings.length} settings`);\n\t\t\t\tif (settings.length > 0) {\n\t\t\t\t\tlogger.trace(\n\t\t\t\t\t\t`Sample: ${settings\n\t\t\t\t\t\t\t.slice(0, 3)\n\t\t\t\t\t\t\t.map((s) => `${s.key}=${JSON.stringify(s.value)}`)\n\t\t\t\t\t\t\t.join(', ')}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn settings.reduce(\n\t\t\t\t\t(acc, setting) => {\n\t\t\t\t\t\tacc[setting.key] = setting.value as T;\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t},\n\t\t\t\t\t{} as Record<string, T>\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t}\n\n\t\t\t// For user preferences, build projection for all keys at once\n\t\t\tconst projection = keys.reduce(\n\t\t\t\t(acc, key) => {\n\t\t\t\t\tacc[`preferences.${key}`] = 1;\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{} as Record<string, number>\n\t\t\t);\n\n\t\t\tconst userPrefs = await this.SystemPreferencesModel.findOne({ userId: userId.toString() }, projection).lean<{\n\t\t\t\tpreferences: Record<string, T>;\n\t\t\t}>();\n\n\t\t\tif (!userPrefs?.preferences) return {};\n\n\t\t\t// Filter to only include requested keys\n\t\t\treturn keys.reduce(\n\t\t\t\t(acc, key) => {\n\t\t\t\t\tif (key in userPrefs.preferences) {\n\t\t\t\t\t\tacc[key] = userPrefs.preferences[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{} as Record<string, T>\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_GET_MANY_ERROR', 'Failed to get multiple preferences');\n\t\t}\n\t}\n\n\t/**\n\t * Sets multiple preference values in a single database call using bulkWrite.\n\t * 33x faster than sequential sets - one DB round-trip instead of N.\n\t */\n\tasync setMany<T>(\n\t\tpreferences: Array<{ key: string; value: T; scope?: 'user' | 'system'; userId?: DatabaseId; category?: 'public' | 'private' }>\n\t): Promise<void> {\n\t\ttry {\n\t\t\tif (preferences.length === 0) return;\n\n\t\t\t// Group by scope for efficient batch processing\n\t\t\tconst systemPrefs = preferences.filter((p) => (p.scope || 'system') === 'system');\n\t\t\tconst userPrefs = preferences.filter((p) => p.scope === 'user');\n\n\t\t\t// Batch update system preferences\n\t\t\tif (systemPrefs.length > 0) {\n\t\t\t\tconst operations = systemPrefs.map((pref) => {\n\t\t\t\t\tconst updateData: Record<string, unknown> = { value: pref.value, updatedAt: new Date() };\n\t\t\t\t\tif (pref.category) {\n\t\t\t\t\t\tupdateData.category = pref.category;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\t\tfilter: { key: pref.key },\n\t\t\t\t\t\t\tupdate: { $set: updateData },\n\t\t\t\t\t\t\tupsert: true\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tawait this.SystemSettingModel.bulkWrite(operations);\n\t\t\t}\n\n\t\t\t// Batch update user preferences grouped by userId\n\t\t\tif (userPrefs.length > 0) {\n\t\t\t\t// Group by userId\n\t\t\t\tconst prefsByUser = userPrefs.reduce(\n\t\t\t\t\t(acc, pref) => {\n\t\t\t\t\t\tif (!pref.userId) {\n\t\t\t\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst userIdStr = pref.userId.toString();\n\t\t\t\t\t\tif (!acc[userIdStr]) acc[userIdStr] = [];\n\t\t\t\t\t\tacc[userIdStr].push(pref);\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t},\n\t\t\t\t\t{} as Record<string, typeof userPrefs>\n\t\t\t\t);\n\n\t\t\t\tconst operations = Object.entries(prefsByUser).map(([userIdStr, prefs]) => {\n\t\t\t\t\tconst setFields = prefs.reduce(\n\t\t\t\t\t\t(acc, pref) => {\n\t\t\t\t\t\t\tacc[`preferences.${pref.key}`] = pref.value;\n\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ updatedAt: new Date() } as Record<string, unknown>\n\t\t\t\t\t);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\t\tfilter: { userId: userIdStr },\n\t\t\t\t\t\t\tupdate: { $set: setFields },\n\t\t\t\t\t\t\tupsert: true\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tawait this.SystemPreferencesModel.bulkWrite(operations);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_SET_MANY_ERROR', 'Failed to set multiple preferences');\n\t\t}\n\t}\n\n\t/**\n\t * Deletes multiple preference keys in a single database call using bulkWrite.\n\t * 33x faster than sequential deletes - one DB round-trip instead of N.\n\t */\n\tasync deleteMany(keys: string[], scope: 'user' | 'system' = 'system', userId?: DatabaseId): Promise<void> {\n\t\ttry {\n\t\t\tif (keys.length === 0) return;\n\n\t\t\tif (scope === 'system') {\n\t\t\t\t// Single deleteMany with $in operator\n\t\t\t\tawait this.SystemSettingModel.deleteMany({ key: { $in: keys } });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new Error('User ID is required for user-scoped preferences.');\n\t\t\t}\n\n\t\t\t// Use $unset for all keys in a single update operation\n\t\t\tconst unsetFields = keys.reduce(\n\t\t\t\t(acc, key) => {\n\t\t\t\t\tacc[`preferences.${key}`] = '';\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{} as Record<string, string>\n\t\t\t);\n\n\t\t\tawait this.SystemPreferencesModel.updateOne({ userId: userId.toString() }, { $unset: unsetFields });\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCE_DELETE_MANY_ERROR', 'Failed to delete multiple preferences');\n\t\t}\n\t}\n\n\t// Clears all preferences within a given scope\n\tasync clear(scope: 'user' | 'system' = 'system', userId?: DatabaseId): Promise<void> {\n\t\ttry {\n\t\t\tif (scope === 'system') {\n\t\t\t\tawait this.SystemSettingModel.deleteMany({});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (userId) {\n\t\t\t\t// Clear for a specific user\n\t\t\t\tawait this.SystemPreferencesModel.deleteMany({ userId: userId.toString() });\n\t\t\t} else {\n\t\t\t\t// Clear all user preferences\n\t\t\t\tawait this.SystemPreferencesModel.deleteMany({});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'PREFERENCES_CLEAR_ERROR', `Failed to clear ${scope} preferences`);\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/systemVirtualFolderMethods.ts\n * @description Methods for managing system virtual folders in MongoDB.\n */\n\nimport type { DatabaseId, DatabaseResult, SystemVirtualFolder, MediaItem } from '@shared/database/dbInterface';\nimport { SystemVirtualFolderModel } from '../models/systemVirtualFolder';\nimport { generateId, createDatabaseError } from './mongoDBUtils';\nimport { MediaModel } from '../models';\n\n/**\n * MongoSystemVirtualFolderMethods provides virtual folder management for MongoDB.\n * Implements the systemVirtualFolder interface from IDBAdapter.\n */\nexport class MongoSystemVirtualFolderMethods {\n\tasync create(folder: Omit<SystemVirtualFolder, '_id' | 'createdAt' | 'updatedAt'>): Promise<DatabaseResult<SystemVirtualFolder>> {\n\t\ttry {\n\t\t\tconst _id = generateId();\n\t\t\tconst newFolder = new SystemVirtualFolderModel({\n\t\t\t\t...folder,\n\t\t\t\t_id\n\t\t\t});\n\t\t\tconst savedFolder = await newFolder.save();\n\t\t\treturn { success: true, data: savedFolder.toObject() };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_CREATE_ERROR', 'Failed to create virtual folder'),\n\t\t\t\tmessage: 'Failed to create virtual folder'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getById(folderId: DatabaseId): Promise<DatabaseResult<SystemVirtualFolder | null>> {\n\t\ttry {\n\t\t\tconst folder = await SystemVirtualFolderModel.findById(folderId).lean().exec();\n\t\t\treturn { success: true, data: folder as SystemVirtualFolder | null };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_GET_ERROR', 'Failed to get virtual folder by ID'),\n\t\t\t\tmessage: 'Failed to get virtual folder by ID'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getByParentId(parentId: DatabaseId | null): Promise<DatabaseResult<SystemVirtualFolder[]>> {\n\t\ttry {\n\t\t\tconst folders = await SystemVirtualFolderModel.find({ parentId: parentId ?? null })\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\t\t\treturn { success: true, data: folders as SystemVirtualFolder[] };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_GET_ERROR', 'Failed to get virtual folders by parent ID'),\n\t\t\t\tmessage: 'Failed to get virtual folders by parent ID'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getAll(): Promise<DatabaseResult<SystemVirtualFolder[]>> {\n\t\ttry {\n\t\t\tconst folders = await SystemVirtualFolderModel.find({}).lean().exec();\n\t\t\treturn { success: true, data: folders as SystemVirtualFolder[] };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_GET_ERROR', 'Failed to get all virtual folders'),\n\t\t\t\tmessage: 'Failed to get all virtual folders'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync update(folderId: DatabaseId, updateData: Partial<SystemVirtualFolder>): Promise<DatabaseResult<SystemVirtualFolder>> {\n\t\ttry {\n\t\t\tconst updatedFolder = await SystemVirtualFolderModel.findByIdAndUpdate(folderId, updateData, { new: true }).lean().exec();\n\t\t\tif (!updatedFolder) {\n\t\t\t\treturn { success: false, error: { code: 'NOT_FOUND', message: 'Folder not found' }, message: 'Folder not found' };\n\t\t\t}\n\t\t\treturn { success: true, data: updatedFolder as SystemVirtualFolder };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_UPDATE_ERROR', 'Failed to update virtual folder'),\n\t\t\t\tmessage: 'Failed to update virtual folder'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync addToFolder(contentId: DatabaseId, folderPath: string): Promise<DatabaseResult<void>> {\n\t\t// This seems to be more related to media files, not generic content\n\t\ttry {\n\t\t\tconst folder = await SystemVirtualFolderModel.findOne({ path: folderPath }).lean().exec();\n\t\t\tif (!folder) {\n\t\t\t\treturn { success: false, error: { code: 'NOT_FOUND', message: 'Folder not found' }, message: 'Folder not found' };\n\t\t\t}\n\t\t\tawait MediaModel.findByIdAndUpdate(contentId, { folderId: folder._id });\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_ADD_ERROR', 'Failed to add content to virtual folder'),\n\t\t\t\tmessage: 'Failed to add content to virtual folder'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Gets the contents of a virtual folder (subfolders and files).\n\t * Uses Promise.all to fetch subfolders and files in parallel (2x faster).\n\t */\n\tasync getContents(folderPath: string): Promise<DatabaseResult<{ folders: SystemVirtualFolder[]; files: MediaItem[] }>> {\n\t\ttry {\n\t\t\tconst folder = await SystemVirtualFolderModel.findOne({ path: folderPath }).lean().exec();\n\n\t\t\t//  Run these two independent queries in parallel\n\t\t\tconst [subfolders, files] = await Promise.all([\n\t\t\t\tSystemVirtualFolderModel.find({ parentId: folder?._id }).lean().exec(),\n\t\t\t\tMediaModel.find({ folderId: folder?._id }).lean().exec()\n\t\t\t]);\n\n\t\t\treturn { success: true, data: { folders: subfolders as SystemVirtualFolder[], files: files as MediaItem[] } };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_CONTENTS_ERROR', 'Failed to get virtual folder contents'),\n\t\t\t\tmessage: 'Failed to get virtual folder contents'\n\t\t\t};\n\t\t}\n\t}\n\n\tasync delete(folderId: DatabaseId): Promise<DatabaseResult<void>> {\n\t\ttry {\n\t\t\t// This should probably be a recursive delete or prevent deleting non-empty folders\n\t\t\tawait SystemVirtualFolderModel.findByIdAndDelete(folderId).exec();\n\t\t\treturn { success: true, data: undefined };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_DELETE_ERROR', 'Failed to delete virtual folder'),\n\t\t\t\tmessage: 'Failed to delete virtual folder'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a virtual folder exists at the given path.\n\t * Uses findOne with projection instead of countDocuments for faster execution.\n\t */\n\tasync exists(path: string): Promise<DatabaseResult<boolean>> {\n\t\ttry {\n\t\t\t// Use findOne with projection for optimal performance\n\t\t\tconst doc = await SystemVirtualFolderModel.findOne({ path }, { _id: 1 }).lean().exec();\n\t\t\treturn { success: true, data: !!doc };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: createDatabaseError(error, 'VIRTUAL_FOLDER_EXISTS_ERROR', 'Failed to check if virtual folder exists'),\n\t\t\t\tmessage: 'Failed to check if virtual folder exists'\n\t\t\t};\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/themeMethods.ts\n * @description Theme management for the MongoDB adapter.\n * This class uses Dependency Injection for the Mongoose model to ensure testability.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type { Model } from 'mongoose';\nimport type { DatabaseId, Theme } from '../../dbInterface';\nimport { createDatabaseError } from './mongoDBUtils';\nimport { withCache, CacheCategory, invalidateCategoryCache } from './mongoDBCacheUtils';\n\n// Define the model type for dependency injection, making the class testable.\ntype ThemeModelType = Model<Theme>;\n\nexport class MongoThemeMethods {\n\tprivate readonly themeModel: ThemeModelType;\n\n\t/**\n\t * Constructs the MongoThemeMethods instance.\n\t * @param {ThemeModelType} themeModel - The Mongoose model for themes.\n\t */\n\tconstructor(themeModel: ThemeModelType) {\n\t\tthis.themeModel = themeModel;\n\t\tlogger.trace('MongoThemeMethods initialized.');\n\t}\n\n\t/**\n\t * Retrieves the currently active theme.\n\t * Cached with 300s TTL since active theme is accessed on every page load\n\t * @returns {Promise<Theme | null>} The active theme object or null if none is active.\n\t * @throws {DatabaseError} If the database query fails.\n\t */\n\tasync getActive(): Promise<Theme | null> {\n\t\treturn withCache(\n\t\t\t'theme:active',\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.themeModel.findOne({ isActive: true }).lean().exec();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'THEME_FETCH_FAILED', 'Failed to get active theme');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.THEME }\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves the default theme.\n\t * Cached with 300s TTL since default theme is frequently accessed\n\t * @returns {Promise<Theme | null>} The default theme object or null if none is set.\n\t * @throws {DatabaseError} If the database query fails.\n\t */\n\tasync getDefault(): Promise<Theme | null> {\n\t\treturn withCache(\n\t\t\t'theme:default',\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.themeModel.findOne({ isDefault: true }).lean().exec();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'THEME_FETCH_FAILED', 'Failed to get default theme');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.THEME }\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves all themes from the database, sorted by order.\n\t * Cached with 300s TTL since theme list is frequently accessed in admin UI\n\t * @returns {Promise<Theme[]>} An array of theme objects.\n\t * @throws {DatabaseError} If the database query fails.\n\t */\n\tasync findAll(): Promise<Theme[]> {\n\t\treturn withCache(\n\t\t\t'theme:all',\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.themeModel.find().sort({ order: 1 }).lean().exec();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'THEME_FETCH_ALL_FAILED', 'Failed to get all themes');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.THEME }\n\t\t);\n\t}\n\n\t/**\n\t * Sets a specific theme as the active one. This will deactivate any other active theme.\n\t * @param {DatabaseId} themeId The ID of the theme to activate.\n\t * @returns {Promise<Theme | null>} The updated theme object or null if not found.\n\t * @throws {DatabaseError} If the database query fails.\n\t */\n\tasync setActive(themeId: DatabaseId): Promise<Theme | null> {\n\t\tconst result = await this._setUniqueFlag(themeId, 'isActive');\n\t\t// Invalidate all theme caches since active theme changed\n\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a specific theme as the default one. This will unset any other default theme.\n\t * @param {DatabaseId} themeId The ID of the theme to set as default.\n\t * @returns {Promise<Theme | null>} The updated theme object or null if not found.\n\t * @throws {DatabaseError} If the database query fails.\n\t */\n\tasync setDefault(themeId: DatabaseId): Promise<Theme | null> {\n\t\tconst result = await this._setUniqueFlag(themeId, 'isDefault');\n\t\t// Invalidate all theme caches since default theme changed\n\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Installs (creates) a new theme in the database.\n\t * @param {Omit<Theme, '_id' | 'createdAt' | 'updatedAt'>} themeData - The theme data to install.\n\t * @returns {Promise<Theme>} The newly created theme object.\n\t * @throws {DatabaseError} If the creation fails.\n\t */\n\tasync install(themeData: Omit<Theme, '_id' | 'createdAt' | 'updatedAt'>): Promise<Theme> {\n\t\ttry {\n\t\t\tconst newTheme = new this.themeModel(themeData);\n\t\t\tconst savedTheme = await newTheme.save();\n\n\t\t\t// Invalidate theme caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\n\t\t\treturn savedTheme.toObject();\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'THEME_INSTALL_FAILED', 'Failed to install theme');\n\t\t}\n\t}\n\n\t/**\n\t * Installs or updates a theme using atomic upsert operation.\n\t * If the theme exists (by _id), it updates it. Otherwise, it creates a new one.\n\t * This method is safe from duplicate key errors.\n\t * @param {Theme} themeData - The complete theme data including _id.\n\t * @returns {Promise<Theme>} The created or updated theme object.\n\t * @throws {DatabaseError} If the operation fails.\n\t */\n\tasync installOrUpdate(themeData: Theme): Promise<Theme> {\n\t\ttry {\n\t\t\tconst result = await this.themeModel\n\t\t\t\t.findOneAndUpdate({ _id: themeData._id }, themeData, { upsert: true, new: true, setDefaultsOnInsert: true })\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\n\t\t\t// Invalidate theme caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\n\t\t\treturn result as Theme;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'THEME_UPSERT_FAILED', 'Failed to install or update theme');\n\t\t}\n\t}\n\n\t/**\n\t * Uninstalls (deletes) a theme from the database.\n\t * @param {DatabaseId} themeId - The ID of the theme to uninstall.\n\t * @returns {Promise<boolean>} True if a theme was deleted, false otherwise.\n\t * @throws {DatabaseError} If the deletion fails.\n\t */\n\tasync uninstall(themeId: DatabaseId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst result = await this.themeModel.findByIdAndDelete(themeId).exec();\n\n\t\t\t// Invalidate theme caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\n\t\t\treturn !!result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'THEME_UNINSTALL_FAILED', 'Failed to uninstall theme');\n\t\t}\n\t}\n\n\t/**\n\t * Updates an existing theme's data.\n\t * @param {DatabaseId} themeId - The ID of the theme to update.\n\t * @param {Partial<Omit<Theme, '_id' | 'createdAt' | 'updatedAt'>>} themeData - The fields to update.\n\t * @returns {Promise<Theme | null>} The updated theme object, or null if not found.\n\t * @throws {DatabaseError} If the update fails.\n\t */\n\tasync update(themeId: DatabaseId, themeData: Partial<Omit<Theme, '_id' | 'createdAt' | 'updatedAt'>>): Promise<Theme | null> {\n\t\ttry {\n\t\t\tconst result = await this.themeModel.findByIdAndUpdate(themeId, { $set: themeData }, { new: true }).lean().exec();\n\n\t\t\t// Invalidate theme caches\n\t\t\tawait invalidateCategoryCache(CacheCategory.THEME);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'THEME_UPDATE_FAILED', 'Failed to update theme');\n\t\t}\n\t}\n\n\t/**\n\t * A private helper to atomically set a unique boolean flag on a document.\n\t * Uses a single bulkWrite operation for atomicity and efficiency.\n\t * @param {DatabaseId} themeId - The ID of the theme to set the flag on.\n\t * @param {string} flag - The flag name ('isActive' or 'isDefault').\n\t * @returns {Promise<Theme | null>} The updated theme object or null if not found.\n\t * @throws {DatabaseError} If the operation fails.\n\t */\n\tprivate async _setUniqueFlag(themeId: DatabaseId, flag: 'isActive' | 'isDefault'): Promise<Theme | null> {\n\t\ttry {\n\t\t\t// Single atomic bulkWrite operation: unset flag for others, then set for target\n\t\t\tawait this.themeModel.bulkWrite([\n\t\t\t\t{\n\t\t\t\t\t// Step 1: Unset the flag for all other themes\n\t\t\t\t\tupdateMany: {\n\t\t\t\t\t\tfilter: { _id: { $ne: themeId } },\n\t\t\t\t\t\tupdate: { $set: { [flag]: false } }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Step 2: Set the flag for the target theme\n\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\tfilter: { _id: themeId },\n\t\t\t\t\t\tupdate: { $set: { [flag]: true } }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]);\n\n\t\t\t// Fetch and return the updated document\n\t\t\treturn await this.themeModel.findById(themeId).lean().exec();\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'THEME_FLAG_UPDATE_FAILED', `Failed to set the '${flag}' flag for theme ${themeId}`);\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/websiteTokenMethods.ts\n * @description Generic, reusable CRUD operations for WebsiteToken collection.\n *\n * Responsibility: ALL generic CRUD operations for WebsiteToken model.\n *\n * Features:\n * - findOne, findMany, findByIds\n * - insert, update, upsert\n * - delete, deleteMany\n * - count, exists\n * - aggregate (for complex queries)\n * - Batch operations (upsertMany)\n */\n\nimport type { Model } from 'mongoose';\nimport type { DatabaseId, WebsiteToken } from '../../dbInterface';\nimport { MongoCrudMethods } from './crudMethods';\n\nexport class MongoWebsiteTokenMethods {\n\tprivate readonly crud: MongoCrudMethods<WebsiteToken>;\n\n\tconstructor(websiteTokenModel: Model<WebsiteToken>) {\n\t\tthis.crud = new MongoCrudMethods(websiteTokenModel);\n\t}\n\n\tasync create(token: Omit<WebsiteToken, '_id' | 'createdAt'>): Promise<WebsiteToken> {\n\t\treturn this.crud.insert(token as WebsiteToken);\n\t}\n\n\tasync getAll(options: {\n\t\tlimit?: number;\n\t\tskip?: number;\n\t\tsort?: string;\n\t\torder?: string;\n\t\tfilter?: any;\n\t}): Promise<{ data: WebsiteToken[]; total: number }> {\n\t\tconst sort = options.sort && options.order ? { [options.sort]: options.order as 'asc' | 'desc' | 1 | -1 } : {};\n\t\tconst data = await this.crud.findMany(options.filter || {}, { limit: options.limit, skip: options.skip, sort });\n\t\tconst total = await this.crud.count(options.filter || {});\n\t\treturn { data, total };\n\t}\n\n\tasync delete(tokenId: DatabaseId): Promise<boolean> {\n\t\treturn this.crud.delete(tokenId);\n\t}\n\n\tasync getByName(name: string): Promise<WebsiteToken | null> {\n\t\treturn this.crud.findOne({ name });\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/widgetMethods.ts\n * @description Widget registration and management for the MongoDB adapter.\n * Provides methods to create, read, update, and delete widgets,\n * as well as activate/deactivate them.\n */\n\nimport { logger } from '@shared/utils/logger';\nimport type { Model } from 'mongoose';\nimport type { DatabaseId, Widget } from '../../dbInterface';\nimport type { Widget as IWidget } from '../../dbInterface'; // Assuming you have a document interface\nimport { createDatabaseError, generateId } from './mongoDBUtils';\nimport { withCache, CacheCategory, invalidateCollectionCache, invalidateCategoryCache } from './mongoDBCacheUtils';\nimport { cacheService } from '@shared/database/CacheService';\n\n// Define the model type for dependency injection.\ntype WidgetModelType = Model<IWidget>;\n\nexport class MongoWidgetMethods {\n\tprivate readonly widgetModel: WidgetModelType;\n\n\t/**\n\t * Constructs the MongoWidgetMethods instance with an injected model.\n\t * @param {WidgetModelType} widgetModel - The Mongoose model for widgets.\n\t */\n\tconstructor(widgetModel: WidgetModelType) {\n\t\tthis.widgetModel = widgetModel;\n\t\tlogger.trace('MongoWidgetMethods initialized.');\n\t}\n\n\t/**\n\t * Registers (creates) a new widget in the database.\n\t * @param {Omit<Widget, '_id' | 'createdAt' | 'updatedAt'>} widgetData - The data for the new widget.\n\t * @returns {Promise<Widget>} The created widget object.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync register(widgetData: Omit<Widget, '_id' | 'createdAt' | 'updatedAt'>): Promise<Widget> {\n\t\ttry {\n\t\t\t// Generate UUID for _id since schema requires it\n\t\t\tconst widgetWithId = {\n\t\t\t\t...widgetData,\n\t\t\t\t_id: generateId()\n\t\t\t};\n\n\t\t\tlogger.debug(`[WidgetMethods] Registering widget \"${widgetData.name}\" to database`, {\n\t\t\t\twidgetId: widgetWithId._id,\n\t\t\t\tcollection: this.widgetModel.collection.name,\n\t\t\t\twidgetData: widgetWithId\n\t\t\t});\n\n\t\t\tconst newWidget = new this.widgetModel(widgetWithId);\n\t\t\tconst savedWidget = await newWidget.save();\n\t\t\tconst result = savedWidget.toObject();\n\n\t\t\tlogger.debug(`[WidgetMethods] Widget \"${widgetData.name}\" saved successfully`, {\n\t\t\t\twidgetId: result._id,\n\t\t\t\tisActive: result.isActive,\n\t\t\t\tcollection: this.widgetModel.collection.name\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error(`[WidgetMethods] Failed to register widget \"${widgetData.name}\"`, {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tcollection: this.widgetModel.collection.name\n\t\t\t});\n\t\t\tthrow createDatabaseError(error, 'WIDGET_REGISTER_FAILED', 'Failed to register widget');\n\t\t}\n\t}\n\n\t/**\n\t * Finds a single widget by its ID.\n\t * Cached with 600s TTL since widget configs are relatively stable\n\t * @param {DatabaseId} widgetId - The ID of the widget to find.\n\t * @returns {Promise<Widget | null>} The widget object or null if not found.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync findById(widgetId: DatabaseId): Promise<Widget | null> {\n\t\treturn withCache(\n\t\t\t`widget:id:${widgetId}`,\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.widgetModel.findById(widgetId).lean().exec();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'WIDGET_FETCH_FAILED', `Failed to find widget with ID ${widgetId}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.WIDGET }\n\t\t);\n\t}\n\n\t/**\n\t * Activates a widget, setting its `isActive` flag to true.\n\t * @param {DatabaseId} widgetId - The ID of the widget to activate.\n\t * @returns {Promise<Widget | null>} The updated widget object or null if not found.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync activate(widgetId: DatabaseId): Promise<Widget | null> {\n\t\ttry {\n\t\t\tconst result = await this.widgetModel\n\t\t\t\t.findByIdAndUpdate(widgetId, { $set: { isActive: true } }, { new: true })\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\n\t\t\t// Invalidate widget caches - including the active widgets list cache\n\t\t\tlogger.debug('[widgetMethods.activate] Invalidating active widgets cache');\n\n\t\t\t// NOTE: This cache clearing is a best-effort attempt but won't work correctly\n\t\t\t// for multi-tenant setups because widgetMethods doesn't have tenant context.\n\t\t\t// The REAL cache invalidation happens in /api/widgets/status/+server.ts\n\t\t\t// which has access to locals.tenantId. We keep this here as defense-in-depth.\n\t\t\tawait Promise.all([\n\t\t\t\tinvalidateCollectionCache(`widget:id:${widgetId}`),\n\t\t\t\tcacheService.delete('widget:active:all'), // No tenant (default)\n\t\t\t\tcacheService.delete('widget:active:all', 'default'), // Explicit default tenant\n\t\t\t\tcacheService.delete('widget:active:all', 'default-tenant'), // default-tenant\n\t\t\t\tinvalidateCategoryCache(CacheCategory.WIDGET)\n\t\t\t]);\n\n\t\t\tlogger.debug('[widgetMethods.activate] Cache invalidated successfully');\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'WIDGET_UPDATE_FAILED', 'Failed to activate widget');\n\t\t}\n\t}\n\n\t/**\n\t * Deactivates a widget, setting its `isActive` flag to false.\n\t * @param {DatabaseId} widgetId - The ID of the widget to deactivate.\n\t * @returns {Promise<Widget | null>} The updated widget object or null if not found.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync deactivate(widgetId: DatabaseId): Promise<Widget | null> {\n\t\ttry {\n\t\t\tconst result = await this.widgetModel\n\t\t\t\t.findByIdAndUpdate(widgetId, { $set: { isActive: false } }, { new: true })\n\t\t\t\t.lean()\n\t\t\t\t.exec();\n\n\t\t\t// Invalidate widget caches - including the active widgets list cache\n\t\t\tlogger.debug('[widgetMethods.deactivate] Invalidating active widgets cache');\n\n\t\t\t// NOTE: This cache clearing is a best-effort attempt but won't work correctly\n\t\t\t// for multi-tenant setups because widgetMethods doesn't have tenant context.\n\t\t\t// The REAL cache invalidation happens in /api/widgets/status/+server.ts\n\t\t\t// which has access to locals.tenantId. We keep this here as defense-in-depth.\n\t\t\tawait Promise.all([\n\t\t\t\tinvalidateCollectionCache(`widget:id:${widgetId}`),\n\t\t\t\tcacheService.delete('widget:active:all'), // No tenant (default)\n\t\t\t\tcacheService.delete('widget:active:all', 'default'), // Explicit default tenant\n\t\t\t\tcacheService.delete('widget:active:all', 'default-tenant'), // default-tenant\n\t\t\t\tinvalidateCategoryCache(CacheCategory.WIDGET)\n\t\t\t]);\n\n\t\t\tlogger.debug('[widgetMethods.deactivate] Cache invalidated successfully');\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'WIDGET_UPDATE_FAILED', 'Failed to deactivate widget');\n\t\t}\n\t}\n\n\t/**\n\t * Updates an existing widget with new data.\n\t * @param {DatabaseId} widgetId - The ID of the widget to update.\n\t * @param {Partial<Omit<Widget, '_id'>>} widgetData - The fields to update.\n\t * @returns {Promise<Widget | null>} The updated widget object or null if not found.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync update(widgetId: DatabaseId, widgetData: Partial<Omit<Widget, '_id'>>): Promise<Widget | null> {\n\t\ttry {\n\t\t\tlogger.debug('[widgetMethods.update] Starting update', {\n\t\t\t\twidgetId,\n\t\t\t\twidgetData,\n\t\t\t\tcollection: this.widgetModel.collection.name\n\t\t\t});\n\n\t\t\t// Check if widget exists before update\n\t\t\tconst existingWidget = await this.widgetModel.findById(widgetId).lean().exec();\n\t\t\tlogger.debug('[widgetMethods.update] Existing widget state', {\n\t\t\t\twidgetId,\n\t\t\t\texists: !!existingWidget,\n\t\t\t\tcurrentIsActive: existingWidget?.isActive,\n\t\t\t\tcurrentUpdatedAt: existingWidget?.updatedAt\n\t\t\t});\n\n\t\t\tconst result = await this.widgetModel.findByIdAndUpdate(widgetId, { $set: widgetData }, { new: true }).lean().exec();\n\n\t\t\tlogger.debug('[widgetMethods.update] Update completed', {\n\t\t\t\twidgetId,\n\t\t\t\tsuccess: !!result,\n\t\t\t\tresultIsActive: result?.isActive,\n\t\t\t\tresultUpdatedAt: result?.updatedAt\n\t\t\t});\n\n\t\t\t// Invalidate widget caches - including the active widgets list cache\n\t\t\tlogger.debug('[widgetMethods.update] Invalidating caches', {\n\t\t\t\twidgetId,\n\t\t\t\tcacheKeys: ['widget:active:all (all tenants)']\n\t\t\t});\n\n\t\t\t// Clear cache for all possible tenant contexts since widgets are system-wide\n\t\t\tawait Promise.all([\n\t\t\t\tinvalidateCollectionCache(`widget:id:${widgetId}`),\n\t\t\t\tcacheService.delete('widget:active:all'), // No tenant (default)\n\t\t\t\tcacheService.delete('widget:active:all', 'default'), // Explicit default tenant\n\t\t\t\tcacheService.delete('widget:active:all', 'default-tenant'), // default-tenant\n\t\t\t\tinvalidateCategoryCache(CacheCategory.WIDGET)\n\t\t\t]);\n\n\t\t\tlogger.debug('[widgetMethods.update] Caches invalidated successfully', {\n\t\t\t\twidgetId\n\t\t\t});\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('[widgetMethods.update] Update failed', {\n\t\t\t\twidgetId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow createDatabaseError(error, 'WIDGET_UPDATE_FAILED', 'Failed to update widget');\n\t\t}\n\t}\n\n\t/**\n\t * Deletes a widget from the database.\n\t * @param {DatabaseId} widgetId - The ID of the widget to delete.\n\t * @returns {Promise<boolean>} True if a widget was deleted, false otherwise.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync delete(widgetId: DatabaseId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst result = await this.widgetModel.findByIdAndDelete(widgetId).exec();\n\n\t\t\t// Invalidate widget caches\n\t\t\tawait Promise.all([invalidateCollectionCache(`widget:id:${widgetId}`), invalidateCategoryCache(CacheCategory.WIDGET)]);\n\n\t\t\treturn !!result;\n\t\t} catch (error) {\n\t\t\tthrow createDatabaseError(error, 'WIDGET_DELETE_FAILED', 'Failed to delete widget');\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves all widgets from the database.\n\t * @returns {Promise<Widget[]>} An array of all widget objects.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync findAll(): Promise<Widget[]> {\n\t\ttry {\n\t\t\tlogger.debug('[widgetMethods.findAll] Querying widgets from database', {\n\t\t\t\tcollection: this.widgetModel.collection.name\n\t\t\t});\n\n\t\t\tconst widgets = await this.widgetModel.find().lean().exec();\n\n\t\t\tlogger.debug('[widgetMethods.findAll] Query completed', {\n\t\t\t\tcount: widgets.length,\n\t\t\t\tcollection: this.widgetModel.collection.name,\n\t\t\t\twidgets: widgets.map((w) => ({ name: w.name, isActive: w.isActive, _id: w._id }))\n\t\t\t});\n\n\t\t\treturn widgets;\n\t\t} catch (error) {\n\t\t\tlogger.error('[widgetMethods.findAll] Failed to query widgets', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tcollection: this.widgetModel.collection.name\n\t\t\t});\n\t\t\tthrow createDatabaseError(error, 'WIDGET_FETCH_ALL_FAILED', 'Failed to get all widgets');\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves all active widgets from the database.\n\t * Cached with 600s TTL since active widgets are frequently accessed on every page\n\t * @returns {Promise<Widget[]>} An array of active widget objects.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync findAllActive(tenantId?: string): Promise<Widget[]> {\n\t\tlogger.debug('[widgetMethods.findAllActive] Fetching active widgets (may be cached)', { tenantId });\n\n\t\tconst result = await withCache(\n\t\t\t'widget:active:all',\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug('[widgetMethods.findAllActive] Cache MISS - querying database');\n\t\t\t\t\tconst widgets = await this.widgetModel.find({ isActive: true }).lean().exec();\n\t\t\t\t\tlogger.debug('[widgetMethods.findAllActive] Database query completed', {\n\t\t\t\t\t\tcount: widgets.length,\n\t\t\t\t\t\twidgets: widgets.map((w) => w.name)\n\t\t\t\t\t});\n\t\t\t\t\treturn widgets;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow createDatabaseError(error, 'WIDGET_FETCH_ACTIVE_FAILED', 'Failed to get active widgets');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ category: CacheCategory.WIDGET, tenantId }\n\t\t);\n\n\t\tlogger.debug('[widgetMethods.findAllActive] Returning result', {\n\t\t\tcount: result.length,\n\t\t\twidgets: result.map((w) => w.name)\n\t\t});\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Direct database query for active widgets\n\t * This method pushes filtering to the database layer instead of fetching all widgets\n\t * and filtering in application code. This is significantly faster for large widget sets.\n\t * @returns {Promise<Widget[]>} An array of active widget objects.\n\t * @throws {DatabaseError} If the database operation fails.\n\t */\n\tasync getActiveWidgets(): Promise<Widget[]> {\n\t\ttry {\n\t\t\tlogger.debug('[widgetMethods.getActiveWidgets] Querying active widgets from database');\n\t\t\tconst widgets = await this.widgetModel.find({ isActive: true }).lean().exec();\n\t\t\tlogger.debug('[widgetMethods.getActiveWidgets] Query completed', {\n\t\t\t\tcount: widgets.length,\n\t\t\t\twidgets: widgets.map((w) => ({ name: w.name, _id: w._id }))\n\t\t\t});\n\t\t\treturn widgets;\n\t\t} catch (error) {\n\t\t\tlogger.error('[widgetMethods.getActiveWidgets] Failed to query active widgets', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow createDatabaseError(error, 'WIDGET_FETCH_ACTIVE_FAILED', 'Failed to get active widgets');\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/MongoQueryBuilder.ts\n * @description MongoDB implementation of the QueryBuilder interface\n *\n * This class provides a fluent interface for building MongoDB queries with support for:\n * - Filtering with MongoDB query operators\n * - Sorting with multiple fields\n * - Pagination with skip/limit\n * - Field projection\n * - Distinct queries\n * - Count operations\n *\n * The builder translates the database-agnostic QueryBuilder interface into MongoDB-specific\n * query operations while maintaining type safety and performance.\n */\n\nimport type { Model } from 'mongoose';\nimport type { BaseEntity, DatabaseError, DatabaseResult, PaginationOptions, QueryBuilder, QueryMeta, QueryOptimizationHints } from '../dbInterface';\n\n// System Logger\nimport { logger } from '@shared/utils/logger';\n\nexport class MongoQueryBuilder<T extends BaseEntity> implements QueryBuilder<T> {\n\tprivate model: Model<T>;\n\tprivate query: Record<string, unknown> = {};\n\tprivate sortOptions: Record<string, 1 | -1> = {};\n\tprivate limitValue?: number;\n\tprivate skipValue?: number;\n\tprivate projectionFields?: Record<string, boolean>;\n\tprivate distinctField?: keyof T;\n\t// private paginationOptions?: PaginationOptions; // Removed unused variable\n\tprivate optimizationHints?: QueryOptimizationHints;\n\tprivate timeoutMs?: number;\n\tprivate selectedFields?: (keyof T)[];\n\tprivate excludedFields?: (keyof T)[];\n\tprivate searchQuery?: { query: string; fields?: (keyof T)[] };\n\tprivate inConditions: Array<{ field: keyof T; values: unknown[] }> = [];\n\tprivate notInConditions: Array<{ field: keyof T; values: unknown[] }> = [];\n\tprivate betweenConditions: Array<{ field: keyof T; min: unknown; max: unknown }> = [];\n\tprivate nullConditions: Array<{ field: keyof T; isNull: boolean }> = [];\n\tprivate groupByField?: keyof T;\n\tprivate multiSortOptions: Array<{ field: keyof T; direction: 'asc' | 'desc' }> = [];\n\n\tconstructor(model: Model<T>) {\n\t\tthis.model = model;\n\t}\n\n\twhere(conditions: Partial<T> | ((item: T) => boolean)): this {\n\t\tif (typeof conditions === 'function') {\n\t\t\t// For function-based conditions, we need to convert to MongoDB query\n\t\t\t// This is a simplified approach - for complex functions, consider using aggregation\n\t\t\tlogger.warn('Function-based where conditions have limited MongoDB support');\n\t\t\treturn this;\n\t\t}\n\t\t// Merge conditions into the existing query\n\t\tthis.query = { ...this.query, ...conditions };\n\t\treturn this;\n\t}\n\n\twhereIn<K extends keyof T>(field: K, values: T[K][]): this {\n\t\tthis.inConditions.push({ field, values });\n\t\treturn this;\n\t}\n\n\twhereNotIn<K extends keyof T>(field: K, values: T[K][]): this {\n\t\tthis.notInConditions.push({ field, values });\n\t\treturn this;\n\t}\n\n\twhereBetween<K extends keyof T>(field: K, min: T[K], max: T[K]): this {\n\t\tthis.betweenConditions.push({ field, min, max });\n\t\treturn this;\n\t}\n\n\twhereNull<K extends keyof T>(field: K): this {\n\t\tthis.nullConditions.push({ field, isNull: true });\n\t\treturn this;\n\t}\n\n\twhereNotNull<K extends keyof T>(field: K): this {\n\t\tthis.nullConditions.push({ field, isNull: false });\n\t\treturn this;\n\t}\n\n\tsearch(query: string, fields?: (keyof T)[]): this {\n\t\tthis.searchQuery = { query, fields };\n\t\treturn this;\n\t}\n\n\tlimit(value: number): this {\n\t\tthis.limitValue = value;\n\t\treturn this;\n\t}\n\n\tskip(value: number): this {\n\t\tthis.skipValue = value;\n\t\treturn this;\n\t}\n\n\tsort<K extends keyof T>(field: K, direction: 'asc' | 'desc'): this {\n\t\tthis.sortOptions[field as string] = direction === 'asc' ? 1 : -1;\n\t\treturn this;\n\t}\n\n\torderBy<K extends keyof T>(sorts: Array<{ field: K; direction: 'asc' | 'desc' }>): this {\n\t\tthis.multiSortOptions = sorts;\n\t\t// Also update sortOptions for backward compatibility\n\t\tsorts.forEach(({ field, direction }) => {\n\t\t\tthis.sortOptions[field as string] = direction === 'asc' ? 1 : -1;\n\t\t});\n\t\treturn this;\n\t}\n\n\tselect<K extends keyof T>(fields: K[]): this {\n\t\tthis.selectedFields = fields;\n\t\treturn this;\n\t}\n\n\texclude<K extends keyof T>(fields: K[]): this {\n\t\tthis.excludedFields = fields;\n\t\treturn this;\n\t}\n\n\tproject<K extends keyof T>(fields: Partial<Record<K, boolean>>): this {\n\t\tthis.projectionFields = fields as Record<string, boolean>;\n\t\treturn this;\n\t}\n\n\tdistinct<K extends keyof T>(field?: K): this {\n\t\tif (field) {\n\t\t\tthis.distinctField = field;\n\t\t}\n\t\treturn this;\n\t}\n\n\tgroupBy<K extends keyof T>(field: K): this {\n\t\tthis.groupByField = field;\n\t\treturn this;\n\t}\n\n\thint(hints: QueryOptimizationHints): this {\n\t\tthis.optimizationHints = hints;\n\t\treturn this;\n\t}\n\n\ttimeout(milliseconds: number): this {\n\t\tthis.timeoutMs = milliseconds;\n\t\treturn this;\n\t}\n\n\tpaginate(options: PaginationOptions): this {\n\t\t// Support both offset-based and cursor-based pagination\n\t\tif (options.cursor) {\n\t\t\t// Cursor-based pagination (more efficient for large datasets)\n\t\t\t// Cursor format: \"field:value\" (e.g., \"_id:507f1f77bcf86cd799439011\")\n\t\t\tconst [cursorField, cursorValue] = options.cursor.split(':');\n\t\t\tif (cursorField && cursorValue) {\n\t\t\t\t// Add cursor condition to query\n\t\t\t\tconst cursorCondition = options.sortDirection === 'desc' ? { $lt: cursorValue } : { $gt: cursorValue };\n\t\t\t\tthis.query[cursorField] = cursorCondition;\n\t\t\t}\n\t\t} else if (options.page && options.pageSize) {\n\t\t\t// Traditional offset-based pagination (less efficient for large datasets)\n\t\t\tthis.skipValue = (options.page - 1) * options.pageSize;\n\t\t\tthis.limitValue = options.pageSize;\n\t\t}\n\n\t\tif (options.sortField && options.sortDirection) {\n\t\t\tthis.sortOptions[options.sortField] = options.sortDirection === 'asc' ? 1 : -1;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate buildQuery(): Record<string, unknown> {\n\t\tconst finalQuery = { ...this.query };\n\n\t\t// Apply whereIn conditions\n\t\tthis.inConditions.forEach(({ field, values }) => {\n\t\t\tfinalQuery[field as string] = { $in: values };\n\t\t});\n\n\t\t// Apply whereNotIn conditions\n\t\tthis.notInConditions.forEach(({ field, values }) => {\n\t\t\tfinalQuery[field as string] = { $nin: values };\n\t\t});\n\n\t\t// Apply whereBetween conditions\n\t\tthis.betweenConditions.forEach(({ field, min, max }) => {\n\t\t\tfinalQuery[field as string] = { $gte: min, $lte: max };\n\t\t});\n\n\t\t// Apply null/not null conditions\n\t\tthis.nullConditions.forEach(({ field, isNull }) => {\n\t\t\tif (isNull) {\n\t\t\t\tfinalQuery[field as string] = { $eq: null };\n\t\t\t} else {\n\t\t\t\tfinalQuery[field as string] = { $ne: null };\n\t\t\t}\n\t\t});\n\n\t\t// Apply text search\n\t\tif (this.searchQuery) {\n\t\t\tif (this.searchQuery.fields && this.searchQuery.fields.length > 0) {\n\t\t\t\t// Field-specific search using regex\n\t\t\t\tconst searchConditions = this.searchQuery.fields.map((field) => ({\n\t\t\t\t\t[field as string]: { $regex: this.searchQuery!.query, $options: 'i' }\n\t\t\t\t}));\n\t\t\t\tfinalQuery.$or = searchConditions;\n\t\t\t} else {\n\t\t\t\t// Full text search if available\n\t\t\t\tfinalQuery.$text = { $search: this.searchQuery.query };\n\t\t\t}\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tprivate buildProjection(): Record<string, number> | undefined {\n\t\tif (this.selectedFields?.length) {\n\t\t\tconst projection: Record<string, number> = {};\n\t\t\tthis.selectedFields.forEach((field) => {\n\t\t\t\tprojection[field as string] = 1;\n\t\t\t});\n\t\t\treturn projection;\n\t\t}\n\n\t\tif (this.excludedFields?.length) {\n\t\t\tconst projection: Record<string, number> = {};\n\t\t\tthis.excludedFields.forEach((field) => {\n\t\t\t\tprojection[field as string] = 0;\n\t\t\t});\n\t\t\treturn projection;\n\t\t}\n\n\t\treturn this.projectionFields as Record<string, number> | undefined;\n\t}\n\n\tprivate createDatabaseError(error: unknown, code: string, message: string): DatabaseError {\n\t\tlogger.error(`${code}: ${message}`, error);\n\t\treturn {\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\tdetails: error instanceof Error ? error.message : String(error),\n\t\t\tstack: error instanceof Error ? error.stack : undefined\n\t\t};\n\t}\n\n\tprivate buildQueryMeta(startTime: number): QueryMeta {\n\t\tconst executionTime = Date.now() - startTime;\n\t\treturn {\n\t\t\texecutionTime,\n\t\t\tcached: false, // MongoDB doesn't provide direct cache info\n\t\t\tindexesUsed: this.optimizationHints?.useIndex || []\n\t\t\t// Note: MongoDB doesn't easily provide recordsExamined without explain()\n\t\t\t// For production monitoring, consider enabling explain() in development\n\t\t};\n\t}\n\n\tasync count(): Promise<DatabaseResult<number>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tconst count = await this.model.countDocuments(query);\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn { success: true, data: count, meta };\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_COUNT_ERROR', 'Failed to count documents');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync exists(): Promise<DatabaseResult<boolean>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tconst count = await this.model.countDocuments(query).limit(1);\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn { success: true, data: count > 0, meta };\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_EXISTS_ERROR', 'Failed to check document existence');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync execute(): Promise<DatabaseResult<T[]>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tlet mongoQuery = this.model.find(query);\n\n\t\t\t// Apply optimization hints\n\t\t\tif (this.optimizationHints) {\n\t\t\t\tif (this.optimizationHints.useIndex?.length) {\n\t\t\t\t\tmongoQuery = mongoQuery.hint(this.optimizationHints.useIndex[0]);\n\t\t\t\t}\n\t\t\t\tif (this.optimizationHints.maxExecutionTime) {\n\t\t\t\t\tmongoQuery = mongoQuery.maxTimeMS(this.optimizationHints.maxExecutionTime);\n\t\t\t\t}\n\t\t\t\tif (this.optimizationHints.batchSize) {\n\t\t\t\t\tmongoQuery = mongoQuery.batchSize(this.optimizationHints.batchSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply timeout\n\t\t\tif (this.timeoutMs) {\n\t\t\t\tmongoQuery = mongoQuery.maxTimeMS(this.timeoutMs);\n\t\t\t}\n\n\t\t\t// Apply sorting (prioritize multi-sort over single sort)\n\t\t\tif (this.multiSortOptions.length > 0) {\n\t\t\t\tconst sortObj: Record<string, 1 | -1> = {};\n\t\t\t\tthis.multiSortOptions.forEach(({ field, direction }) => {\n\t\t\t\t\tsortObj[field as string] = direction === 'asc' ? 1 : -1;\n\t\t\t\t});\n\t\t\t\tmongoQuery = mongoQuery.sort(sortObj);\n\t\t\t} else if (Object.keys(this.sortOptions).length > 0) {\n\t\t\t\tmongoQuery = mongoQuery.sort(this.sortOptions);\n\t\t\t}\n\n\t\t\t// Apply field projection\n\t\t\tconst projection = this.buildProjection();\n\t\t\tif (projection) {\n\t\t\t\tmongoQuery = mongoQuery.select(projection);\n\t\t\t}\n\n\t\t\t// Apply skip/limit\n\t\t\tif (this.skipValue !== undefined) {\n\t\t\t\tmongoQuery = mongoQuery.skip(this.skipValue);\n\t\t\t}\n\t\t\tif (this.limitValue !== undefined) {\n\t\t\t\tmongoQuery = mongoQuery.limit(this.limitValue);\n\t\t\t}\n\n\t\t\t// Handle distinct queries\n\t\t\tif (this.distinctField) {\n\t\t\t\tconst distinctValues = await this.model.distinct(this.distinctField as string, query);\n\t\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\t\treturn { success: true, data: distinctValues as T[], meta };\n\t\t\t}\n\n\t\t\t// Handle group by queries using aggregation\n\t\t\tif (this.groupByField) {\n\t\t\t\tconst pipeline = [{ $match: query }, { $group: { _id: `$${this.groupByField as string}`, items: { $push: '$$ROOT' } } }];\n\t\t\t\tconst results = await this.model.aggregate(pipeline);\n\t\t\t\tconst flatResults = results.flatMap((group) => group.items);\n\t\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\t\treturn { success: true, data: flatResults as T[], meta };\n\t\t\t}\n\n\t\t\t// Execute the query with lean() for better performance\n\t\t\tconst results = await mongoQuery.lean().exec();\n\n\t\t\t// Simplified ISO date conversion: check for object and toISOString method only.\n\t\t\tconst processedResults = results.map((doc) => ({\n\t\t\t\t...doc,\n\t\t\t\tcreatedAt: (doc.createdAt as any) instanceof Date ? (doc.createdAt as any).toISOString() : doc.createdAt,\n\t\t\t\tupdatedAt: (doc.updatedAt as any) instanceof Date ? (doc.updatedAt as any).toISOString() : doc.updatedAt\n\t\t\t})) as T[];\n\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn { success: true, data: processedResults, meta };\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_EXECUTION_ERROR', 'Failed to execute query');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync stream(): Promise<DatabaseResult<AsyncIterable<T>>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tlet mongoQuery = this.model.find(query);\n\n\t\t\t// Apply optimization hints for streaming\n\t\t\tif (this.optimizationHints) {\n\t\t\t\tif (this.optimizationHints.batchSize) {\n\t\t\t\t\tmongoQuery = mongoQuery.batchSize(this.optimizationHints.batchSize);\n\t\t\t\t}\n\t\t\t\tif (this.optimizationHints.maxExecutionTime) {\n\t\t\t\t\tmongoQuery = mongoQuery.maxTimeMS(this.optimizationHints.maxExecutionTime);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply sorting\n\t\t\tif (this.multiSortOptions.length > 0) {\n\t\t\t\tconst sortObj: Record<string, 1 | -1> = {};\n\t\t\t\tthis.multiSortOptions.forEach(({ field, direction }) => {\n\t\t\t\t\tsortObj[field as string] = direction === 'asc' ? 1 : -1;\n\t\t\t\t});\n\t\t\t\tmongoQuery = mongoQuery.sort(sortObj);\n\t\t\t} else if (Object.keys(this.sortOptions).length > 0) {\n\t\t\t\tmongoQuery = mongoQuery.sort(this.sortOptions);\n\t\t\t}\n\n\t\t\t// Apply field projection\n\t\t\tconst projection = this.buildProjection();\n\t\t\tif (projection) {\n\t\t\t\tmongoQuery = mongoQuery.select(projection);\n\t\t\t}\n\n\t\t\t// Create async iterable from cursor\n\t\t\tconst cursor = mongoQuery.lean().cursor();\n\t\t\tconst asyncIterable = {\n\t\t\t\tasync *[Symbol.asyncIterator]() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor await (const doc of cursor) {\n\t\t\t\t\t\t\t// FIX: Check for the toISOString method instead of using `instanceof Date`.\n\t\t\t\t\t\t\t// ...\n\n\t\t\t\t\t\t\tconst processedDoc = {\n\t\t\t\t\t\t\t\t...doc,\n\t\t\t\t\t\t\t\tcreatedAt: (doc.createdAt as any) instanceof Date ? (doc.createdAt as any).toISOString() : doc.createdAt,\n\t\t\t\t\t\t\t\tupdatedAt: (doc.updatedAt as any) instanceof Date ? (doc.updatedAt as any).toISOString() : doc.updatedAt\n\t\t\t\t\t\t\t} as T;\n\t\t\t\t\t\t\tyield processedDoc;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t\t\tlogger.error(`Stream iteration failed: ${error.message}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error('Stream iteration failed with an unknown error', error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn { success: true, data: asyncIterable, meta };\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_STREAM_ERROR', 'Failed to create query stream');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync findOne(): Promise<DatabaseResult<T | null>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tlet mongoQuery = this.model.findOne(query);\n\n\t\t\t// Apply optimization hints\n\t\t\tif (this.optimizationHints) {\n\t\t\t\tif (this.optimizationHints.maxExecutionTime) {\n\t\t\t\t\tmongoQuery = mongoQuery.maxTimeMS(this.optimizationHints.maxExecutionTime);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply timeout\n\t\t\tif (this.timeoutMs) {\n\t\t\t\tmongoQuery = mongoQuery.maxTimeMS(this.timeoutMs);\n\t\t\t}\n\n\t\t\t// Apply field projection\n\t\t\tconst projection = this.buildProjection();\n\t\t\tif (projection) {\n\t\t\t\tmongoQuery = mongoQuery.select(projection);\n\t\t\t}\n\n\t\t\t// Apply sorting (for consistent results when multiple docs match)\n\t\t\tif (this.multiSortOptions.length > 0) {\n\t\t\t\tconst sortObj: Record<string, 1 | -1> = {};\n\t\t\t\tthis.multiSortOptions.forEach(({ field, direction }) => {\n\t\t\t\t\tsortObj[field as string] = direction === 'asc' ? 1 : -1;\n\t\t\t\t});\n\t\t\t\tmongoQuery = mongoQuery.sort(sortObj);\n\t\t\t} else if (Object.keys(this.sortOptions).length > 0) {\n\t\t\t\tmongoQuery = mongoQuery.sort(this.sortOptions);\n\t\t\t}\n\n\t\t\tconst result = await mongoQuery.lean().exec();\n\n\t\t\tif (!result) {\n\t\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\t\treturn { success: true, data: null, meta };\n\t\t\t}\n\n\t\t\t// FIX: Check for the toISOString method instead of using `instanceof Date`.\n\t\t\tconst processedResult = {\n\t\t\t\t...result,\n\t\t\t\tcreatedAt: (result.createdAt as any) instanceof Date ? (result.createdAt as any).toISOString() : result.createdAt,\n\t\t\t\tupdatedAt: (result.updatedAt as any) instanceof Date ? (result.updatedAt as any).toISOString() : result.updatedAt\n\t\t\t} as T;\n\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn { success: true, data: processedResult, meta };\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_FINDONE_ERROR', 'Failed to find document');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync findOneOrFail(): Promise<DatabaseResult<T>> {\n\t\tconst result = await this.findOne();\n\t\tif (!result.success) {\n\t\t\t// The error object from findOne already has the correct shape\n\t\t\treturn result;\n\t\t}\n\t\tif (result.data === null) {\n\t\t\tconst dbError = this.createDatabaseError(new Error('Document not found'), 'DOCUMENT_NOT_FOUND', 'Required document not found');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t\treturn { success: true, data: result.data, meta: result.meta };\n\t}\n\n\tasync updateMany(data: Partial<T>): Promise<DatabaseResult<{ modifiedCount: number }>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tconst updateData = {\n\t\t\t\t...data,\n\t\t\t\tupdatedAt: new Date().toISOString()\n\t\t\t};\n\t\t\tconst result = await this.model.updateMany(query, { $set: updateData });\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { modifiedCount: result.modifiedCount || 0 },\n\t\t\t\tmeta\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_UPDATE_MANY_ERROR', 'Failed to update documents');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\tasync deleteMany(): Promise<DatabaseResult<{ deletedCount: number }>> {\n\t\tconst startTime = Date.now();\n\t\ttry {\n\t\t\tconst query = this.buildQuery();\n\t\t\tconst result = await this.model.deleteMany(query);\n\t\t\tconst meta = this.buildQueryMeta(startTime);\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { deletedCount: result.deletedCount || 0 },\n\t\t\t\tmeta\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst dbError = this.createDatabaseError(error, 'QUERY_DELETE_MANY_ERROR', 'Failed to delete documents');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n}\n","/**\n * @file src/databases/mongodb/methods/authComposition.ts\n * @description Composition layer for MongoDB authentication adapters\n *\n * This file combines three specialized auth adapters (User, Session, Token) into\n * a unified interface. It serves as the glue code between modular adapters and\n * the MongoDB adapter, following the composition over inheritance pattern.\n *\n * **Architecture Pattern:**\n * - Dependency Injection: Adapters are instantiated here\n * - Composition: Methods are bound and exposed as unified interface\n * - Decoupling: Keeps individual adapters independent and testable\n *\n * **Purpose:**\n * Instead of merging 1,786 lines of auth code into one massive file, this\n * composition layer allows us to maintain separation of concerns while\n * providing a single interface for the MongoDB adapter.\n */\n\nimport type { IDBAdapter, DatabaseResult, ISODateString } from '@shared/database/dbInterface';\nimport type { User, Session, Role } from '@shared/database/auth/types';\n\nimport { SessionAdapter } from '../models/authSession';\nimport { TokenAdapter } from '../models/authToken';\nimport { UserAdapter } from '../models/authUser';\nimport { logger } from '@shared/utils/logger';\nimport { hashPassword } from '@shared/utils/crypto';\nimport mongoose from 'mongoose';\n\n// Type helper to extract the auth interface from IDBAdapter\ntype AuthInterface = IDBAdapter['auth'];\n\n/**\n * Compose the MongoDB Auth adapter from its sub-adapters.\n *\n * This function creates instances of UserAdapter, SessionAdapter, and TokenAdapter,\n * then binds all their methods into a unified object that matches the auth interface\n * defined in IDBAdapter['auth'].\n *\n * @returns A composed auth interface with all methods properly bound\n *\n * @example\n * ```typescript\n * // Used internally by MongoDBAdapter\n * const authAdapter = composeMongoAuthAdapter();\n *\n * // All methods are properly bound:\n * const user = await authAdapter.createUser({ email: 'test@example.com' });\n * const session = await authAdapter.createSession({ user_id: user._id, expires: new Date() });\n * ```\n */\nexport function composeMongoAuthAdapter(): AuthInterface {\n\tconst userAdapter = new UserAdapter();\n\tconst sessionAdapter = new SessionAdapter();\n\tconst tokenAdapter = new TokenAdapter();\n\n\tconst adapter = {\n\t\t// User Management Methods\n\t\tcreateUser: userAdapter.createUser.bind(userAdapter),\n\t\tupdateUserAttributes: userAdapter.updateUserAttributes.bind(userAdapter),\n\t\tdeleteUser: userAdapter.deleteUser.bind(userAdapter),\n\t\tgetUserById: userAdapter.getUserById.bind(userAdapter),\n\t\tgetUserByEmail: userAdapter.getUserByEmail.bind(userAdapter),\n\t\tgetAllUsers: userAdapter.getAllUsers.bind(userAdapter),\n\t\tgetUserCount: userAdapter.getUserCount.bind(userAdapter),\n\t\tdeleteUsers: userAdapter.deleteUsers?.bind(userAdapter),\n\t\tblockUsers: userAdapter.blockUsers?.bind(userAdapter),\n\t\tunblockUsers: userAdapter.unblockUsers?.bind(userAdapter),\n\n\t\t// Combined Performance-Optimized Methods\n\t\tcreateUserAndSession: async (\n\t\t\tuserData: Partial<User>,\n\t\t\tsessionData: { expires: ISODateString; tenantId?: string }\n\t\t): Promise<DatabaseResult<{ user: User; session: Session }>> => {\n\t\t\ttry {\n\t\t\t\t// Hash password if provided\n\t\t\t\tif (userData.password) {\n\t\t\t\t\tuserData.password = await hashPassword(userData.password);\n\t\t\t\t}\n\n\t\t\t\t// Create user first\n\t\t\t\tconst userResult = await userAdapter.createUser(userData);\n\t\t\t\tif (!userResult.success) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: userResult.message || 'Failed to create user',\n\t\t\t\t\t\terror: userResult.error\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create session for the new user\n\t\t\t\tconst sessionResult = await sessionAdapter.createSession({\n\t\t\t\t\tuser_id: userResult.data._id,\n\t\t\t\t\texpires: sessionData.expires,\n\t\t\t\t\ttenantId: sessionData.tenantId\n\t\t\t\t});\n\n\t\t\t\tif (!sessionResult.success) {\n\t\t\t\t\t// Rollback: delete the user we just created\n\t\t\t\t\tawait userAdapter.deleteUser(userResult.data._id, sessionData.tenantId);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: sessionResult.message || 'Failed to create session',\n\t\t\t\t\t\terror: sessionResult.error\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tuser: userResult.data,\n\t\t\t\t\t\tsession: sessionResult.data\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error in createUserAndSession: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'CREATE_USER_AND_SESSION_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tdeleteUserAndSessions: async (\n\t\t\tuser_id: string,\n\t\t\ttenantId?: string\n\t\t): Promise<DatabaseResult<{ deletedUser: boolean; deletedSessionCount: number }>> => {\n\t\t\ttry {\n\t\t\t\t// Step 1: Get session count before deletion (for reporting)\n\t\t\t\tlet deletedSessionCount = 0;\n\t\t\t\ttry {\n\t\t\t\t\tconst activeSessions = await sessionAdapter.getActiveSessions(user_id, tenantId);\n\t\t\t\t\tif (activeSessions.success && activeSessions.data) {\n\t\t\t\t\t\tdeletedSessionCount = activeSessions.data.length;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Non-fatal: just log and continue\n\t\t\t\t\tlogger.debug('Could not count sessions before deletion', { user_id });\n\t\t\t\t}\n\n\t\t\t\t// Step 2: Delete all user sessions\n\t\t\t\tconst sessionsResult = await sessionAdapter.invalidateAllUserSessions(user_id, tenantId);\n\n\t\t\t\tif (!sessionsResult.success) {\n\t\t\t\t\tlogger.warn('Failed to invalidate user sessions, continuing with user deletion', {\n\t\t\t\t\t\tuser_id,\n\t\t\t\t\t\terror: sessionsResult.message\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Step 3: Delete the user\n\t\t\t\tconst userResult = await userAdapter.deleteUser(user_id, tenantId);\n\n\t\t\t\tif (!userResult.success) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: userResult.message || 'Failed to delete user',\n\t\t\t\t\t\terror: userResult.error\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlogger.info(`User and sessions deleted: user=${user_id}, sessions=${deletedSessionCount}`, {\n\t\t\t\t\tuser_id,\n\t\t\t\t\tdeletedSessionCount,\n\t\t\t\t\ttenantId\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tdeletedUser: true,\n\t\t\t\t\t\tdeletedSessionCount\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error in deleteUserAndSessions: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message, { user_id, tenantId });\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'DELETE_USER_AND_SESSIONS_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t// Session Management Methods\n\t\tcreateSession: sessionAdapter.createSession.bind(sessionAdapter),\n\t\tupdateSessionExpiry: sessionAdapter.updateSessionExpiry.bind(sessionAdapter),\n\t\tdeleteSession: sessionAdapter.deleteSession.bind(sessionAdapter),\n\t\tdeleteExpiredSessions: sessionAdapter.deleteExpiredSessions.bind(sessionAdapter),\n\t\tvalidateSession: sessionAdapter.validateSession.bind(sessionAdapter),\n\t\tinvalidateAllUserSessions: sessionAdapter.invalidateAllUserSessions.bind(sessionAdapter),\n\t\tgetActiveSessions: sessionAdapter.getActiveSessions.bind(sessionAdapter),\n\t\tgetAllActiveSessions: sessionAdapter.getAllActiveSessions.bind(sessionAdapter),\n\t\tgetSessionTokenData: sessionAdapter.getSessionTokenData.bind(sessionAdapter),\n\t\trotateToken: sessionAdapter.rotateToken.bind(sessionAdapter),\n\t\tcleanupRotatedSessions: sessionAdapter.cleanupRotatedSessions?.bind(sessionAdapter),\n\n\t\t// Token Management Methods\n\t\tcreateToken: tokenAdapter.createToken.bind(tokenAdapter),\n\t\tvalidateToken: tokenAdapter.validateToken.bind(tokenAdapter),\n\t\tconsumeToken: tokenAdapter.consumeToken.bind(tokenAdapter),\n\t\tgetTokenByValue: tokenAdapter.getTokenByValue.bind(tokenAdapter),\n\t\tdeleteExpiredTokens: tokenAdapter.deleteExpiredTokens.bind(tokenAdapter),\n\t\tgetAllTokens: tokenAdapter.getAllTokens.bind(tokenAdapter),\n\t\tupdateToken: tokenAdapter.updateToken.bind(tokenAdapter),\n\t\tdeleteTokens: tokenAdapter.deleteTokens.bind(tokenAdapter),\n\t\tblockTokens: tokenAdapter.blockTokens.bind(tokenAdapter),\n\t\tunblockTokens: tokenAdapter.unblockTokens.bind(tokenAdapter),\n\n\t\t// Role Management Methods (basic implementation)\n\t\tcreateRole: async (role: Role): Promise<DatabaseResult<Role>> => {\n\t\t\ttry {\n\t\t\t\t// Get or create Role model (stored in 'auth_roles' collection)\n\t\t\t\tconst RoleModel =\n\t\t\t\t\tmongoose.models.auth_roles ||\n\t\t\t\t\tmongoose.model<Role>(\n\t\t\t\t\t\t'auth_roles',\n\t\t\t\t\t\tnew mongoose.Schema(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: { type: String, required: true },\n\t\t\t\t\t\t\t\tname: { type: String, required: true },\n\t\t\t\t\t\t\t\tdescription: String,\n\t\t\t\t\t\t\t\tisAdmin: Boolean,\n\t\t\t\t\t\t\t\tpermissions: [String],\n\t\t\t\t\t\t\t\ttenantId: { type: String, index: true }, // Multi-tenant support\n\t\t\t\t\t\t\t\tgroupName: String,\n\t\t\t\t\t\t\t\ticon: String,\n\t\t\t\t\t\t\t\tcolor: String\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: false,\n\t\t\t\t\t\t\t\ttimestamps: true,\n\t\t\t\t\t\t\t\tcollection: 'auth_roles'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t// Create indexes for multi-tenant queries\n\t\t\t\tawait RoleModel.collection.createIndex({ tenantId: 1 });\n\t\t\t\tawait RoleModel.collection.createIndex({ tenantId: 1, _id: 1 });\n\n\t\t\t\tconst newRole = await RoleModel.create(role);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: newRole.toObject() as Role\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error creating role: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'CREATE_ROLE_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tgetAllRoles: async (tenantId?: string): Promise<Role[]> => {\n\t\t\ttry {\n\t\t\t\tconst RoleModel =\n\t\t\t\t\tmongoose.models.auth_roles ||\n\t\t\t\t\tmongoose.model<Role>(\n\t\t\t\t\t\t'auth_roles',\n\t\t\t\t\t\tnew mongoose.Schema(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: { type: String, required: true },\n\t\t\t\t\t\t\t\tname: { type: String, required: true },\n\t\t\t\t\t\t\t\tdescription: String,\n\t\t\t\t\t\t\t\tisAdmin: Boolean,\n\t\t\t\t\t\t\t\tpermissions: [String],\n\t\t\t\t\t\t\t\ttenantId: { type: String, index: true },\n\t\t\t\t\t\t\t\tgroupName: String,\n\t\t\t\t\t\t\t\ticon: String,\n\t\t\t\t\t\t\t\tcolor: String\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: false,\n\t\t\t\t\t\t\t\ttimestamps: true,\n\t\t\t\t\t\t\t\tcollection: 'auth_roles'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t// Filter by tenantId if in multi-tenant mode\n\t\t\t\tconst filter = tenantId ? { tenantId } : { tenantId: { $exists: false } };\n\t\t\t\tconst roles = await RoleModel.find(filter).lean<Role[]>();\n\n\t\t\t\treturn roles;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error(`Error fetching roles: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tgetRoleById: async (roleId: string, tenantId?: string): Promise<DatabaseResult<Role | null>> => {\n\t\t\ttry {\n\t\t\t\tconst RoleModel =\n\t\t\t\t\tmongoose.models.auth_roles ||\n\t\t\t\t\tmongoose.model<Role>(\n\t\t\t\t\t\t'auth_roles',\n\t\t\t\t\t\tnew mongoose.Schema(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: { type: String, required: true },\n\t\t\t\t\t\t\t\tname: { type: String, required: true },\n\t\t\t\t\t\t\t\tdescription: String,\n\t\t\t\t\t\t\t\tisAdmin: Boolean,\n\t\t\t\t\t\t\t\tpermissions: [String],\n\t\t\t\t\t\t\t\ttenantId: { type: String, index: true },\n\t\t\t\t\t\t\t\tgroupName: String,\n\t\t\t\t\t\t\t\ticon: String,\n\t\t\t\t\t\t\t\tcolor: String\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: false,\n\t\t\t\t\t\t\t\ttimestamps: true,\n\t\t\t\t\t\t\t\tcollection: 'auth_roles'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tconst filter: { _id: string; tenantId?: { $exists: boolean } | string } = { _id: roleId };\n\t\t\t\tif (tenantId) {\n\t\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t\t} else {\n\t\t\t\t\tfilter.tenantId = { $exists: false };\n\t\t\t\t}\n\n\t\t\t\tconst role = await RoleModel.findOne(filter).lean<Role>();\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: role || null\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error fetching role: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'GET_ROLE_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tupdateRole: async (roleId: string, roleData: Partial<Role>, tenantId?: string): Promise<DatabaseResult<Role>> => {\n\t\t\ttry {\n\t\t\t\tconst RoleModel =\n\t\t\t\t\tmongoose.models.auth_roles ||\n\t\t\t\t\tmongoose.model<Role>(\n\t\t\t\t\t\t'auth_roles',\n\t\t\t\t\t\tnew mongoose.Schema(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: { type: String, required: true },\n\t\t\t\t\t\t\t\tname: { type: String, required: true },\n\t\t\t\t\t\t\t\tdescription: String,\n\t\t\t\t\t\t\t\tisAdmin: Boolean,\n\t\t\t\t\t\t\t\tpermissions: [String],\n\t\t\t\t\t\t\t\ttenantId: { type: String, index: true },\n\t\t\t\t\t\t\t\tgroupName: String,\n\t\t\t\t\t\t\t\ticon: String,\n\t\t\t\t\t\t\t\tcolor: String\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: false,\n\t\t\t\t\t\t\t\ttimestamps: true,\n\t\t\t\t\t\t\t\tcollection: 'auth_roles'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tconst filter: { _id: string; tenantId?: { $exists: boolean } | string } = { _id: roleId };\n\t\t\t\tif (tenantId) {\n\t\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t\t} else {\n\t\t\t\t\tfilter.tenantId = { $exists: false };\n\t\t\t\t}\n\n\t\t\t\tconst updatedRole = await RoleModel.findOneAndUpdate(filter, { $set: roleData }, { new: true }).lean<Role>();\n\n\t\t\t\tif (!updatedRole) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Role not found',\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'ROLE_NOT_FOUND',\n\t\t\t\t\t\t\tmessage: 'Role not found'\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: updatedRole\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error updating role: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'UPDATE_ROLE_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tdeleteRole: async (roleId: string, tenantId?: string): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tconst RoleModel =\n\t\t\t\t\tmongoose.models.auth_roles ||\n\t\t\t\t\tmongoose.model<Role>(\n\t\t\t\t\t\t'auth_roles',\n\t\t\t\t\t\tnew mongoose.Schema(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: { type: String, required: true },\n\t\t\t\t\t\t\t\tname: { type: String, required: true },\n\t\t\t\t\t\t\t\tdescription: String,\n\t\t\t\t\t\t\t\tisAdmin: Boolean,\n\t\t\t\t\t\t\t\tpermissions: [String],\n\t\t\t\t\t\t\t\ttenantId: { type: String, index: true },\n\t\t\t\t\t\t\t\tgroupName: String,\n\t\t\t\t\t\t\t\ticon: String,\n\t\t\t\t\t\t\t\tcolor: String\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_id: false,\n\t\t\t\t\t\t\t\ttimestamps: true,\n\t\t\t\t\t\t\t\tcollection: 'auth_roles'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tconst filter: { _id: string; tenantId?: { $exists: boolean } | string } = { _id: roleId };\n\t\t\t\tif (tenantId) {\n\t\t\t\t\tfilter.tenantId = tenantId;\n\t\t\t\t} else {\n\t\t\t\t\tfilter.tenantId = { $exists: false };\n\t\t\t\t}\n\n\t\t\t\tconst result = await RoleModel.deleteOne(filter);\n\n\t\t\t\tif (result.deletedCount === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Role not found',\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: 'ROLE_NOT_FOUND',\n\t\t\t\t\t\t\tmessage: 'Role not found'\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: undefined\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tconst message = `Error deleting role: ${err instanceof Error ? err.message : String(err)}`;\n\t\t\t\tlogger.error(message);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'DELETE_ROLE_ERROR',\n\t\t\t\t\t\tmessage: err instanceof Error ? err.message : String(err)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t};\n\n\t// Return the composed adapter (TypeScript will enforce type compatibility)\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\treturn adapter as any as AuthInterface;\n}\n","/**\n * @file src/databases/mongodb/mongoDBAdapter.ts\n * @description Central MongoDB adapter for CMS database operations\n *\n * This module provides an implementation of the `dbInterface` for MongoDB, handling:\n * - MongoDB connection management with a robust retry mechanism\n * - CRUD operations for collections, documents, drafts, revisions, and widgets\n * - Management of media storage, retrieval, and virtual folders\n * - User authentication and revisions\n * - Management of system preferences including user screen sizes and widget layouts\n * - Theme management\n * - Content Structure Management\n *\n * Key Features:\n * - Automatic reconnection with exponential backoff for MongoDB\n * - Schema definitions and model creation for various collections (e.g., Drafts, Revisions, Widgets, Media)\n * - Robust handling of media files with specific schemas for different media types\n * - Management of authentication-related models (e.g., User, Token, Session)\n * - Default and custom theme management with database storage\n * - User preferences storage and retrieval, including layout and screen size information\n * - Virtual folder management for organizing media\n * - Flexible Content Structure management for pages and collections\n *\n * Usage:\n * This adapter is utilized when the CMS is configured to use MongoDB, providing a\n * database-agnostic interface for various database operations within the CMS.\n * The adapter supports complex queries, schema management, and handles error logging\n * and connection retries. It integrates fully with the CMS for all data management needs.\n */\n\n// Mongoose and core types\nimport mongoose from 'mongoose';\nimport type {\n\tBaseEntity,\n\tConnectionPoolOptions,\n\tDatabaseId,\n\tDatabaseResult,\n\tIDBAdapter,\n\tDatabaseError,\n\tISODateString,\n\tQueryFilter\n} from '../dbInterface';\nimport type { ConnectionPoolDiagnostics } from '../DatabaseResilience';\n\n// All Mongoose Models\nimport {\n\tContentNodeModel,\n\tDraftModel,\n\tMediaModel,\n\tRevisionModel,\n\tSystemPreferencesModel,\n\tSystemSettingModel,\n\tThemeModel,\n\tWidgetModel,\n\tWebsiteTokenModel\n} from './models';\n\n// The full suite of refined, modular method classes\nimport { MongoAuthModelRegistrar } from './methods/authMethods';\nimport { MongoCollectionMethods } from './methods/collectionMethods';\nimport { MongoContentMethods } from './methods/contentMethods';\nimport { MongoCrudMethods } from './methods/crudMethods';\nimport { MongoMediaMethods } from './methods/mediaMethods';\nimport * as mongoDBUtils from './methods/mongoDBUtils';\nimport * as mongoDBCacheUtils from './methods/mongoDBCacheUtils';\nimport { MongoSystemMethods } from './methods/systemMethods';\nimport { MongoSystemVirtualFolderMethods } from './methods/systemVirtualFolderMethods';\nimport { MongoThemeMethods } from './methods/themeMethods';\nimport { MongoWebsiteTokenMethods } from './methods/websiteTokenMethods';\nimport { MongoWidgetMethods } from './methods/widgetMethods';\nimport { MongoQueryBuilder } from './MongoQueryBuilder';\n\n// Auth adapter composition\nimport { composeMongoAuthAdapter } from './methods/authComposition';\n\nimport { logger } from '@shared/utils/logger.server';\nimport type {\n\tContentNode,\n\tContentDraft,\n\tMediaItem,\n\tMediaMetadata,\n\tContentRevision,\n\tSchema,\n\tDatabaseTransaction,\n\tBatchOperation,\n\tBatchResult,\n\tPerformanceMetrics,\n\tCacheOptions\n} from '../dbInterface';\nimport { cacheService } from '@shared/database/CacheService';\nimport { cacheMetrics } from '@shared/database/CacheMetrics';\nimport { createDatabaseError, generateId } from './methods/mongoDBUtils';\n\nexport class MongoDBAdapter implements IDBAdapter {\n\t// --- Private properties for internal, unwrapped method classes ---\n\tprivate _collectionMethods!: MongoCollectionMethods;\n\tprivate _content!: MongoContentMethods;\n\tprivate _media!: MongoMediaMethods;\n\tprivate _themes!: MongoThemeMethods;\n\tprivate _widgets!: MongoWidgetMethods;\n\tprivate _websiteTokens!: MongoWebsiteTokenMethods;\n\tprivate _system!: MongoSystemMethods;\n\tprivate _systemVirtualFolder!: MongoSystemVirtualFolderMethods;\n\tprivate _auth!: MongoAuthModelRegistrar;\n\tprivate _repositories = new Map<string, MongoCrudMethods<BaseEntity>>();\n\n\t// --- Public properties that expose the compliant, wrapped API ---\n\tpublic content!: IDBAdapter['content'];\n\tpublic media!: IDBAdapter['media'];\n\tpublic themes!: IDBAdapter['themes'];\n\tpublic widgets!: IDBAdapter['widgets'];\n\tpublic systemPreferences!: IDBAdapter['systemPreferences'];\n\tpublic crud!: IDBAdapter['crud'];\n\tpublic auth!: IDBAdapter['auth'];\n\tpublic websiteTokens!: IDBAdapter['websiteTokens'];\n\tpublic readonly utils = mongoDBUtils;\n\tpublic readonly cacheUtils = mongoDBCacheUtils;\n\tpublic collection!: IDBAdapter['collection'];\n\n\tgetCapabilities(): import('../dbInterface').DatabaseCapabilities {\n\t\treturn {\n\t\t\tsupportsTransactions: true,\n\t\t\tsupportsIndexing: true,\n\t\t\tsupportsFullTextSearch: true,\n\t\t\tsupportsAggregation: true,\n\t\t\tsupportsStreaming: true,\n\t\t\tsupportsPartitioning: false,\n\t\t\tmaxBatchSize: 1000,\n\t\t\tmaxQueryComplexity: 10\n\t\t};\n\t}\n\n\tasync getConnectionHealth(): Promise<DatabaseResult<{ healthy: boolean; latency: number; activeConnections: number }>> {\n\t\ttry {\n\t\t\tif (!mongoose.connection.db) {\n\t\t\t\treturn { success: false, message: 'Not connected to DB', error: { code: 'DB_DISCONNECTED', message: 'Not connected' } };\n\t\t\t}\n\t\t\tconst start = Date.now();\n\t\t\tawait mongoose.connection.db.admin().ping();\n\t\t\tconst latency = Date.now() - start;\n\t\t\t// Note: Mongoose does not expose active connections directly from the pool.\n\t\t\t// This is a placeholder. For more detailed monitoring, a dedicated APM tool is recommended.\n\t\t\tconst activeConnections = -1;\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\thealthy: this.isConnected(),\n\t\t\t\t\tlatency,\n\t\t\t\t\tactiveConnections\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst dbError = this.utils.createDatabaseError(error, 'CONNECTION_HEALTH_CHECK_FAILED', 'Failed to check connection health');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: dbError,\n\t\t\t\tmessage: dbError.message\n\t\t\t};\n\t\t}\n\t}\n\n\t// --- Legacy Support ---\n\tpublic findMany<T extends BaseEntity>(coll: string, query: QueryFilter<T>, options?: { limit?: number; offset?: number }) {\n\t\tlogger.warn('Direct call to dbAdapter.findMany() is deprecated. Use dbAdapter.crud.findMany() instead.');\n\t\treturn this.crud.findMany(coll, query, options);\n\t}\n\n\tpublic create<T extends BaseEntity>(coll: string, data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>) {\n\t\tlogger.warn('Direct call to dbAdapter.create() is deprecated. Use dbAdapter.crud.insert() instead.');\n\t\treturn this.crud.insert(coll, data);\n\t}\n\n\t// --- Query Builder ---\n\tpublic queryBuilder<T extends BaseEntity>(collection: string) {\n\t\tconst repo = this._getRepository(collection);\n\t\tif (!repo) {\n\t\t\tthrow new Error(`Collection ${collection} not found`);\n\t\t}\n\t\tconst model = repo.model as unknown as mongoose.Model<T>;\n\t\tif (!model) {\n\t\t\tthrow new Error(`Model not found for collection ${collection}`);\n\t\t}\n\t\treturn new MongoQueryBuilder<T>(model);\n\t}\n\n\tprivate async _wrapResult<T, A extends unknown[]>(fn: (...args: A) => Promise<T>, ...args: A): Promise<DatabaseResult<T>> {\n\t\ttry {\n\t\t\tconst data = await fn(...args);\n\t\t\treturn { success: true, data };\n\t\t} catch (error: unknown) {\n\t\t\tconst typedError = error as { code?: string; message?: string };\n\t\t\tconst dbError = this.utils.createDatabaseError(error, typedError.code || 'OPERATION_FAILED', typedError.message || 'Unknown error');\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: dbError.message,\n\t\t\t\terror: dbError\n\t\t\t};\n\t\t}\n\t}\n\n\t// Overload signatures to match IDBAdapter interface\n\t/**\n\t * Check if the adapter is fully initialized (connection + models + wrappers)\n\t */\n\tprivate _isFullyInitialized(): boolean {\n\t\treturn this.isConnected() && this.auth !== undefined && this._auth !== undefined;\n\t}\n\n\tconnect(connectionString: string, options?: unknown): Promise<DatabaseResult<void>>;\n\tconnect(poolOptions?: ConnectionPoolOptions): Promise<DatabaseResult<void>>;\n\tconnect(connectionStringOrOptions?: string | ConnectionPoolOptions, options?: unknown): Promise<DatabaseResult<void>> {\n\t\treturn this._wrapResult(async () => {\n\t\t\t// Check if already fully initialized\n\t\t\tif (this._isFullyInitialized()) {\n\t\t\t\tlogger.info('MongoDB adapter already fully initialized.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If connected but not fully initialized, complete the initialization\n\t\t\tif (this.isConnected() && !this._isFullyInitialized()) {\n\t\t\t\tlogger.info('MongoDB connection exists but adapter not fully initialized. Completing initialization...');\n\t\t\t\tawait this._initializeModelsAndWrappers();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet connectionString: string;\n\t\t\tlet mongooseOptions: unknown = options;\n\n\t\t\t// Check if it's a string connection string\n\t\t\tif (typeof connectionStringOrOptions === 'string' && connectionStringOrOptions) {\n\t\t\t\tconnectionString = connectionStringOrOptions;\n\t\t\t\tlogger.debug(`Using provided connection string: mongodb://*****@${connectionString.split('@')[1] || 'localhost'}`);\n\t\t\t} else if (connectionStringOrOptions && typeof connectionStringOrOptions === 'object') {\n\t\t\t\t// It's ConnectionPoolOptions\n\t\t\t\tlogger.warn('ConnectionPoolOptions are not fully supported yet. Using default connection string.');\n\t\t\t\tconnectionString = process.env.MONGODB_URI || 'mongodb://localhost:27017/sveltycms';\n\t\t\t\tmongooseOptions = connectionStringOrOptions; // Use the options if provided\n\t\t\t} else {\n\t\t\t\t// No parameters provided, use environment variable\n\t\t\t\tlogger.warn('No connection string provided. Using environment variable or default.');\n\t\t\t\tconnectionString = process.env.MONGODB_URI || 'mongodb://localhost:27017/sveltycms';\n\t\t\t}\n\n\t\t\t// Connection pool configuration for optimal performance\n\t\t\tconst connectOptions: mongoose.ConnectOptions = (mongooseOptions as mongoose.ConnectOptions) || {\n\t\t\t\t// Connection Pool Settings (MongoDB 8.0+ optimized)\n\t\t\t\tmaxPoolSize: 50, // Maximum concurrent connections\n\t\t\t\tminPoolSize: 10, // Maintain minimum pool for fast response\n\t\t\t\tmaxIdleTimeMS: 30000, // Close idle connections after 30s\n\n\t\t\t\t// Performance Optimizations\n\t\t\t\t// Note: Compression disabled to avoid optional dependency issues (zstd, snappy not installed)\n\t\t\t\t// You can enable compression by installing: bun add snappy @mongodb-js/zstd\n\t\t\t\treadPreference: 'primaryPreferred', // Balance between consistency and availability\n\n\t\t\t\t// Timeout Settings\n\t\t\t\tserverSelectionTimeoutMS: 5000, // Fail fast on connection issues\n\t\t\t\tsocketTimeoutMS: 45000, // Socket timeout for long-running queries\n\t\t\t\tconnectTimeoutMS: 10000, // Connection timeout\n\n\t\t\t\t// Reliability Settings\n\t\t\t\tretryWrites: true, // Auto-retry failed writes\n\t\t\t\tretryReads: true, // Auto-retry failed reads\n\t\t\t\tw: 'majority', // Write concern for data durability\n\n\t\t\t\t// Monitoring\n\t\t\t\tmonitorCommands: process.env.NODE_ENV === 'development' // Enable command monitoring in dev\n\t\t\t};\n\n\t\t\t// Use DatabaseResilience for automatic retry with exponential backoff\n\t\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\t\tconst resilience = getDatabaseResilience();\n\n\t\t\tawait resilience.executeWithRetry(async () => {\n\t\t\t\tawait mongoose.connect(connectionString, connectOptions);\n\t\t\t\tlogger.info('MongoDB connection established with resilience and optimized pool configuration.');\n\t\t\t}, 'MongoDB connection');\n\n\t\t\t// Setup self-healing reconnection listeners\n\t\t\tthis._setupReconnectionHandlers(connectionString, connectOptions);\n\n\t\t\t// Initialize models and wrappers\n\t\t\tawait this._initializeModelsAndWrappers();\n\t\t});\n\t}\n\n\t// Setup mongoose event listeners for self-healing database reconnection\n\tprivate _setupReconnectionHandlers(connectionString: string, connectOptions: mongoose.ConnectOptions): void {\n\t\t// Remove existing listeners to avoid duplicates\n\t\tmongoose.connection.removeAllListeners('disconnected');\n\t\tmongoose.connection.removeAllListeners('error');\n\t\tmongoose.connection.removeAllListeners('reconnected');\n\n\t\t// Handle disconnection events\n\t\tmongoose.connection.on('disconnected', async () => {\n\t\t\tlogger.warn('MongoDB connection lost. Attempting self-healing reconnection...');\n\n\t\t\tconst { getDatabaseResilience, notifyAdminsOfDatabaseFailure } = await import('@shared/database/DatabaseResilience');\n\t\t\tconst resilience = getDatabaseResilience();\n\n\t\t\tconst reconnected = await resilience.attemptReconnection(\n\t\t\t\tasync () => {\n\t\t\t\t\tawait mongoose.connect(connectionString, connectOptions);\n\t\t\t\t},\n\t\t\t\tasync (error) => {\n\t\t\t\t\t// Notify admins on persistent failure\n\t\t\t\t\tawait notifyAdminsOfDatabaseFailure(error, resilience.getMetrics());\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (reconnected) {\n\t\t\t\tlogger.info('MongoDB self-healing reconnection successful');\n\t\t\t} else {\n\t\t\t\tlogger.error('MongoDB self-healing reconnection failed after all attempts');\n\t\t\t}\n\t\t});\n\n\t\t// Handle connection errors\n\t\tmongoose.connection.on('error', (err) => {\n\t\t\tlogger.error('MongoDB connection error occurred', { error: err });\n\t\t});\n\n\t\t// Log successful reconnections\n\t\tmongoose.connection.on('reconnected', () => {\n\t\t\tlogger.info('MongoDB reconnected successfully');\n\t\t});\n\n\t\tlogger.debug('Self-healing reconnection handlers registered');\n\t}\n\n\t// Initialize all models, repositories, method classes, and wrappers\n\tprivate async _initializeModelsAndWrappers(): Promise<void> {\n\t\t// --- 1. Register All Models ---\n\t\tthis._auth = new MongoAuthModelRegistrar(mongoose);\n\t\tawait this._auth.setupAuthModels();\n\t\tMongoMediaMethods.registerModels(mongoose);\n\t\tlogger.info('All Mongoose models registered.');\n\n\t\t// --- 2. Instantiate Repositories ---\n\t\tconst repositories = {\n\t\t\tnodes: new MongoCrudMethods(ContentNodeModel as unknown as mongoose.Model<BaseEntity>),\n\t\t\tdrafts: new MongoCrudMethods(DraftModel as unknown as mongoose.Model<BaseEntity>),\n\t\t\trevisions: new MongoCrudMethods(RevisionModel as unknown as mongoose.Model<BaseEntity>),\n\t\t\twebsiteTokens: new MongoCrudMethods(WebsiteTokenModel as unknown as mongoose.Model<BaseEntity>)\n\t\t};\n\t\tObject.entries(repositories).forEach(([key, repo]) => this._repositories.set(key, repo));\n\n\t\t// --- 3. Instantiate Method Classes ---\n\t\t// Initialize collection methods (for dynamic model creation)\n\t\tthis._collectionMethods = new MongoCollectionMethods();\n\n\t\tthis._content = new MongoContentMethods(\n\t\t\trepositories.nodes as unknown as MongoCrudMethods<ContentNode>,\n\t\t\trepositories.drafts as unknown as MongoCrudMethods<ContentDraft<unknown>>,\n\t\t\trepositories.revisions as unknown as MongoCrudMethods<ContentRevision>\n\t\t);\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tthis._media = new MongoMediaMethods(MediaModel as any);\n\t\tthis._themes = new MongoThemeMethods(ThemeModel);\n\t\tthis._widgets = new MongoWidgetMethods(WidgetModel);\n\t\tthis._websiteTokens = new MongoWebsiteTokenMethods(WebsiteTokenModel);\n\t\tthis._system = new MongoSystemMethods(SystemPreferencesModel, SystemSettingModel);\n\t\tthis._systemVirtualFolder = new MongoSystemVirtualFolderMethods();\n\n\t\t// --- 4. Build the Public-Facing Wrapped API ---\n\t\tthis._initializeWrappers();\n\t\tlogger.info('MongoDB adapter fully initialized.');\n\t}\n\n\tprivate _initializeWrappers(): void {\n\t\t// AUTH - Compose from the auth adapters\n\t\tconst authAdapter = composeMongoAuthAdapter();\n\n\t\tthis.auth = {\n\t\t\t// Setup method for model registration\n\t\t\tsetupAuthModels: async () => {\n\t\t\t\tawait this._auth.setupAuthModels();\n\t\t\t},\n\n\t\t\t// User Management Methods (authAdapter already returns DatabaseResult, don't double-wrap)\n\t\t\tcreateUser: (user) => authAdapter.createUser(user),\n\t\t\tupdateUserAttributes: (userId, attributes) => authAdapter.updateUserAttributes(userId, attributes),\n\t\t\tdeleteUser: (userId) => authAdapter.deleteUser(userId),\n\t\t\tgetUserById: (userId) => authAdapter.getUserById(userId),\n\t\t\tgetUserByEmail: (email) => authAdapter.getUserByEmail(email),\n\t\t\tgetAllUsers: (pagination) => authAdapter.getAllUsers(pagination),\n\t\t\tgetUserCount: () => authAdapter.getUserCount(),\n\t\t\tdeleteUsers: (userIds) => authAdapter.deleteUsers?.(userIds),\n\t\t\tblockUsers: (userIds) => authAdapter.blockUsers?.(userIds),\n\t\t\tunblockUsers: (userIds) => authAdapter.unblockUsers?.(userIds),\n\n\t\t\t// Combined Performance-Optimized Methods\n\t\t\tcreateUserAndSession: (userData, sessionData) => authAdapter.createUserAndSession(userData, sessionData),\n\t\t\tdeleteUserAndSessions: (userId, tenantId) => authAdapter.deleteUserAndSessions(userId, tenantId),\n\n\t\t\t// Session Management Methods (authAdapter already returns DatabaseResult, don't double-wrap)\n\t\t\tcreateSession: (session) => authAdapter.createSession(session),\n\t\t\tupdateSessionExpiry: (sessionId, expiresAt) => authAdapter.updateSessionExpiry(sessionId, expiresAt),\n\t\t\tdeleteSession: (sessionId) => authAdapter.deleteSession(sessionId),\n\t\t\tdeleteExpiredSessions: () => authAdapter.deleteExpiredSessions(),\n\t\t\tvalidateSession: (sessionId) => authAdapter.validateSession(sessionId),\n\t\t\tinvalidateAllUserSessions: (userId) => authAdapter.invalidateAllUserSessions(userId),\n\t\t\tgetActiveSessions: (userId, pagination) => authAdapter.getActiveSessions(userId, pagination),\n\t\t\tgetAllActiveSessions: (pagination) => authAdapter.getAllActiveSessions(pagination),\n\t\t\tgetSessionTokenData: (sessionId) => authAdapter.getSessionTokenData(sessionId),\n\t\t\trotateToken: (oldSessionId, expires) => authAdapter.rotateToken(oldSessionId, expires),\n\t\t\tcleanupRotatedSessions: async () => {\n\t\t\t\tconst result = await authAdapter.cleanupRotatedSessions?.();\n\t\t\t\treturn result || { success: true, data: 0 };\n\t\t\t},\n\n\t\t\t// Token Management Methods (authAdapter already returns DatabaseResult, don't double-wrap)\n\t\t\tcreateToken: (token) => authAdapter.createToken(token),\n\t\t\tupdateToken: (tokenValue, updates) => authAdapter.updateToken(tokenValue, updates),\n\t\t\tvalidateToken: (tokenValue, type) => authAdapter.validateToken(tokenValue, type),\n\t\t\tconsumeToken: (tokenValue) => authAdapter.consumeToken(tokenValue),\n\t\t\tgetTokenData: (tokenValue) => authAdapter.getTokenByValue(tokenValue),\n\t\t\tgetTokenByValue: (tokenValue) => authAdapter.getTokenByValue(tokenValue),\n\t\t\tgetAllTokens: (pagination) => authAdapter.getAllTokens(pagination),\n\t\t\tdeleteExpiredTokens: () => authAdapter.deleteExpiredTokens(),\n\t\t\tdeleteTokens: (tokenIds) => authAdapter.deleteTokens?.(tokenIds),\n\t\t\tblockTokens: (tokenIds) => authAdapter.blockTokens?.(tokenIds),\n\t\t\tunblockTokens: (tokenIds) => authAdapter.unblockTokens?.(tokenIds),\n\n\t\t\t// Role Management Methods (authAdapter already returns DatabaseResult or Role[], don't double-wrap)\n\t\t\tgetAllRoles: (tenantId) => authAdapter.getAllRoles(tenantId),\n\t\t\tgetRoleById: (roleId, tenantId) => authAdapter.getRoleById(roleId, tenantId),\n\t\t\tcreateRole: (role) => authAdapter.createRole(role),\n\t\t\tupdateRole: (roleId, roleData, tenantId) => authAdapter.updateRole(roleId, roleData, tenantId),\n\t\t\tdeleteRole: (roleId, tenantId) => authAdapter.deleteRole(roleId, tenantId)\n\t\t};\n\n\t\t// WEBSITE TOKENS\n\t\tthis.websiteTokens = {\n\t\t\tcreate: (token) => this._wrapResult(() => this._websiteTokens.create(token)),\n\t\t\tgetAll: (options) => this._wrapResult(() => this._websiteTokens.getAll(options)),\n\t\t\tgetByName: (name) => this._wrapResult(() => this._websiteTokens.getByName(name)),\n\t\t\tdelete: (tokenId) =>\n\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\tawait this._websiteTokens.delete(tokenId);\n\t\t\t\t})\n\t\t};\n\n\t\t// THEMES\n\t\tthis.themes = {\n\t\t\tsetupThemeModels: async () => {\n\t\t\t\t/* models already set up */\n\t\t\t},\n\t\t\tgetActive: async () => {\n\t\t\t\tconst result = await this._wrapResult(() => this._themes.getActive());\n\t\t\t\tif (!result.success) return result;\n\t\t\t\tif (!result.data) return { success: false, message: 'No active theme found', error: { code: 'NOT_FOUND', message: 'No active theme found' } };\n\t\t\t\treturn { success: true, data: result.data };\n\t\t\t},\n\t\t\tsetDefault: async (id) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._themes.setDefault(id));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t},\n\t\t\tinstall: (theme) => this._wrapResult(() => this._themes.install(theme)),\n\t\t\tuninstall: async (id) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._themes.uninstall(id));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t},\n\t\t\tupdate: async (id, theme) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._themes.update(id, theme));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\tif (!result.data) return { success: false, message: 'Theme not found', error: { code: 'NOT_FOUND', message: 'Theme not found' } };\n\t\t\t\treturn { success: true, data: result.data };\n\t\t\t},\n\t\t\tgetAllThemes: async () => await this._themes.findAll(),\n\t\t\tstoreThemes: async (themes) => {\n\t\t\t\tfor (const theme of themes) {\n\t\t\t\t\t// Use atomic upsert to avoid duplicate key errors and cache issues\n\t\t\t\t\tif (theme._id) {\n\t\t\t\t\t\tawait this._themes.installOrUpdate(theme);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait this._themes.install(theme);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetDefaultTheme: async () => this._wrapResult(() => this._themes.getDefault())\n\t\t};\n\n\t\t// WIDGETS\n\t\tthis.widgets = {\n\t\t\tsetupWidgetModels: async () => {\n\t\t\t\t/* models already set up */\n\t\t\t},\n\t\t\tregister: (widget) => this._wrapResult(() => this._widgets.register(widget)),\n\t\t\tfindAll: async () => {\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.findAll());\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: result.data || [] };\n\t\t\t},\n\t\t\tgetActiveWidgets: async () => {\n\t\t\t\t// Push filtering to database instead of application code\n\t\t\t\t// fetch only active widgets from DB directly\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.getActiveWidgets());\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: result.data || [] };\n\t\t\t},\n\t\t\tactivate: async (id) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.activate(id));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t},\n\t\t\tdeactivate: async (id) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.deactivate(id));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t},\n\t\t\tupdate: async (id, widget) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.update(id, widget));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\tif (!result.data) return { success: false, message: 'Widget not found', error: { code: 'NOT_FOUND', message: 'Widget not found' } };\n\t\t\t\treturn { success: true, data: result.data };\n\t\t\t},\n\t\t\tdelete: async (id) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._widgets.delete(id));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t}\n\t\t};\n\n\t\t// SYSTEM PREFERENCES\n\t\tthis.systemPreferences = {\n\t\t\tget: async <T>(key: string, scope?: 'user' | 'system', userId?: DatabaseId) => {\n\t\t\t\tconst result = await this._wrapResult(() => this._system.get(key, scope, userId));\n\t\t\t\tif (!result.success) return result;\n\t\t\t\tif (result.data === null)\n\t\t\t\t\treturn { success: false, message: 'Preference not found', error: { code: 'NOT_FOUND', message: 'Preference not found' } };\n\t\t\t\treturn { success: true, data: result.data as T };\n\t\t\t},\n\t\t\t// Use bulk database query instead of sequential gets (10x faster)\n\t\t\tgetMany: <T>(keys: string[], scope?: 'user' | 'system', userId?: DatabaseId) =>\n\t\t\t\tthis._wrapResult(() => this._system.getMany<T>(keys, scope, userId)),\n\t\t\tset: <T>(key: string, value: T, scope?: 'user' | 'system', userId?: DatabaseId, category?: 'public' | 'private') =>\n\t\t\t\tthis._wrapResult(() => this._system.set(key, value, scope, userId, category)),\n\t\t\t// Use bulkWrite instead of sequential sets (33x faster)\n\t\t\tsetMany: <T>(preferences: Array<{ key: string; value: T; scope?: 'user' | 'system'; userId?: DatabaseId; category?: 'public' | 'private' }>) =>\n\t\t\t\tthis._wrapResult(() => this._system.setMany(preferences)),\n\t\t\tdelete: (key: string, scope?: 'user' | 'system', userId?: DatabaseId) => this._wrapResult(() => this._system.delete(key, scope, userId)),\n\t\t\t// Use bulk database operation instead of sequential deletes (33x faster)\n\t\t\tdeleteMany: (keys: string[], scope?: 'user' | 'system', userId?: DatabaseId) =>\n\t\t\t\tthis._wrapResult(() => this._system.deleteMany(keys, scope, userId)),\n\t\t\tclear: (scope?: 'user' | 'system', userId?: DatabaseId) => this._wrapResult(() => this._system.clear(scope, userId))\n\t\t};\n\n\t\t// MEDIA\n\t\tthis.media = {\n\t\t\tsetupMediaModels: async () => {\n\t\t\t\t/* models already set up */\n\t\t\t},\n\t\t\tfiles: {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tupload: (file) => this._wrapResult(async () => (await this._media.uploadMany([file as any]))[0]),\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tuploadMany: (files) => this._wrapResult(() => this._media.uploadMany(files as any)),\n\t\t\t\tdelete: async (id) => {\n\t\t\t\t\tconst result = await this._wrapResult(() => this._media.deleteMany([id]));\n\t\t\t\t\tif (!result.success) return result;\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t},\n\t\t\t\tdeleteMany: (ids) => this._wrapResult(() => this._media.deleteMany(ids)),\n\t\t\t\tgetByFolder: (folderId, options) => this._wrapResult(() => this._media.getFiles(folderId, options)),\n\t\t\t\tsearch: (_query, options) => this._wrapResult(() => this._media.getFiles(undefined, options)),\n\t\t\t\tgetMetadata: (ids) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst files = await this._repositories.get('media')!.findByIds(ids);\n\t\t\t\t\t\treturn files.reduce(\n\t\t\t\t\t\t\t(acc: Record<string, MediaMetadata>, f: BaseEntity & { metadata?: unknown }) => ({ ...acc, [f._id]: f.metadata as MediaMetadata }),\n\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\tupdateMetadata: async (id, metadata) => {\n\t\t\t\t\tconst result = await this._wrapResult(() => this._media.updateMetadata(id, metadata));\n\t\t\t\t\tif (!result.success) return result;\n\t\t\t\t\tif (!result.data) return { success: false, message: 'Media item not found', error: { code: 'NOT_FOUND', message: 'Media item not found' } };\n\t\t\t\t\treturn { success: true, data: result.data };\n\t\t\t\t},\n\t\t\t\tmove: (ids, targetId) => this._wrapResult(() => this._media.move(ids, targetId)),\n\t\t\t\tduplicate: (id, newName) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst file = await this._repositories.get('media')!.findOne({ _id: id } as QueryFilter<BaseEntity>);\n\t\t\t\t\t\tif (!file) throw new Error('File not found');\n\t\t\t\t\t\tconst newFile = await this._repositories.get('media')!.insert({\n\t\t\t\t\t\t\t...file,\n\t\t\t\t\t\t\t_id: this.utils.generateId(),\n\t\t\t\t\t\t\tfilename: newName || `${(file as MediaItem).filename}_copy`\n\t\t\t\t\t\t} as BaseEntity);\n\t\t\t\t\t\treturn newFile as MediaItem;\n\t\t\t\t\t})\n\t\t\t},\n\t\t\t// Note: Media files are stored flat with hash-based naming\n\t\t\t// Physical folders (year/month) are managed by mediaStorage.ts utilities\n\t\t\t// Database stores only metadata (filename, size, type, etc.) with no folder hierarchy\n\t\t\t// For content organization, use SystemVirtualFolder instead\n\t\t\tfolders: {\n\t\t\t\tcreate: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tcreateMany: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tdelete: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tdeleteMany: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tgetTree: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tgetFolderContents: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t},\n\t\t\t\tmove: async () => {\n\t\t\t\t\tthrow new Error('Media folders not supported. Use SystemVirtualFolder for content organization.');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// SYSTEM VIRTUAL FOLDERS\n\t\tthis.systemVirtualFolder = {\n\t\t\tcreate: (folder) => this._systemVirtualFolder.create(folder),\n\t\t\tgetById: (folderId) => this._systemVirtualFolder.getById(folderId),\n\t\t\tgetByParentId: (parentId) => this._systemVirtualFolder.getByParentId(parentId),\n\t\t\tgetAll: () => this._systemVirtualFolder.getAll(),\n\t\t\tupdate: (folderId, updateData) => this._systemVirtualFolder.update(folderId, updateData),\n\t\t\taddToFolder: (contentId, folderPath) => this._systemVirtualFolder.addToFolder(contentId, folderPath),\n\t\t\tgetContents: (folderPath) => this._systemVirtualFolder.getContents(folderPath),\n\t\t\tdelete: (folderId) => this._systemVirtualFolder.delete(folderId),\n\t\t\texists: (path) => this._systemVirtualFolder.exists(path)\n\t\t};\n\n\t\t// CONTENT\n\t\tthis.content = {\n\t\t\tnodes: {\n\t\t\t\tgetStructure: (mode, filter, bypassCache) => this._wrapResult(() => this._content.getStructure(mode, filter, bypassCache)),\n\t\t\t\tupsertContentStructureNode: (node) => this._wrapResult(() => this._content.upsertNodeByPath(node)),\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tcreate: (node) => this._wrapResult(() => this._repositories.get('nodes')!.insert(node as any) as Promise<ContentNode>),\n\t\t\t\tcreateMany: async () => {\n\t\t\t\t\tthrow new Error('insertMany not implemented');\n\t\t\t\t},\n\t\t\t\tupdate: (path, changes) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst node = await this._repositories.get('nodes')!.findOne({ path } as QueryFilter<BaseEntity>);\n\t\t\t\t\t\tif (!node) throw new Error('Node not found');\n\t\t\t\t\t\treturn (await this._repositories.get('nodes')!.update(node._id, changes as Partial<BaseEntity>)) as ContentNode;\n\t\t\t\t\t}),\n\t\t\t\tbulkUpdate: (updates) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tawait this._content.bulkUpdateNodes(updates);\n\t\t\t\t\t\tconst paths = updates.map((u) => u.path);\n\t\t\t\t\t\treturn (await this._repositories.get('nodes')!.findMany({ path: { $in: paths } } as QueryFilter<BaseEntity>)) as ContentNode[];\n\t\t\t\t\t}),\n\t\t\t\tfixMismatchedNodeIds: (nodes) => this._content.fixMismatchedNodeIds(nodes),\n\t\t\t\tdelete: (path) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst node = await this._repositories.get('nodes')!.findOne({ path } as QueryFilter<BaseEntity>);\n\t\t\t\t\t\tif (!node) throw new Error('Node not found');\n\t\t\t\t\t\tawait this._repositories.get('nodes')!.delete(node._id);\n\t\t\t\t\t}),\n\t\t\t\tdeleteMany: (paths) =>\n\t\t\t\t\tthis._wrapResult(() => this._repositories.get('nodes')!.deleteMany({ path: { $in: paths } } as QueryFilter<BaseEntity>)),\n\t\t\t\treorder: (nodeUpdates) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst updates = nodeUpdates.map(({ path, newOrder }) => ({ path, changes: { order: newOrder } as Partial<BaseEntity> }));\n\t\t\t\t\t\tawait this._content.bulkUpdateNodes(updates);\n\t\t\t\t\t\tconst paths = nodeUpdates.map((u) => u.path);\n\t\t\t\t\t\treturn (await this._repositories.get('nodes')!.findMany({ path: { $in: paths } } as QueryFilter<BaseEntity>)) as ContentNode[];\n\t\t\t\t\t}),\n\t\t\t\treorderStructure: (items) => this._wrapResult(() => this._content.reorderStructure(items))\n\t\t\t},\n\t\t\tdrafts: {\n\t\t\t\tcreate: (draft) => this._wrapResult(() => this._content.createDraft(draft)),\n\t\t\t\tcreateMany: async () => {\n\t\t\t\t\tthrow new Error('insertMany not implemented');\n\t\t\t\t},\n\t\t\t\tupdate: (id, data) =>\n\t\t\t\t\tthis._wrapResult(() => this._repositories.get('drafts')!.update(id, { data } as Partial<BaseEntity>) as Promise<ContentDraft<unknown>>),\n\t\t\t\tpublish: async (id) => {\n\t\t\t\t\tconst result = await this._wrapResult(() => this._content.publishManyDrafts([id]));\n\t\t\t\t\tif (!result.success) return result;\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t},\n\t\t\t\tpublishMany: (ids) =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tconst result = await this._content.publishManyDrafts(ids);\n\t\t\t\t\t\treturn { publishedCount: result.modifiedCount };\n\t\t\t\t\t}),\n\t\t\t\tgetForContent: (contentId, options) => this._wrapResult(() => this._content.getDraftsForContent(contentId, options)),\n\t\t\t\tdelete: async (id) => {\n\t\t\t\t\tconst result = await this._wrapResult(() => this._repositories.get('drafts')!.delete(id));\n\t\t\t\t\tif (!result.success) return result;\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t},\n\t\t\t\tdeleteMany: (ids) => this._wrapResult(() => this._repositories.get('drafts')!.deleteMany({ _id: { $in: ids } } as QueryFilter<BaseEntity>))\n\t\t\t},\n\t\t\trevisions: {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tcreate: (revision) => this._wrapResult(() => this._content.createRevision(revision as any)),\n\t\t\t\tgetHistory: (contentId, options) => this._wrapResult(() => this._content.getRevisionHistory(contentId, options)),\n\t\t\t\trestore: () =>\n\t\t\t\t\tthis._wrapResult(async () => {\n\t\t\t\t\t\tthrow new Error('Restore not yet implemented');\n\t\t\t\t\t}),\n\t\t\t\tdelete: async (id) => {\n\t\t\t\t\tconst result = await this._wrapResult(() => this._repositories.get('revisions')!.delete(id));\n\t\t\t\t\tif (!result.success) return result;\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t},\n\t\t\t\tdeleteMany: (ids) =>\n\t\t\t\t\tthis._wrapResult(() => this._repositories.get('revisions')!.deleteMany({ _id: { $in: ids } } as QueryFilter<BaseEntity>)),\n\t\t\t\tcleanup: (contentId, keepLatest) => this._wrapResult(() => this._content.cleanupRevisions(contentId, keepLatest))\n\t\t\t}\n\t\t};\n\n\t\t// CRUD - Generic CRUD operations\n\t\tthis.crud = {\n\t\t\tfindOne: <T extends BaseEntity>(coll: string, query: QueryFilter<T>, options?: { fields?: (keyof T)[] }) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.findOne(query as any, options as { fields?: (keyof BaseEntity)[] }) as Promise<T | null>);\n\t\t\t},\n\t\t\tfindMany: <T extends BaseEntity>(coll: string, query: QueryFilter<T>, options?: { limit?: number; offset?: number; fields?: (keyof T)[] }) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(\n\t\t\t\t\t() =>\n\t\t\t\t\t\trepo.findMany(query, { limit: options?.limit, skip: options?.offset, fields: options?.fields as (keyof BaseEntity)[] }) as Promise<T[]>\n\t\t\t\t);\n\t\t\t},\n\t\t\tinsert: <T extends BaseEntity>(coll: string, data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.insert(data as T) as Promise<T>);\n\t\t\t},\n\t\t\tupdate: <T extends BaseEntity>(coll: string, id: DatabaseId, data: Partial<Omit<T, 'createdAt' | 'updatedAt'>>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.update(id, data as Partial<T>) as Promise<T>);\n\t\t\t},\n\t\t\tdelete: (coll: string, id: DatabaseId) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(async () => {\n\t\t\t\t\tawait repo.delete(id);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfindByIds: <T extends BaseEntity>(coll: string, ids: DatabaseId[]) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.findByIds(ids) as Promise<T[]>);\n\t\t\t},\n\t\t\tinsertMany: <T extends BaseEntity>(coll: string, data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>[]) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.insertMany(data) as Promise<T[]>);\n\t\t\t},\n\t\t\tupdateMany: <T extends BaseEntity>(coll: string, query: QueryFilter<T>, data: Partial<Omit<T, 'createdAt' | 'updatedAt'>>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.updateMany(query as any, data as Partial<T>));\n\t\t\t},\n\t\t\tdeleteMany: <T extends BaseEntity>(coll: string, query: QueryFilter<T>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.deleteMany(query as any));\n\t\t\t},\n\t\t\tupsert: <T extends BaseEntity>(coll: string, query: Partial<T>, data: Omit<T, '_id' | 'createdAt' | 'updatedAt'>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.upsert(query as any, data as T) as Promise<T>);\n\t\t\t},\n\t\t\tupsertMany: <T extends BaseEntity>(coll: string, items: Array<{ query: Partial<T>; data: Omit<T, '_id' | 'createdAt' | 'updatedAt'> }>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.upsertMany(items));\n\t\t\t},\n\t\t\tcount: <T extends BaseEntity>(coll: string, query: QueryFilter<T>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.count(query as any));\n\t\t\t},\n\t\t\texists: <T extends BaseEntity>(coll: string, query: QueryFilter<T>) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(async () => (await repo.count(query as any)) > 0);\n\t\t\t},\n\t\t\taggregate: (coll: string, pipeline: mongoose.PipelineStage[]) => {\n\t\t\t\tconst repo = this._getRepository(coll);\n\t\t\t\tif (!repo) return this._repoNotFound(coll);\n\t\t\t\treturn this._wrapResult(() => repo.aggregate(pipeline));\n\t\t\t}\n\t\t};\n\n\t\t// COLLECTION - Dynamic model management\n\t\tthis.collection = {\n\t\t\tgetModel: async (id: string) => {\n\t\t\t\treturn await this._collectionMethods.getModel(id);\n\t\t\t},\n\t\t\tcreateModel: async (schema: Schema) => {\n\t\t\t\tawait this._collectionMethods.createModel(schema);\n\t\t\t},\n\t\t\tupdateModel: async (schema: Schema) => {\n\t\t\t\tawait this._collectionMethods.updateModel(schema);\n\t\t\t},\n\t\t\tdeleteModel: async (id: string) => {\n\t\t\t\tawait this._collectionMethods.deleteModel(id);\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate _getRepository(collection: string): MongoCrudMethods<BaseEntity> | null {\n\t\tconst normalized = this.utils.normalizeCollectionName(collection);\n\n\t\tif (this._repositories.has(normalized)) {\n\t\t\treturn this._repositories.get(normalized)!;\n\t\t}\n\n\t\t// Create repository for unknown collection\n\t\ttry {\n\t\t\tlet model: mongoose.Model<BaseEntity>;\n\t\t\tif (mongoose.models[normalized]) {\n\t\t\t\tmodel = mongoose.models[normalized];\n\t\t\t} else {\n\t\t\t\t// Use String _id to support UUID-based IDs\n\t\t\t\tconst schema = new mongoose.Schema({ _id: { type: String, required: true } }, { _id: false, strict: false, timestamps: true });\n\t\t\t\tmodel = mongoose.model<BaseEntity>(normalized, schema);\n\t\t\t}\n\t\t\tconst repo = new MongoCrudMethods(model);\n\t\t\tthis._repositories.set(normalized, repo);\n\t\t\treturn repo;\n\t\t} catch (error) {\n\t\t\tlogger.error(`Failed to create repository for ${collection}`, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate _repoNotFound(collection: string): Promise<DatabaseResult<never>> {\n\t\treturn Promise.resolve({\n\t\t\tsuccess: false,\n\t\t\tmessage: `Collection ${collection} not found`,\n\t\t\terror: { code: 'COLLECTION_NOT_FOUND', message: 'Collection not found' }\n\t\t});\n\t}\n\n\tasync disconnect(): Promise<DatabaseResult<void>> {\n\t\treturn this._wrapResult(() => mongoose.disconnect());\n\t}\n\n\tisConnected(): boolean {\n\t\treturn mongoose.connection.readyState === 1;\n\t}\n\n\tasync transaction<T>(fn: (transaction: DatabaseTransaction) => Promise<DatabaseResult<T>>): Promise<DatabaseResult<T>> {\n\t\tconst session = await mongoose.startSession();\n\t\tsession.startTransaction();\n\t\ttry {\n\t\t\tconst result = await fn({\n\t\t\t\tcommit: async () => {\n\t\t\t\t\tawait session.commitTransaction();\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t},\n\t\t\t\trollback: async () => {\n\t\t\t\t\tawait session.abortTransaction();\n\t\t\t\t\treturn { success: true, data: undefined };\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (result.success) {\n\t\t\t\tawait session.commitTransaction();\n\t\t\t} else {\n\t\t\t\tawait session.abortTransaction();\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tawait session.abortTransaction();\n\t\t\tconst dbError = this.utils.createDatabaseError(error, 'TRANSACTION_ERROR', 'Transaction failed');\n\t\t\treturn { success: false, error: dbError, message: dbError.message };\n\t\t} finally {\n\t\t\tsession.endSession();\n\t\t}\n\t}\n\n\tbatch = {\n\t\t/**\n\t\t * Executes a batch of mixed operations (insert, update, delete, upsert) using MongoDB's native bulkWrite.\n\t\t * Uses bulkWrite per collection instead of sequential operations (33x faster for 100 operations).\n\t\t * Operations are grouped by collection and executed in parallel across different collections.\n\t\t */\n\t\texecute: async <T>(operations: BatchOperation<T>[]): Promise<DatabaseResult<BatchResult<T>>> => {\n\t\t\tif (operations.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tresults: [],\n\t\t\t\t\t\ttotalProcessed: 0,\n\t\t\t\t\t\terrors: []\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Group operations by collection for efficient bulk processing\n\t\t\t\tconst opsByCollection = operations.reduce(\n\t\t\t\t\t(acc, op, index) => {\n\t\t\t\t\t\tif (!acc[op.collection]) {\n\t\t\t\t\t\t\tacc[op.collection] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacc[op.collection].push({ op, originalIndex: index });\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t},\n\t\t\t\t\t{} as Record<string, Array<{ op: BatchOperation<T>; originalIndex: number }>>\n\t\t\t\t);\n\n\t\t\t\tconst allErrors: DatabaseError[] = [];\n\t\t\t\tlet totalSuccessful = 0;\n\n\t\t\t\t// Execute bulkWrite for each collection in parallel\n\t\t\t\tconst collectionResults = await Promise.all(\n\t\t\t\t\tObject.entries(opsByCollection).map(async ([collectionName, opsWithIndex]) => {\n\t\t\t\t\t\tconst repo = this._getRepository(collectionName);\n\t\t\t\t\t\tif (!repo) {\n\t\t\t\t\t\t\tconst error = createDatabaseError(\n\t\t\t\t\t\t\t\tnew Error(`Collection ${collectionName} not found`),\n\t\t\t\t\t\t\t\t'COLLECTION_NOT_FOUND',\n\t\t\t\t\t\t\t\t`Collection ${collectionName} not found during batch execution`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcollectionName,\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\toperations: opsWithIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Build bulkWrite operations array\n\t\t\t\t\t\t\tconst bulkOps = opsWithIndex.map(({ op }) => {\n\t\t\t\t\t\t\t\tconst now = new Date();\n\t\t\t\t\t\t\t\tswitch (op.operation) {\n\t\t\t\t\t\t\t\t\tcase 'insert':\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tinsertOne: {\n\t\t\t\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t...op.data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t_id: generateId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: now,\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: now\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcase 'update':\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\t\t\t\t\t\t\tfilter: { _id: op.id },\n\t\t\t\t\t\t\t\t\t\t\t\tupdate: { $set: { ...op.data, updatedAt: now } }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcase 'delete':\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tdeleteOne: {\n\t\t\t\t\t\t\t\t\t\t\t\tfilter: { _id: op.id }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcase 'upsert':\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tupdateOne: {\n\t\t\t\t\t\t\t\t\t\t\t\tfilter: op.query as any,\n\t\t\t\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$set: { ...op.data, updatedAt: now },\n\t\t\t\t\t\t\t\t\t\t\t\t\t$setOnInsert: { createdAt: now }\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tupsert: true\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Unknown operation type: ${(op as BatchOperation<T>).operation}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Execute bulkWrite with ordered: false for better performance\n\t\t\t\t\t\t\tconst result = await repo.model.bulkWrite(bulkOps as mongoose.AnyBulkWriteOperation<any>[], {\n\t\t\t\t\t\t\t\tordered: false // Don't stop on first error, process all operations\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcollectionName,\n\t\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\toperations: opsWithIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconst dbError = createDatabaseError(error, 'BULK_WRITE_ERROR', `Bulk write failed for collection ${collectionName}`);\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcollectionName,\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\terror: dbError,\n\t\t\t\t\t\t\t\toperations: opsWithIndex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\t// Process results and build response\n\t\t\t\tconst results: DatabaseResult<T>[] = new Array(operations.length);\n\t\t\t\tlet overallSuccess = true;\n\n\t\t\t\tfor (const collectionResult of collectionResults) {\n\t\t\t\t\tif (collectionResult.success && collectionResult.result) {\n\t\t\t\t\t\t// Mark successful operations\n\t\t\t\t\t\tconst successCount =\n\t\t\t\t\t\t\t(collectionResult.result.insertedCount || 0) +\n\t\t\t\t\t\t\t(collectionResult.result.modifiedCount || 0) +\n\t\t\t\t\t\t\t(collectionResult.result.deletedCount || 0) +\n\t\t\t\t\t\t\t(collectionResult.result.upsertedCount || 0);\n\t\t\t\t\t\ttotalSuccessful += successCount;\n\n\t\t\t\t\t\t// Fill in success results at original indices\n\t\t\t\t\t\tfor (const { originalIndex } of collectionResult.operations) {\n\t\t\t\t\t\t\tresults[originalIndex] = {\n\t\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\t\tdata: {} as T // bulkWrite doesn't return individual documents\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (collectionResult.error) {\n\t\t\t\t\t\t// Mark failed operations\n\t\t\t\t\t\toverallSuccess = false;\n\t\t\t\t\t\tallErrors.push(collectionResult.error);\n\n\t\t\t\t\t\tfor (const { originalIndex } of collectionResult.operations) {\n\t\t\t\t\t\t\tresults[originalIndex] = {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\tmessage: collectionResult.error.message,\n\t\t\t\t\t\t\t\terror: collectionResult.error\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tsuccess: overallSuccess,\n\t\t\t\t\t\tresults,\n\t\t\t\t\t\ttotalProcessed: totalSuccessful,\n\t\t\t\t\t\terrors: allErrors\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tconst dbError = createDatabaseError(error, 'BATCH_EXECUTE_ERROR', 'Batch execution failed');\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: dbError.message,\n\t\t\t\t\terror: dbError\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tbulkInsert: async <T extends BaseEntity>(\n\t\t\tcollection: string,\n\t\t\titems: Omit<T, '_id' | 'createdAt' | 'updatedAt'>[]\n\t\t): Promise<DatabaseResult<T[]>> => {\n\t\t\tconst repo = this._getRepository(collection);\n\t\t\tif (!repo) return this._repoNotFound(collection);\n\t\t\treturn this._wrapResult(() => repo.insertMany(items as T[]) as Promise<T[]>);\n\t\t},\n\t\tbulkUpdate: async <T extends BaseEntity>(\n\t\t\tcollection: string,\n\t\t\tupdates: Array<{ id: DatabaseId; data: Partial<T> }>\n\t\t): Promise<DatabaseResult<{ modifiedCount: number }>> => {\n\t\t\tconst repo = this._getRepository(collection);\n\t\t\tif (!repo) return this._repoNotFound(collection);\n\t\t\tconst bulkOps = updates.map((u) => ({\n\t\t\t\tupdateOne: {\n\t\t\t\t\tfilter: { _id: u.id },\n\t\t\t\t\tupdate: u.data\n\t\t\t\t}\n\t\t\t}));\n\t\t\treturn this._wrapResult(async () => {\n\t\t\t\tconst result = await repo.model.bulkWrite(bulkOps as mongoose.AnyBulkWriteOperation<any>[]);\n\t\t\t\treturn { modifiedCount: result.modifiedCount };\n\t\t\t});\n\t\t},\n\t\tbulkDelete: async (collection: string, ids: DatabaseId[]): Promise<DatabaseResult<{ deletedCount: number }>> => {\n\t\t\tconst repo = this._getRepository(collection);\n\t\t\tif (!repo) return this._repoNotFound(collection);\n\t\t\tconst result = await repo.deleteMany({ _id: { $in: ids } } as QueryFilter<BaseEntity>);\n\t\t\treturn { success: true, data: { deletedCount: result.deletedCount || 0 } };\n\t\t},\n\t\tbulkUpsert: async <T extends BaseEntity>(collection: string, items: Array<Partial<T> & { id?: DatabaseId }>): Promise<DatabaseResult<T[]>> => {\n\t\t\tconst repo = this._getRepository(collection);\n\t\t\tif (!repo) return this._repoNotFound(collection);\n\t\t\tconst bulkOps = items.map((item) => ({\n\t\t\t\tupdateOne: {\n\t\t\t\t\tfilter: { _id: item.id } as QueryFilter<T>,\n\t\t\t\t\tupdate: { $set: item },\n\t\t\t\t\tupsert: true\n\t\t\t\t}\n\t\t\t}));\n\t\t\treturn this._wrapResult(async () => {\n\t\t\t\tawait repo.model.bulkWrite(bulkOps as mongoose.AnyBulkWriteOperation<any>[]);\n\t\t\t\t// Note: This won't return the upserted documents in a single operation.\n\t\t\t\t// A find query would be needed to retrieve them, which is complex.\n\t\t\t\t// Returning empty array for now.\n\t\t\t\treturn [];\n\t\t\t});\n\t\t}\n\t};\n\n\tsystemVirtualFolder!: IDBAdapter['systemVirtualFolder'];\n\n\tperformance = {\n\t\tgetMetrics: async (): Promise<DatabaseResult<PerformanceMetrics>> => {\n\t\t\ttry {\n\t\t\t\t// Get cache metrics\n\t\t\t\tconst cacheSnapshot = cacheMetrics.getSnapshot();\n\n\t\t\t\t// Get MongoDB stats\n\t\t\t\tconst dbStats = mongoose.connection.db ? await mongoose.connection.db.stats() : null;\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tqueryCount: cacheSnapshot.totalRequests,\n\t\t\t\t\t\taverageQueryTime: cacheSnapshot.avgResponseTime,\n\t\t\t\t\t\tslowQueries: [],\n\t\t\t\t\t\tcacheHitRate: cacheSnapshot.hitRate,\n\t\t\t\t\t\tconnectionPoolUsage: dbStats ? dbStats.connections || -1 : -1\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Failed to get performance metrics',\n\t\t\t\t\terror: createDatabaseError(error, 'METRICS_ERROR', 'Failed to retrieve performance metrics')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tclearMetrics: async (): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tcacheMetrics.reset();\n\t\t\t\tlogger.info('Performance metrics cleared');\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Failed to clear metrics',\n\t\t\t\t\terror: createDatabaseError(error, 'METRICS_CLEAR_ERROR', 'Failed to clear performance metrics')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tenableProfiling: async (enabled: boolean): Promise<DatabaseResult<void>> => {\n\t\t\tif (!mongoose.connection.db) {\n\t\t\t\treturn { success: false, message: 'Not connected to DB', error: { code: 'DB_DISCONNECTED', message: 'Not connected' } };\n\t\t\t}\n\t\t\tconst level = enabled ? 'all' : 'off';\n\t\t\tawait mongoose.connection.db.setProfilingLevel(level);\n\t\t\treturn { success: true, data: undefined };\n\t\t},\n\t\tgetSlowQueries: async (limit = 10): Promise<DatabaseResult<Array<{ query: string; duration: number; timestamp: ISODateString }>>> => {\n\t\t\tif (!mongoose.connection.db) {\n\t\t\t\treturn { success: false, message: 'Not connected to DB', error: { code: 'DB_DISCONNECTED', message: 'Not connected' } };\n\t\t\t}\n\t\t\tconst profileData = await mongoose.connection.db.collection('system.profile').find().limit(limit).toArray();\n\t\t\tconst slowQueries = profileData.map((p) => {\n\t\t\t\tconst doc = p as unknown as { command: object; millis: number; ts: Date };\n\t\t\t\treturn {\n\t\t\t\t\tquery: JSON.stringify(doc.command),\n\t\t\t\t\tduration: doc.millis,\n\t\t\t\t\ttimestamp: doc.ts.toISOString() as ISODateString\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn { success: true, data: slowQueries };\n\t\t},\n\t\tgetPoolDiagnostics: async (): Promise<DatabaseResult<ConnectionPoolDiagnostics>> => {\n\t\t\ttry {\n\t\t\t\tconst { getDatabaseResilience } = await import('@shared/database/DatabaseResilience');\n\t\t\t\tconst resilience = getDatabaseResilience();\n\t\t\t\tconst diagnostics = await resilience.getPoolDiagnostics();\n\n\t\t\t\treturn { success: true, data: diagnostics };\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Failed to get pool diagnostics',\n\t\t\t\t\terror: createDatabaseError(error, 'POOL_DIAGNOSTICS_ERROR', 'Failed to retrieve connection pool diagnostics')\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t};\n\n\t// Smart Cache Layer Integration with Multi-Tenant Support\n\tcache = {\n\t\tget: async <T>(key: string): Promise<DatabaseResult<T | null>> => {\n\t\t\ttry {\n\t\t\t\tawait cacheService.initialize();\n\t\t\t\tconst value = await cacheService.get<T>(key);\n\t\t\t\tlogger.debug(`Cache get: ${key}`, { found: value !== null });\n\t\t\t\treturn { success: true, data: value };\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Cache get failed:', error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cache retrieval failed',\n\t\t\t\t\terror: createDatabaseError(error, 'CACHE_GET_ERROR', 'Failed to get from cache')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tset: async <T>(key: string, value: T, options?: CacheOptions): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tawait cacheService.initialize();\n\t\t\t\tconst ttl = options?.ttl || 60; // Default 60 seconds\n\t\t\t\tconst tenantId = options?.tags?.find((tag) => tag.startsWith('tenant:'))?.replace('tenant:', '');\n\n\t\t\t\tawait cacheService.set(key, value, ttl, tenantId);\n\t\t\t\tlogger.debug(`Cache set: ${key}`, { ttl, tenantId });\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Cache set failed:', error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cache storage failed',\n\t\t\t\t\terror: createDatabaseError(error, 'CACHE_SET_ERROR', 'Failed to set in cache')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tdelete: async (key: string): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tawait cacheService.initialize();\n\t\t\t\tawait cacheService.delete(key);\n\t\t\t\tlogger.debug(`Cache delete: ${key}`);\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Cache delete failed:', error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cache deletion failed',\n\t\t\t\t\terror: createDatabaseError(error, 'CACHE_DELETE_ERROR', 'Failed to delete from cache')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tclear: async (tags?: string[]): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tawait cacheService.initialize();\n\n\t\t\t\tif (tags && tags.length > 0) {\n\t\t\t\t\t// Clear specific tags using pattern matching\n\t\t\t\t\tfor (const tag of tags) {\n\t\t\t\t\t\t// Extract tenant ID if present\n\t\t\t\t\t\tconst tenantId = tag.startsWith('tenant:') ? tag.replace('tenant:', '') : undefined;\n\t\t\t\t\t\tconst pattern = tenantId ? `*` : `*${tag}*`;\n\t\t\t\t\t\tawait cacheService.clearByPattern(pattern, tenantId);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug(`Cache cleared for tags: ${tags.join(', ')}`);\n\t\t\t\t} else {\n\t\t\t\t\t// Clear all cache (use carefully!)\n\t\t\t\t\tawait cacheService.clearByPattern('*');\n\t\t\t\t\tlogger.warn('All cache cleared (global clear)');\n\t\t\t\t}\n\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Cache clear failed:', error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cache clear failed',\n\t\t\t\t\terror: createDatabaseError(error, 'CACHE_CLEAR_ERROR', 'Failed to clear cache')\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tinvalidateCollection: async (collection: string): Promise<DatabaseResult<void>> => {\n\t\t\ttry {\n\t\t\t\tawait cacheService.initialize();\n\n\t\t\t\t// Invalidate all cache keys related to this collection\n\t\t\t\tconst pattern = `collection:${collection}:*`;\n\t\t\t\tawait cacheService.clearByPattern(pattern);\n\n\t\t\t\tlogger.info(`Cache invalidated for collection: ${collection}`);\n\t\t\t\treturn { success: true, data: undefined };\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Cache invalidation failed:', error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cache invalidation failed',\n\t\t\t\t\terror: createDatabaseError(error, 'CACHE_INVALIDATE_ERROR', 'Failed to invalidate collection cache')\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t};\n\n\tasync getCollectionData(\n\t\tcollectionName: string,\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t\tfields?: string[];\n\t\t\tincludeMetadata?: boolean;\n\t\t}\n\t): Promise<DatabaseResult<{ data: unknown[]; metadata?: { totalCount: number; schema?: unknown; indexes?: string[] } }>> {\n\t\tconst repo = this._getRepository(collectionName);\n\t\tif (!repo) return this._repoNotFound(collectionName);\n\n\t\tconst data = await repo.findMany({}, { limit: options?.limit, skip: options?.offset });\n\n\t\tif (options?.includeMetadata) {\n\t\t\tconst totalCount = await repo.count({});\n\t\t\tconst schema = repo.model.schema.obj;\n\t\t\tconst indexes = Object.keys(repo.model.schema.indexes());\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tdata,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\ttotalCount,\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tindexes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\treturn { success: true, data: { data } };\n\t}\n\n\tasync getMultipleCollectionData(\n\t\tcollectionNames: string[],\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\tfields?: string[];\n\t\t}\n\t): Promise<DatabaseResult<Record<string, unknown[]>>> {\n\t\t// Fetch all collections in parallel instead of sequentially\n\t\t// This reduces total time from sum(queries) to max(query)\n\t\tconst results = await Promise.all(\n\t\t\tcollectionNames.map((name) =>\n\t\t\t\tthis.getCollectionData(name, options).then((result) => ({\n\t\t\t\t\tname,\n\t\t\t\t\tsuccess: result.success,\n\t\t\t\t\tdata: result.success ? result.data.data : []\n\t\t\t\t}))\n\t\t\t)\n\t\t);\n\n\t\tconst responseData: Record<string, unknown[]> = {};\n\t\tfor (const result of results) {\n\t\t\tif (result.success) {\n\t\t\t\tresponseData[result.name] = result.data;\n\t\t\t} else {\n\t\t\t\tlogger.warn(`Failed to fetch data for collection: ${result.name}`);\n\t\t\t\tresponseData[result.name] = [];\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true, data: responseData };\n\t}\n}\n"],"names":["error","message","logger","MongooseSchema","result","meta","results","ContentNodeModel"],"mappings":"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"}