{"version":3,"file":"settingsService.js","sources":["../../../../../../shared/services/src/settingsService.ts"],"sourcesContent":["/**\n * @file shared/services/src/settingsService.ts\n * @description Server-only settings cache and management\n *\n * ⚠️ SECURITY: This file should NEVER be imported in client-side components\n * It handles both public AND private settings on the server only.\n *\n * ### Features\n * - Server-side cache for fast access\n * - Type-safe getters for public and private settings\n * - Database synchronization\n * - Settings import/export for admin operations\n */\n\nimport { privateConfigSchema, publicConfigSchema } from '@shared/database/schemas';\nimport { type InferOutput } from 'valibot';\nimport { logger } from '@shared/utils/logger';\n\ntype PrivateEnv = InferOutput<typeof privateConfigSchema>;\ntype PublicEnv = InferOutput<typeof publicConfigSchema> & { PKG_VERSION?: string };\n\n// Extract setting keys from schemas (single source of truth)\nconst KNOWN_PUBLIC_KEYS = Object.keys(publicConfigSchema.entries);\n\n// Infrastructure keys that come from config file, not database\nconst INFRASTRUCTURE_KEYS = new Set([\n\t'DB_TYPE',\n\t'DB_HOST',\n\t'DB_PORT',\n\t'DB_NAME',\n\t'DB_USER',\n\t'DB_PASSWORD',\n\t'DB_RETRY_ATTEMPTS',\n\t'DB_RETRY_DELAY',\n\t'DB_POOL_SIZE',\n\t'JWT_SECRET_KEY',\n\t'ENCRYPTION_KEY',\n\t'MULTI_TENANT'\n]);\n\nconst KNOWN_PRIVATE_KEYS = Object.keys(privateConfigSchema.entries).filter((key) => !INFRASTRUCTURE_KEYS.has(key));\n\n// Internal server-side cache (not reactive, plain objects)\nconst cache = {\n\tloaded: false,\n\tloadedAt: 0, // Timestamp for TTL\n\tprivate: {} as PrivateEnv,\n\tpublic: {} as PublicEnv,\n\tTTL: 5 * 60 * 1000 // 5 minutes TTL\n};\n\n// Memoized version loader\nlet pkgVersionPromise: Promise<string> | null = null;\nasync function loadPkgVersion(): Promise<string> {\n\tif (!pkgVersionPromise) {\n\t\tpkgVersionPromise = import('@root/package.json').then((pkg) => pkg.version || '0.0.0').catch(() => '0.0.0');\n\t}\n\treturn pkgVersionPromise;\n}\n\n/**\n * Loads settings from the database into the server-side cache if not already loaded.\n * Cache automatically invalidates after TTL (5 minutes) to prevent stale data.\n * This is the single source of truth on the server.\n */\nexport async function loadSettingsCache(): Promise<typeof cache> {\n\tconst now = Date.now();\n\n\t// Invalidate cache after TTL\n\tif (cache.loaded && now - cache.loadedAt > cache.TTL) {\n\t\tcache.loaded = false;\n\t\tlogger.debug('Settings cache invalidated (TTL expired)');\n\t}\n\n\tif (cache.loaded) {\n\t\treturn cache;\n\t}\n\n\ttry {\n\t\tconst { dbAdapter, getPrivateEnv } = await import('@shared/database/db');\n\n\t\t// Check if database adapter is available (might not be during setup)\n\t\tif (!dbAdapter?.systemPreferences) {\n\t\t\tlogger.warn('Database adapter not yet initialized, using empty settings cache');\n\t\t\t// Return an empty cache but mark it as loaded to prevent repeated warnings\n\t\t\tcache.loaded = true;\n\t\t\tcache.loadedAt = Date.now();\n\t\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\t\treturn cache;\n\t\t}\n\n\t\t// Load both public and private settings in parallel\n\t\tconst [publicResult, privateResult] = await Promise.all([\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PUBLIC_KEYS, 'system'),\n\t\t\tdbAdapter.systemPreferences.getMany(KNOWN_PRIVATE_KEYS, 'system')\n\t\t]);\n\n\t\tif (!publicResult.success) {\n\t\t\tthrow new Error(`Failed to load public settings: ${publicResult.error?.message || 'Unknown error'}`);\n\t\t}\n\n\t\t// Get public settings from database\n\t\tconst publicSettings = publicResult.data || {};\n\n\t\t// Get private settings from database (may be empty)\n\t\tconst privateDynamic = privateResult.success ? privateResult.data || {} : {};\n\n\t\t// Get private config settings (infrastructure settings)\n\t\t// Prefer in-memory config (set by initializeWithConfig) over filesystem import\n\t\t// This eliminates unnecessary file I/O and Vite cache dependency\n\t\tconst inMemoryConfig = getPrivateEnv();\n\n\t\tlet privateConfig: PrivateEnv;\n\t\tif (inMemoryConfig) {\n\t\t\t// Use in-memory config when available (post-setup, zero-restart mode)\n\t\t\tprivateConfig = inMemoryConfig;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t// Fall back to filesystem import (normal startup or first load)\n\t\t\t\tconst configModule = '@config/private';\n\t\t\t\tconst { privateEnv } = await import(/* @vite-ignore */ configModule);\n\t\t\t\tprivateConfig = privateEnv;\n\t\t\t} catch (error) {\n\t\t\t\t// Private config doesn't exist during setup - this is expected\n\t\t\t\tlogger.trace('Private config not found during setup - this is expected during initial setup', {\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t});\n\t\t\t\t// During setup, allow private env to be empty but correctly typed\n\t\t\t\tprivateConfig = {} as PrivateEnv;\n\t\t\t}\n\t\t}\n\n\t\t// Merge: infrastructure settings from config + dynamic settings from DB\n\t\tconst mergedPrivate = {\n\t\t\t...privateConfig,\n\t\t\t...privateDynamic\n\t\t};\n\n\t\t// Update cache with merged data\n\t\tcache.private = mergedPrivate as PrivateEnv;\n\t\tcache.public = publicSettings as PublicEnv;\n\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\tcache.loaded = true;\n\t\tcache.loadedAt = Date.now(); // Track when cache was loaded\n\n\t\treturn cache;\n\t} catch (error) {\n\t\t// Log error but don't throw during initial load to prevent blocking server startup\n\t\tconst { logger } = await import('@shared/utils/logger');\n\t\tlogger.error('Failed to load settings cache:', error);\n\n\t\t// Return empty cache with PKG_VERSION to allow server to continue\n\t\tcache.public.PKG_VERSION = await loadPkgVersion();\n\t\tthrow error; // Re-throw for caller to handle\n\t}\n}\n\n/**\n * Invalidates the server-side cache, forcing a reload on the next request.\n * Call this after any database update to the settings.\n * Note: PKG_VERSION is preserved as it's read from package.json, not database.\n */\nexport async function invalidateSettingsCache(): Promise<void> {\n\tconst pkgVersion = await loadPkgVersion();\n\tcache.loaded = false;\n\tcache.loadedAt = 0; // Reset timestamp\n\tcache.private = {} as PrivateEnv;\n\tcache.public = { PKG_VERSION: pkgVersion } as PublicEnv;\n\tlogger.debug('Settings cache manually invalidated');\n}\n\n/**\n * Populates the settings cache with new values.\n * Used by loadSettingsFromDB in db.ts\n */\nexport async function setSettingsCache(newPrivate: PrivateEnv, newPublic: PublicEnv): Promise<void> {\n\tcache.private = newPrivate;\n\tcache.public = { ...newPublic, PKG_VERSION: await loadPkgVersion() };\n\tcache.loaded = true;\n}\n\n/**\n * Check if cache is loaded\n */\nexport function isCacheLoaded(): boolean {\n\treturn cache.loaded;\n}\n\n/**\n * Type-safe getter for a private setting (SERVER ONLY)\n */\nexport async function getPrivateSetting<K extends keyof PrivateEnv>(key: K): Promise<PrivateEnv[K]> {\n\tconst { private: privateEnv } = await loadSettingsCache();\n\treturn privateEnv[key];\n}\n\n/**\n * Type-safe getter for a public setting (SERVER ONLY)\n */\nexport async function getPublicSetting<K extends keyof PublicEnv>(key: K): Promise<PublicEnv[K]> {\n\tconst { public: publicEnv } = await loadSettingsCache();\n\treturn publicEnv[key];\n}\n\n/**\n * Gets a setting that is NOT defined in the schema (SERVER ONLY)\n * Use this as an escape hatch only when necessary. It's not type-safe.\n */\nexport async function getUntypedSetting<T = unknown>(key: string, scope?: 'public' | 'private'): Promise<T | undefined> {\n\tconst { public: publicEnv, private: privateEnv } = await loadSettingsCache();\n\n\tif (!scope || scope === 'public') {\n\t\tif ((publicEnv as Record<string, unknown>)[key] !== undefined) {\n\t\t\treturn (publicEnv as unknown as Record<string, T>)[key];\n\t\t}\n\t}\n\tif (!scope || scope === 'private') {\n\t\tif ((privateEnv as Record<string, unknown>)[key] !== undefined) {\n\t\t\treturn (privateEnv as unknown as Record<string, T>)[key];\n\t\t}\n\t}\n\treturn undefined;\n}\n\n/**\n * SYNCHRONOUS cache accessors for legacy compatibility.\n * ⚠️ WARNING: These bypass the async loading pattern and can return empty values!\n *\n * These exist ONLY for:\n * - Module-level initialization (CacheService, googleAuth, etc.)\n * - Synchronous hooks that can't await\n *\n * In all other cases, prefer the async getters:\n * - Use getPublicSetting() for public settings\n * - Use getPrivateSetting() for private settings\n *\n * The cache must be pre-loaded via hooks.server.ts or these will return undefined!\n */\nexport function getPublicSettingSync<K extends keyof PublicEnv>(key: K): PublicEnv[K] {\n\treturn cache.public[key];\n}\n\nexport function getPrivateSettingSync<K extends keyof PrivateEnv>(key: K): PrivateEnv[K] {\n\treturn cache.private[key];\n}\n\n/**\n * Returns a merged view of all current settings for export.\n *\n * ⚠️ SECURITY WARNING: This function exposes PRIVATE settings!\n * Only use this for:\n * - Server-side admin operations\n * - Authenticated admin export functionality\n * - System backup/restore operations\n */\nexport async function getAllSettings(): Promise<Record<string, unknown>> {\n\tconst { public: publicEnv, private: privateEnv } = await loadSettingsCache();\n\treturn {\n\t\tpublic: { ...publicEnv },\n\t\tprivate: { ...privateEnv }\n\t} as Record<string, unknown>;\n}\n\n/**\n * Applies a snapshot to the database via systemPreferences adapter.\n * Invalidates cache after successful update.\n */\nexport async function updateSettingsFromSnapshot(snapshot: Record<string, unknown>): Promise<{ updated: number }> {\n\tconst { dbAdapter } = await import('@shared/database/db');\n\tif (!dbAdapter?.systemPreferences) {\n\t\tthrow new Error('Database adapter not available');\n\t}\n\n\ttype SnapshotRecord = Record<string, unknown>;\n\ttype Snapshot = { settings?: SnapshotRecord } | SnapshotRecord;\n\tconst snap = snapshot as Snapshot;\n\tconst settings: SnapshotRecord = (snap as { settings?: SnapshotRecord }).settings ?? (snap as SnapshotRecord);\n\n\tconst ops: Array<{ key: string; value: unknown; scope: 'user' | 'system' }> = [];\n\n\tfunction isValueWrapper(v: unknown): v is { value: unknown } {\n\t\treturn typeof v === 'object' && v !== null && 'value' in (v as Record<string, unknown>);\n\t}\n\n\tfor (const [key, value] of Object.entries(settings)) {\n\t\tconst v = isValueWrapper(value) ? value.value : value;\n\t\tops.push({ key, value: v, scope: 'system' });\n\t}\n\n\tconst res = await dbAdapter.systemPreferences.setMany(ops);\n\tif (!res.success) {\n\t\tthrow new Error(res.error?.message || 'Failed to update settings');\n\t}\n\n\t// Invalidate cache so next access fetches fresh data\n\tinvalidateSettingsCache();\n\n\treturn { updated: ops.length };\n}\n"],"names":["logger"],"mappings":"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"}