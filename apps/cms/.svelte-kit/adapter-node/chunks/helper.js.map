{"version":3,"file":"helper.js","sources":["../../../../../../shared/services/src/token/helper.ts"],"sourcesContent":["/**\n * @file src/services/token/helper.ts\n * @description Helper functions for token processing, validation, and extraction\n *\n * Features:\n * - Token Validation\n * - Token Escaping\n * - Token Replacement\n */\nimport { replaceTokens } from './engine';\nimport type { TokenContext } from './types';\nimport type { User } from '@shared/database/auth/types';\nimport { logger } from '@shared/utils/logger';\nimport { validateTokenSyntax, extractTokenPaths, containsTokens } from './tokenUtils';\n\n// Re-export pure utils\nexport { validateTokenSyntax, extractTokenPaths, containsTokens };\n\n// Recursively processes tokens in an object or array\nexport async function processTokensInResponse(data: any, user: User | undefined, locale: string, context: Partial<TokenContext> = {}): Promise<any> {\n\tif (!data) return data;\n\n\t// Prevent infinite recursion\n\tconst maxDepth = context.maxDepth || 10;\n\tconst currentDepth = context.currentDepth || 0;\n\tif (currentDepth > maxDepth) return data;\n\n\t// Handle Arrays\n\tif (Array.isArray(data)) {\n\t\treturn Promise.all(data.map((item) => processTokensInResponse(item, user, locale, { ...context, currentDepth: currentDepth + 1 })));\n\t}\n\n\t// Handle Objects\n\tif (typeof data === 'object' && data !== null) {\n\t\t// Skip Date objects and other non-plain objects if needed\n\t\tif (data instanceof Date) return data;\n\n\t\tconst result: any = {};\n\t\tfor (const [key, value] of Object.entries(data)) {\n\t\t\tresult[key] = await processTokensInResponse(value, user, locale, { ...context, currentDepth: currentDepth + 1 });\n\t\t}\n\t\treturn result;\n\t}\n\n\t// Handle Strings (Tokens)\n\tif (typeof data === 'string' && data.includes('{{')) {\n\t\t// Skip if it looks like a token but is escaped\n\t\tif (data.includes('\\\\{{')) return data.replace(/\\\\\\{\\{/g, '{{').replace(/\\\\\\}\\}/g, '}}');\n\n\t\ttry {\n\t\t\t// Build full context\n\t\t\tconst fullContext: TokenContext = {\n\t\t\t\tuser,\n\t\t\t\tlocale,\n\t\t\t\tsystem: context.system || { now: new Date().toISOString() as any }\n\t\t\t};\n\n\t\t\treturn await replaceTokens(data, fullContext);\n\t\t} catch (error) {\n\t\t\tlogger.warn('Token resolution failed', { error, token: data });\n\t\t\treturn data; // Return original string on error\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// Previews token resolution (for UI)\nexport async function previewTokenResolution(text: string, user: User | undefined, context: Partial<TokenContext> = {}): Promise<string> {\n\tif (!containsTokens(text)) return text;\n\n\ttry {\n\t\treturn await replaceTokens(text, {\n\t\t\tuser,\n\t\t\t...context,\n\t\t\tsystem: { now: new Date().toISOString() as any }\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Preview resolution failed', error);\n\t\treturn 'Error resolving token';\n\t}\n}\n"],"names":[],"mappings":";;AAmBA,eAAsB,wBAAwB,MAAW,MAAwB,QAAgB,UAAiC,CAAA,GAAkB;AACnJ,MAAI,CAAC,KAAM,QAAO;AAGlB,QAAM,WAAW,QAAQ,YAAY;AACrC,QAAM,eAAe,QAAQ,gBAAgB;AAC7C,MAAI,eAAe,SAAU,QAAO;AAGpC,MAAI,MAAM,QAAQ,IAAI,GAAG;AACxB,WAAO,QAAQ,IAAI,KAAK,IAAI,CAAC,SAAS,wBAAwB,MAAM,MAAM,QAAQ,EAAE,GAAG,SAAS,cAAc,eAAe,EAAA,CAAG,CAAC,CAAC;AAAA,EACnI;AAGA,MAAI,OAAO,SAAS,YAAY,SAAS,MAAM;AAE9C,QAAI,gBAAgB,KAAM,QAAO;AAEjC,UAAM,SAAc,CAAA;AACpB,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AAChD,aAAO,GAAG,IAAI,MAAM,wBAAwB,OAAO,MAAM,QAAQ,EAAE,GAAG,SAAS,cAAc,eAAe,GAAG;AAAA,IAChH;AACA,WAAO;AAAA,EACR;AAGA,MAAI,OAAO,SAAS,YAAY,KAAK,SAAS,IAAI,GAAG;AAEpD,QAAI,KAAK,SAAS,MAAM,EAAG,QAAO,KAAK,QAAQ,WAAW,IAAI,EAAE,QAAQ,WAAW,IAAI;AAEvF,QAAI;AAEH,YAAM,cAA4B;AAAA,QACjC;AAAA,QACA;AAAA,QACA,QAAQ,QAAQ,UAAU,EAAE,MAAK,oBAAI,KAAA,GAAO,YAAA,EAAY;AAAA,MAAS;AAGlE,aAAO,MAAM,cAAc,MAAM,WAAW;AAAA,IAC7C,SAAS,OAAO;AACf,aAAO,KAAK,2BAA2B,EAAE,OAAO,OAAO,MAAM;AAC7D,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO;AACR;"}