{"version":3,"file":"hooks.server.js","sources":["../../../../src/hooks/tokenResolution.ts","../../../../src/hooks/handleStaticAssetCaching.ts","../../../../src/hooks/handleApiRequests.ts","../../../../src/hooks/handleCompression.ts","../../../../src/services/token/relationResolver.ts","../../../../src/services/token/relationEngine.ts","../../../../src/hooks.server.ts"],"sourcesContent":["/**\n * @file src/hooks/tokenResolution.ts\n * @description Middleware hook for RBAC-aware token resolution in API responses\n *\n * Features:\n * - Token Resolution\n * - Token Caching\n * - Token Modifiers\n * - Token Permissions\n * - Token Validation\n * - Token Escaping\n * - Token Replacement\n */\nimport type { Handle } from '@sveltejs/kit';\nimport { processTokensInResponse } from '@shared/services/token/helper';\nimport { logger } from '@shared/utils/logger';\n\nexport const handleTokenResolution: Handle = async ({ event, resolve }) => {\n\tconst response = await resolve(event);\n\n\t// Only process JSON API responses\n\tconst contentType = response.headers.get('content-type');\n\tconst isJson = contentType?.includes('application/json');\n\tconst isApi = event.url.pathname.startsWith('/api/');\n\n\tif (!isJson || !isApi) {\n\t\treturn response;\n\t}\n\n\t// Skip internal endpoints that shouldn't have token replacement\n\tif (\n\t\tevent.url.pathname.startsWith('/api/system') ||\n\t\tevent.url.pathname.startsWith('/api/dashboard') ||\n\t\tevent.url.pathname.startsWith('/api/auth') ||\n\t\tevent.url.pathname.startsWith('/api/graphql')\n\t) {\n\t\treturn response;\n\t}\n\n\ttry {\n\t\t// Clone response to read body (streaming-safe)\n\t\tconst clonedResponse = response.clone();\n\t\tconst body = await clonedResponse.json();\n\n\t\t// Process tokens with RBAC context\n\t\t// We use event.locals which are populated by handleAuthentication and handleAuthorization\n\t\tconst processed = await processTokensInResponse(body, event.locals.user || undefined, (event.locals as any).contentLanguage || 'en', {\n\t\t\ttenantId: (event.locals as any).tenantId,\n\t\t\troles: (event.locals as any).roles\n\t\t\t// Add collection context if available in locals (optional optimization)\n\t\t\t// collection: event.locals.collection\n\t\t});\n\n\t\t// Return new response with processed body\n\t\treturn new Response(JSON.stringify(processed), {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: response.headers\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Token resolution middleware failed', {\n\t\t\terror,\n\t\t\tpath: event.url.pathname\n\t\t});\n\t\t// Return original response on error to prevent breakage\n\t\treturn response;\n\t}\n};\n","/**\n * @file src/hooks/handleStaticAssetCaching.ts\n * @description Middleware that applies aggressive caching headers to static assets\n *\n * ### Purpose\n * Static assets (images, fonts, scripts, styles) are immutable and can be cached\n * indefinitely. This hook applies optimal caching headers to:\n * - Reduce server load and bandwidth\n * - Improve page load performance\n * - Leverage browser and CDN caching effectively\n *\n * ### Caching Strategy\n * - **max-age=31536000**: Cache for 1 year (maximum practical value)\n * - **public**: Allow CDNs and proxies to cache\n * - **immutable**: Tell browsers the asset will never change\n *\n * ### Assets Cached\n * - SvelteKit build artifacts (`/_app/`)\n * - User static files (`/static/`)\n * - Media files (`/files/`)\n * - JavaScript and CSS files (`.js`, `.css`)\n * - Images (`.svg`, `.png`, `.jpg`, `.jpeg`, `.gif`, `.webp`, `.avif`)\n * - Fonts (`.woff`, `.woff2`, `.ttf`, `.eot`)\n * - Source maps (`.map`)\n * - Icons and manifests (`favicon.ico`, `manifest.webmanifest`, `apple-touch-icon.png`)\n *\n * ### Why This Hook Runs Early\n * Static assets don't need authentication, rate limiting, or other middleware.\n * By handling them early, we avoid unnecessary processing overhead.\n *\n * @prerequisite handleSystemState confirmed system is operational\n */\n\nimport type { Handle } from '@sveltejs/kit';\n\n// --- ASSET DETECTION ---\n\n/**\n * Comprehensive regex pattern to match all types of static assets.\n * Optimized for performance with specific path prefixes and file extensions.\n */\nconst STATIC_ASSET_REGEX =\n\t/^\\/(?:_app\\/|static\\/|files\\/|favicon\\.ico|manifest\\.webmanifest|apple-touch-icon.*\\.png|robots\\.txt|sitemap\\.xml)|.*\\.(?:js|css|map|svg|png|jpe?g|gif|webp|avif|woff2?|ttf|eot)$/;\n\n/**\n * Alternative function-based approach for more readable asset detection.\n * Use this if you prefer explicit logic over regex.\n *\n * @param pathname - The URL pathname to check\n * @returns True if the path represents a static asset\n */\nfunction isStaticAsset(pathname: string): boolean {\n\t// Check path prefixes (most common, check first)\n\tif (pathname.startsWith('/_app/') || pathname.startsWith('/static/') || pathname.startsWith('/files/')) {\n\t\treturn true;\n\t}\n\n\t// Check specific files\n\tif (\n\t\tpathname === '/favicon.ico' ||\n\t\tpathname === '/manifest.webmanifest' ||\n\t\tpathname === '/robots.txt' ||\n\t\tpathname === '/sitemap.xml' ||\n\t\tpathname.startsWith('/apple-touch-icon')\n\t) {\n\t\treturn true;\n\t}\n\n\t// Check file extensions\n\tconst ext = pathname.split('.').pop()?.toLowerCase();\n\tif (ext) {\n\t\tconst staticExtensions = new Set([\n\t\t\t'js',\n\t\t\t'css',\n\t\t\t'map', // Scripts and styles\n\t\t\t'svg',\n\t\t\t'png',\n\t\t\t'jpg',\n\t\t\t'jpeg', // Images\n\t\t\t'gif',\n\t\t\t'webp',\n\t\t\t'avif', // Images (modern formats)\n\t\t\t'woff',\n\t\t\t'woff2',\n\t\t\t'ttf',\n\t\t\t'eot' // Fonts\n\t\t]);\n\t\treturn staticExtensions.has(ext);\n\t}\n\n\treturn false;\n}\n\n// --- MAIN HOOK ---\n\nexport const handleStaticAssetCaching: Handle = async ({ event, resolve }) => {\n\t// Check if this is a static asset request\n\t// Using regex for performance (faster than function calls)\n\tif (STATIC_ASSET_REGEX.test(event.url.pathname)) {\n\t\t// Resolve the request to get the response\n\t\tconst response = await resolve(event);\n\n\t\t// Apply aggressive caching headers\n\t\t// These headers tell browsers and CDNs to cache the asset for 1 year\n\t\tresponse.headers.set('Cache-Control', 'public, max-age=31536000, immutable');\n\n\t\treturn response;\n\t}\n\n\t// Not a static asset - continue to next middleware\n\treturn resolve(event);\n};\n\n// --- ALTERNATIVE EXPORTS ---\n\n/**\n * Export the function-based approach for use in other contexts.\n * Useful for API endpoints or route guards that need to check asset types.\n */\nexport { isStaticAsset };\n\n/**\n * Export the regex pattern for reuse in other hooks or utilities.\n */\nexport { STATIC_ASSET_REGEX };\n","/**\n * @file src/hooks/handleApiRequests.ts\n * @description Middleware for API request authorization and intelligent caching with streaming optimization\n *\n * ### Responsibilities\n * - Enforces role-based API access control using permission rules\n * - Implements tenant-aware response caching for GET requests\n * - Automatically invalidates caches on mutations (POST/PUT/DELETE/PATCH)\n * - Tracks performance metrics (cache hits, misses, errors)\n * - Handles cache bypass with query parameters\n * - Optimizes streaming performance by using response clones\n *\n * ### Caching Strategy\n * - **Cached**: Successful GET requests (per user, per tenant, per endpoint)\n * - **Not Cached**: GraphQL queries (complex caching handled separately)\n * - **Bypass**: Add `?refresh=true` or `?nocache=true` to skip cache\n * - **Invalidation**: Automatic on mutations, manual via `invalidateApiCache()`\n *\n * ### Performance Optimizations\n * - Uses response.clone() to avoid blocking streaming for large responses\n * - Background cache population doesn't delay response to client\n * - Minimal memory overhead for large payloads\n *\n * ### Prerequisites\n * - handleSystemState confirmed system is READY\n * - handleAuthentication validated session and set locals.user\n * - handleAuthorization loaded roles and permissions\n *\n * @prerequisite User authentication and authorization are complete\n */\n\nimport { error, type Handle } from '@sveltejs/kit';\nimport { getErrorMessage } from '@shared/utils/errorHandling';\nimport { hasApiPermission } from '@shared/database/auth/apiPermissions';\nimport { cacheService, API_CACHE_TTL_S } from '@shared/database/CacheService';\nimport { metricsService } from '@shared/services/MetricsService';\nimport { logger } from '@shared/utils/logger.server';\n\n// --- METRICS INTEGRATION ---\n// API metrics are now handled by the unified MetricsService for enterprise-grade monitoring\n\n/** Extracts the API endpoint from the URL pathname. */\nfunction getApiEndpoint(pathname: string): string | null {\n\tconst parts = pathname.split('/api/')[1]?.split('/');\n\treturn parts?.[0] || null;\n}\n\n/** Generates a cache key for API responses. */\nfunction generateCacheKey(pathname: string, search: string, userId: string): string {\n\treturn `api:${userId}:${pathname}${search}`;\n}\n\n/** Checks if cache should be bypassed based on query parameters. */\nfunction shouldBypassCache(searchParams: URLSearchParams): boolean {\n\treturn searchParams.get('refresh') === 'true' || searchParams.get('nocache') === 'true';\n}\n\n// --- MAIN HOOK ---\n\nexport const handleApiRequests: Handle = async ({ event, resolve }) => {\n\tconst { url, locals, request } = event;\n\n\t// Early exit for non-API routes\n\tif (!url.pathname.startsWith('/api/')) {\n\t\treturn resolve(event);\n\t}\n\n\t// Skip authentication check for setup API routes\n\t// These are handled by handleSetup middleware for access control\n\tif (url.pathname.startsWith('/api/setup')) {\n\t\treturn resolve(event);\n\t}\n\n\t// Allow public API endpoints without authentication\n\t// - /api/system/version: Version check for login page\n\t// - /api/user/login: Public login endpoint\n\tif (['/api/system/version', '/api/user/login'].includes(url.pathname)) {\n\t\treturn resolve(event);\n\t}\n\n\t// Require authentication for all other API routes\n\tif (!locals.user) {\n\t\tlogger.warn(`Unauthenticated API access attempt: ${url.pathname}`);\n\t\tthrow error(401, 'Authentication required');\n\t}\n\n\tmetricsService.incrementApiRequests();\n\n\ttry {\n\t\tconst apiEndpoint = getApiEndpoint(url.pathname);\n\n\t\tif (!apiEndpoint) {\n\t\t\tlogger.warn(`Invalid API path: ${url.pathname}`);\n\t\t\tthrow error(400, 'Invalid API path');\n\t\t}\n\n\t\t// --- 1. Authorization Check ---\n\t\tif (url.pathname === '/api/user/logout') {\n\t\t\tlogger.trace('Logout endpoint - bypassing permission checks');\n\t\t\treturn resolve(event);\n\t\t}\n\n\t\tif (!hasApiPermission(locals.user.role, apiEndpoint)) {\n\t\t\tlogger.warn(\n\t\t\t\t`User ${locals.user._id} (role: ${locals.user.role}, tenant: ${locals.tenantId || 'global'}) ` +\n\t\t\t\t\t`denied access to /api/${apiEndpoint} - insufficient permissions`\n\t\t\t);\n\t\t\tthrow error(403, `Forbidden: Your role (${locals.user.role}) does not have permission to access this API endpoint.`);\n\t\t}\n\n\t\tlogger.trace(`User ${locals.user._id} granted access to /api/${apiEndpoint}`, {\n\t\t\trole: locals.user.role,\n\t\t\ttenant: locals.tenantId || 'global'\n\t\t});\n\n\t\t// --- 2. Handle GET Requests with Caching ---\n\t\tif (request.method === 'GET') {\n\t\t\tconst bypassCache = shouldBypassCache(url.searchParams);\n\t\t\tconst cacheKey = generateCacheKey(url.pathname, url.search, locals.user._id);\n\n\t\t\tif (!bypassCache) {\n\t\t\t\ttry {\n\t\t\t\t\tconst cached = await cacheService.get<{\n\t\t\t\t\t\tdata: unknown;\n\t\t\t\t\t\theaders: Record<string, string>;\n\t\t\t\t\t}>(cacheKey, locals.tenantId);\n\n\t\t\t\t\tif (cached) {\n\t\t\t\t\t\tlogger.debug(`Cache hit for API GET ${url.pathname} (tenant: ${locals.tenantId || 'global'})`);\n\t\t\t\t\t\tmetricsService.recordApiCacheHit();\n\t\t\t\t\t\treturn new Response(JSON.stringify(cached.data), {\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t...cached.headers,\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t\t\t\t'X-Cache': 'HIT'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (cacheError) {\n\t\t\t\t\tlogger.warn(`Cache read error for ${cacheKey}: ${getErrorMessage(cacheError)}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug(`Cache bypass requested for ${url.pathname}`);\n\t\t\t} // Resolve the request (cache miss or bypassed)\n\t\t\tconst response = await resolve(event);\n\n\t\t\t// --- OPTIMIZED: GraphQL bypass, no new Response created ---\n\t\t\tif (apiEndpoint === 'graphql') {\n\t\t\t\tresponse.headers.set('X-Cache', 'BYPASS');\n\t\t\t\tmetricsService.recordApiCacheMiss();\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\t// --- STREAMING OPTIMIZATION: Cache successful responses without blocking ---\n\t\t\tif (response.ok) {\n\t\t\t\tmetricsService.recordApiCacheMiss();\n\n\t\t\t\t// Clone the response to read body without consuming the original stream\n\t\t\t\tconst responseClone = response.clone();\n\n\t\t\t\t// Set cache header immediately\n\t\t\t\tresponse.headers.set('X-Cache', 'MISS');\n\n\t\t\t\t// Cache in background - don't await to avoid blocking the response stream\n\t\t\t\t// This is especially important for large payloads (e.g., file downloads, large JSON)\n\t\t\t\t(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst responseBody = await responseClone.text();\n\t\t\t\t\t\tconst responseData = JSON.parse(responseBody);\n\n\t\t\t\t\t\tawait cacheService.set(\n\t\t\t\t\t\t\tcacheKey,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata: responseData,\n\t\t\t\t\t\t\t\theaders: Object.fromEntries(responseClone.headers)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAPI_CACHE_TTL_S,\n\t\t\t\t\t\t\tlocals.tenantId\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlogger.trace(`Background cache set complete for ${url.pathname}`);\n\t\t\t\t\t} catch (processingError) {\n\t\t\t\t\t\t// Only log JSON parse errors if response is expected to be JSON\n\t\t\t\t\t\tconst contentType = responseClone.headers.get('content-type');\n\t\t\t\t\t\tif (contentType?.includes('application/json')) {\n\t\t\t\t\t\t\tlogger.error(`Error caching API response for /api/${apiEndpoint}: ${getErrorMessage(processingError)}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.trace(`Skipped caching non-JSON response for /api/${apiEndpoint}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\t// Return original response immediately (streaming not blocked)\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\treturn response;\n\t\t}\n\n\t\t// --- 3. Handle Mutations (POST, PUT, DELETE, PATCH) ---\n\t\tconst response = await resolve(event);\n\n\t\t// Exclude specific endpoints from invalidation\n\t\tconst isWarmCache = url.pathname.endsWith('/warm-cache');\n\n\t\tif (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method) && response.ok && !isWarmCache) {\n\t\t\ttry {\n\t\t\t\tconst patternToInvalidate = `api:${locals.user._id}:/api/${apiEndpoint}`;\n\t\t\t\tawait cacheService.clearByPattern(`${patternToInvalidate}*`, locals.tenantId);\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t`Invalidated API cache for pattern ${patternToInvalidate}* (tenant: ${locals.tenantId || 'global'}) after ${request.method} request`\n\t\t\t\t);\n\t\t\t} catch (invalidationError) {\n\t\t\t\tlogger.error(`Failed to invalidate API cache after ${request.method}: ${getErrorMessage(invalidationError)}`);\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t} catch (err) {\n\t\tmetricsService.incrementApiErrors();\n\t\tthrow err;\n\t}\n};\n\n// --- UTILITY EXPORTS ---\n\n/** Manually invalidates API cache for a specific endpoint and user. */\nexport async function invalidateApiCache(apiEndpoint: string, userId: string, tenantId?: string): Promise<void> {\n\tconst baseKey = `api:${userId}:/api/${apiEndpoint}`;\n\tlogger.debug(`Manually invalidating API cache for pattern ${baseKey}* (tenant: ${tenantId || 'global'})`);\n\n\ttry {\n\t\tawait cacheService.clearByPattern(`${baseKey}*`, tenantId);\n\t\tawait cacheService.delete(baseKey, tenantId);\n\t} catch (err) {\n\t\tlogger.error(`Error during manual API cache invalidation for ${baseKey}: ${getErrorMessage(err)}`);\n\t}\n}\n\n/** Returns API metrics from the unified metrics service. */\nexport function getApiHealthMetrics() {\n\tconst report = metricsService.getReport();\n\treturn {\n\t\tcache: {\n\t\t\thits: report.api.cacheHits,\n\t\t\tmisses: report.api.cacheMisses,\n\t\t\thitRate: report.api.cacheHitRate\n\t\t},\n\t\trequests: {\n\t\t\ttotal: report.api.requests,\n\t\t\terrors: report.api.errors\n\t\t}\n\t};\n}\n\n/** API metrics are now managed by the unified MetricsService. */\nexport function resetApiHealthMetrics(): void {\n\tlogger.trace('API health metrics managed by unified MetricsService');\n}\n","import type { Handle } from '@sveltejs/kit';\nimport * as zlib from 'node:zlib';\nimport { promisify } from 'node:util';\n\nconst gzip = promisify(zlib.gzip);\nconst brotli = promisify(zlib.brotliCompress);\n\nconst MIN_COMPRESSION_SIZE = 1024; // 1KB\n\nconst COMPRESSIBLE_TYPES = [\n\t'text/html',\n\t'text/css',\n\t'text/plain',\n\t'text/xml',\n\t'application/json',\n\t'application/javascript',\n\t'application/xml',\n\t'image/svg+xml'\n];\n\nexport const handleCompression: Handle = async ({ event, resolve }) => {\n\tconst response = await resolve(event);\n\n\t// Skip if already compressed or body is empty/stream\n\tif (response.headers.has('Content-Encoding') || !response.body || response.status === 204 || response.status === 304) {\n\t\treturn response;\n\t}\n\n\t// Skip SvelteKit internal data endpoints - they handle their own compression\n\t// Also skip if Content-Length is already set by SvelteKit\n\tif (event.url.pathname.includes('/__data.json') || response.headers.has('content-length')) {\n\t\treturn response;\n\t}\n\n\tconst contentType = response.headers.get('Content-Type');\n\tif (!contentType || !COMPRESSIBLE_TYPES.some((t) => contentType.includes(t))) {\n\t\treturn response;\n\t}\n\n\t// We need to read the body to compress it.\n\t// Note: This buffers the response in memory.\n\tconst body = await response.arrayBuffer();\n\n\tif (body.byteLength < MIN_COMPRESSION_SIZE) {\n\t\treturn new Response(body, {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: response.headers\n\t\t});\n\t}\n\n\tconst acceptEncoding = event.request.headers.get('Accept-Encoding') || '';\n\tconst buffer = Buffer.from(body);\n\n\ttry {\n\t\tif (acceptEncoding.includes('br')) {\n\t\t\tconst compressed = await brotli(buffer);\n\t\t\tconst headers = Object.fromEntries(response.headers);\n\t\t\t// Remove original Content-Length to prevent duplicate header error\n\t\t\tdelete headers['Content-Length'];\n\t\t\tdelete headers['content-length'];\n\t\t\treturn new Response(compressed, {\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t'Content-Encoding': 'br',\n\t\t\t\t\t'Content-Length': compressed.byteLength.toString(),\n\t\t\t\t\tVary: 'Accept-Encoding'\n\t\t\t\t},\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText\n\t\t\t});\n\t\t} else if (acceptEncoding.includes('gzip')) {\n\t\t\tconst compressed = await gzip(buffer);\n\t\t\tconst headers = Object.fromEntries(response.headers);\n\t\t\t// Remove original Content-Length to prevent duplicate header error\n\t\t\tdelete headers['Content-Length'];\n\t\t\tdelete headers['content-length'];\n\t\t\treturn new Response(compressed, {\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t'Content-Encoding': 'gzip',\n\t\t\t\t\t'Content-Length': compressed.byteLength.toString(),\n\t\t\t\t\tVary: 'Accept-Encoding'\n\t\t\t\t},\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('Compression failed:', error);\n\t\t// Return new response with original body on failure\n\t\treturn new Response(body, {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: response.headers\n\t\t});\n\t}\n\n\treturn new Response(body, {\n\t\tstatus: response.status,\n\t\tstatusText: response.statusText,\n\t\theaders: response.headers\n\t});\n};\n","/**\n * @file src/services/token/relationResolver.ts\n * @description Client-safe relation token resolution and permission checking\n */\nimport type { TokenContext } from './types';\nimport type { FieldInstance } from '@cms-types/content';\nimport type { User } from '@shared/database/auth/types';\nimport { hasPermissionByAction } from '@shared/database/auth/permissions';\nimport { logger } from '@shared/utils/logger';\n\n// Checks if user has read access to a collection\nexport async function canAccessCollection(user: User | undefined, collectionId: string, _tenantId?: string, roles?: any[]): Promise<boolean> {\n\tif (!user) return false;\n\n\t// Admins have access to everything\n\tconst userRole = roles?.find((r) => r._id === user.role);\n\tif (userRole?.isAdmin) return true;\n\n\t// Check collection-specific read permission\n\treturn hasPermissionByAction(user, 'read', 'collection', collectionId, roles);\n}\n\n// Middleware-aware token resolution that respects user permissions\nexport async function resolveRelationToken(tokenPath: string, context: TokenContext, user: User | undefined, tenantId?: string): Promise<any> {\n\t// Parse relation path: entry.manufacturer.name\n\tconst parts = tokenPath.split('.');\n\tif (parts.length < 3 || parts[0] !== 'entry') {\n\t\treturn null;\n\t}\n\n\tconst [, relationField, ...nestedPath] = parts;\n\tconst relationData = context.entry?.[relationField];\n\n\tif (!relationData) return null;\n\n\t// Security check: Verify user has access to the related collection\n\t// This is enforced during token registration, but double-check at resolution time\n\tconst schema = context.collection;\n\tif (schema) {\n\t\tconst field = (schema.fields as FieldInstance[]).find((f) => (f.db_fieldName || f.label) === relationField);\n\n\t\tif (field?.widget?.Name === 'Relation') {\n\t\t\tconst relatedCollectionId = (field.widget as any).collection;\n\t\t\tconst hasAccess = await canAccessCollection(user, relatedCollectionId, tenantId, context.roles);\n\n\t\t\tif (!hasAccess) {\n\t\t\t\tlogger.warn(`Unauthorized relation access attempt: user=${user?._id}, field=${relationField}`);\n\t\t\t\treturn '[Access Denied]';\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigate nested path\n\tlet value = relationData;\n\tfor (const key of nestedPath) {\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue = value[0]; // For arrays, take first item\n\t\t}\n\t\tvalue = value?.[key];\n\t\tif (value === undefined || value === null) break;\n\t}\n\n\treturn value;\n}\n","/**\n * @file src/services/token/relationEngine.ts\n * @description Extension for the token engine to support Relations widget with RBAC\n *\n * Features\n * - Relation Tokens\n * - Security Checks\n * - Token Generation\n */\nimport type { TokenContext, TokenDefinition } from './types';\nimport type { Schema, FieldInstance } from '@cms-types/content';\nimport type { User } from '@shared/database/auth/types';\nimport { contentManager } from '@content/ContentManager';\nimport { logger } from '@shared/utils/logger';\nimport { canAccessCollection } from './relationResolver';\n\n// Generates token definitions for Relations fields with security checks\nexport async function getRelationTokens(schema: Schema, user: User | undefined, tenantId?: string, roles?: any[]): Promise<TokenDefinition[]> {\n\tconst tokens: TokenDefinition[] = [];\n\n\t// Find all Relation fields in the schema\n\tconst relationFields = (schema.fields as FieldInstance[]).filter((field) => field.widget?.Name === 'Relation');\n\n\tfor (const field of relationFields) {\n\t\tconst fieldName = field.db_fieldName || field.label;\n\t\tconst widget = field.widget as any;\n\t\tconst relatedCollection = widget?.collection;\n\n\t\tif (!fieldName || !relatedCollection) continue;\n\n\t\t// Security: Check if user can access the related collection\n\t\tconst hasAccess = await canAccessCollection(user, relatedCollection, tenantId, roles);\n\t\tif (!hasAccess) {\n\t\t\tlogger.debug(`User ${user?._id} denied access to relation ${fieldName} â†’ ${relatedCollection}`);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the related collection schema to discover its fields\n\t\ttry {\n\t\t\tconst relatedSchema = await contentManager.getCollectionById(relatedCollection, tenantId);\n\t\t\tif (!relatedSchema) continue;\n\n\t\t\t// Generate tokens for related collection fields\n\t\t\tconst displayField = widget?.display_field || 'title';\n\n\t\t\t// Primary display field token\n\t\t\ttokens.push({\n\t\t\t\ttoken: `entry.${fieldName}.${displayField}`,\n\t\t\t\tname: `${field.label || fieldName} â†’ ${displayField}`,\n\t\t\t\tcategory: 'entry',\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: `Related ${relatedSchema.label || relatedSchema.name}: ${displayField} field`,\n\t\t\t\texample: `{{entry.${fieldName}.${displayField}}}`,\n\t\t\t\trequiresPermission: `read:collection:${relatedCollection}`,\n\t\t\t\tresolve: async (ctx: TokenContext) => {\n\t\t\t\t\tconst relationData = ctx.entry?.[fieldName];\n\t\t\t\t\tif (!relationData) return '';\n\n\t\t\t\t\t// Handle both single and multiple relations\n\t\t\t\t\tif (Array.isArray(relationData)) {\n\t\t\t\t\t\t// Multiple relations: return first item's display field\n\t\t\t\t\t\treturn relationData[0]?.[displayField] || '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// Single relation\n\t\t\t\t\treturn relationData[displayField] || '';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Additional common fields from related collection\n\t\t\t// const commonFields = ['_id', 'createdAt', 'updatedAt', 'status'];\n\n\t\t\tfor (const relField of relatedSchema.fields as FieldInstance[]) {\n\t\t\t\tconst relFieldName = relField.db_fieldName || relField.label;\n\t\t\t\tif (!relFieldName || relFieldName === displayField) continue;\n\n\t\t\t\t// Skip sensitive fields\n\t\t\t\tif (relFieldName.toLowerCase().includes('password')) continue;\n\n\t\t\t\ttokens.push({\n\t\t\t\t\ttoken: `entry.${fieldName}.${relFieldName}`,\n\t\t\t\t\tname: `${field.label || fieldName} â†’ ${relField.label || relFieldName}`,\n\t\t\t\t\tcategory: 'entry',\n\t\t\t\t\ttype: getFieldType(relField),\n\t\t\t\t\tdescription: `Related ${relatedSchema.label || relatedSchema.name}: ${relField.helper || relFieldName}`,\n\t\t\t\t\texample: `{{entry.${fieldName}.${relFieldName}}}`,\n\t\t\t\t\trequiresPermission: `read:collection:${relatedCollection}`,\n\t\t\t\t\tresolve: async (ctx: TokenContext) => {\n\t\t\t\t\t\tconst relationData = ctx.entry?.[fieldName];\n\t\t\t\t\t\tif (!relationData) return '';\n\n\t\t\t\t\t\tif (Array.isArray(relationData)) {\n\t\t\t\t\t\t\treturn relationData[0]?.[relFieldName] || '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn relationData[relFieldName] || '';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Special token for multiple relations (array handling)\n\t\t\tif (widget?.multiple) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttoken: `entry.${fieldName}.count`,\n\t\t\t\t\tname: `${field.label || fieldName} â†’ Count`,\n\t\t\t\t\tcategory: 'entry',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdescription: `Number of related ${relatedSchema.label || relatedSchema.name} items`,\n\t\t\t\t\texample: `{{entry.${fieldName}.count}}`,\n\t\t\t\t\trequiresPermission: `read:collection:${relatedCollection}`,\n\t\t\t\t\tresolve: async (ctx: TokenContext) => {\n\t\t\t\t\t\tconst relationData = ctx.entry?.[fieldName];\n\t\t\t\t\t\tif (!relationData) return 0;\n\t\t\t\t\t\treturn Array.isArray(relationData) ? relationData.length : 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\ttokens.push({\n\t\t\t\t\ttoken: `entry.${fieldName}.all`,\n\t\t\t\t\tname: `${field.label || fieldName} â†’ All Items`,\n\t\t\t\t\tcategory: 'entry',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: `Comma-separated list of all related ${relatedSchema.label || relatedSchema.name}`,\n\t\t\t\t\texample: `{{entry.${fieldName}.all | truncate(100)}}`,\n\t\t\t\t\trequiresPermission: `read:collection:${relatedCollection}`,\n\t\t\t\t\tresolve: async (ctx: TokenContext) => {\n\t\t\t\t\t\tconst relationData = ctx.entry?.[fieldName];\n\t\t\t\t\t\tif (!relationData) return '';\n\n\t\t\t\t\t\tif (Array.isArray(relationData)) {\n\t\t\t\t\t\t\treturn relationData\n\t\t\t\t\t\t\t\t.map((item) => item[displayField] || item._id)\n\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t\t.join(', ');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn relationData[displayField] || '';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(`Failed to load relation schema for ${relatedCollection}:`, error);\n\t\t}\n\t}\n\n\treturn tokens;\n}\n\n// Helper to infer field type from widget\nfunction getFieldType(field: FieldInstance): 'string' | 'number' | 'date' | 'boolean' | 'any' {\n\tconst widgetName = field.widget?.Name;\n\n\tconst typeMap: Record<string, any> = {\n\t\tCheckbox: 'boolean',\n\t\tDate: 'date',\n\t\tNumber: 'number',\n\t\tCurrency: 'number',\n\t\tRating: 'number',\n\t\tInput: 'string',\n\t\tRichText: 'string',\n\t\tEmail: 'string'\n\t};\n\n\treturn typeMap[widgetName || ''] || 'string';\n}\n","/**\n * @file src/hooks.server.ts\n * @description Hook middleware pipeline with unified metrics and automated security response\n *\n * This file orchestrates a streamlined sequence of middleware to handle\n * all incoming server requests. The architecture emphasizes security, observability,\n * and performance with unified metrics collection and automated threat detection.\n *\n * Middleware Sequence:\n * 1. Static asset caching (performance optimization, skip all processing)\n * 2. System state validation (gatekeeper)\n * 3. Rate limiting (abuse prevention)\n * 4. Application firewall (threat detection)\n * 5. Setup completion enforcement (installation gate)\n * 6. Language preferences (i18n cookie synchronization)\n * 7. Theme management (SSR dark mode support)\n * 8. Authentication & session management (identity)\n * 9. Authorization & access control (security)\n * 10. API request handling (optional, commented out by default)\n * 11. Security headers with nonce-based CSP (defense in depth)\n *\n * Core Services:\n * - MetricsService: Unified performance & security monitoring\n * - SecurityResponseService: Automated threat detection & response\n *\n * Utility Exports:\n * - getHealthMetrics(): Returns comprehensive metrics report\n * - invalidateSessionCache(): Invalidates specific user session\n * - clearAllSessionCaches(): Clears all cached sessions\n */\n\nimport { building } from '$app/environment';\nimport { type Handle } from '@sveltejs/kit';\nimport { sequence } from '@sveltejs/kit/hooks';\nimport { logger } from '@shared/utils/logger';\nimport { metricsService } from '@shared/services/MetricsService';\n\n// --- Import enterprise middleware hooks ---\nimport { handleSystemState } from '@cms/hooks/handleSystemState';\nimport { handleAuthentication } from '@cms/hooks/handleAuthentication';\nimport { handleAuthorization } from '@cms/hooks/handleAuthorization';\nimport { handleLocale } from '@cms/hooks/handleLocale';\nimport { handleTheme } from '@cms/hooks/handleTheme';\nimport { addSecurityHeaders } from '@cms/hooks/addSecurityHeaders';\nimport { handleTokenResolution } from '@cms/hooks/tokenResolution';\nimport { handleStaticAssetCaching } from '@cms/hooks/handleStaticAssetCaching';\nimport { handleRateLimit } from '@cms/hooks/handleRateLimit';\nimport { handleFirewall } from '@cms/hooks/handleFirewall';\n// API middleware for role-based access control and caching\nimport { handleApiRequests } from '@cms/hooks/handleApiRequests';\nimport { handleCompression } from '@cms/hooks/handleCompression';\n\n// --- Import Token Services for Dependency Injection ---\nimport { TokenRegistry } from '@shared/services/token/engine';\nimport { getRelationTokens } from './services/token/relationEngine';\nimport { resolveRelationToken } from './services/token/relationResolver';\n\n// --- Server Startup Logic ---\nif (!building) {\n\t/**\n\t * The main initialization logic (settings, DB connection) is handled\n\t * in `src/databases/db.ts` to ensure it runs once on server start.\n\t *\n\t * The system will transition through these states:\n\t * IDLE -> INITIALIZING -> READY (or DEGRADED/FAILED)\n\t *\n\t * The handleSystemState hook will block requests appropriately\n\t * based on the current state.\n\t */\n\t// Static import ensures the module is loaded and initialization promise is created\n\timport('@shared/database/db').then(async () => {\n\t\tlogger.info('ðŸ“¦ [SveltyCMS] Database initialized. Performing application-side service injection...');\n\n\t\ttry {\n\t\t\t// 1. Initialize ContentManager and inject into ConfigService\n\t\t\tconst { ContentManager } = await import('@content/ContentManager');\n\t\t\tconst { configService } = await import('@shared/services');\n\t\t\tconst contentManager = ContentManager.getInstance();\n\t\t\tconfigService.setContentManager(contentManager as any);\n\n\t\t\t// 2. Register Widgets in WidgetRegistryService\n\t\t\tconst { widgetRegistryService } = await import('@shared/services/WidgetRegistryService');\n\t\t\tconst { coreModules, customModules } = await import('@widgets/scanner');\n\n\t\t\t// Register core widgets\n\t\t\tfor (const [path, module] of Object.entries(coreModules)) {\n\t\t\t\tconst processed = widgetRegistryService.processWidgetModule(path, module as any, 'core');\n\t\t\t\tif (processed) {\n\t\t\t\t\twidgetRegistryService.registerWidget(processed.name, processed.widgetFn);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register custom widgets\n\t\t\tfor (const [path, module] of Object.entries(customModules)) {\n\t\t\t\tconst processed = widgetRegistryService.processWidgetModule(path, module as any, 'custom');\n\t\t\t\tif (processed) {\n\t\t\t\t\twidgetRegistryService.registerWidget(processed.name, processed.widgetFn);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info('âœ… [SveltyCMS] Application services initialized and injected.');\n\t\t} catch (err) {\n\t\t\tlogger.error('âŒ [SveltyCMS] Failed to initialize application services in hooks:', err);\n\t\t}\n\t});\n\n\t// Inject server-side relation engine into TokenRegistry\n\tTokenRegistry.setRelationTokenGenerator(getRelationTokens);\n\tTokenRegistry.setRelationResolver(resolveRelationToken);\n\n\t// Start telemetry heartbeat in background (Singleton pattern to survive HMR)\n\timport('@shared/utils/setupCheck').then(({ isSetupComplete }) => {\n\t\tif (!isSetupComplete()) return;\n\n\t\t// Define global type for TypeScript\n\t\tconst globalWithTelemetry = globalThis as typeof globalThis & {\n\t\t\t__SVELTY_TELEMETRY_INTERVAL__?: NodeJS.Timeout;\n\t\t};\n\n\t\t// Prevent duplicate intervals during Hot Module Replacement (HMR)\n\t\tif (globalWithTelemetry.__SVELTY_TELEMETRY_INTERVAL__) {\n\t\t\tlogger.debug('Reusing existing telemetry interval (HMR detected)');\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.info('ðŸ“¡ Initializing Telemetry Service...');\n\n\t\t// Background Services (Telemetry) - Non-blocking\n\t\timport('@shared/services/TelemetryService').then(({ telemetryService }) => {\n\t\t\t// Run initial check after a short delay\n\t\t\tsetTimeout(() => {\n\t\t\t\ttelemetryService.checkUpdateStatus().catch((err) => {\n\t\t\t\t\tconsole.error('[Telemetry] Initial check failed:', err);\n\t\t\t\t});\n\t\t\t}, 10000);\n\n\t\t\t// Schedule periodic checks (12 hours) and store ID in global\n\t\t\tglobalWithTelemetry.__SVELTY_TELEMETRY_INTERVAL__ = setInterval(\n\t\t\t\t() => {\n\t\t\t\t\ttelemetryService.checkUpdateStatus().catch((err) => logger.error('Periodic telemetry check failed', err));\n\t\t\t\t},\n\t\t\t\t1000 * 60 * 60 * 12\n\t\t\t);\n\t\t});\n\t});\n\n\tlogger.info('âœ… DB module loaded. System will initialize on first request via handleSystemState.');\n}\n\n// --- Middleware Sequence ---\nconst middleware: Handle[] = [\n\t// 0. Compression (GZIP/Brotli) - Outer layer to compress final processed responses\n\thandleCompression,\n\n\t// 1. Static assets FIRST (skip all other processing for maximum performance)\n\thandleStaticAssetCaching,\n\n\t// 2. System state validation (enterprise gatekeeper with metrics)\n\thandleSystemState,\n\n\t// 3. Rate limiting (early protection against abuse)\n\thandleRateLimit,\n\n\t// 4. Application firewall (detect threats Nginx/CDN can't catch)\n\thandleFirewall,\n\n\t// 5. Language preferences (i18n cookie synchronization)\n\thandleLocale,\n\n\t// 6. Theme management (SSR dark mode support)\n\thandleTheme,\n\n\t// 7. Authentication & session management (identity with security monitoring)\n\thandleAuthentication,\n\n\t// 8. Authorization & access control (permissions with threat detection)\n\thandleAuthorization,\n\n\t// 9. API request handling (role-based access control & caching)\n\thandleApiRequests,\n\n\t// 10. Token resolution for API responses\n\t// CRITICAL: Must be AFTER handleAuthorization (needs locals.user, locals.roles)\n\t//           and BEFORE addSecurityHeaders (modifies response body)\n\thandleTokenResolution,\n\n\t// 11. Essential security headers (defense in depth)\n\taddSecurityHeaders\n];\n\n// --- Main Handle Export ---\nexport const handle: Handle = sequence(...middleware);\n\n// --- Utility Functions for External Use ---\nexport const getHealthMetrics = () => metricsService.getReport();\nexport {\n\tinvalidateSessionCache,\n\tclearAllSessionCaches,\n\tclearSessionRefreshAttempt,\n\tforceSessionRotation,\n\tgetSessionCacheStats\n} from '@cms/hooks/handleAuthentication';\n"],"names":["error","logger","response","f","contentManager"],"mappings":"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"}