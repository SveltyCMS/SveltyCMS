{"version":3,"file":"index7.js","sources":["../../../../../../node_modules/svelte-dnd-action/dist/index.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n// external events\nvar FINALIZE_EVENT_NAME = \"finalize\";\nvar CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nfunction dispatchFinalizeEvent(el, items, info) {\n  el.dispatchEvent(new CustomEvent(FINALIZE_EVENT_NAME, {\n    detail: {\n      items: items,\n      info: info\n    }\n  }));\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nfunction dispatchConsiderEvent(el, items, info) {\n  el.dispatchEvent(new CustomEvent(CONSIDER_EVENT_NAME, {\n    detail: {\n      items: items,\n      info: info\n    }\n  }));\n}\n\n// internal events\nvar DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nvar DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nvar DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nvar DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\nvar DRAGGED_LEFT_TYPES = {\n  LEFT_FOR_ANOTHER: \"leftForAnother\",\n  OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\nfunction dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n  containerEl.dispatchEvent(new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n    detail: {\n      indexObj: indexObj,\n      draggedEl: draggedEl\n    }\n  }));\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nfunction dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n  containerEl.dispatchEvent(new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n    detail: {\n      draggedEl: draggedEl,\n      type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER,\n      theOtherDz: theOtherDz\n    }\n  }));\n}\nfunction dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n  containerEl.dispatchEvent(new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n    detail: {\n      draggedEl: draggedEl,\n      type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY\n    }\n  }));\n}\nfunction dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n  containerEl.dispatchEvent(new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n    detail: {\n      indexObj: indexObj,\n      draggedEl: draggedEl\n    }\n  }));\n}\nfunction dispatchDraggedLeftDocument(draggedEl) {\n  window.dispatchEvent(new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n    detail: {\n      draggedEl: draggedEl\n    }\n  }));\n}\n\nvar TRIGGERS = {\n  DRAG_STARTED: \"dragStarted\",\n  DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n  DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n  DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n  DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n  DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n  DROPPED_INTO_ZONE: \"droppedIntoZone\",\n  DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n  DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n  DRAG_STOPPED: \"dragStopped\"\n};\nvar SOURCES = {\n  POINTER: \"pointer\",\n  KEYBOARD: \"keyboard\"\n};\nvar SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nvar SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-internal\";\nvar SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-hint\";\nvar SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nvar DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\nvar ITEM_ID_KEY = \"id\";\nvar activeDndZoneCount = 0;\nfunction incrementActiveDropZoneCount() {\n  activeDndZoneCount++;\n}\nfunction decrementActiveDropZoneCount() {\n  if (activeDndZoneCount === 0) {\n    throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n  }\n  activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nfunction overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n  if (activeDndZoneCount > 0) {\n    throw new Error(\"can only override the id key before initialising any dndzone\");\n  }\n  if (typeof newKeyName !== \"string\") {\n    throw new Error(\"item id key has to be a string\");\n  }\n  printDebug(function () {\n    return [\"overriding item id key name\", newKeyName];\n  });\n  ITEM_ID_KEY = newKeyName;\n}\nvar isOnServer = typeof window === \"undefined\";\nvar printDebug = function printDebug() {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {boolean} isDebug\n */\nfunction setDebugMode(isDebug) {\n  if (isDebug) {\n    printDebug = function printDebug(generateMessage) {\n      var logFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console.debug;\n      var message = generateMessage();\n      if (Array.isArray(message)) {\n        logFunction.apply(void 0, _toConsumableArray(message));\n      } else {\n        logFunction(message);\n      }\n    };\n  } else {\n    printDebug = function printDebug() {};\n  }\n}\n\n// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @param {boolean} [onlyVisible] - use the visible rect defaults to true\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nfunction getBoundingRectNoTransforms(el) {\n  var onlyVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var ta;\n  var rect = onlyVisible ? getVisibleRectRecursive(el) : el.getBoundingClientRect();\n  var style = getComputedStyle(el);\n  var tx = style.transform;\n  if (tx) {\n    var sx, sy, dx, dy;\n    if (tx.startsWith(\"matrix3d(\")) {\n      ta = tx.slice(9, -1).split(/, /);\n      sx = +ta[0];\n      sy = +ta[5];\n      dx = +ta[12];\n      dy = +ta[13];\n    } else if (tx.startsWith(\"matrix(\")) {\n      ta = tx.slice(7, -1).split(/, /);\n      sx = +ta[0];\n      sy = +ta[3];\n      dx = +ta[4];\n      dy = +ta[5];\n    } else {\n      return rect;\n    }\n    var to = style.transformOrigin;\n    var x = rect.x - dx - (1 - sx) * parseFloat(to);\n    var y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n    var w = sx ? rect.width / sx : el.offsetWidth;\n    var h = sy ? rect.height / sy : el.offsetHeight;\n    return {\n      x: x,\n      y: y,\n      width: w,\n      height: h,\n      top: y,\n      right: x + w,\n      bottom: y + h,\n      left: x\n    };\n  } else {\n    return rect;\n  }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nfunction getAbsoluteRectNoTransforms(el) {\n  var rect = getBoundingRectNoTransforms(el);\n  return {\n    top: rect.top + window.scrollY,\n    bottom: rect.bottom + window.scrollY,\n    left: rect.left + window.scrollX,\n    right: rect.right + window.scrollX\n  };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nfunction getAbsoluteRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: rect.top + window.scrollY,\n    bottom: rect.bottom + window.scrollY,\n    left: rect.left + window.scrollX,\n    right: rect.right + window.scrollX\n  };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nfunction findCenter(rect) {\n  return {\n    x: (rect.left + rect.right) / 2,\n    y: (rect.top + rect.bottom) / 2\n  };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nfunction isPointInsideRect(point, rect) {\n  return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nfunction findCenterOfElement(el) {\n  return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * Calculate distance from a point to the center of an element\n * @param {{x: number, y: number}} point\n * @param {HTMLElement|ChildNode} el\n * @return {number}\n */\nfunction calcDistanceFromPointToCenter(point, el) {\n  var centerOfEl = findCenterOfElement(el);\n  return calcDistance(point, centerOfEl);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off-screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nfunction isElementOffDocument(el) {\n  var rect = getAbsoluteRect(el);\n  return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\n/**\n * Computes the portion of an element that is actually visible inside its scrollable\n * ancestor containers. If the element is clipped by any scrollable ancestor (overflow: auto|scroll),\n * the returned rect is the clipped one. If it is not clipped by any scrollable ancestor but is\n * partially or fully outside the viewport, the function returns the element's full bounding rect\n * (i.e. it does NOT clip to the viewport).\n *\n * This is useful for distinguishing \"hidden because parent scrolls\" from\n * \"hidden because off-screen\".\n *\n * @param {HTMLElement} element - The DOM element to measure.\n * @returns {{top: number, bottom: number, left: number, right: number, width: number, height: number}}\n * An object describing the visible rectangle in viewport coordinates.\n */\nfunction getVisibleRectRecursive(element) {\n  // original rect of the element (can be off-screen)\n  var rect = element.getBoundingClientRect();\n\n  // this will be our \"clipped by scroll containers\" rect\n  var visibleRect = {\n    top: rect.top,\n    bottom: rect.bottom,\n    left: rect.left,\n    right: rect.right\n  };\n  var wasClippedByScrollY = false;\n  var wasClippedByScrollX = false;\n\n  // walk up and clip ONLY by scrollable ancestors\n  var parent = element.parentElement;\n  while (parent && parent !== document.body) {\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n    var overflowX = style.overflowX;\n    var isScrollableY = overflowY === \"scroll\" || overflowY === \"auto\";\n    var isScrollableX = overflowX === \"scroll\" || overflowX === \"auto\";\n    if (isScrollableY || isScrollableX) {\n      var parentRect = parent.getBoundingClientRect();\n      if (isScrollableY) {\n        // if we actually shrink, mark it\n        var newTop = Math.max(visibleRect.top, parentRect.top);\n        var newBottom = Math.min(visibleRect.bottom, parentRect.bottom);\n        if (newTop !== visibleRect.top || newBottom !== visibleRect.bottom) {\n          wasClippedByScrollY = true;\n        }\n        visibleRect.top = newTop;\n        visibleRect.bottom = newBottom;\n      }\n      if (isScrollableX) {\n        var newLeft = Math.max(visibleRect.left, parentRect.left);\n        var newRight = Math.min(visibleRect.right, parentRect.right);\n        if (newLeft !== visibleRect.left || newRight !== visibleRect.right) {\n          wasClippedByScrollX = true;\n        }\n        visibleRect.left = newLeft;\n        visibleRect.right = newRight;\n      }\n    }\n    parent = parent.parentElement;\n  }\n\n  // CASE 1: element was clipped by a scrollable container\n  // → return the clipped rect (this is your 500px content inside 250px scroller case)\n  if (wasClippedByScrollY || wasClippedByScrollX) {\n    return {\n      top: visibleRect.top,\n      bottom: visibleRect.bottom,\n      left: visibleRect.left,\n      right: visibleRect.right,\n      width: Math.max(0, visibleRect.right - visibleRect.left),\n      height: Math.max(0, visibleRect.bottom - visibleRect.top)\n    };\n  }\n\n  // CASE 2: not clipped by scroll containers\n  // → we want the element’s FULL rect, even if it’s off-screen\n  // i.e. do NOT clip to viewport\n  return {\n    top: rect.top,\n    bottom: rect.bottom,\n    left: rect.left,\n    right: rect.right,\n    width: Math.max(0, rect.right - rect.left),\n    height: Math.max(0, rect.bottom - rect.top)\n  };\n}\n\nvar dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nfunction resetIndexesCache() {\n  printDebug(function () {\n    return \"resetting indexes cache\";\n  });\n  dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n  var shadowElIndex = Array.from(dz.children).findIndex(function (child) {\n    return child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n  });\n  if (shadowElIndex >= 0) {\n    if (!dzToShadowIndexToRect.has(dz)) {\n      dzToShadowIndexToRect.set(dz, new Map());\n    }\n    dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n    return shadowElIndex;\n  }\n  return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {{x: number, y: number}} referencePoint - The reference point for detection (cursor position or element center)\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nfunction findWouldBeIndex(referencePoint, collectionBelowEl) {\n  var collectionRect = getAbsoluteRectNoTransforms(collectionBelowEl);\n  if (!isPointInsideRect(referencePoint, collectionRect)) {\n    return null;\n  }\n  var children = collectionBelowEl.children;\n  // the container is empty, floating element should be the first\n  if (children.length === 0) {\n    return {\n      index: 0,\n      isProximityBased: true\n    };\n  }\n  var shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n  // the search could be more efficient but keeping it simple for now\n  // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n  for (var i = 0; i < children.length; i++) {\n    var childRect = getAbsoluteRectNoTransforms(children[i]);\n    if (isPointInsideRect(referencePoint, childRect)) {\n      var cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n      if (cachedShadowRect) {\n        if (!isPointInsideRect(referencePoint, cachedShadowRect)) {\n          return {\n            index: shadowElIndex,\n            isProximityBased: false\n          };\n        }\n      }\n      return {\n        index: i,\n        isProximityBased: false\n      };\n    }\n  }\n  // this can happen if there is space around the children so the floating element has\n  //entered the container but not any of the children, in this case we will find the nearest child\n  var minDistanceSoFar = Number.MAX_VALUE;\n  var indexOfMin = undefined;\n  // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n  for (var _i = 0; _i < children.length; _i++) {\n    var distance = calcDistanceFromPointToCenter(referencePoint, children[_i]);\n    if (distance < minDistanceSoFar) {\n      minDistanceSoFar = distance;\n      indexOfMin = _i;\n    }\n  }\n\n  // -------- Phantom slot check --------\n  // Regardless of layout (simple vertical list, flex-wrap, grid, floats …) the\n  // visually closest drop target can be *after* the current last **real** child.\n  // In simple layouts the would be index from the existing children would always be the last index\n  // but in more complex layouts (flex-wrap, grid, floats …) it can be any index.\n  // The problem is we can't predict where an additional element would be rendered in the general case,\n  // We therefore create a temporary, invisible clone of that last element, let\n  // the browser position it, measure the distance, and remove it immediately\n  // (same task → no paint).  This leaves `children` back in its original state\n  // before we exit the function, so existing index-caching logic and shadow-\n  // element bookkeeping continue to work unchanged.\n  if (children.length > 0) {\n    var originalLen = children.length; // before we append the phantom\n    var template = children[originalLen - 1];\n    var phantom = template.cloneNode(false); // shallow clone is enough for size\n    phantom.style.visibility = \"hidden\";\n    phantom.style.pointerEvents = \"none\";\n    collectionBelowEl.appendChild(phantom);\n    var phantomDistance = calcDistanceFromPointToCenter(referencePoint, phantom);\n    if (phantomDistance < minDistanceSoFar) {\n      indexOfMin = originalLen; // index of phantom slot in original list\n    }\n\n    collectionBelowEl.removeChild(phantom);\n  }\n  return {\n    index: indexOfMin,\n    isProximityBased: true\n  };\n}\n\n/**\n * @param {Object} object\n * @return {string}\n */\nfunction toString(object) {\n  return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nfunction getDepth(node) {\n  if (!node) {\n    throw new Error(\"cannot get depth of a falsy node\");\n  }\n  return _getDepth(node, 0);\n}\nfunction _getDepth(node) {\n  var countSoFar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!node.parentElement) {\n    return countSoFar - 1;\n  }\n  return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nfunction areObjectsShallowEqual(objA, objB) {\n  if (Object.keys(objA).length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (var keyA in objA) {\n    if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nfunction areArraysShallowEqualSameOrder(arrA, arrB) {\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (var i = 0; i < arrA.length; i++) {\n    if (arrA[i] !== arrB[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar INTERVAL_MS = 200;\nvar TOLERANCE_PX = 10;\nvar next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n * @param {MultiScroller} multiScroller\n * @param {function(): {x: number, y: number}} getReferencePoint - Function that returns the reference point for detection (cursor or element center)\n */\nfunction observe(draggedEl, dropZones) {\n  var intervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INTERVAL_MS;\n  var multiScroller = arguments.length > 3 ? arguments[3] : undefined;\n  var getReferencePoint = arguments.length > 4 ? arguments[4] : undefined;\n  // initialization\n  var lastDropZoneFound;\n  var lastIndexFound;\n  var lastIsDraggedInADropZone = false;\n  var lastCentrePositionOfDragged;\n  // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n  var dropZonesFromDeepToShallow = Array.from(dropZones).sort(function (dz1, dz2) {\n    return getDepth(dz2) - getDepth(dz1);\n  });\n\n  /**\n   * The main function in this module. Tracks where everything is/ should be a take the actions\n   */\n  function andNow() {\n    var referencePoint = getReferencePoint();\n    var scrolled = multiScroller.multiScrollIfNeeded();\n    // we only want to make a new decision after the element was moved a bit to prevent flickering\n    if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - referencePoint.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - referencePoint.y) < TOLERANCE_PX) {\n      next = window.setTimeout(andNow, intervalMs);\n      return;\n    }\n    if (isElementOffDocument(draggedEl)) {\n      printDebug(function () {\n        return \"off document\";\n      });\n      dispatchDraggedLeftDocument(draggedEl);\n      return;\n    }\n    lastCentrePositionOfDragged = referencePoint;\n    // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n    var isDraggedInADropZone = false;\n    var _iterator = _createForOfIteratorHelper(dropZonesFromDeepToShallow),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dz = _step.value;\n        if (scrolled) resetIndexesCache();\n        var indexObj = findWouldBeIndex(referencePoint, dz);\n        if (indexObj === null) {\n          // it is not inside\n          continue;\n        }\n        var index = indexObj.index;\n        isDraggedInADropZone = true;\n        // the element is over a container\n        if (dz !== lastDropZoneFound) {\n          lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n          dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n          lastDropZoneFound = dz;\n        } else if (index !== lastIndexFound) {\n          dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n          lastIndexFound = index;\n        }\n        // we handle looping with the 'continue' statement above\n        break;\n      }\n      // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n      dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n      lastDropZoneFound = undefined;\n      lastIndexFound = undefined;\n      lastIsDraggedInADropZone = false;\n    } else {\n      lastIsDraggedInADropZone = true;\n    }\n    next = window.setTimeout(andNow, intervalMs);\n  }\n  andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nfunction unobserve() {\n  printDebug(function () {\n    return \"unobserving\";\n  });\n  clearTimeout(next);\n  resetIndexesCache();\n}\n\nvar SCROLL_ZONE_PX = 30;\n\n/**\n * Will make a scroller that can scroll any element given to it in any direction\n * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}\n */\nfunction makeScroller() {\n  var scrollingInfo;\n  function resetScrolling() {\n    scrollingInfo = {\n      directionObj: undefined,\n      stepPx: 0\n    };\n  }\n  resetScrolling();\n  // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n  function scrollContainer(containerEl) {\n    var _scrollingInfo = scrollingInfo,\n      directionObj = _scrollingInfo.directionObj,\n      stepPx = _scrollingInfo.stepPx;\n    if (directionObj) {\n      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n      window.requestAnimationFrame(function () {\n        return scrollContainer(containerEl);\n      });\n    }\n  }\n  function calcScrollStepPx(distancePx) {\n    return SCROLL_ZONE_PX - distancePx;\n  }\n\n  /**\n   * @param {Point} pointer - the pointer will be used to decide in which direction to scroll\n   * @param {HTMLElement} elementToScroll - the scroll container\n   * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n   * Can be called repeatedly with updated pointer and elementToScroll values without issues\n   * @return {boolean} - true if scrolling was needed\n   */\n  function scrollIfNeeded(pointer, elementToScroll) {\n    if (!elementToScroll) {\n      return false;\n    }\n    var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n    var isAlreadyScrolling = !!scrollingInfo.directionObj;\n    if (distances === null) {\n      if (isAlreadyScrolling) resetScrolling();\n      return false;\n    }\n    var scrollingVertically = false,\n      scrollingHorizontally = false;\n    // vertical\n    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n      if (distances.bottom < SCROLL_ZONE_PX) {\n        scrollingVertically = true;\n        scrollingInfo.directionObj = {\n          x: 0,\n          y: 1\n        };\n        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n      } else if (distances.top < SCROLL_ZONE_PX) {\n        scrollingVertically = true;\n        scrollingInfo.directionObj = {\n          x: 0,\n          y: -1\n        };\n        scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n      }\n      if (!isAlreadyScrolling && scrollingVertically) {\n        scrollContainer(elementToScroll);\n        return true;\n      }\n    }\n    // horizontal\n    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n      if (distances.right < SCROLL_ZONE_PX) {\n        scrollingHorizontally = true;\n        scrollingInfo.directionObj = {\n          x: 1,\n          y: 0\n        };\n        scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n      } else if (distances.left < SCROLL_ZONE_PX) {\n        scrollingHorizontally = true;\n        scrollingInfo.directionObj = {\n          x: -1,\n          y: 0\n        };\n        scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n      }\n      if (!isAlreadyScrolling && scrollingHorizontally) {\n        scrollContainer(elementToScroll);\n        return true;\n      }\n    }\n    resetScrolling();\n    return false;\n  }\n  return {\n    scrollIfNeeded: scrollIfNeeded,\n    resetScrolling: resetScrolling\n  };\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nfunction calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n  // Even if the scrolling element is small it acts as a scroller for the viewport\n  var rect = el === document.scrollingElement ? {\n    top: 0,\n    bottom: window.innerHeight,\n    left: 0,\n    right: window.innerWidth\n  } : el.getBoundingClientRect();\n  if (!isPointInsideRect(point, rect)) {\n    return null;\n  }\n  return {\n    top: point.y - rect.top,\n    bottom: rect.bottom - point.y,\n    left: point.x - rect.left,\n    right: rect.right - point.x\n  };\n}\n\n/**\n @typedef {Object} MultiScroller\n @property {function():boolean} multiScrollIfNeeded - call this on every \"tick\" to scroll containers if needed, returns true if anything was scrolled\n/**\n * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)\n * @param {HTMLElement[]} baseElementsForScrolling\n * @param {function():Point} getPointerPosition\n * @return {MultiScroller}\n */\nfunction createMultiScroller() {\n  var baseElementsForScrolling = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var getPointerPosition = arguments.length > 1 ? arguments[1] : undefined;\n  printDebug(function () {\n    return \"creating multi-scroller\";\n  });\n  var scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);\n  var scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort(function (dz1, dz2) {\n    return getDepth(dz2) - getDepth(dz1);\n  });\n  var _makeScroller = makeScroller(),\n    scrollIfNeeded = _makeScroller.scrollIfNeeded,\n    resetScrolling = _makeScroller.resetScrolling;\n\n  /**\n   * @return {boolean} - was any container scrolled\n   */\n  function tick() {\n    var mousePosition = getPointerPosition();\n    if (!mousePosition || !scrollingContainersDeepToShallow) {\n      return false;\n    }\n    var scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(function (el) {\n      return isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement;\n    });\n    for (var i = 0; i < scrollContainersUnderCursor.length; i++) {\n      var scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);\n      if (scrolled) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return {\n    multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : function () {\n      return false;\n    },\n    destroy: function destroy() {\n      return resetScrolling();\n    }\n  };\n}\n\n// internal utils\nfunction findScrollableParents(element) {\n  if (!element) {\n    return [];\n  }\n  var scrollableContainers = [];\n  var parent = element;\n  while (parent) {\n    var _window$getComputedSt = window.getComputedStyle(parent),\n      overflow = _window$getComputedSt.overflow;\n    if (overflow.split(\" \").some(function (o) {\n      return o.includes(\"auto\") || o.includes(\"scroll\");\n    })) {\n      scrollableContainers.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return scrollableContainers;\n}\nfunction findRelevantScrollContainers(dropZones) {\n  var scrollingContainers = new Set();\n  var _iterator = _createForOfIteratorHelper(dropZones),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var dz = _step.value;\n      findScrollableParents(dz).forEach(function (container) {\n        return scrollingContainers.add(container);\n      });\n    }\n    // The scrolling element might have overflow visible and still be scrollable\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight || document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight) {\n    scrollingContainers.add(document.scrollingElement);\n  }\n  return scrollingContainers;\n}\n\n/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n *\n * @param {HTMLElement} el\n * @returns\n */\nfunction svelteNodeClone(el) {\n  var cloned = el.cloneNode(true);\n  var values = [];\n  var elIsSelect = el.tagName === \"SELECT\";\n  var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll(\"select\"));\n  var _iterator = _createForOfIteratorHelper(selects),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _select = _step.value;\n      values.push(_select.value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (selects.length > 0) {\n    var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll(\"select\"));\n    for (var i = 0; i < clonedSelects.length; i++) {\n      var select = clonedSelects[i];\n      var value = values[i];\n      var optionEl = select.querySelector(\"option[value=\\\"\".concat(value, \"\\\"\"));\n      if (optionEl) {\n        optionEl.setAttribute(\"selected\", true);\n      }\n    }\n  }\n  var elIsCanvas = el.tagName === \"CANVAS\";\n  var canvases = elIsCanvas ? [el] : _toConsumableArray(el.querySelectorAll(\"canvas\"));\n  if (canvases.length > 0) {\n    var clonedCanvases = elIsCanvas ? [cloned] : _toConsumableArray(cloned.querySelectorAll(\"canvas\"));\n    for (var _i = 0; _i < clonedCanvases.length; _i++) {\n      var canvas = canvases[_i];\n      var clonedCanvas = clonedCanvases[_i];\n      clonedCanvas.width = canvas.width;\n      clonedCanvas.height = canvas.height;\n      if (canvas.width > 0 && canvas.height > 0) {\n        clonedCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n      }\n    }\n  }\n  return cloned;\n}\n\n/**\n * @type {{USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: string}}\n */\nvar FEATURE_FLAG_NAMES = Object.freeze({\n  // This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470\n  USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: \"USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT\"\n});\nvar featureFlagsMap = _defineProperty({}, FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT, false);\n\n/**\n * @param {FEATURE_FLAG_NAMES} flagName\n * @param {boolean} flagValue\n */\nfunction setFeatureFlag(flagName, flagValue) {\n  if (!FEATURE_FLAG_NAMES[flagName]) throw new Error(\"Can't set non existing feature flag \".concat(flagName, \"! Supported flags: \").concat(Object.keys(FEATURE_FLAG_NAMES)));\n  featureFlagsMap[flagName] = !!flagValue;\n}\n\n/**\n *\n * @param {FEATURE_FLAG_NAMES} flagName\n * @return {boolean}\n */\nfunction getFeatureFlag(flagName) {\n  if (!FEATURE_FLAG_NAMES[flagName]) throw new Error(\"Can't get non existing feature flag \".concat(flagName, \"! Supported flags: \").concat(Object.keys(FEATURE_FLAG_NAMES)));\n  return featureFlagsMap[flagName];\n}\n\nvar TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n  return \"\".concat(property, \" \").concat(TRANSITION_DURATION_SECONDS, \"s ease\");\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nfunction createDraggedElementFrom(originalElement, positionCenterOnXY) {\n  var rect = originalElement.getBoundingClientRect();\n  var draggedEl = svelteNodeClone(originalElement);\n  copyStylesFromTo(originalElement, draggedEl);\n  draggedEl.id = DRAGGED_ELEMENT_ID;\n  draggedEl.style.position = \"fixed\";\n  var elTopPx = rect.top;\n  var elLeftPx = rect.left;\n  draggedEl.style.top = \"\".concat(elTopPx, \"px\");\n  draggedEl.style.left = \"\".concat(elLeftPx, \"px\");\n  if (positionCenterOnXY) {\n    var center = findCenter(rect);\n    elTopPx -= center.y - positionCenterOnXY.y;\n    elLeftPx -= center.x - positionCenterOnXY.x;\n    window.setTimeout(function () {\n      draggedEl.style.top = \"\".concat(elTopPx, \"px\");\n      draggedEl.style.left = \"\".concat(elLeftPx, \"px\");\n    }, 0);\n  }\n  draggedEl.style.margin = \"0\";\n  // we can't have relative or automatic height and width or it will break the illusion\n  draggedEl.style.boxSizing = \"border-box\";\n  draggedEl.style.height = \"\".concat(rect.height, \"px\");\n  draggedEl.style.width = \"\".concat(rect.width, \"px\");\n  draggedEl.style.transition = \"\".concat(trs(\"top\"), \", \").concat(trs(\"left\"), \", \").concat(trs(\"background-color\"), \", \").concat(trs(\"opacity\"), \", \").concat(trs(\"color\"), \" \");\n  // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n  window.setTimeout(function () {\n    return draggedEl.style.transition += \", \".concat(trs(\"width\"), \", \").concat(trs(\"height\"));\n  }, 0);\n  draggedEl.style.zIndex = \"9999\";\n  draggedEl.style.cursor = \"grabbing\";\n  return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nfunction moveDraggedElementToWasDroppedState(draggedEl) {\n  draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nfunction morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n  copyStylesFromTo(copyFromEl, draggedEl);\n  var newRect = copyFromEl.getBoundingClientRect();\n  var draggedElRect = draggedEl.getBoundingClientRect();\n  var widthChange = newRect.width - draggedElRect.width;\n  var heightChange = newRect.height - draggedElRect.height;\n  if (widthChange || heightChange) {\n    var relativeDistanceOfMousePointerFromDraggedSides = {\n      left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n      top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n    };\n    if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {\n      draggedEl.style.height = \"\".concat(newRect.height, \"px\");\n      draggedEl.style.width = \"\".concat(newRect.width, \"px\");\n    }\n    draggedEl.style.left = \"\".concat(parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange, \"px\");\n    draggedEl.style.top = \"\".concat(parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange, \"px\");\n  }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n  var computedStyle = window.getComputedStyle(copyFromEl);\n  Array.from(computedStyle).filter(function (s) {\n    return s.startsWith(\"background\") || s.startsWith(\"padding\") || s.startsWith(\"font\") || s.startsWith(\"text\") || s.startsWith(\"align\") || s.startsWith(\"justify\") || s.startsWith(\"display\") || s.startsWith(\"flex\") || s.startsWith(\"border\") || s === \"opacity\" || s === \"color\" || s === \"list-style-type\" ||\n    // copying with and height to make up for rect update timing issues in some browsers\n    getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === \"width\" || s === \"height\");\n  }).forEach(function (s) {\n    return copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s));\n  });\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nfunction styleDraggable(draggableEl, dragDisabled) {\n  draggableEl.draggable = false;\n  draggableEl.ondragstart = function () {\n    return false;\n  };\n  if (!dragDisabled) {\n    draggableEl.style.userSelect = \"none\";\n    draggableEl.style.WebkitUserSelect = \"none\";\n    draggableEl.style.cursor = \"grab\";\n  } else {\n    draggableEl.style.userSelect = \"\";\n    draggableEl.style.WebkitUserSelect = \"\";\n    draggableEl.style.cursor = \"\";\n  }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nfunction hideElement(dragTarget) {\n  dragTarget.style.display = \"none\";\n  dragTarget.style.position = \"fixed\";\n  dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nfunction decorateShadowEl(shadowEl) {\n  shadowEl.style.visibility = \"hidden\";\n  shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nfunction unDecorateShadowElement(shadowEl) {\n  shadowEl.style.visibility = \"\";\n  shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nfunction styleActiveDropZones(dropZones) {\n  var getStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var getClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return [];\n  };\n  dropZones.forEach(function (dz) {\n    var styles = getStyles(dz);\n    Object.keys(styles).forEach(function (style) {\n      dz.style[style] = styles[style];\n    });\n    getClasses(dz).forEach(function (c) {\n      return dz.classList.add(c);\n    });\n  });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nfunction styleInactiveDropZones(dropZones) {\n  var getStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var getClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return [];\n  };\n  dropZones.forEach(function (dz) {\n    var styles = getStyles(dz);\n    Object.keys(styles).forEach(function (style) {\n      dz.style[style] = \"\";\n    });\n    getClasses(dz).forEach(function (c) {\n      return dz.classList.contains(c) && dz.classList.remove(c);\n    });\n  });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nfunction preventShrinking(el) {\n  var originalMinHeight = el.style.minHeight;\n  el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n  var originalMinWidth = el.style.minWidth;\n  el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n  return function undo() {\n    el.style.minHeight = originalMinHeight;\n    el.style.minWidth = originalMinWidth;\n  };\n}\n\nvar DEFAULT_DROP_ZONE_TYPE$1 = \"--any--\";\nvar MIN_OBSERVATION_INTERVAL_MS = 100;\nvar DISABLED_OBSERVATION_INTERVAL_MS = 20;\nvar MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nvar DEFAULT_TOUCH_DELAY_MS = 80;\nvar DEFAULT_DROP_TARGET_STYLE$1 = {\n  outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nvar ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = \"data-is-dnd-original-dragged-item\";\nvar originalDragTarget;\nvar draggedEl;\nvar draggedElData;\nvar draggedElType;\nvar originDropZone;\nvar originIndex;\nvar shadowElData;\nvar shadowElDropZone;\nvar dragStartMousePosition;\nvar currentMousePosition;\nvar isWorkingOnPreviousDrag = false;\nvar finalizingPreviousDrag = false;\nvar unlockOriginDzMinDimensions;\nvar isDraggedOutsideOfAnyDz = false;\nvar scheduledForRemovalAfterDrop = [];\nvar multiScroller;\nvar touchDragHoldTimer;\nvar touchHoldElapsed = false;\nvar useCursorForDetectionActive = false;\n\n// a map from type to a set of drop-zones\nvar typeToDropZones$1 = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nvar dzToConfig$1 = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nvar elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone$1(dropZoneEl, type) {\n  printDebug(function () {\n    return \"registering drop-zone if absent\";\n  });\n  if (!typeToDropZones$1.has(type)) {\n    typeToDropZones$1.set(type, new Set());\n  }\n  if (!typeToDropZones$1.get(type).has(dropZoneEl)) {\n    typeToDropZones$1.get(type).add(dropZoneEl);\n    incrementActiveDropZoneCount();\n  }\n}\nfunction unregisterDropZone$1(dropZoneEl, type) {\n  typeToDropZones$1.get(type)[\"delete\"](dropZoneEl);\n  decrementActiveDropZoneCount();\n  if (typeToDropZones$1.get(type).size === 0) {\n    typeToDropZones$1[\"delete\"](type);\n  }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n  printDebug(function () {\n    return \"watching dragged element\";\n  });\n  var dropZones = typeToDropZones$1.get(draggedElType);\n  var _iterator = _createForOfIteratorHelper(dropZones),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var dz = _step.value;\n      dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n      dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n      dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);\n\n  // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n  var setIntervalMs = Math.max.apply(Math, _toConsumableArray(Array.from(dropZones.keys()).map(function (dz) {\n    return dzToConfig$1.get(dz).dropAnimationDurationMs;\n  })));\n  var observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.\n  multiScroller = createMultiScroller(dropZones, function () {\n    return currentMousePosition;\n  });\n  // Returns reference point in document coordinates - either cursor position or element center\n  var getReferencePoint = useCursorForDetectionActive ? function () {\n    return {\n      x: currentMousePosition.x + window.scrollX,\n      y: currentMousePosition.y + window.scrollY\n    };\n  } : function () {\n    return findCenterOfElement(draggedEl);\n  };\n  observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller, getReferencePoint);\n}\nfunction unWatchDraggedElement() {\n  printDebug(function () {\n    return \"unwatching dragged element\";\n  });\n  var dropZones = typeToDropZones$1.get(draggedElType);\n  var _iterator2 = _createForOfIteratorHelper(dropZones),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var dz = _step2.value;\n      dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n      dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n      dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);\n  // ensuring multiScroller is not already destroyed before destroying\n  if (multiScroller) {\n    multiScroller.destroy();\n    multiScroller = undefined;\n  }\n  unobserve();\n}\nfunction findShadowElementIdx(items) {\n  return items.findIndex(function (item) {\n    return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME];\n  });\n}\nfunction createShadowElData(draggedElData) {\n  var _objectSpread2$1;\n  return _objectSpread2(_objectSpread2({}, draggedElData), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, SHADOW_ITEM_MARKER_PROPERTY_NAME, true), _defineProperty(_objectSpread2$1, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID), _objectSpread2$1));\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n  printDebug(function () {\n    return [\"dragged entered\", e.currentTarget, e.detail];\n  });\n  var _dzToConfig$get = dzToConfig$1.get(e.currentTarget),\n    items = _dzToConfig$get.items,\n    dropFromOthersDisabled = _dzToConfig$get.dropFromOthersDisabled;\n  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n    printDebug(function () {\n      return \"ignoring dragged entered because drop is currently disabled\";\n    });\n    return;\n  }\n  isDraggedOutsideOfAnyDz = false;\n  // this deals with another race condition. on some occasions (super rapid operations) the list hasn't updated yet\n  items = items.filter(function (item) {\n    return item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID;\n  });\n  printDebug(function () {\n    return \"dragged entered items \".concat(toString(items));\n  });\n  if (originDropZone !== e.currentTarget) {\n    var originZoneItems = dzToConfig$1.get(originDropZone).items;\n    var newOriginZoneItems = originZoneItems.filter(function (item) {\n      return !item[SHADOW_ITEM_MARKER_PROPERTY_NAME];\n    });\n    dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n      trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n      id: draggedElData[ITEM_ID_KEY],\n      source: SOURCES.POINTER\n    });\n  }\n  var shadowElIdx = e.detail.indexObj.index;\n  shadowElDropZone = e.currentTarget;\n  items.splice(shadowElIdx, 0, shadowElData);\n  dispatchConsiderEvent(e.currentTarget, items, {\n    trigger: TRIGGERS.DRAGGED_ENTERED,\n    id: draggedElData[ITEM_ID_KEY],\n    source: SOURCES.POINTER\n  });\n}\nfunction handleDraggedLeft(e) {\n  // dealing with a rare race condition on extremely rapid clicking and dropping\n  if (!isWorkingOnPreviousDrag) return;\n  printDebug(function () {\n    return [\"dragged left\", e.currentTarget, e.detail];\n  });\n  var _dzToConfig$get2 = dzToConfig$1.get(e.currentTarget),\n    originalItems = _dzToConfig$get2.items,\n    dropFromOthersDisabled = _dzToConfig$get2.dropFromOthersDisabled;\n  if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n    printDebug(function () {\n      return \"drop is currently disabled\";\n    });\n    return;\n  }\n  var items = _toConsumableArray(originalItems);\n  var shadowElIdx = findShadowElementIdx(items);\n  if (shadowElIdx !== -1) {\n    items.splice(shadowElIdx, 1);\n  }\n  var origShadowDz = shadowElDropZone;\n  shadowElDropZone = undefined;\n  var _e$detail = e.detail,\n    type = _e$detail.type,\n    theOtherDz = _e$detail.theOtherDz;\n  if (type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY || type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig$1.get(theOtherDz).dropFromOthersDisabled) {\n    printDebug(function () {\n      return \"dragged left all, putting shadow element back in the origin dz\";\n    });\n    isDraggedOutsideOfAnyDz = true;\n    shadowElDropZone = originDropZone;\n    // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)\n    var originZoneItems = origShadowDz === originDropZone ? items : _toConsumableArray(dzToConfig$1.get(originDropZone).items);\n    originZoneItems.splice(originIndex, 0, shadowElData);\n    dispatchConsiderEvent(originDropZone, originZoneItems, {\n      trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n      id: draggedElData[ITEM_ID_KEY],\n      source: SOURCES.POINTER\n    });\n  }\n  // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n  dispatchConsiderEvent(e.currentTarget, items, {\n    trigger: TRIGGERS.DRAGGED_LEFT,\n    id: draggedElData[ITEM_ID_KEY],\n    source: SOURCES.POINTER\n  });\n}\nfunction handleDraggedIsOverIndex(e) {\n  printDebug(function () {\n    return [\"dragged is over index\", e.currentTarget, e.detail];\n  });\n  var _dzToConfig$get3 = dzToConfig$1.get(e.currentTarget),\n    originalItems = _dzToConfig$get3.items,\n    dropFromOthersDisabled = _dzToConfig$get3.dropFromOthersDisabled;\n  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n    printDebug(function () {\n      return \"drop is currently disabled\";\n    });\n    return;\n  }\n  var items = _toConsumableArray(originalItems);\n  isDraggedOutsideOfAnyDz = false;\n  var index = e.detail.indexObj.index;\n  var shadowElIdx = findShadowElementIdx(items);\n  if (shadowElIdx !== -1) {\n    items.splice(shadowElIdx, 1);\n  }\n  items.splice(index, 0, shadowElData);\n  dispatchConsiderEvent(e.currentTarget, items, {\n    trigger: TRIGGERS.DRAGGED_OVER_INDEX,\n    id: draggedElData[ITEM_ID_KEY],\n    source: SOURCES.POINTER\n  });\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n  e.preventDefault();\n  var c = e.touches ? e.touches[0] : e;\n  currentMousePosition = {\n    x: c.clientX,\n    y: c.clientY\n  };\n  draggedEl.style.transform = \"translate3d(\".concat(currentMousePosition.x - dragStartMousePosition.x, \"px, \").concat(currentMousePosition.y - dragStartMousePosition.y, \"px, 0)\");\n}\nfunction handleDrop$1() {\n  printDebug(function () {\n    return \"dropped\";\n  });\n  finalizingPreviousDrag = true;\n  // cleanup\n  window.removeEventListener(\"mousemove\", handleMouseMove);\n  window.removeEventListener(\"touchmove\", handleMouseMove);\n  window.removeEventListener(\"mouseup\", handleDrop$1);\n  window.removeEventListener(\"touchend\", handleDrop$1);\n  unWatchDraggedElement();\n  moveDraggedElementToWasDroppedState(draggedEl);\n  if (!shadowElDropZone) {\n    printDebug(function () {\n      return \"element was dropped right after it left origin but before entering somewhere else\";\n    });\n    shadowElDropZone = originDropZone;\n  }\n  printDebug(function () {\n    return [\"dropped in dz\", shadowElDropZone];\n  });\n  var _dzToConfig$get4 = dzToConfig$1.get(shadowElDropZone),\n    items = _dzToConfig$get4.items,\n    type = _dzToConfig$get4.type;\n  styleInactiveDropZones(typeToDropZones$1.get(type), function (dz) {\n    return dzToConfig$1.get(dz).dropTargetStyle;\n  }, function (dz) {\n    return dzToConfig$1.get(dz).dropTargetClasses;\n  });\n  var shadowElIdx = findShadowElementIdx(items);\n  // the handler might remove the shadow element, ex: dragula like copy on drag\n  if (shadowElIdx === -1) {\n    if (shadowElDropZone === originDropZone) {\n      shadowElIdx = originIndex;\n    }\n  }\n  items = items.map(function (item) {\n    return item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item;\n  });\n  function finalizeWithinZone() {\n    unlockOriginDzMinDimensions();\n    dispatchFinalizeEvent(shadowElDropZone, items, {\n      trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n      id: draggedElData[ITEM_ID_KEY],\n      source: SOURCES.POINTER\n    });\n    if (shadowElDropZone !== originDropZone) {\n      // letting the origin drop zone know the element was permanently taken away\n      dispatchFinalizeEvent(originDropZone, dzToConfig$1.get(originDropZone).items, {\n        trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n      });\n    }\n    // In edge cases the dom might have not been updated yet so we can't rely on data list index\n    var domShadowEl = Array.from(shadowElDropZone.children).find(function (c) {\n      return c.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n    });\n    if (domShadowEl) unDecorateShadowElement(domShadowEl);\n    cleanupPostDrop();\n  }\n  if (dzToConfig$1.get(shadowElDropZone).dropAnimationDisabled) {\n    finalizeWithinZone();\n  } else {\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n  }\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n  var shadowElRect = shadowElIdx > -1 ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx], false) : getBoundingRectNoTransforms(shadowElDropZone, false);\n  var newTransform = {\n    x: shadowElRect.left - parseFloat(draggedEl.style.left),\n    y: shadowElRect.top - parseFloat(draggedEl.style.top)\n  };\n  var _dzToConfig$get5 = dzToConfig$1.get(shadowElDropZone),\n    dropAnimationDurationMs = _dzToConfig$get5.dropAnimationDurationMs;\n  var transition = \"transform \".concat(dropAnimationDurationMs, \"ms ease\");\n  draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n  draggedEl.style.transform = \"translate3d(\".concat(newTransform.x, \"px, \").concat(newTransform.y, \"px, 0)\");\n  window.setTimeout(callback, dropAnimationDurationMs);\n}\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n  scheduledForRemovalAfterDrop.push({\n    dz: dz,\n    destroy: destroy\n  });\n  window.requestAnimationFrame(function () {\n    hideElement(dz);\n    document.body.appendChild(dz);\n  });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n  // Remove the temporary elements that were kept in the DOM during the drag\n  if (draggedEl && draggedEl.remove) {\n    draggedEl.remove();\n  }\n  if (originalDragTarget && originalDragTarget.remove) {\n    originalDragTarget.remove();\n  }\n  draggedEl = undefined;\n  originalDragTarget = undefined;\n  draggedElData = undefined;\n  draggedElType = undefined;\n  originDropZone = undefined;\n  originIndex = undefined;\n  shadowElData = undefined;\n  shadowElDropZone = undefined;\n  dragStartMousePosition = undefined;\n  currentMousePosition = undefined;\n  isWorkingOnPreviousDrag = false;\n  finalizingPreviousDrag = false;\n  unlockOriginDzMinDimensions = undefined;\n  isDraggedOutsideOfAnyDz = false;\n  if (touchDragHoldTimer) {\n    clearTimeout(touchDragHoldTimer);\n  }\n  touchDragHoldTimer = undefined;\n  touchHoldElapsed = false;\n  useCursorForDetectionActive = false;\n  if (scheduledForRemovalAfterDrop.length) {\n    printDebug(function () {\n      return [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop];\n    });\n    scheduledForRemovalAfterDrop.forEach(function (_ref) {\n      var dz = _ref.dz,\n        destroy = _ref.destroy;\n      destroy();\n      dz.remove();\n    });\n    scheduledForRemovalAfterDrop = [];\n  }\n}\nfunction dndzone$2(node, options) {\n  var initialized = false;\n  var config = {\n    items: undefined,\n    type: undefined,\n    flipDurationMs: 0,\n    dragDisabled: false,\n    morphDisabled: false,\n    dropFromOthersDisabled: false,\n    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,\n    dropTargetClasses: [],\n    transformDraggedElement: function transformDraggedElement() {},\n    centreDraggedOnCursor: false,\n    useCursorForDetection: false,\n    dropAnimationDisabled: false,\n    delayTouchStartMs: 0\n  };\n  printDebug(function () {\n    return [\"dndzone good to go options: \".concat(toString(options), \", config: \").concat(toString(config)), {\n      node: node\n    }];\n  });\n  var elToIdx = new Map();\n  function addMaybeListeners() {\n    window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {\n      passive: false\n    });\n    window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {\n      passive: false,\n      capture: false\n    });\n    window.addEventListener(\"mouseup\", handleFalseAlarm, {\n      passive: false\n    });\n    window.addEventListener(\"touchend\", handleFalseAlarm, {\n      passive: false\n    });\n  }\n  function removeMaybeListeners() {\n    window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n    window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n    window.removeEventListener(\"mouseup\", handleFalseAlarm);\n    window.removeEventListener(\"touchend\", handleFalseAlarm);\n    if (touchDragHoldTimer) {\n      clearTimeout(touchDragHoldTimer);\n      touchDragHoldTimer = undefined;\n      touchHoldElapsed = false;\n    }\n  }\n  function handleFalseAlarm(e) {\n    removeMaybeListeners();\n    originalDragTarget = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n\n    // dragging initiated by touch events prevents onclick from initially firing\n    if (e.type === \"touchend\") {\n      var clickEvent = new Event(\"click\", {\n        bubbles: true,\n        cancelable: true\n      });\n      // doing it this way instead of calling .click() because that doesn't work for SVG elements\n      e.target.dispatchEvent(clickEvent);\n    }\n  }\n  function handleMouseMoveMaybeDragStart(e) {\n    var isTouch = !!e.touches;\n    var c = isTouch ? e.touches[0] : e;\n    // If touch drag delay is configured and not elapsed yet, allow scrolling until either\n    // the delay elapses (timer will call handleDragStart) or the user moves significantly,\n    // in which case we cancel the potential drag and let the interaction be a scroll.\n    if (isTouch && config.delayTouchStartMs > 0 && !touchHoldElapsed) {\n      currentMousePosition = {\n        x: c.clientX,\n        y: c.clientY\n      };\n      if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {\n        // User started scrolling, cancel drag attempt.\n        if (touchDragHoldTimer) {\n          clearTimeout(touchDragHoldTimer);\n          touchDragHoldTimer = undefined;\n        }\n        handleFalseAlarm(e);\n      }\n      return; // Do not preventDefault so scrolling works.\n    }\n\n    // legacy / post-delay path – block scrolling and maybe start drag\n    e.preventDefault();\n    currentMousePosition = {\n      x: c.clientX,\n      y: c.clientY\n    };\n    if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {\n      removeMaybeListeners();\n      handleDragStart();\n    }\n  }\n  function handleMouseDown(e) {\n    // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n    if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n      printDebug(function () {\n        return \"won't initiate drag on a nested input element\";\n      });\n      return;\n    }\n    // prevents responding to any button but left click which equals 0 (which is falsy)\n    if (e.button) {\n      printDebug(function () {\n        return \"ignoring none left click button: \".concat(e.button);\n      });\n      return;\n    }\n    if (isWorkingOnPreviousDrag) {\n      printDebug(function () {\n        return \"cannot start a new drag before finalizing previous one\";\n      });\n      return;\n    }\n    var isTouchStart = !!e.touches;\n    var useDelay = isTouchStart && config.delayTouchStartMs > 0;\n    if (!useDelay) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    var c = isTouchStart ? e.touches[0] : e;\n    dragStartMousePosition = {\n      x: c.clientX,\n      y: c.clientY\n    };\n    currentMousePosition = _objectSpread2({}, dragStartMousePosition);\n    originalDragTarget = e.currentTarget;\n    if (useDelay) {\n      touchHoldElapsed = false;\n      touchDragHoldTimer = window.setTimeout(function () {\n        // If the finger is still down and no false-alarm happened\n        if (!originalDragTarget) return;\n        touchHoldElapsed = true;\n        removeMaybeListeners();\n        handleDragStart();\n      }, config.delayTouchStartMs);\n    }\n    addMaybeListeners();\n  }\n  function handleDragStart() {\n    printDebug(function () {\n      return [\"drag start config: \".concat(toString(config)), originalDragTarget];\n    });\n    isWorkingOnPreviousDrag = true;\n\n    // initialising globals\n    var currentIdx = elToIdx.get(originalDragTarget);\n    originIndex = currentIdx;\n    originDropZone = originalDragTarget.parentElement;\n    /** @type {ShadowRoot | HTMLDocument | Element } */\n    var rootNode = originDropZone.closest(\"dialog\") || originDropZone.closest(\"[popover]\") || originDropZone.getRootNode();\n    var originDropZoneRoot = rootNode.body || rootNode;\n    var originalItems = config.items,\n      type = config.type,\n      centreDraggedOnCursor = config.centreDraggedOnCursor,\n      useCursorForDetection = config.useCursorForDetection;\n    var items = _toConsumableArray(originalItems);\n    draggedElData = items[currentIdx];\n    draggedElType = type;\n    shadowElData = createShadowElData(draggedElData);\n    useCursorForDetectionActive = useCursorForDetection;\n\n    // creating the draggable element\n    draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n    originDropZoneRoot.appendChild(draggedEl);\n    // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n    function keepOriginalElementInDom() {\n      if (!originalDragTarget.parentElement) {\n        originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);\n        originDropZoneRoot.appendChild(originalDragTarget);\n        // have to watch before we hide, otherwise Svelte 5 $state gets confused\n        watchDraggedElement();\n        hideElement(originalDragTarget);\n        // after the removal of the original element we can give the shadow element the original item id so that the host zone can find it and render it correctly if it does lookups by id\n        shadowElData[ITEM_ID_KEY] = draggedElData[ITEM_ID_KEY];\n        // to prevent the outline from disappearing\n        draggedEl.focus();\n      } else {\n        window.requestAnimationFrame(keepOriginalElementInDom);\n      }\n    }\n    window.requestAnimationFrame(keepOriginalElementInDom);\n    styleActiveDropZones(Array.from(typeToDropZones$1.get(config.type)).filter(function (dz) {\n      return dz === originDropZone || !dzToConfig$1.get(dz).dropFromOthersDisabled;\n    }), function (dz) {\n      return dzToConfig$1.get(dz).dropTargetStyle;\n    }, function (dz) {\n      return dzToConfig$1.get(dz).dropTargetClasses;\n    });\n\n    // removing the original element by removing its data entry\n    items.splice(currentIdx, 1, shadowElData);\n    unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n    dispatchConsiderEvent(originDropZone, items, {\n      trigger: TRIGGERS.DRAG_STARTED,\n      id: draggedElData[ITEM_ID_KEY],\n      source: SOURCES.POINTER\n    });\n\n    // handing over to global handlers - starting to watch the element\n    window.addEventListener(\"mousemove\", handleMouseMove, {\n      passive: false\n    });\n    window.addEventListener(\"touchmove\", handleMouseMove, {\n      passive: false,\n      capture: false\n    });\n    window.addEventListener(\"mouseup\", handleDrop$1, {\n      passive: false\n    });\n    window.addEventListener(\"touchend\", handleDrop$1, {\n      passive: false\n    });\n  }\n  function configure(_ref2) {\n    var _ref2$items = _ref2.items,\n      items = _ref2$items === void 0 ? undefined : _ref2$items,\n      _ref2$flipDurationMs = _ref2.flipDurationMs,\n      dropAnimationDurationMs = _ref2$flipDurationMs === void 0 ? 0 : _ref2$flipDurationMs,\n      _ref2$type = _ref2.type,\n      newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE$1 : _ref2$type,\n      _ref2$dragDisabled = _ref2.dragDisabled,\n      dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,\n      _ref2$morphDisabled = _ref2.morphDisabled,\n      morphDisabled = _ref2$morphDisabled === void 0 ? false : _ref2$morphDisabled,\n      _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled,\n      dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD,\n      _ref2$dropTargetStyle = _ref2.dropTargetStyle,\n      dropTargetStyle = _ref2$dropTargetStyle === void 0 ? DEFAULT_DROP_TARGET_STYLE$1 : _ref2$dropTargetStyle,\n      _ref2$dropTargetClass = _ref2.dropTargetClasses,\n      dropTargetClasses = _ref2$dropTargetClass === void 0 ? [] : _ref2$dropTargetClass,\n      _ref2$transformDragge = _ref2.transformDraggedElement,\n      transformDraggedElement = _ref2$transformDragge === void 0 ? function () {} : _ref2$transformDragge,\n      _ref2$centreDraggedOn = _ref2.centreDraggedOnCursor,\n      centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn,\n      _ref2$useCursorForDet = _ref2.useCursorForDetection,\n      useCursorForDetection = _ref2$useCursorForDet === void 0 ? false : _ref2$useCursorForDet,\n      _ref2$dropAnimationDi = _ref2.dropAnimationDisabled,\n      dropAnimationDisabled = _ref2$dropAnimationDi === void 0 ? false : _ref2$dropAnimationDi,\n      _ref2$delayTouchStart = _ref2.delayTouchStart,\n      delayTouchStartOpt = _ref2$delayTouchStart === void 0 ? false : _ref2$delayTouchStart;\n    config.dropAnimationDurationMs = dropAnimationDurationMs;\n    var effectiveDelayMs = 0;\n    if (delayTouchStartOpt === true) {\n      effectiveDelayMs = DEFAULT_TOUCH_DELAY_MS;\n    } else if (typeof delayTouchStartOpt === \"number\" && isFinite(delayTouchStartOpt) && delayTouchStartOpt >= 0) {\n      effectiveDelayMs = delayTouchStartOpt;\n    }\n    config.delayTouchStartMs = effectiveDelayMs;\n    if (config.type && newType !== config.type) {\n      unregisterDropZone$1(node, config.type);\n    }\n    config.type = newType;\n    config.items = _toConsumableArray(items);\n    config.dragDisabled = dragDisabled;\n    config.morphDisabled = morphDisabled;\n    config.transformDraggedElement = transformDraggedElement;\n    config.centreDraggedOnCursor = centreDraggedOnCursor;\n    config.useCursorForDetection = useCursorForDetection;\n    config.dropAnimationDisabled = dropAnimationDisabled;\n\n    // realtime update for dropTargetStyle\n    if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {\n      styleInactiveDropZones([node], function () {\n        return config.dropTargetStyle;\n      }, function () {\n        return dropTargetClasses;\n      });\n      styleActiveDropZones([node], function () {\n        return dropTargetStyle;\n      }, function () {\n        return dropTargetClasses;\n      });\n    }\n    config.dropTargetStyle = dropTargetStyle;\n    config.dropTargetClasses = _toConsumableArray(dropTargetClasses);\n\n    // realtime update for dropFromOthersDisabled\n    function getConfigProp(dz, propName) {\n      return dzToConfig$1.get(dz) ? dzToConfig$1.get(dz)[propName] : config[propName];\n    }\n    if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n      if (dropFromOthersDisabled) {\n        styleInactiveDropZones([node], function (dz) {\n          return getConfigProp(dz, \"dropTargetStyle\");\n        }, function (dz) {\n          return getConfigProp(dz, \"dropTargetClasses\");\n        });\n      } else {\n        styleActiveDropZones([node], function (dz) {\n          return getConfigProp(dz, \"dropTargetStyle\");\n        }, function (dz) {\n          return getConfigProp(dz, \"dropTargetClasses\");\n        });\n      }\n    }\n    config.dropFromOthersDisabled = dropFromOthersDisabled;\n    dzToConfig$1.set(node, config);\n    registerDropZone$1(node, newType);\n    var shadowElIdx = isWorkingOnPreviousDrag ? findShadowElementIdx(config.items) : -1;\n    for (var idx = 0; idx < node.children.length; idx++) {\n      var draggableEl = node.children[idx];\n      styleDraggable(draggableEl, dragDisabled);\n      if (idx === shadowElIdx) {\n        if (!morphDisabled) {\n          morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n        }\n        config.transformDraggedElement(draggedEl, draggedElData, idx);\n        decorateShadowEl(draggableEl);\n        continue;\n      }\n      draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n      draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n      if (!dragDisabled) {\n        draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n        draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n        elToMouseDownListener.set(draggableEl, handleMouseDown);\n      }\n      // updating the idx\n      elToIdx.set(draggableEl, idx);\n      if (!initialized) {\n        initialized = true;\n      }\n    }\n  }\n  configure(options);\n  return {\n    update: function update(newOptions) {\n      printDebug(function () {\n        return \"pointer dndzone will update newOptions: \".concat(toString(newOptions));\n      });\n      configure(newOptions);\n    },\n    destroy: function destroy() {\n      function destroyDz() {\n        printDebug(function () {\n          return \"pointer dndzone will destroy\";\n        });\n        unregisterDropZone$1(node, dzToConfig$1.get(node).type);\n        dzToConfig$1[\"delete\"](node);\n      }\n      if (isWorkingOnPreviousDrag && !node.closest(\"[\".concat(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, \"]\"))) {\n        printDebug(function () {\n          return \"pointer dndzone will be scheduled for destruction\";\n        });\n        scheduleDZForRemovalAfterDrop(node, destroyDz);\n      } else {\n        destroyDz();\n      }\n    }\n  };\n}\n\nvar _ID_TO_INSTRUCTION;\nvar INSTRUCTION_IDs$1 = {\n  DND_ZONE_ACTIVE: \"dnd-zone-active\",\n  DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nvar ID_TO_INSTRUCTION = (_ID_TO_INSTRUCTION = {}, _defineProperty(_ID_TO_INSTRUCTION, INSTRUCTION_IDs$1.DND_ZONE_ACTIVE, \"Tab to one the items and press space-bar or enter to start dragging it\"), _defineProperty(_ID_TO_INSTRUCTION, INSTRUCTION_IDs$1.DND_ZONE_DRAG_DISABLED, \"This is a disabled drag and drop list\"), _ID_TO_INSTRUCTION);\nvar ALERT_DIV_ID = \"dnd-action-aria-alert\";\nvar alertsDiv;\nfunction initAriaOnBrowser() {\n  if (alertsDiv) {\n    // it is already initialized\n    return;\n  }\n  // setting the dynamic alerts\n  alertsDiv = document.createElement(\"div\");\n  (function initAlertsDiv() {\n    alertsDiv.id = ALERT_DIV_ID;\n    // tab index -1 makes the alert be read twice on chrome for some reason\n    //alertsDiv.tabIndex = -1;\n    alertsDiv.style.position = \"fixed\";\n    alertsDiv.style.bottom = \"0\";\n    alertsDiv.style.left = \"0\";\n    alertsDiv.style.zIndex = \"-5\";\n    alertsDiv.style.opacity = \"0\";\n    alertsDiv.style.height = \"0\";\n    alertsDiv.style.width = \"0\";\n    alertsDiv.setAttribute(\"role\", \"alert\");\n  })();\n  document.body.prepend(alertsDiv);\n\n  // setting the instructions\n  Object.entries(ID_TO_INSTRUCTION).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      id = _ref2[0],\n      txt = _ref2[1];\n    return document.body.prepend(instructionToHiddenDiv(id, txt));\n  });\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nfunction initAria() {\n  if (isOnServer) return null;\n  if (document.readyState === \"complete\") {\n    initAriaOnBrowser();\n  } else {\n    window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n  }\n  return _objectSpread2({}, INSTRUCTION_IDs$1);\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nfunction destroyAria() {\n  if (isOnServer || !alertsDiv) return;\n  Object.keys(ID_TO_INSTRUCTION).forEach(function (id) {\n    var _document$getElementB;\n    return (_document$getElementB = document.getElementById(id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();\n  });\n  alertsDiv.remove();\n  alertsDiv = undefined;\n}\nfunction instructionToHiddenDiv(id, txt) {\n  var div = document.createElement(\"div\");\n  div.id = id;\n  div.innerHTML = \"<p>\".concat(txt, \"</p>\");\n  div.style.display = \"none\";\n  div.style.position = \"fixed\";\n  div.style.zIndex = \"-5\";\n  return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nfunction alertToScreenReader(txt) {\n  if (isOnServer) return;\n  if (!alertsDiv) {\n    initAriaOnBrowser();\n  }\n  alertsDiv.innerHTML = \"\";\n  var alertText = document.createTextNode(txt);\n  alertsDiv.appendChild(alertText);\n  // this is needed for Safari\n  alertsDiv.style.display = \"none\";\n  alertsDiv.style.display = \"inline\";\n}\n\nvar DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nvar DEFAULT_DROP_TARGET_STYLE = {\n  outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nvar isDragging = false;\nvar draggedItemType;\nvar focusedDz;\nvar focusedDzLabel = \"\";\nvar focusedItem;\nvar focusedItemId;\nvar focusedItemLabel = \"\";\nvar allDragTargets = new WeakSet();\nvar elToKeyDownListeners = new WeakMap();\nvar elToFocusListeners = new WeakMap();\nvar dzToHandles = new Map();\nvar dzToConfig = new Map();\nvar typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nvar INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n  printDebug(function () {\n    return \"registering drop-zone if absent\";\n  });\n  if (typeToDropZones.size === 0) {\n    printDebug(function () {\n      return \"adding global keydown and click handlers\";\n    });\n    INSTRUCTION_IDs = initAria();\n    window.addEventListener(\"keydown\", globalKeyDownHandler);\n    window.addEventListener(\"click\", globalClickHandler);\n  }\n  if (!typeToDropZones.has(type)) {\n    typeToDropZones.set(type, new Set());\n  }\n  if (!typeToDropZones.get(type).has(dropZoneEl)) {\n    typeToDropZones.get(type).add(dropZoneEl);\n    incrementActiveDropZoneCount();\n  }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n  printDebug(function () {\n    return \"unregistering drop-zone\";\n  });\n  if (focusedDz === dropZoneEl) {\n    handleDrop();\n  }\n  typeToDropZones.get(type)[\"delete\"](dropZoneEl);\n  decrementActiveDropZoneCount();\n  if (typeToDropZones.get(type).size === 0) {\n    typeToDropZones[\"delete\"](type);\n  }\n  if (typeToDropZones.size === 0) {\n    printDebug(function () {\n      return \"removing global keydown and click handlers\";\n    });\n    window.removeEventListener(\"keydown\", globalKeyDownHandler);\n    window.removeEventListener(\"click\", globalClickHandler);\n    INSTRUCTION_IDs = undefined;\n    destroyAria();\n  }\n}\nfunction globalKeyDownHandler(e) {\n  if (!isDragging) return;\n  switch (e.key) {\n    case \"Escape\":\n      {\n        handleDrop();\n        break;\n      }\n  }\n}\nfunction globalClickHandler() {\n  if (!isDragging) return;\n  if (!allDragTargets.has(document.activeElement)) {\n    printDebug(function () {\n      return \"clicked outside of any draggable\";\n    });\n    handleDrop();\n  }\n}\nfunction handleZoneFocus(e) {\n  printDebug(function () {\n    return \"zone focus\";\n  });\n  if (!isDragging) return;\n  var newlyFocusedDz = e.currentTarget;\n  if (newlyFocusedDz === focusedDz) return;\n  focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n  var _dzToConfig$get = dzToConfig.get(focusedDz),\n    originItems = _dzToConfig$get.items;\n  var originItem = originItems.find(function (item) {\n    return item[ITEM_ID_KEY] === focusedItemId;\n  });\n  var originIdx = originItems.indexOf(originItem);\n  var itemToMove = originItems.splice(originIdx, 1)[0];\n  var _dzToConfig$get2 = dzToConfig.get(newlyFocusedDz),\n    targetItems = _dzToConfig$get2.items,\n    autoAriaDisabled = _dzToConfig$get2.autoAriaDisabled;\n  if (newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top || newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left) {\n    targetItems.push(itemToMove);\n    if (!autoAriaDisabled) {\n      alertToScreenReader(\"Moved item \".concat(focusedItemLabel, \" to the end of the list \").concat(focusedDzLabel));\n    }\n  } else {\n    targetItems.unshift(itemToMove);\n    if (!autoAriaDisabled) {\n      alertToScreenReader(\"Moved item \".concat(focusedItemLabel, \" to the beginning of the list \").concat(focusedDzLabel));\n    }\n  }\n  var dzFrom = focusedDz;\n  dispatchFinalizeEvent(dzFrom, originItems, {\n    trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n    id: focusedItemId,\n    source: SOURCES.KEYBOARD\n  });\n  dispatchFinalizeEvent(newlyFocusedDz, targetItems, {\n    trigger: TRIGGERS.DROPPED_INTO_ZONE,\n    id: focusedItemId,\n    source: SOURCES.KEYBOARD\n  });\n  focusedDz = newlyFocusedDz;\n}\nfunction triggerAllDzsUpdate() {\n  dzToHandles.forEach(function (_ref, dz) {\n    var update = _ref.update;\n    return update(dzToConfig.get(dz));\n  });\n}\nfunction handleDrop() {\n  var dispatchConsider = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  printDebug(function () {\n    return \"drop\";\n  });\n  if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n    alertToScreenReader(\"Stopped dragging item \".concat(focusedItemLabel));\n  }\n  if (allDragTargets.has(document.activeElement)) {\n    document.activeElement.blur();\n  }\n  if (dispatchConsider) {\n    dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n      trigger: TRIGGERS.DRAG_STOPPED,\n      id: focusedItemId,\n      source: SOURCES.KEYBOARD\n    });\n  }\n  styleInactiveDropZones(typeToDropZones.get(draggedItemType), function (dz) {\n    return dzToConfig.get(dz).dropTargetStyle;\n  }, function (dz) {\n    return dzToConfig.get(dz).dropTargetClasses;\n  });\n  focusedItem = null;\n  focusedItemId = null;\n  focusedItemLabel = \"\";\n  draggedItemType = null;\n  focusedDz = null;\n  focusedDzLabel = \"\";\n  isDragging = false;\n  triggerAllDzsUpdate();\n}\n//////\nfunction dndzone$1(node, options) {\n  var config = {\n    items: undefined,\n    type: undefined,\n    dragDisabled: false,\n    zoneTabIndex: 0,\n    zoneItemTabIndex: 0,\n    dropFromOthersDisabled: false,\n    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n    dropTargetClasses: [],\n    autoAriaDisabled: false\n  };\n  function swap(arr, i, j) {\n    if (arr.length <= 1) return;\n    arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n  }\n  function handleKeyDown(e) {\n    printDebug(function () {\n      return [\"handling key down\", e.key];\n    });\n    switch (e.key) {\n      case \"Enter\":\n      case \" \":\n        {\n          // we don't want to affect nested input elements or clickable elements\n          if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n            return;\n          }\n          e.preventDefault(); // preventing scrolling on spacebar\n          e.stopPropagation();\n          if (isDragging) {\n            // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n            handleDrop();\n          } else {\n            // drag start\n            handleDragStart(e);\n          }\n          break;\n        }\n      case \"ArrowDown\":\n      case \"ArrowRight\":\n        {\n          if (!isDragging) return;\n          e.preventDefault(); // prevent scrolling\n          e.stopPropagation();\n          var _dzToConfig$get3 = dzToConfig.get(node),\n            items = _dzToConfig$get3.items;\n          var children = Array.from(node.children);\n          var idx = children.indexOf(e.currentTarget);\n          printDebug(function () {\n            return [\"arrow down\", idx];\n          });\n          if (idx < children.length - 1) {\n            if (!config.autoAriaDisabled) {\n              alertToScreenReader(\"Moved item \".concat(focusedItemLabel, \" to position \").concat(idx + 2, \" in the list \").concat(focusedDzLabel));\n            }\n            swap(items, idx, idx + 1);\n            dispatchFinalizeEvent(node, items, {\n              trigger: TRIGGERS.DROPPED_INTO_ZONE,\n              id: focusedItemId,\n              source: SOURCES.KEYBOARD\n            });\n          }\n          break;\n        }\n      case \"ArrowUp\":\n      case \"ArrowLeft\":\n        {\n          if (!isDragging) return;\n          e.preventDefault(); // prevent scrolling\n          e.stopPropagation();\n          var _dzToConfig$get4 = dzToConfig.get(node),\n            _items = _dzToConfig$get4.items;\n          var _children = Array.from(node.children);\n          var _idx = _children.indexOf(e.currentTarget);\n          printDebug(function () {\n            return [\"arrow up\", _idx];\n          });\n          if (_idx > 0) {\n            if (!config.autoAriaDisabled) {\n              alertToScreenReader(\"Moved item \".concat(focusedItemLabel, \" to position \").concat(_idx, \" in the list \").concat(focusedDzLabel));\n            }\n            swap(_items, _idx, _idx - 1);\n            dispatchFinalizeEvent(node, _items, {\n              trigger: TRIGGERS.DROPPED_INTO_ZONE,\n              id: focusedItemId,\n              source: SOURCES.KEYBOARD\n            });\n          }\n          break;\n        }\n    }\n  }\n  function handleDragStart(e) {\n    printDebug(function () {\n      return \"drag start\";\n    });\n    setCurrentFocusedItem(e.currentTarget);\n    focusedDz = node;\n    draggedItemType = config.type;\n    isDragging = true;\n    var dropTargets = Array.from(typeToDropZones.get(config.type)).filter(function (dz) {\n      return dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled;\n    });\n    styleActiveDropZones(dropTargets, function (dz) {\n      return dzToConfig.get(dz).dropTargetStyle;\n    }, function (dz) {\n      return dzToConfig.get(dz).dropTargetClasses;\n    });\n    if (!config.autoAriaDisabled) {\n      var msg = \"Started dragging item \".concat(focusedItemLabel, \". Use the arrow keys to move it within its list \").concat(focusedDzLabel);\n      if (dropTargets.length > 1) {\n        msg += \", or tab to another list in order to move the item into it\";\n      }\n      alertToScreenReader(msg);\n    }\n    dispatchConsiderEvent(node, dzToConfig.get(node).items, {\n      trigger: TRIGGERS.DRAG_STARTED,\n      id: focusedItemId,\n      source: SOURCES.KEYBOARD\n    });\n    triggerAllDzsUpdate();\n  }\n  function handleClick(e) {\n    if (!isDragging) return;\n    if (e.currentTarget === focusedItem) return;\n    e.stopPropagation();\n    handleDrop(false);\n    handleDragStart(e);\n  }\n  function setCurrentFocusedItem(draggableEl) {\n    var _dzToConfig$get5 = dzToConfig.get(node),\n      items = _dzToConfig$get5.items;\n    var children = Array.from(node.children);\n    var focusedItemIdx = children.indexOf(draggableEl);\n    focusedItem = draggableEl;\n    focusedItem.tabIndex = config.zoneItemTabIndex;\n    focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n    focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n  }\n  function configure(_ref2) {\n    var _ref2$items = _ref2.items,\n      items = _ref2$items === void 0 ? [] : _ref2$items,\n      _ref2$type = _ref2.type,\n      newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE : _ref2$type,\n      _ref2$dragDisabled = _ref2.dragDisabled,\n      dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,\n      _ref2$zoneTabIndex = _ref2.zoneTabIndex,\n      zoneTabIndex = _ref2$zoneTabIndex === void 0 ? 0 : _ref2$zoneTabIndex,\n      _ref2$zoneItemTabInde = _ref2.zoneItemTabIndex,\n      zoneItemTabIndex = _ref2$zoneItemTabInde === void 0 ? 0 : _ref2$zoneItemTabInde,\n      _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled,\n      dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD,\n      _ref2$dropTargetStyle = _ref2.dropTargetStyle,\n      dropTargetStyle = _ref2$dropTargetStyle === void 0 ? DEFAULT_DROP_TARGET_STYLE : _ref2$dropTargetStyle,\n      _ref2$dropTargetClass = _ref2.dropTargetClasses,\n      dropTargetClasses = _ref2$dropTargetClass === void 0 ? [] : _ref2$dropTargetClass,\n      _ref2$autoAriaDisable = _ref2.autoAriaDisabled,\n      autoAriaDisabled = _ref2$autoAriaDisable === void 0 ? false : _ref2$autoAriaDisable;\n    config.items = _toConsumableArray(items);\n    config.dragDisabled = dragDisabled;\n    config.dropFromOthersDisabled = dropFromOthersDisabled;\n    config.zoneTabIndex = zoneTabIndex;\n    config.zoneItemTabIndex = zoneItemTabIndex;\n    config.dropTargetStyle = dropTargetStyle;\n    config.dropTargetClasses = dropTargetClasses;\n    config.autoAriaDisabled = autoAriaDisabled;\n    if (config.type && newType !== config.type) {\n      unregisterDropZone(node, config.type);\n    }\n    config.type = newType;\n    registerDropZone(node, newType);\n    if (!autoAriaDisabled) {\n      node.setAttribute(\"role\", \"list\");\n      node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n    }\n    dzToConfig.set(node, config);\n    if (isDragging) {\n      node.tabIndex = node === focusedDz || focusedItem.contains(node) || config.dropFromOthersDisabled || focusedDz && config.type !== dzToConfig.get(focusedDz).type ? -1 : 0;\n    } else {\n      node.tabIndex = config.zoneTabIndex;\n    }\n    node.addEventListener(\"focus\", handleZoneFocus);\n    var _loop = function _loop(i) {\n      var draggableEl = node.children[i];\n      allDragTargets.add(draggableEl);\n      draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;\n      if (!autoAriaDisabled) {\n        draggableEl.setAttribute(\"role\", \"listitem\");\n      }\n      draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n      draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n      if (!dragDisabled) {\n        draggableEl.addEventListener(\"keydown\", handleKeyDown);\n        elToKeyDownListeners.set(draggableEl, handleKeyDown);\n        draggableEl.addEventListener(\"click\", handleClick);\n        elToFocusListeners.set(draggableEl, handleClick);\n      }\n      if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n        printDebug(function () {\n          return [\"focusing on\", {\n            i: i,\n            focusedItemId: focusedItemId\n          }];\n        });\n        // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = config.zoneItemTabIndex;\n        // without this the element loses focus if it moves backwards in the list\n        draggableEl.focus();\n      }\n    };\n    for (var i = 0; i < node.children.length; i++) {\n      _loop(i);\n    }\n  }\n  configure(options);\n  var handles = {\n    update: function update(newOptions) {\n      printDebug(function () {\n        return \"keyboard dndzone will update newOptions: \".concat(toString(newOptions));\n      });\n      configure(newOptions);\n    },\n    destroy: function destroy() {\n      printDebug(function () {\n        return \"keyboard dndzone will destroy\";\n      });\n      unregisterDropZone(node, config.type);\n      dzToConfig[\"delete\"](node);\n      dzToHandles[\"delete\"](node);\n    }\n  };\n  dzToHandles.set(node, handles);\n  return handles;\n}\n\nvar _excluded = [\"items\", \"flipDurationMs\", \"type\", \"dragDisabled\", \"morphDisabled\", \"dropFromOthersDisabled\", \"zoneTabIndex\", \"zoneItemTabIndex\", \"dropTargetStyle\", \"dropTargetClasses\", \"transformDraggedElement\", \"autoAriaDisabled\", \"centreDraggedOnCursor\", \"useCursorForDetection\", \"delayTouchStart\", \"dropAnimationDisabled\"];\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {boolean|number} [delayTouchStart] - On touch devices, wait this long before converting the gesture to a drag.\n * `true` uses the built-in default (80 ms).\n * @property {boolean} [dropAnimationDisabled] - cancels the drop animation to place\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nfunction dndzone(node, options) {\n  if (shouldIgnoreZone(node)) {\n    return {\n      update: function update() {},\n      destroy: function destroy() {}\n    };\n  }\n  validateOptions(options);\n  var pointerZone = dndzone$2(node, options);\n  var keyboardZone = dndzone$1(node, options);\n  return {\n    update: function update(newOptions) {\n      validateOptions(newOptions);\n      pointerZone.update(newOptions);\n      keyboardZone.update(newOptions);\n    },\n    destroy: function destroy() {\n      pointerZone.destroy();\n      keyboardZone.destroy();\n    }\n  };\n}\n\n/**\n * If the user marked something in the ancestry of our node as shadow element, we can ignore it\n * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)\n * @param {HTMLElement} node\n * @return {boolean}\n */\nfunction shouldIgnoreZone(node) {\n  return !!node.closest(\"[\".concat(SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME, \"=\\\"true\\\"]\"));\n}\nfunction validateOptions(options) {\n  /*eslint-disable*/\n  var items = options.items;\n    options.flipDurationMs;\n    options.type;\n    options.dragDisabled;\n    options.morphDisabled;\n    options.dropFromOthersDisabled;\n    var zoneTabIndex = options.zoneTabIndex,\n    zoneItemTabIndex = options.zoneItemTabIndex;\n    options.dropTargetStyle;\n    var dropTargetClasses = options.dropTargetClasses;\n    options.transformDraggedElement;\n    options.autoAriaDisabled;\n    options.centreDraggedOnCursor;\n    options.useCursorForDetection;\n    var delayTouchStart = options.delayTouchStart;\n    options.dropAnimationDisabled;\n    var rest = _objectWithoutProperties(options, _excluded);\n  /*eslint-enable*/\n  if (Object.keys(rest).length > 0) {\n    console.warn(\"dndzone will ignore unknown options\", rest);\n  }\n  if (!items) {\n    throw new Error(\"no 'items' key provided to dndzone\");\n  }\n  var itemWithMissingId = items.find(function (item) {\n    return !{}.hasOwnProperty.call(item, ITEM_ID_KEY);\n  });\n  if (itemWithMissingId) {\n    throw new Error(\"missing '\".concat(ITEM_ID_KEY, \"' property for item \").concat(toString(itemWithMissingId)));\n  }\n  if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n    throw new Error(\"dropTargetClasses should be an array but instead it is a \".concat(_typeof(dropTargetClasses), \", \").concat(toString(dropTargetClasses)));\n  }\n  if (zoneTabIndex && !isInt(zoneTabIndex)) {\n    throw new Error(\"zoneTabIndex should be a number but instead it is a \".concat(_typeof(zoneTabIndex), \", \").concat(toString(zoneTabIndex)));\n  }\n  if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {\n    throw new Error(\"zoneItemTabIndex should be a number but instead it is a \".concat(_typeof(zoneItemTabIndex), \", \").concat(toString(zoneItemTabIndex)));\n  }\n  if (delayTouchStart !== undefined && delayTouchStart !== false) {\n    var validBoolean = delayTouchStart === true;\n    var validNumber = typeof delayTouchStart === \"number\" && isFinite(delayTouchStart) && delayTouchStart >= 0;\n    if (!validBoolean && !validNumber) {\n      throw new Error(\"delayTouchStart should be a boolean (true/false) or a non-negative number but instead it is a \".concat(_typeof(delayTouchStart), \", \").concat(toString(delayTouchStart)));\n    }\n  }\n}\nfunction isInt(value) {\n  return !isNaN(value) && function (x) {\n    return (x | 0) === x;\n  }(parseFloat(value));\n}\n\nfunction createStore(initialValue) {\n  var _val = initialValue;\n  var subs = new Set();\n  return {\n    get: function get() {\n      return _val;\n    },\n    set: function set(newVal) {\n      _val = newVal;\n      Array.from(subs).forEach(function (cb) {\n        return cb(_val);\n      });\n    },\n    subscribe: function subscribe(cb) {\n      subs.add(cb);\n      cb(_val);\n    },\n    unsubscribe: function unsubscribe(cb) {\n      subs[\"delete\"](cb);\n    }\n  };\n}\n\nvar isItemsDragDisabled = createStore(true);\nvar userDragDisabled = createStore(false);\nfunction getAddedOptions() {\n  return {\n    dragDisabled: userDragDisabled.get() || isItemsDragDisabled.get(),\n    zoneItemTabIndex: -1\n  };\n}\n\n/**\n * This is an action that wraps around the dndzone action to make it easy to work with drag handles\n * When using this you must also use the 'dragHandle' action (see below) on an element inside each item within the zone\n * Credit for the idea and initial implementation goes to @gleuch (Greg Leuch) and @geovie (Georg Vienna)\n *\n * @param {HTMLElement} node\n * @param options - will be passed down to the dndzone\n * @return {{update: (newOptions: Object) => {}, destroy: () => {}}}\n */\nfunction dragHandleZone(node, options) {\n  var _options$dragDisabled;\n  // Initialise stores from initial options\n  userDragDisabled.set((_options$dragDisabled = options === null || options === void 0 ? void 0 : options.dragDisabled) !== null && _options$dragDisabled !== void 0 ? _options$dragDisabled : false);\n  var currentOptions = options;\n  var zone = dndzone(node, _objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));\n  function updateZone() {\n    zone.update(_objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));\n  }\n\n  // Subscribe to internal store so finishing a drag updates the zone\n  isItemsDragDisabled.subscribe(updateZone);\n\n  // We don't need to subscribe to userDragDisabled here because updates to\n  // it always come through the `update` lifecycle and will call `updateZone`\n  // anyway.\n\n  function consider(e) {\n    var _e$detail$info = e.detail.info,\n      source = _e$detail$info.source,\n      trigger = _e$detail$info.trigger;\n    // Ensure dragging is stopped on drag finish via keyboard\n    if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {\n      isItemsDragDisabled.set(true);\n    }\n  }\n  function finalize(e) {\n    var source = e.detail.info.source;\n    // Ensure dragging is stopped on drag finish via pointer (mouse, touch)\n    if (source === SOURCES.POINTER) {\n      isItemsDragDisabled.set(true);\n    }\n  }\n  node.addEventListener(\"consider\", consider);\n  node.addEventListener(\"finalize\", finalize);\n  return {\n    update: function update(newOptions) {\n      var _currentOptions$dragD, _currentOptions;\n      currentOptions = newOptions;\n      // keep store in sync with external prop\n      userDragDisabled.set((_currentOptions$dragD = (_currentOptions = currentOptions) === null || _currentOptions === void 0 ? void 0 : _currentOptions.dragDisabled) !== null && _currentOptions$dragD !== void 0 ? _currentOptions$dragD : false);\n      updateZone();\n    },\n    destroy: function destroy() {\n      node.removeEventListener(\"consider\", consider);\n      node.removeEventListener(\"finalize\", finalize);\n      isItemsDragDisabled.unsubscribe(updateZone);\n    }\n  };\n}\n\n/**\n * This should be used to mark drag handles inside items that belong to a 'dragHandleZone' (see above)\n * @param {HTMLElement} handle\n * @return {{update: *, destroy: *}}\n */\nfunction dragHandle(handle) {\n  handle.setAttribute(\"role\", \"button\");\n  function startDrag(e) {\n    // preventing default to prevent lag on touch devices (because of the browser checking for screen scrolling)\n    e.preventDefault();\n    isItemsDragDisabled.set(false);\n\n    // Reset the startDrag/isItemsDragDisabled if the user releases the mouse/touch without initiating a drag\n    window.addEventListener(\"mouseup\", resetStartDrag);\n    window.addEventListener(\"touchend\", resetStartDrag);\n  }\n  function handleKeyDown(e) {\n    if (e.key === \"Enter\" || e.key === \" \") isItemsDragDisabled.set(false);\n  }\n  function resetStartDrag() {\n    isItemsDragDisabled.set(true);\n    window.removeEventListener(\"mouseup\", resetStartDrag);\n    window.removeEventListener(\"touchend\", resetStartDrag);\n  }\n  var recomputeHandleState = function recomputeHandleState() {\n    var userDisabled = userDragDisabled.get();\n    var internalDisabled = isItemsDragDisabled.get();\n    if (userDisabled) {\n      handle.tabIndex = -1;\n      handle.style.cursor = \"\"; // default cursor\n    } else {\n      handle.tabIndex = internalDisabled ? 0 : -1;\n      handle.style.cursor = internalDisabled ? \"grab\" : \"grabbing\";\n    }\n  };\n\n  // Subscribe to both stores\n  userDragDisabled.subscribe(recomputeHandleState);\n  isItemsDragDisabled.subscribe(recomputeHandleState);\n  handle.addEventListener(\"mousedown\", startDrag);\n  handle.addEventListener(\"touchstart\", startDrag);\n  handle.addEventListener(\"keydown\", handleKeyDown);\n  return {\n    update: function update() {},\n    destroy: function destroy() {\n      handle.removeEventListener(\"mousedown\", startDrag);\n      handle.removeEventListener(\"touchstart\", startDrag);\n      handle.removeEventListener(\"keydown\", handleKeyDown);\n      userDragDisabled.unsubscribe(recomputeHandleState);\n      isItemsDragDisabled.unsubscribe(recomputeHandleState);\n    }\n  };\n}\n\nexport { DRAGGED_ELEMENT_ID, FEATURE_FLAG_NAMES, SHADOW_ITEM_MARKER_PROPERTY_NAME, SHADOW_PLACEHOLDER_ITEM_ID, SOURCES, TRIGGERS, alertToScreenReader, dndzone, dragHandle, dragHandleZone, overrideItemIdKeyNameBeforeInitialisingDndZones, setDebugMode, setFeatureFlag };\n"],"names":[],"mappings":"AA8BA,SAAS,gBAAgB,KAAK,KAAK,OAAO;AACxC,MAAI,OAAO,KAAK;AACd,WAAO,eAAe,KAAK,KAAK;AAAA,MAC9B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IAChB,CAAK;AAAA,EACH,OAAO;AACL,QAAI,GAAG,IAAI;AAAA,EACb;AACA,SAAO;AACT;AAilCA,IAAI,qBAAqB,OAAO,OAAO;AAAA;AAAA,EAErC,6CAA6C;AAC/C,CAAC;AACqB,gBAAgB,CAAA,GAAI,mBAAmB,6CAA6C,KAAK;AAw9B/G,IAAI;AACJ,IAAI,oBAAoB;AAAA,EACtB,iBAAiB;AAAA,EACjB,wBAAwB;AAC1B;AACyB,qBAAqB,CAAA,GAAI,gBAAgB,oBAAoB,kBAAkB,iBAAiB,wEAAwE,GAAG,gBAAgB,oBAAoB,kBAAkB,wBAAwB,uCAAuC,GAAG;","x_google_ignoreList":[0]}