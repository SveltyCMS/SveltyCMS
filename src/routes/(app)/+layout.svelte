<!--
@file src/routes/(app)/+layout.svelte
@component
**This component renders the main application layout with a persistent state for UI components.**
## Props:
- `theme` {string} - The theme of the website

## Features:
-     Skeleton UI framework for SvelteKit
-     Dynamic theme management based on user preferences or defaults
-     SEO optimization with Open Graph and Twitter Card metadata for enhanced social sharing
-     Initialization of Skeleton stores for UI components
-     Granular loading strategy
-     Asynchronous loading of non-critical data
-->

<script lang="ts">
	// selected theme:
	import '../../app.postcss';

	// Icons from https://icon-sets.iconify.design/
	import 'iconify-icon';

	import { browser } from '$app/environment';
	import { afterNavigate, beforeNavigate } from '$app/navigation';
	import { page } from '$app/state';
	import { onDestroy, onMount } from 'svelte';
	import { fade } from 'svelte/transition';
	// Auth
	import type { User } from '@src/databases/auth/types';

	// Utils
	import { isSearchVisible } from '@utils/globalSearchIndex';
	import { getTextDirection } from '@utils/utils';
	// Stores
	import { contentStructure } from '@stores/collectionStore.svelte';
	import { publicEnv } from '@stores/globalSettings.svelte';
	import { globalLoadingStore, loadingOperations } from '@stores/loadingStore.svelte';
	import { isDesktop, screenSize } from '@stores/screenSizeStore.svelte';
	import { avatarSrc, systemLanguage } from '@stores/store.svelte';
	import { uiStateManager } from '@stores/UIStore.svelte';
	// Components
	import HeaderEdit from '@components/HeaderEdit.svelte';
	import LeftSidebar from '@components/LeftSidebar.svelte';
	import Loading from '@components/Loading.svelte';
	import PageFooter from '@components/PageFooter.svelte';
	import RightSidebar from '@components/RightSidebar.svelte';
	import SearchComponent from '@components/SearchComponent.svelte';
	import FloatingNav from '@components/system/FloatingNav.svelte';
    // Skeleton v4 (migrated)
    import { Toast, createToaster } from '@skeletonlabs/skeleton-svelte';
	import { setGlobalModalStore } from '@utils/modalUtils';
	import { setGlobalToastStore } from '@utils/toast';
    // Removed deprecated global popup store and Floating UI setup; Skeleton v4 components handle positioning

	interface Props {
		children?: import('svelte').Snippet;
		data: {
			user: User;
			contentStructure: any[]; // Changed from ContentNode[] to any[]
		};
	}

	let { children, data }: Props = $props();
    // Initialize Toast store for Skeleton v4
    const toaster = createToaster();
    setGlobalToastStore(toaster);

	// --- State Management ---
	globalLoadingStore.startLoading(loadingOperations.initialization); // Start initial loading immediately.
	let loadError = $state<Error | null>(null);
	let mediaQuery: MediaQueryList;

	// A single derived value now controls the loading indicator's visibility.
	let shouldShowLoading = $derived(globalLoadingStore.isLoading);

	// A derived value to compute the loading text cleanly.
	let loadingTopText = $derived(() => {
		// Use the reason from the global store to set the text.
		switch (globalLoadingStore.loadingReason) {
			case loadingOperations.initialization:
				return 'Initializing';
			case loadingOperations.navigation:
				return 'Navigating';
			case loadingOperations.dataFetch:
				return 'Loading data';
			case loadingOperations.authentication:
				return 'Authenticating';
			case loadingOperations.formSubmission:
				return 'Submitting';
			default:
				return 'Loading'; // Fallback text.
		}
	});

	// Stop initialization loader once server provided contentStructure (even if empty)
	$effect(() => {
		if (Array.isArray(data.contentStructure)) {
			globalLoadingStore.stopLoading(loadingOperations.initialization);
		}
	});

	// Keep contentStructure store in sync with server data across navigations
	$effect(() => {
		// Defer store updates to the next microtask to avoid UpdatedAtError during reactive batch updates
		const defer = (fn: () => void) => (typeof queueMicrotask === 'function' ? queueMicrotask(fn) : Promise.resolve().then(fn));
		if (Array.isArray(data.contentStructure)) {
			defer(() => contentStructure.set(data.contentStructure));
		}
	});

	// Handle system language changes
	$effect(() => {
		const lang = systemLanguage.value;
		if (!lang) return;

		const dir = getTextDirection(lang);
		if (!dir) return;

		document.documentElement.dir = dir;
		document.documentElement.lang = lang;
	});

	// Theme management
    function updateThemeBasedOnSystemPreference(event: MediaQueryListEvent) {
        const prefersDarkMode = event.matches;

        // Immediately apply the theme to the DOM
        document.documentElement.classList.toggle('dark', prefersDarkMode);

        // Set cookie for server-side persistence
        document.cookie = `theme=${prefersDarkMode ? 'dark' : 'light'}; path=/; max-age=${60 * 60 * 24 * 365}; SameSite=Lax${process.env.NODE_ENV === 'production' ? '; Secure' : ''}`;
        document.cookie = `darkMode=${prefersDarkMode}; path=/; max-age=${60 * 60 * 24 * 365}; SameSite=Lax${process.env.NODE_ENV === 'production' ? '; Secure' : ''}`;
    }

	// Keyboard shortcuts
	function onKeyDown(event: KeyboardEvent) {
		if (event.altKey && event.key === 's') {
			event.preventDefault();
			isSearchVisible.update((v) => !v);
		}
	}

	onMount(() => {
		// Theme initialization
		mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
		mediaQuery.addEventListener('change', updateThemeBasedOnSystemPreference);

		// Check for saved theme preference in cookies
		const getCookie = (name: string) => {
			const value = `; ${document.cookie}`;
			const parts = value.split(`; ${name}=`);
			if (parts.length === 2) return parts.pop()?.split(';').shift();
			return null;
		};

		const savedTheme = getCookie('theme');
		const savedDarkMode = getCookie('darkMode');

        if (savedTheme) {
            const newModeIsDark = savedTheme !== 'light';
            document.documentElement.classList.toggle('dark', newModeIsDark);
        } else if (savedDarkMode) {
            const newModeIsDark = savedDarkMode === 'true';
            document.documentElement.classList.toggle('dark', newModeIsDark);
        } else {
            // No saved preference found, use device preference
            const prefersDarkMode = mediaQuery.matches;
            document.documentElement.classList.toggle('dark', prefersDarkMode);

			// Save the device preference as the initial user preference
			document.cookie = `theme=${prefersDarkMode ? 'dark' : 'light'}; path=/; max-age=${60 * 60 * 24 * 365}; SameSite=Lax${process.env.NODE_ENV === 'production' ? '; Secure' : ''}`;
			document.cookie = `darkMode=${prefersDarkMode}; path=/; max-age=${60 * 60 * 24 * 365}; SameSite=Lax${process.env.NODE_ENV === 'production' ? '; Secure' : ''}`;
		}

		if (data.user) {
			// Initialize avatar with user's avatar URL from database, fallback to default
			if (data.user.avatar && data.user.avatar !== '/Default_User.svg') {
				avatarSrc.value = data.user.avatar;
			} else {
				avatarSrc.value = '/Default_User.svg';
			}
		}

		// Event listeners
		window.addEventListener('keydown', onKeyDown);
	});

	// Navigation loading handlers
	beforeNavigate(({ from, to }) => {
		// Only show loading for actual page changes, not hash changes
		if (from && to && from.route.id !== to.route.id) {
			globalLoadingStore.startLoading(loadingOperations.navigation);
		}
	});

	afterNavigate(() => {
		// Stop navigation loading
		globalLoadingStore.stopLoading(loadingOperations.navigation);

		// Clear any stale loading operations after navigation
		setTimeout(() => {
			// Only clear if no other operations are running
			if (globalLoadingStore.loadingStack.size === 1 && globalLoadingStore.isLoadingReason(loadingOperations.navigation)) {
				globalLoadingStore.stopLoading(loadingOperations.navigation);
			}
		}, 100);
	});

	onDestroy(() => {
		// Cleanup: remove event listeners
		mediaQuery?.removeEventListener('change', updateThemeBasedOnSystemPreference);
		window.removeEventListener('keydown', onKeyDown);
	});

	// SEO
	const siteName = $derived(publicEnv.SITE_NAME || 'SveltyCMS');
	const SeoDescription = $derived(
		`${siteName} - a modern, powerful, and easy-to-use CMS powered by SvelteKit. Manage your content with ease & take advantage of the latest web technologies.`
	);
</script>

<svelte:head>
	<!-- Dark Mode -->
	<!-- eslint-disable-next-line svelte/no-at-html-tags-->
	{@html '<script>(' + setInitialClassState.toString() + ')();</script>'}

	<!--Basic SEO-->
	<meta name="description" content={SeoDescription} />

	<!-- Open Graph -->
	<meta property="og:title" content={siteName} />
	<meta property="og:description" content={SeoDescription} />
	<meta property="og:type" content="website" />
	<meta property="og:image" content="/SveltyCMS.png" />
	<meta property="og:image:width" content="1200" />
	<meta property="og:image:height" content="630" />
	<meta property="og:site_name" content={page.url.origin} />

	<!-- Open Graph : Twitter-->
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:title" content={siteName} />
	<meta name="twitter:description" content={SeoDescription} />
	<meta name="twitter:image" content="/SveltyCMS.png" />
	<meta property="twitter:domain" content={page.url.origin} />
	<meta property="twitter:url" content={page.url.href} />
</svelte:head>

{#if loadError}
	<div class="text-error-500">An error occurred: {loadError.message}</div>
{:else}
	<!-- This outer div is a good container for overlays -->
	<div class="relative h-lvh w-full">
		<!-- Background and Overlay components live here, outside the main content flow -->
		{#if screenSize.value === 'XS' || screenSize.value === 'SM'}
			<FloatingNav />
		{/if}
        <!-- Toasts (Skeleton v4) -->
        <Toast.Group toaster={toaster}>
            { (toast) => (
                <Toast toast={toast} />
            ) }
        </Toast.Group>
        <!-- Modal removed while migrating to Skeleton v4 Dialog API -->
		{#if $isSearchVisible}
			<SearchComponent />
		{/if}

		<!-- Body -->
		<div class="flex h-lvh flex-col overflow-hidden">
			<!-- Header (unused) -->
			{#if uiStateManager.uiState.value.header !== 'hidden'}
				<header class="sticky top-0 z-10 bg-tertiary-500">Header</header>
			{/if}

			<div class="flex flex-1 overflow-hidden">
				<!-- Sidebar Left -->
				{#if uiStateManager.uiState.value.leftSidebar !== 'hidden'}
					<aside
						class="max-h-dvh {uiStateManager.uiState.value.leftSidebar === 'full'
							? 'w-[220px]'
							: 'w-fit'} relative border-r bg-white !px-2 text-center dark:border-surface-500 dark:bg-gradient-to-r dark:from-surface-700 dark:to-surface-900"
					>
						<LeftSidebar />
					</aside>
				{/if}

				<!-- Content Area -->
				<main class="relative z-0 flex w-full min-w-0 flex-1 flex-col">
					<!-- Page Header -->
					{#if uiStateManager.uiState.value.pageheader !== 'hidden'}
						<header class="sticky top-0 w-full"><HeaderEdit /></header>
					{/if}

					<!-- Router Slot & Scoped Loader -->
					<div
						role="main"
						class="relative flex-1 {uiStateManager.uiState.value.leftSidebar === 'full' ? 'mx-2' : 'mx-1'} {isDesktop.value ? 'mb-2' : 'mb-16'}"
					>
						<!-- The loading component  -->
						{#if shouldShowLoading}
							<div transition:fade={{ duration: 200 }} class="variant-glass-surface absolute z-50 flex h-full w-full items-center justify-center">
								<Loading
									customTopText={loadingTopText()}
									customBottomText={globalLoadingStore.loadingReason === loadingOperations.initialization ? 'Loading application...' : 'Please wait'}
								/>
							</div>
						{/if}

						<!-- The page content is rendered here. -->
						{@render children?.()}
					</div>

					<!-- Page Footer (Mobile Nav) -->
					{#if uiStateManager.uiState.value.pagefooter !== 'hidden'}
						<footer class="mt-auto w-full bg-surface-50 bg-gradient-to-b px-1 text-center dark:from-surface-700 dark:to-surface-900">
							<PageFooter />
						</footer>
					{/if}
				</main>

				<!-- Sidebar Right -->
				{#if uiStateManager.uiState.value.rightSidebar !== 'hidden'}
					<aside
						class="max-h-dvh w-[220px] border-l bg-surface-50 bg-gradient-to-r dark:border-surface-500 dark:from-surface-700 dark:to-surface-900"
					>
						<RightSidebar />
					</aside>
				{/if}
			</div>

			<!-- Footer (unused) -->
			{#if uiStateManager.uiState.value.footer !== 'hidden'}
				<footer class="bg-blue-500">Footer</footer>
			{/if}
		</div>
	</div>
{/if}
