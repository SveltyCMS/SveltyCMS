---
path: 'docs/Widgets/Widget_Management_System.mdx'
title: 'Widget Management System'
description: 'Comprehensive guide to SveltyCMS widget architecture with 3-pillar design, core/custom categorization, and multi-tenant support'
order: 52
icon: 'mdi:widgets'
author: 'admin'
created: '2025-08-05'
updated: '2025-10-04'
tags:
  - 'developer'
  - 'widgets'
  - 'management'
  - 'architecture'
  - '3-pillar'
---

# Widget Management System

## Overview

The SveltyCMS widget management system provides a robust architecture for handling both core and custom widgets with the **3-Pillar Architecture** (Definition, Input, Display), proper dependency management, tenant isolation, and database synchronization.

## Architecture

### Core Concepts

- **3-Pillar Architecture**: Modern widget design with Definition (index.ts), Input (Input.svelte), and Display (Display.svelte) components
- **Core Widgets**: Essential widgets that are always enabled by default (e.g., `input`, `richText`, `date`, `mediaUpload`)
- **Custom Widgets**: Optional widgets that can be enabled/disabled per tenant (e.g., `seo`, `colorPicker`, `rating`)
- **Widget Dependencies**: Widgets can depend on other widgets, preventing invalid configurations
- **Tenant Isolation**: Multi-tenant support with per-tenant widget configurations

## 3-Pillar Architecture

The modern widget architecture separates concerns into three distinct pillars:

### 1. Definition Pillar (index.ts)

The widget's blueprint containing:

- Widget metadata (name, icon, description)
- Configuration schema (GuiSchema)
- Validation rules (Valibot schemas)
- Default values
- Dependencies

```typescript
import { createWidget } from '@widgets/factory';

export default createWidget({
  Name: 'MyWidget',
  Icon: 'mdi:icon',
  Description: 'Widget description',

  // 3-Pillar Architecture paths
  inputComponentPath: '/src/widgets/custom/myWidget/Input.svelte',
  displayComponentPath: '/src/widgets/custom/myWidget/Display.svelte',

  defaults: { /* default values */ },
  validationSchema: /* Valibot schema */
});
```

### 2. Input Pillar (Input.svelte)

Interactive component for data entry:

- Used in collection form editing
- Full CRUD operations
- Rich user interactions
- Form validation

### 3. Display Pillar (Display.svelte)

Lightweight component for viewing:

- Used in entry lists and previews
- Read-only display
- Optimized for performance
- Minimal dependencies

## Widget Management Interface

Access the widget management dashboard at `/config/widgetManagement`:

### Features

- **ğŸ“Š Statistics Dashboard**: Real-time metrics for all widgets
- **ğŸ” Search & Filter**: Find widgets quickly by name, description, or status
- **ğŸ“‹ 2-Column Layout**: Professional grid layout for desktop (responsive single column on mobile)
- **ğŸª Marketplace Integration**: Browse and install widgets from marketplace (coming soon)
- **ğŸ¯ 3-Pillar Visibility**: See which components are implemented for each widget
- **âš™ï¸ Quick Actions**: Activate/deactivate widgets with one click
- **ğŸ”’ Permission Control**: Role-based access with read-only mode for non-admins
- **ğŸ“¦ Dependency Management**: Automatic dependency resolution and validation

### Statistics Metrics

- **Total Widgets**: All registered widgets (core + custom)
- **Active**: Currently enabled widgets
- **Core**: Essential widgets (always on)
- **Custom**: Optional widgets (can be toggled)
- **Input**: Widgets with Input component implemented
- **Display**: Widgets with Display component implemented

### File Structure

```
src/
â”œâ”€â”€ stores/
â”‚   â””â”€â”€ widgetStore.svelte.ts          # Centralized widget state management
â”œâ”€â”€ widgets/
â”‚   â”œâ”€â”€ core/                          # Core widgets (always enabled)
â”‚   â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â”œâ”€â”€ richText/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ custom/                        # Custom widgets (optional)
â”‚   â”‚   â”œâ”€â”€ seo/
â”‚   â”‚   â”œâ”€â”€ colorPicker/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ widgetManager.svelte.ts        # Legacy compatibility layer
â”‚   â””â”€â”€ types.ts                       # Widget type definitions
â””â”€â”€ routes/api/widgets/                # Widget API endpoints
    â”œâ”€â”€ active/+server.ts              # Get active widgets
    â”œâ”€â”€ status/+server.ts              # Update widget status
    â””â”€â”€ collections/
        â””â”€â”€ widgets/
            â”œâ”€â”€ required/+server.ts    # Get widgets required by collections
            â””â”€â”€ validate/+server.ts    # Validate collections against widgets
```

## Usage

### Basic Widget Operations

```typescript
import { widgetStoreActions, isWidgetActive, canDisableWidget, getWidgetDependencies } from '@stores/widgetStore.svelte';

// Initialize widgets for a tenant
await widgetStoreActions.initializeWidgets('tenant123');

// Check widget status
const isActive = isWidgetActive('SEO');
const canDisable = canDisableWidget('SEO');
const deps = getWidgetDependencies('SEO');

// Update widget status
await widgetStoreActions.updateWidgetStatus('SEO', 'active', 'tenant123');

// Bulk activate widgets with dependency resolution
await widgetStoreActions.bulkActivateWidgets(['SEO', 'ColorPicker'], 'tenant123');
```

### Collection Analysis

```typescript
// Get widgets required by all collections
const requiredWidgets = await widgetStoreActions.getRequiredWidgetsByCollections('tenant123');

// Validate collections against current widget state
const validation = await widgetStoreActions.validateCollectionsAgainstWidgets('tenant123');
console.log(`Valid: ${validation.valid}, Invalid: ${validation.invalid}`);
console.log('Warnings:', validation.warnings);
```

### Widget Store State

The widget store maintains the following state:

```typescript
interface WidgetStoreState {
	widgets: Record<string, Widget>; // Widget instances
	widgetFunctions: Record<string, WidgetFunction>; // Widget factory functions
	activeWidgets: string[]; // Currently active widget names
	coreWidgets: string[]; // Core widget names (always enabled)
	customWidgets: string[]; // Custom widget names (optional)
	dependencyMap: Record<string, string[]>; // Widget dependencies
	isLoaded: boolean; // Initialization status
	isLoading: boolean; // Loading state
	tenantId?: string; // Current tenant context
}
```

## Widget Development

### Creating a Core Widget

1. Create directory: `src/widgets/core/myWidget/`
2. Add `index.ts` with widget function:

```typescript
// src/widgets/core/myWidget/index.ts
export default function MyWidget(config: Record<string, unknown>) {
  return {
    Name: 'MyWidget',
    component: MyWidgetComponent,
    config,
    // ... other widget properties
  };
}

MyWidget.Name = 'My Widget';
MyWidget.Icon = 'mdi:widget';
MyWidget.Description = 'A core widget';
MyWidget.dependencies = []; // Optional dependencies

Note: Prefer the Three-Pillars pattern: export a factory-created widget (Definition) and provide `Input.svelte` + `Display.svelte` components. Keep validation centralized in the widget definition using Valibot.
```

### Creating a Custom Widget

1. Create directory: `src/widgets/custom/myCustomWidget/`
2. Add `index.ts` with widget function (same structure as core widgets)
3. The widget will be automatically categorized as 'custom'

### Widget Dependencies

Declare dependencies in your widget:

```typescript
export default function SEOWidget(config: Record<string, unknown>) {
	// ... widget implementation
}

SEOWidget.dependencies = ['Input', 'RichText']; // Dependencies on other widgets
```

## API Endpoints

### GET `/api/widgets/list`

Get comprehensive widget list with 3-pillar architecture metadata.

**Query Parameters:**

- `tenantId`: Tenant identifier (optional)

**Response:**

```json
{
	"widgets": [
		{
			"name": "Input",
			"icon": "mdi:form-textbox",
			"description": "Text input widget",
			"isCore": true,
			"isActive": true,
			"dependencies": [],
			"pillar": {
				"definition": {
					"name": "Input",
					"description": "Text input widget",
					"icon": "mdi:form-textbox",
					"guiSchema": 5,
					"aggregations": false
				},
				"input": {
					"componentPath": "/src/widgets/core/input/Input.svelte",
					"exists": true
				},
				"display": {
					"componentPath": "/src/widgets/core/input/Display.svelte",
					"exists": true
				}
			},
			"canDisable": false,
			"hasValidation": true
		}
	],
	"summary": {
		"total": 19,
		"active": 10,
		"core": 10,
		"custom": 9
	},
	"tenantId": "tenant123"
}
```

### GET `/api/widgets/active`

Get currently active widgets for a tenant with enriched metadata.

**Headers:**

- `X-Tenant-ID`: Tenant identifier (optional)

**Response:**

```json
{
	"widgets": ["Input", "RichText", "SEO"],
	"tenantId": "tenant123"
}
```

### POST `/api/widgets/status`

Update widget activation status.

**Headers:**

- `X-Tenant-ID`: Tenant identifier (optional)

**Body:**

```json
{
	"widgetName": "SEO",
	"isActive": true
}
```

### GET `/api/collections/widgets/required`

Get widgets required by all collections.

**Headers:**

- `X-Tenant-ID`: Tenant identifier (optional)

**Response:**

```json
{
	"requiredWidgets": ["Input", "RichText", "Date"],
	"collectionsAnalyzed": 5,
	"tenantId": "tenant123"
}
```

### GET `/api/collections/widgets/validate`

Validate collections against current widget state.

**Query Parameters:**

- `activeWidgets`: Comma-separated list of active widget names

**Headers:**

- `X-Tenant-ID`: Tenant identifier (optional)

**Response:**

```json
{
	"valid": 3,
	"invalid": 2,
	"warnings": ["Collection 'posts' requires inactive widgets: SEO, SocialShare"],
	"total": 5,
	"tenantId": "tenant123"
}
```

## Multi-Tenant Support

The widget system supports multi-tenancy:

- Each tenant can have different widget activation states
- Core widgets are always active for all tenants
- Custom widgets can be enabled/disabled per tenant
- Widget configurations are isolated per tenant

Migration note â€” cleaning up legacy custom widgets:

If you previously maintained separate `src/widgets/custom/email`, `number`, or `phoneNumber` widgets, those can be safely deprecated since the core `Input` widget now handles these types via `inputType`. Before removing files:

1. Search the codebase for usages of the legacy widget factories and update collection definitions to use `widgets.Input({ inputType: 'email' })`, `widgets.Input({ inputType: 'number' })`, or `widgets.Input({ inputType: 'phone' })`.
2. Ensure any custom validation or special GUI schema from the legacy widget is ported into the `Input` widget's GuiSchema or into a small wrapper that calls `Input` but sets `validationSchema` or Gui overrides.
3. Run the collection validation API (`/api/collections/widgets/validate`) to ensure no collections require the removed widgets.

The factory now accepts a `validationSchema` that may be a function (field-aware) or a static Valibot schema. Use the function form if validation needs access to other field properties.

## Error Handling

The system includes comprehensive error handling:

- **Dependency Validation**: Prevents disabling widgets that other widgets depend on
- **Core Widget Protection**: Prevents disabling essential core widgets
- **Missing Dependencies**: Warns when activating widgets with inactive dependencies
- **Collection Validation**: Identifies collections that require inactive widgets

## Performance Considerations

- Widget loading uses dynamic imports for code splitting
- Client-side state is synchronized with server-side database
- Hot Module Replacement (HMR) support for development
- Efficient dependency resolution algorithms

## Migration from Legacy System

The new system maintains backward compatibility through `widgetManager.svelte.ts`. Existing code will continue to work while you migrate to the new store-based approach.

To migrate:

1. Replace imports from `@widgets/widgetManager.svelte` with `@stores/widgetStore.svelte`
2. Update function calls to use the new store actions
3. Add tenant context where applicable
4. Utilize new features like dependency management and collection validation

## Troubleshooting

### Common Issues

1. **"Cannot disable core widget"**: Core widgets cannot be disabled as they're essential
2. **"Missing dependencies"**: Activate required widgets before activating dependent widgets
3. **"Widget database adapter not available"**: Ensure database connection is properly configured
4. **Collection validation warnings**: Activate required widgets or update collection schemas

### Debug Information

Enable debug logging to see detailed widget operations:

```typescript
import { logger } from '@utils/logger.svelte';
logger.setLevel('debug');
```

## Future Enhancements

- Widget versioning and migration support
- Advanced dependency resolution with automatic activation
- Widget marketplace integration
- Performance metrics and analytics
- A/B testing support for widget configurations
