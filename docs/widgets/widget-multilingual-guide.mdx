---
path: 'docs/widgets/widget-multilingual-guide.mdx'
title: 'Widget Multilingual Guide'
description: 'Comprehensive guide to implementing translation support in SveltyCMS widgets with dual-language system patterns.'
order: 3
icon: 'mdi:translate'
author: 'admin'
created: '2025-11-14'
updated: '2025-11-14'
tags:
  - 'widgets'
  - 'multilingual'
  - 'i18n'
  - 'translation'
  - 'contentLanguage'
  - 'systemLanguage'
---

# Widget Multilingual Guide

**Comprehensive guide to implementing translation support in SveltyCMS widgets.**

## Overview

SveltyCMS uses a **dual-language system** for complete multilingual support:

| Language Type       | Purpose                                    | Store             | Example                                 |
| ------------------- | ------------------------------------------ | ----------------- | --------------------------------------- |
| **systemLanguage**  | UI/Interface text (buttons, labels, menus) | `systemLanguage`  | Login button shows "Anmelden" in German |
| **contentLanguage** | User data (posts, pages, fields)           | `contentLanguage` | Blog post title exists in EN, DE, FR    |

### Translation Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Widget Component                      │
│  ┌──────────────────────┐  ┌─────────────────────────┐ │
│  │  systemLanguage      │  │  contentLanguage        │ │
│  │  (UI Labels)         │  │  (Field Data)           │ │
│  ├──────────────────────┤  ├─────────────────────────┤ │
│  │ - Paraglide m.*()    │  │ - value[contentLang]    │ │
│  │ - Static UI text     │  │ - Reactive to language  │ │
│  │ - Form labels        │  │ - Stored in DB          │ │
│  └──────────────────────┘  └─────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

---

## Implementation Patterns

### 1. Widget Definition (index.ts)

**Enable translation for field data:**

```typescript
import { createWidget } from '@src/widgets/widgetFactory';
import type { InputProps } from './types';

const InputWidget = createWidget<InputProps>({
	Name: 'Input',
	Description: m.widget_text_description(), // ✅ systemLanguage via Paraglide

	// ✅ Enable content translation by default
	defaults: {
		translated: true
	},

	// ✅ Validation handles translated object { en: "", de: "" }
	validationSchema: (field) => {
		if (field.translated) {
			return object({ _any: any() }); // Flexible object for language keys
		}
		return string(); // Single value for non-translated
	},

	// ✅ Aggregations support language-specific queries
	aggregations: {
		filters: async ({ field, filter, contentLanguage }) => [
			{ $match: { [`${field.db_fieldName}.${contentLanguage}`]: { $regex: filter, $options: 'i' } } }
		],
		sorts: async ({ field, sortDirection, contentLanguage }) => ({
			[`${field.db_fieldName}.${contentLanguage}`]: sortDirection
		})
	}
});
```

**Key Points:**

- `defaults.translated: true` → Field stores object `{ en: "Title", de: "Titel" }`
- `validationSchema` → Use `object()` for translated, `string()` for single-value
- `aggregations` → Always use `contentLanguage` parameter for DB queries

---

### 2. Input Component (Input.svelte)

**Handle translated field data reactively:**

```svelte
<script lang="ts">
	import { app } from '@stores/store.svelte';
	import { publicEnv } from '@stores/globalSettings.svelte';
	import type { FieldType } from '.';

	let { field, value = $bindable() }: Props = $props();

	// ✅ Reactive language selection
	const _language = $derived(
		field.translated
			? app.contentLanguage // Use active content language
			: (publicEnv.DEFAULT_CONTENT_LANGUAGE || 'en').toLowerCase() // Fallback for non-translated
	);

	// ✅ Safe value access with fallback
	let safeValue = $derived(value?.[_language] ?? '');

	// ✅ Safe value setter
	function updateValue(newValue: string) {
		if (!value) value = {};
		value = { ...value, [_language]: newValue };
	}
</script>

<input
	type="text"
	value={safeValue}
	oninput={(e) => updateValue(e.currentTarget.value)}
	placeholder={field.placeholder}
	<!--
	❌
	NOT
	translated
	-
	use
	m.*
	for
	UI
	text
	--
/>
/>
```

**Anti-Patterns to Avoid:**

❌ **Don't hardcode language:**

```svelte
let currentValue = value?.en ?? ''; // ❌ Always uses English
```

✅ **Do use app.contentLanguage:**

```svelte
let currentValue = $derived(value?.[app.contentLanguage] ?? ''); // ✅ Reactive
```

---

### 3. Display Component (Display.svelte)

**Render translated content for current language:**

```svelte
<script lang="ts">
	import { app } from '@stores/store.svelte';
	import type { InputWidgetData } from '.';

	let { value }: { value: InputWidgetData | null } = $props();

	// ✅ Display only current language (not all translations)
	let displayValue = $derived(
		typeof value === 'string'
			? value // Non-translated field
			: (value?.[app.contentLanguage] ?? '–') // Translated field
	);
</script>

{#if displayValue && displayValue !== '–'}
	<span>{displayValue}</span>
{:else}
	<span class="text-gray-400">–</span> <!-- Empty state -->
{/if}
```

**Key Points:**

- Display component is **view-only** → no bindings
- Always check `typeof value` to handle both translated/non-translated
- Use empty state (`–`) for missing translations instead of throwing errors

---

## Language Store Integration

### app Singleton (Reactive)

**Used for language state in Input/Display components:**

```typescript
// src/stores/store.svelte.ts
export class AppStore {
	_contentLanguage = $state<Locale>('en' as Locale);
	_systemLanguage = $state<Locale>('en' as Locale);

	get contentLanguage() {
		return this._contentLanguage;
	}
	set contentLanguage(v: Locale) {
		this._contentLanguage = v;
	}
}

export const app = new AppStore();
```

**Usage Pattern:**

```svelte
<script>
	import { app } from '@stores/store.svelte';

	// ✅ Reactive - automatically updates when language changes
	let currentLang = $derived(app.contentLanguage);
</script>

{#key currentLang}
	<!-- Re-render when language changes -->
	<WidgetComponent {field} {value} />
{/key}
```

### systemLanguage Store (UI Text)

**Used for interface labels via Paraglide:**

```typescript
// src/paraglide/messages.ts
export const widget_text_description = () => {
	switch (app.systemLanguage) {
		case 'de':
			return 'Texteingabe-Widget';
		case 'en':
			return 'Text Input Widget';
		default:
			return 'Text Input Widget';
	}
};
```

**Usage in Components:**

```svelte
<script>
	import * as m from '@paraglide/messages';
</script>

<label>{m.widget_label_title()}</label> <!-- Shows "Title" or "Titel" based on systemLanguage -->
```

---

## Translation Status Tracking

**Calculate per-field completion percentage:**

```typescript
// In Fields.svelte or EntryList.svelte
function getTranslationStatus(entry: any, fields: FieldDefinition[]): { completed: number; total: number } {
	const availableLanguages = publicEnv.AVAILABLE_CONTENT_LANGUAGES || ['en'];
	let completed = 0;
	let total = 0;

	for (const field of fields) {
		if (!field.translated) continue; // Skip non-translated fields

		const fieldName = field.db_fieldName || field.label;
		const fieldValue = entry[fieldName];

		for (const lang of availableLanguages) {
			total++;
			if (fieldValue?.[lang] && fieldValue[lang] !== '') {
				completed++;
			}
		}
	}

	return { completed, total };
}

// Usage:
const { completed, total } = getTranslationStatus(entry, collection.fields);
const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
```

**Visual Indicator:**

```svelte
<div class="translation-status">
	<span>{percentage}% translated</span>
	<div class="progress-bar">
		<div class="progress-fill" style="width: {percentage}%"></div>
	</div>
</div>
```

---

## Testing Multilingual Widgets

**Unit Test Example:**

```typescript
// tests/widgets/input.test.ts
import { render } from '@testing-library/svelte';
import Input from '@widgets/core/input/Input.svelte';
import { contentLanguage } from '@stores/store.svelte';

describe('Input Widget - Multilingual', () => {
	test('displays correct language value', () => {
		const field = { label: 'Title', translated: true };
		const value = { en: 'Hello', de: 'Hallo' };

		app.contentLanguage = 'de';
		const { container } = render(Input, { field, value });
		const input = container.querySelector('input');

		expect(input.value).toBe('Hallo'); // Shows German
	});

	test('updates correct language on input', async () => {
		const field = { label: 'Title', translated: true };
		let value = $state({ en: 'Hello', de: 'Hallo' });

		app.contentLanguage = 'en';
		const { container } = render(Input, { field, value });
		const input = container.querySelector('input');

		await fireEvent.input(input, { target: { value: 'World' } });

		expect(value.en).toBe('World'); // Updates English only
		expect(value.de).toBe('Hallo'); // German unchanged
	});
});
```

---

## Common Pitfalls

### ❌ Pitfall 1: Not Handling Null Values

```svelte
<!-- BAD -->
let displayValue = value[app.contentLanguage]; // ❌ Throws if value is null
```

```svelte
<!-- GOOD -->
let displayValue = $derived(value?.[app.contentLanguage] ?? '–'); // ✅ Safe access
```

### ❌ Pitfall 2: Overwriting All Languages

```svelte
<!-- BAD -->
function updateValue(newValue: string) {
	value = { en: newValue }; // ❌ Deletes all other languages!
}
```

```svelte
<!-- GOOD -->
function updateValue(newValue: string) {
	value = { ...value, [_language]: newValue }; // ✅ Preserves other languages
}
```

### ❌ Pitfall 3: Mixing systemLanguage and contentLanguage

```svelte
<!-- BAD -->
let currentLang = app.systemLanguage; // ❌ UI language, not content language let displayValue = value[currentLang]; // Shows wrong data if UI ≠ Content
```

```svelte
<!-- GOOD -->
let currentLang = app.contentLanguage; // ✅ Always use contentLanguage for data let displayValue = value[currentLang];
```

---

## Migration Checklist

When adding translation support to existing widgets:

- [ ] Update `defaults.translated = true` in index.ts
- [ ] Change `validationSchema` to handle object type for translated fields
- [ ] Update aggregations to use `contentLanguage` parameter
- [ ] Refactor Input.svelte to use `$derived(contentLanguage.value)`
- [ ] Update value access: `value` → `value[_language]`
- [ ] Add safe value setter: `value = { ...value, [_language]: newValue }`
- [ ] Update Display.svelte to handle both string and object types
- [ ] Add empty state handling (`–` for missing translations)
- [ ] Test language switching in both Input and Display modes
- [ ] Update widget documentation with translation examples

---

## Related Documentation

- [Widget Testing Guide](./widget-testing-guide.mdx) - Unit testing multilingual widgets
- [Collection Store Dataflow](../architecture/collection-store-dataflow.mdx) - How language changes trigger updates
- [Database Schema](../database/schema.mdx) - Translated field storage format

---

## Questions?

This guide consolidates best practices from all core widgets. For specific widget examples:

- **Text Input**: `src/widgets/core/input/`
- **Rich Text**: `src/widgets/core/richText/`
- **Select**: `src/widgets/core/select/`

All widgets follow these same patterns for consistency.
