---
title: 'Telemetry Server Implementation'
description: 'Technical specification for implementing the SveltyCMS telemetry receiver.'
order: 6
icon: 'mdi:server-network'
author: 'SveltyCMS Team'
created: '2025-12-02'
updated: '2025-12-02'
tags:
  - 'telemetry'
  - 'server'
  - 'api'
---

# Telemetry Server Implementation Guide

This document outlines the technical specifications for the **SveltyCMS Telemetry Receiver**. This server is responsible for receiving health checks from SveltyCMS instances, aggregating anonymous usage data, and returning security status updates.

## 1. API Specification

The telemetry service communicates via a single REST endpoint.

### Endpoint Definition

- **URL:** `https://telemetry.sveltycms.com/api/check-update`
- **Method:** `POST`
- **Content-Type:** `application/json`

### Request Payload

SveltyCMS instances send the following JSON payload:

```json
{
	"current_version": "0.5.0", // The version of SveltyCMS running
	"node_version": "v20.10.0", // Node.js runtime version
	"environment": "production", // 'development' or 'production'
	"os": "linux", // Operating system platform
	"license": "BSL-1.1" // License type
}
```

### Response Schema

The server must return a JSON response indicating the latest version and any security alerts.

**Success (200 OK):**

```json
{
	"latest_version": "0.6.0", // The current latest stable release
	"has_vulnerability": false, // true if the *client's* version has known CVEs
	"message": "Update available" // Optional message to display in dashboard
}
```

**Error (500/503):**
If the server fails, the client will cache the failure and retry after 12 hours.

## 2. Implementation Logic

A robust telemetry server should perform the following steps:

1.  **Validation**: Ensure the request body matches the expected schema.
2.  **Data Ingestion**: Log the anonymous data (Version, Node, OS) to a time-series database (e.g., InfluxDB, ClickHouse) or a relational DB for analytics.
    - _Privacy Note:_ Do not log IP addresses if possible, or hash them to respect privacy.
3.  **Version Comparison**:
    - Compare `payload.current_version` against the latest known release (stored in DB or fetched from GitHub Releases).
    - Check if `payload.current_version` is in a list of known vulnerable versions.
4.  **Response Construction**: Return the comparison result.

## 3. Reference Implementation (Node.js / Hono)

Here is a minimal example using [Hono](https://hono.dev/) (a lightweight web framework) that could be deployed to Cloudflare Workers, Vercel, or a VPS.

```typescript
import { Hono } from 'hono';
import { semver } from 'bun'; // or 'semver' package

const app = new Hono();

// Mock Data Source (Replace with DB/GitHub API)
const LATEST_VERSION = '0.6.0';
const VULNERABLE_VERSIONS = ['0.4.0', '0.4.1'];

app.post('/api/check-update', async (c) => {
	try {
		const body = await c.req.json();
		const { current_version } = body;

		// 1. Log Telemetry (Async - don't block response)
		// await db.insert('telemetry_events', { ...body, timestamp: new Date() });
		console.log(`Telemetry received from v${current_version}`);

		// 2. Determine Status
		const isVulnerable = VULNERABLE_VERSIONS.includes(current_version);
		const updateAvailable = semver.gt(LATEST_VERSION, current_version);

		let message = 'You are up to date.';
		if (isVulnerable) message = 'CRITICAL: Security update required immediately.';
		else if (updateAvailable) message = `Update to v${LATEST_VERSION} available.`;

		// 3. Return Response
		return c.json({
			latest_version: LATEST_VERSION,
			has_vulnerability: isVulnerable,
			message: message
		});
	} catch (err) {
		return c.json({ error: 'Invalid request' }, 400);
	}
});

export default app;
```

## 4. Security Considerations

- **Rate Limiting**: Implement rate limiting (e.g., by IP) to prevent abuse, although the client is polite (12h interval).
- **Payload Validation**: Strictly validate input types to prevent injection attacks if storing in a SQL database.
- **CORS**: Configure CORS to allow requests from any origin (since CMS instances can be hosted anywhere), or restrict if intended for specific enterprise clients.

## 5. Deployment

The telemetry receiver is stateless and ideal for serverless deployment:

- **Cloudflare Workers**: Low latency, global edge network.
- **Vercel / Netlify Functions**: Easy integration.
- **Docker / Kubernetes**: For self-hosted control.
