---
path: 'docs/architecture/telemetry-server-implementation.mdx'
title: 'Telemetry Server Implementation'
description: 'Technical specification for implementing the SveltyCMS telemetry receiver.'
order: 6
icon: 'mdi:server-network'
author: 'SveltyCMS Team'
created: '2025-12-02'
updated: '2025-12-02'
tags:
  - 'telemetry'
  - 'server'
  - 'api'
---

# Telemetry Server Implementation Guide

This document outlines the technical specifications for the **SveltyCMS Telemetry Receiver**. This server is responsible for receiving health checks from SveltyCMS instances, aggregating anonymous usage data, and returning security status updates.

## 1. HMAC Authentication

To reduce fake data and ensure authenticity, all telemetry requests must be signed using HMAC-SHA256 with a shared salt.

### Salt Configuration

The `TELEMETRY_SALT` must be identical on both the SveltyCMS package and the telemetry server.
Default value: `sveltycms-telemetry`

### Replay Protection

Requests must include a `timestamp` (Unix milliseconds). The server should reject any request where the timestamp is older than 5 minutes or more than 1 minute in the future.

## 2. API Specification

- **URL:** `https://telemetry.sveltycms.com/api/check-update`
- **Method:** `POST`
- **Content-Type:** `application/json`

### Request Payload

```typescript
interface TelemetryPayload {
	// Required fields
	current_version: string; // "0.9.0"
	node_version: string; // "v20.10.0"
	environment: string; // "production"
	os: string; // "linux"
	installation_id: string; // SHA256 hash of JWT_SECRET_KEY

	// Authentication fields (REQUIRED)
	timestamp: number; // Unix timestamp in milliseconds
	signature: string; // HMAC-SHA256 signature (hex)

	// Optional fields
	stable_id?: string;
	db_type?: string;
	location?: { ... };
	usage_metrics?: { ... };
	system_info?: { ... };
	widgets?: string[];
}
```

### Signature Generation

The signature is computed over the string: `installation_id:current_version:timestamp`

```typescript
const data = `${payload.installation_id}:${payload.current_version}:${payload.timestamp}`;
const signature = crypto.createHmac('sha256', TELEMETRY_SALT).update(data).digest('hex');
```

## 3. Implementation Logic

A robust telemetry server should perform the following steps:

1.  **Validate Timestamp**: Ensure the request is not a replay (5-minute window).
2.  **Validate Signature**: Recompute the HMAC and use `crypto.timingSafeEqual` for comparison.
3.  **Data Ingestion**: Log the anonymous data to your analytics database.
4.  **Version Check**: Compare `current_version` against the latest release and known vulnerabilities.

### Signature Validation Code (Example)

```typescript
function validateSignature(payload: TelemetryPayload, salt: string): boolean {
	const { installation_id, current_version, timestamp, signature } = payload;

	// 1. Check timestamp (5-minute window)
	const age = Date.now() - timestamp;
	if (age > 5 * 60 * 1000 || age < -60 * 1000) {
		return false;
	}

	// 2. Recompute expected signature
	const data = `${installation_id}:${current_version}:${timestamp}`;
	const expected = crypto.createHmac('sha256', salt).update(data).digest('hex');

	// 3. Constant-time comparison
	return crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expected, 'hex'));
}
```

## 4. Response Codes

| Status | Meaning                                                        |
| :----- | :------------------------------------------------------------- |
| `200`  | Telemetry accepted, signature valid                            |
| `400`  | Invalid payload format                                         |
| `403`  | Authentication failed (invalid signature or expired timestamp) |
| `429`  | Rate limited                                                   |
| `500`  | Internal server error                                          |

## 5. Deployment

The telemetry receiver is stateless and ideal for serverless deployment on Cloudflare Workers, Vercel, or Fly.io.
