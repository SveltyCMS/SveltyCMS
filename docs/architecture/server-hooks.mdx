---
path: 'docs/architecture/server-hooks.mdx'
title: 'Server Hooks & Middleware'
description: 'Enterprise-grade middleware architecture with unified metrics and production-ready optimizations.'
order: 4
icon: 'mdi:server-network'
author: 'admin'
created: '2025-10-12'
updated: '2025-10-20'
tags:
  - 'architecture'
  - 'hooks'
  - 'middleware'
  - 'performance'
  - 'security'
  - 'state-management'
---

# Server Hooks & Middleware Architecture

SveltyCMS employs an **enterprise-grade, streamlined middleware pipeline** using SvelteKit Server Hooks. This architecture emphasizes **security, performance, and observability** with unified metrics collection and automated threat detection.

---

## Design Philosophy

The middleware architecture is built on **core enterprise principles**:

1.  **Sequential & Predictable**: Hooks run in a defined order for every request, making the system easy to understand, debug, and scale.

2.  **Centralized State-Guarding**: The `handleSystemState` hook acts as the authoritative gatekeeper, ensuring no requests are processed unless the system is operational.

3.  **Unified Metrics & Monitoring**: All hooks integrate with the **MetricsService** for comprehensive performance and security monitoring.

4.  **Production-Optimized**: WeakRef-based memory management, non-blocking streaming, and distributed rate limiting for clustered deployments.

5.  **Framework-Native**: Leverages SvelteKit's built-in CSP and optimizes around framework capabilities.

---

## Current Middleware Sequence

```typescript
// src/hooks.server.ts
const middleware: Handle[] = [
	handleStaticAssetCaching, // 1. Static assets FIRST (skip all processing)
	handleSystemState, // 2. System readiness & state validation
	handleRateLimit, // 3. Rate limiting (abuse prevention)
	handleFirewall, // 4. Application firewall (threat detection)
	handleSetup, // 5. Setup completion enforcement
	handleLocale, // 6. Language preferences (i18n)
	handleTheme, // 7. Theme management (SSR)
	handleAuthentication, // 8. Session validation & multi-tenancy
	handleAuthorization, // 9. Role-based access control
	// handleApiRequests, // 10. Optional: API caching (commented out)
	addSecurityHeaders // 11. Security headers (defense in depth)
];

export const handle: Handle = sequence(...middleware);
```

## ðŸ“¡ Telemetry & Usage Tracking

SveltyCMS includes a minimal Heartbeat System (Telemetry) to help the core team understand usage patterns and enforce the BSL 1.1 license for enterprise users.

### How it works

1.  **Non-Blocking:** The telemetry runs asynchronously in the background. It never blocks a user request.
2.  **Frequency:** It sends a heartbeat once every 24 hours per server instance.
3.  **Data Collected:**
    - SveltyCMS Version (e.g., 1.0.0)
    - Hostname / Domain (e.g., cms.example.com)
    - Environment (Development vs Production)
    - Node.js Version

### Privacy & Opt-Out

We respect user privacy. Telemetry can be completely disabled by setting the following environment variable in your `.env` file:

```bash
# Disable SveltyCMS Telemetry
SVELTY_TELEMETRY_DISABLED=true
# OR use the universal standard
DO_NOT_TRACK=1
```

## ðŸš€ Server Startup & Initialization Flow

### Optimized Startup Strategy

SveltyCMS employs a **lazy initialization strategy** to minimize server startup time and enable **zero-restart setup completion**:

```mermaid
sequenceDiagram
    participant Build as Vite Build
    participant Server as SvelteKit Server
    participant Hooks as hooks.server.ts
    participant DB as db.ts Module
    participant State as System State

    Note over Build,Server: Server Startup (Cold Start)

    alt During Build (!building = false)
        Build->>Hooks: Skip all initialization
        Note over Hooks: No DB import during build
    else Production Server (!building = true)
        Server->>Hooks: Server starts
        Hooks->>DB: Dynamic import('@src/databases/db')
        Note over DB: Module loaded but NOT initialized
        State->>State: Set state = IDLE
        Hooks-->>Server: Ready (no blocking)
    end

    Note over Server: First Request Arrives

    Server->>Hooks: handleSystemState()
    Hooks->>State: Check state

    alt State = IDLE && !initializationAttempted
        Hooks->>DB: await dbInitPromise
        DB->>DB: loadPrivateConfig()

        alt Config exists (normal startup)
            DB->>DB: initializeSystem()
            DB->>DB: Connect to database
            DB->>DB: Load adapters & models
            State->>State: Set state = READY
        else No config (first-time setup)
            DB->>State: Keep state = IDLE
            Hooks->>Hooks: Allow /setup paths only
        end
    end

    Hooks-->>Server: Continue request processing
```

### First-Time Installation Flow (Zero Restart Required)

```mermaid
sequenceDiagram
    participant User as User/Browser
    participant Setup as /setup Wizard
    participant API as /api/setup/complete
    participant DB as db.ts
    participant State as System State
    participant Cache as Server Cache

    Note over User,Cache: Fresh Server (No Config)

    User->>Setup: Navigate to /setup
    Note over State: State = IDLE (allows /setup paths)
    Setup-->>User: Display setup wizard

    User->>Setup: Fill configuration form
    User->>Setup: Submit setup

    Setup->>API: POST /api/setup/complete
    API->>API: Write config/private.ts file
    API->>DB: initializeWithConfig(fullConfig)
    Note over DB: In-memory config passed<br/>(bypasses Vite cache)

    DB->>DB: privateEnv = config
    DB->>DB: initializeSystem(false, true)
    DB->>DB: Connect database
    DB->>DB: Load adapters
    DB->>DB: Setup auth models
    State->>State: Set state = READY

    API->>API: Create admin user
    API->>Cache: Warm cache: fetch('/')
    Note over Cache: Pre-load homepage SSR

    API-->>Setup: { success: true, redirect: '/login' }
    Setup->>User: Redirect to /login

    Note over User,State: âœ… System fully operational<br/>NO SERVER RESTART NEEDED
```

### Key Implementation: hooks.server.ts

```typescript
// --- Server Startup Logic ---
if (!building) {
	/**
	 * Lazy initialization: DB module is loaded but NOT initialized
	 * until the first request arrives.
	 *
	 * This enables:
	 * 1. Fast server startup (no blocking I/O)
	 * 2. Zero-restart setup completion
	 * 3. Dynamic configuration reloading
	 *
	 * State transitions: IDLE -> INITIALIZING -> READY/DEGRADED/FAILED
	 */
	import('@src/databases/db')
		.then(() => {
			logger.info('âœ… DB module loaded. Will initialize on first request.');
		})
		.catch((error) => {
			logger.error('Fatal: Failed to load DB module:', error);
		});
}
```

**Why Dynamic Import?**

- âœ… **Non-Blocking**: Server starts immediately without waiting for DB
- âœ… **Setup-Friendly**: First-time installs don't crash (IDLE state)
- âœ… **Hot Reload**: Configuration changes don't require restarts
- âœ… **Build-Safe**: Skipped entirely during Vite build process

### Zero-Restart Setup: initializeWithConfig()

**Problem Solved:** Traditional approach required server restart after creating `config/private.ts` because Vite caches module imports.

**Solution:** Pass configuration in-memory, bypassing filesystem imports:

```typescript
// src/databases/db.ts
export async function initializeWithConfig(config: PrivateEnv): Promise<{ status: string }> {
	try {
		logger.info('Initializing system with provided configuration (bypassing Vite cache)...');

		// CRITICAL: Set config in memory BEFORE initialization
		privateEnv = config;

		// Now initialize system (skipSetupCheck = true means use in-memory config)
		initializationPromise = initializeSystem(false, true);
		await initializationPromise;

		return { status: 'success' };
	} catch (error) {
		logger.error('Failed to initialize with config:', error);
		throw error;
	}
}
```

**Called by:** `/api/setup/complete` endpoint after writing `config/private.ts`

**Benefits:**

1. **Immediate Availability**: System becomes operational instantly
2. **No Restart**: Configuration takes effect without process restart
3. **Cache Warming**: First page load happens during setup completion
4. **Smooth UX**: Users redirected directly to login page

---

## Hook Implementations

### 1. handleStaticAssetCaching - Performance Optimization

**File**: `src/hooks/handleStaticAssetCaching.ts`  
**Purpose**: Aggressive caching for static assets (runs FIRST for maximum performance)

**Strategy**: `max-age=31536000, public, immutable` (1 year cache)

```typescript
export const handleStaticAssetCaching: Handle = async ({ event, resolve }) => {
	// Regex-based detection for performance
	if (STATIC_ASSET_REGEX.test(event.url.pathname)) {
		const response = await resolve(event);
		response.headers.set('Cache-Control', 'public, max-age=31536000, immutable');
		return response;
	}
	return resolve(event);
};
```

**Assets Cached**:

- SvelteKit build artifacts (`/_app/`)
- Static files (`/static/`)
- JavaScript, CSS, source maps (`.js`, `.css`, `.map`)
- Images (`.svg`, `.png`, `.jpg`, `.webp`, `.avif`)
- Fonts (`.woff`, `.woff2`, `.ttf`, `.eot`)
- Manifests, favicons

**Performance Impact**: Skips ALL other middleware (~15-20ms saved per static request)

---

### 2. handleSystemState - System Gateway

**File**: `src/hooks/handleSystemState.ts`  
**Purpose**: Validates system readiness before processing requests

**State Machine**: `IDLE â†’ INITIALIZING â†’ READY/DEGRADED/FAILED`

```typescript
export const handleSystemState: Handle = async ({ event, resolve }) => {
	const { pathname } = event.url;
	let systemState = getSystemState();

	// Wait for initialization on first request
	if (systemState.overallState === 'IDLE' && !initializationAttempted) {
		initializationAttempted = true;
		await dbInitPromise;
		systemState = getSystemState();
	}

	// Allow setup wizard and root redirect during IDLE state
	if (systemState.overallState === 'IDLE') {
		const allowedPaths = ['/setup', '/api/setup', '/api/system/health', '/login', '/static', '/.well-known'];
		if (allowedPaths.some((prefix) => pathname.startsWith(prefix)) || pathname === '/') {
			return resolve(event);
		}
	}

	// Block all requests if system FAILED
	if (systemState.overallState === 'FAILED') {
		const allowedPaths = ['/api/system/health', '/api/dashboard/health', '/.well-known'];
		if (allowedPaths.some((prefix) => pathname.startsWith(prefix))) {
			return resolve(event);
		}
		throw error(503, 'Service Unavailable: A critical system component has failed.');
	}

	// During INITIALIZING, wait for initialization to complete
	if (systemState.overallState === 'INITIALIZING') {
		const allowedPaths = ['/api/system/health', '/api/dashboard/health', '/setup', '/api/setup', '/login', '/.well-known'];
		if (allowedPaths.some((prefix) => pathname.startsWith(prefix)) || pathname === '/') {
			return resolve(event);
		}

		// Wait for initialization to complete
		await dbInitPromise;
		systemState = getSystemState();

		// If still not ready after initialization, block the request
		if (!isSystemReady()) {
			throw error(503, 'Service Unavailable: The system failed to initialize.');
		}
	}

	// Allow requests only when READY or DEGRADED
	const isReady = isSystemReady();
	if (!isReady) {
		const allowedPaths = ['/api/system/health', '/setup', '/api/setup'];
		if (allowedPaths.some((prefix) => pathname.startsWith(prefix))) {
			return resolve(event);
		}
		throw error(503, 'Service Unavailable: The system is starting up.');
	}

	return resolve(event);
};
```

**Key Features**:

- **Smart Initialization**: Waits for initialization during INITIALIZING state instead of blocking
- **Root Path Handling**: Allows `/` during IDLE and INITIALIZING for proper redirects to /setup, /login, or first collection
- **State Machine Enforcement**: Blocks requests appropriately based on system state
- **Partial Functionality**: Allows essential routes in DEGRADED state
- **Always-On Health Checks**: Health check endpoints accessible in all states

---

### 3. handleRateLimit - Abuse Prevention

**File**: `src/hooks/handleRateLimit.ts`  
**Purpose**: Distributed rate limiting with Redis support for clustered deployments

**Limits**:

- **General Routes**: 500 requests/minute per IP + IP+UA
- **API Routes**: 500/min per IP, 200/min per IP+UA (stricter)

```typescript
// Distributed store for Redis-backed rate limiting
const distributedStore = {
	async get(key: string): Promise<number | undefined> {
		const data = await cacheService.get<{ count: number; expires: number }>(`ratelimit:${key}`);
		return data && data.expires > Date.now() ? data.count : undefined;
	},
	async increment(key: string, ttlSeconds: number): Promise<number> {
		const existing = await this.get(key);
		const newCount = (existing || 0) + 1;
		await cacheService.set(`ratelimit:${key}`, { count: newCount, expires: Date.now() + ttlSeconds * 1000 }, ttlSeconds);
		return newCount;
	}
};

const generalLimiter = new RateLimiter({
	IP: [500, 'm'],
	IPUA: [500, 'm'],
	cookie: { name: 'ratelimit', secret: JWT_SECRET, rate: [500, 'm'] },
	store: cacheService ? distributedStore : undefined // Redis if available
});

export const handleRateLimit: Handle = async ({ event, resolve }) => {
	// Skip localhost in dev, static assets, build process
	if (building || (dev && isLocalhost(ip))) return resolve(event);
	if (isStaticAsset(url.pathname)) return resolve(event);

	const limiter = url.pathname.startsWith('/api/') ? apiLimiter : generalLimiter;

	if (await limiter.isLimited(event)) {
		metricsService.incrementRateLimitViolations();
		logger.warn(`Rate limit exceeded: IP=${ip}, Path=${url.pathname}`);
		throw error(429, 'Too Many Requests');
	}

	return resolve(event);
};
```

**Key Features**:

- **Redis-backed**: Shared limits across all server instances in cluster
- **Automatic fallback**: In-memory if Redis unavailable
- **Static asset exemption**: CDN-cached content bypasses rate limiting
- **Multi-layer protection**: IP-based + IP+UA + signed cookie

---

### 4. handleFirewall - Application Threat Detection

**File**: `src/hooks/handleFirewall.ts`  
**Purpose**: Detects application-specific threats that Nginx/CDN cannot catch

**What It Detects** âœ…:

- Advanced bots (Selenium, Puppeteer, Playwright) while allowing legitimate crawlers
- Business logic abuse (bulk delete operations, admin enumeration)
- Suspicious parameters (credentials in URLs, tokens in query strings)
- Template injection attempts (`{{...}}`, `${...}`, `<%...%>`)
- Command injection patterns (`;ls`, `;wget`, `;curl`)
- Path depth enumeration (>10 levels)
- Encoded bypass attempts (`%2e%2e`, `%252e`)

**What It Does NOT Check** âŒ (handled elsewhere):

- SQL injection â†’ Nginx + parameterized queries
- Path traversal â†’ Nginx + static middleware
- Basic bot filtering â†’ CDN
- Rate limiting â†’ handleRateLimit

```typescript
export const handleFirewall: Handle = async ({ event, resolve }) => {
	const { request, url } = event;
	const userAgent = request.headers.get('user-agent') || '';
	const pathname = url.pathname.toLowerCase();

	// 1. Advanced bot detection (allow legitimate crawlers)
	if (isAdvancedBot(userAgent) && !isLegitimateBot(userAgent)) {
		metricsService.incrementSecurityViolations('bot_detection');
		logger.warn(`Bot blocked: UA=${userAgent}, Path=${pathname}`);
		throw error(403, 'Forbidden: Automated access detected');
	}

	// 2. Application threat patterns
	if (hasApplicationThreat(pathname, url.search)) {
		metricsService.incrementSecurityViolations('app_firewall');
		logger.warn(`Threat detected: IP=${event.getClientAddress()}, Path=${pathname}`);
		throw error(403, 'Forbidden: Request pattern not allowed');
	}

	// 3. Suspicious patterns (enumeration, abuse)
	if (hasSuspiciousPattern(pathname)) {
		metricsService.incrementSecurityViolations('suspicious_pattern');
		logger.warn(`Suspicious pattern: IP=${event.getClientAddress()}, Path=${pathname}`);
		throw error(403, 'Forbidden: Invalid request pattern');
	}

	return resolve(event);
};
```

**Performance**: ~1-2ms overhead per request, early exit for legitimate traffic

**Legitimate Bots Allowed**:

- Googlebot, Bingbot, DuckDuckBot
- Baiduspider, YandexBot
- Social media crawlers (Facebook, Twitter, LinkedIn, WhatsApp, Telegram, Discord)

---

### 5. handleSetup - Installation Gateway

**File**: `src/hooks/handleSetup.ts`  
**Purpose**: Ensures CMS installation is complete

**Flow**: `Config Missing â†’ Setup â†’ Configured â†’ Normal Operation`

```typescript
export const handleSetup: Handle = async ({ event, resolve }) => {
	const { pathname } = event.url;

	// Quick config check (cached per request)
	if (event.locals.__setupConfigExists === undefined) {
		event.locals.__setupConfigExists = isSetupComplete();
	}

	const configExists = event.locals.__setupConfigExists;

	// Config missing - redirect to setup
	if (!configExists) {
		const allowedDuringSetup = pathname.startsWith('/setup') || pathname.startsWith('/api/setup') || ASSET_REGEX.test(pathname);

		if (allowedDuringSetup) {
			return resolve(event, createSetupResolver());
		}

		throw redirect(302, '/setup');
	}

	// Config exists - block access to setup routes
	if (pathname.startsWith('/setup') && !pathname.startsWith('/api/setup')) {
		throw redirect(302, '/login');
	}

	return resolve(event);
};
```

**Key Features**:

- **Config Validation**: Checks both existence and content of `config/private.ts`
- **Smart Redirects**: Empty config values treated as "not configured"
- **Asset Allowance**: Static assets allowed during setup for UI rendering
- **Special Response Filter**: Allows setup API to set cookies before redirect
- **One-Time Setup**: Blocks setup routes after completion

---

### Root Path (`/`) Redirect Flow

The root path has special handling to provide an optimal user experience across all system states:

**Redirect Logic Sequence**:

1. **No `config/private.ts`** (or empty values)
   - `handleSetup` â†’ Redirect to `/setup`
   - User completes installation wizard

2. **Has `config/private.ts`, no valid session**
   - `handleSetup` â†’ Passes through
   - `handleAuthentication` â†’ Sets `locals.user = null`
   - Root `+page.server.ts` â†’ Redirect to `/login`

3. **Has `config/private.ts`, valid session**
   - `handleSetup` â†’ Passes through
   - `handleAuthentication` â†’ Sets `locals.user = User`
   - Root `+page.server.ts` â†’ Redirect to first collection

**Implementation** (`src/routes/+page.server.ts`):

```typescript
export const load: PageServerLoad = async ({ locals, url }) => {
	const { user } = locals;

	// No session - redirect to login
	if (!user) {
		throw redirect(302, '/login');
	}

	// Only for root path
	if (url.pathname !== '/') {
		return { user, permissions: locals.permissions };
	}

	// Wait for system initialization
	await dbInitPromise;
	await contentManager.initialize(tenantId);

	// Get first collection and redirect
	const redirectUrl = await contentManager.getFirstCollectionRedirectUrl(redirectLanguage, tenantId);

	if (redirectUrl) {
		throw redirect(302, redirectUrl);
	}

	// No collections found - stay on root
	return { user, permissions: locals.permissions };
};
```

**Why Root Path is Always Allowed**:

The root path (`/`) must pass through `handleSystemState` during IDLE and INITIALIZING states to enable:

- Setup wizard detection and redirect
- Login page redirect for invalid sessions
- First collection redirect for authenticated users

Blocking `/` during initialization would prevent these essential flows from working.

---

### 6. handleLocale - Language Management

**File**: `src/hooks/handleLocale.ts`  
**Purpose**: Synchronizes language preferences from cookies to stores

```typescript
export const handleLocale: Handle = async ({ event, resolve }) => {
	const { cookies } = event;

	// Safety check: Ensure stores are available
	if (!systemLanguage || !contentLanguage) {
		logger.warn('Language stores not available on server, skipping handleLocale');
		return resolve(event);
	}

	// Sync system language from cookie
	const systemLangCookie = cookies.get('systemLanguage');
	const systemLangSet = safelySetLanguage('systemLanguage', systemLangCookie, (value) => systemLanguage.set(value));

	// Clean up invalid cookies
	if (systemLangCookie && !systemLangSet) {
		cookies.delete('systemLanguage', { path: '/' });
	}

	// Sync content language from cookie
	const contentLangCookie = cookies.get('contentLanguage');
	const contentLangSet = safelySetLanguage('contentLanguage', contentLangCookie, (value) => contentLanguage.set(value));

	// Clean up invalid cookies
	if (contentLangCookie && !contentLangSet) {
		cookies.delete('contentLanguage', { path: '/' });
	}

	return resolve(event);
};
```

**Key Features**:

- Dual language support (system UI + content)
- Cookie validation against supported locales
- Store synchronization for SSR consistency
- Automatic cleanup of invalid cookies

---

### 7. handleTheme - SSR Theme Management

**File**: `src/hooks/handleTheme.ts`  
**Purpose**: Prevents theme flickering with server-side injection

```typescript
export const handleTheme: Handle = async ({ event, resolve }) => {
	// Read single 'theme' cookie as source of truth
	const theme = event.cookies.get('theme') as 'dark' | 'light' | undefined;
	const isDarkMode = theme === 'dark';

	// Set locals for use in load functions
	event.locals.darkMode = isDarkMode;
	event.locals.theme = null; // Theme entity from DB (not a simple string)

	// Transform HTML to inject dark class before browser sees it
	return resolve(event, {
		transformPageChunk: ({ html }) => {
			const htmlTag = '<html lang="en" dir="ltr">';
			if (isDarkMode) {
				return html.replace(htmlTag, '<html lang="en" dir="ltr" class="dark">');
			}
			return html;
		}
	});
};
```

**Key Features**:

- Zero-flash theme application (applied before HTML reaches browser)
- SSR optimization for immediate correct theme
- `locals.darkMode` boolean for theme state
- `locals.theme` reserved for DB Theme entities
- Cookie as single source of truth

---

### 8. Authentication & Multi-Tenancy (`handleAuthentication`)

**File**: `src/hooks/handleAuthentication.ts`
**Purpose**: Manages user identity, session security, and tenant isolation.

**Key Responsibilities:**

- **Multi-Tenancy**:
  - **Standard Mode**: Resolves `tenantId` from the hostname (subdomain).
  - **Demo Mode**: Checks for `SVELTYCMS_DEMO` environment variable. If active, it looks for a `demo_tenant_id` cookie.
    - If missing, it generates a new UUID `tenantId`, sets the cookie (20 min TTL), and **automatically seeds** the new tenant with default data.
- **Session Validation**: Verifies the `session_id` cookie against the database/cache.
- **Tenant Isolation**: Ensures the authenticated user belongs to the resolved `tenantId`.
- **Session Rotation**: Rotates session tokens every 15 minutes for security.
- **WeakRef Caching**: Uses a memory-efficient cache to reduce database lookups for active sessions.

```typescript
// Simplified Logic
const isDemoMode = getPrivateSettingSync('DEMO');

if (multiTenant) {
    let tenantId: string | null = null;

    if (isDemoMode) {
        // Demo Mode: Tenant ID from cookie
        tenantId = cookies.get('demo_tenant_id');
        if (!tenantId) {
            tenantId = crypto.randomUUID();
            cookies.set('demo_tenant_id', tenantId, ...);
            await seedDemoTenant(dbAdapter, tenantId); // Auto-seed new tenant
        }
    } else {
        // Standard Mode: Tenant ID from hostname
        tenantId = getTenantIdFromHostname(url.hostname);
    }
    locals.tenantId = tenantId;
}
```

**Key Features**:

- WeakRef-based automatic garbage collection
- LRU cache for top 100 hot sessions
- 3-layer caching (in-memory â†’ Redis â†’ database)
- Multi-tenancy with hostname-based tenant ID
- Tenant isolation enforcement
- Automatic session rotation every 15 minutes for security
- Rate-limited rotation attempts to prevent abuse

---

### 9. handleAuthorization - Access Control

**File**: `src/hooks/handleAuthorization.ts`  
**Purpose**: Enforces role-based permissions and loads admin data conditionally

```typescript
export const handleAuthorization: Handle = async ({ event, resolve }) => {
	const { url, locals } = event;
	const { user } = locals;
	const isApi = url.pathname.startsWith('/api/');
	const isPublic = isPublicRoute(url.pathname);

	// Skip internal routes
	if (url.pathname.startsWith('/.well-known/') || url.pathname.startsWith('/_')) {
		return resolve(event);
	}

	// Public routes - set defaults and continue
	if (isPublic) {
		locals.isAdmin = false;
		locals.hasManageUsersPermission = false;
		locals.isFirstUser = false;
		return resolve(event);
	}

	// Check first user status (for setup completion)
	const userCount = await getCachedUserCount(locals.tenantId);
	locals.isFirstUser = userCount === 0;

	// Load roles (required for everyone)
	const rolesData = await getCachedRoles(locals.tenantId);
	locals.roles = rolesData;

	// Authenticated users
	if (user) {
		const userRole = locals.roles.find((r) => r._id === user.role);
		const isAdmin = !!userRole?.isAdmin;

		locals.isAdmin = isAdmin;
		locals.hasManageUsersPermission = isAdmin || hasPermissionByAction(user, 'manage', 'user', undefined, locals.roles);

		// OPTIMIZATION: Only load heavy admin data when needed
		if (
			(isAdmin || locals.hasManageUsersPermission) &&
			(isApi || url.pathname.includes('/admin') || url.pathname.includes('/user') || url.pathname.includes('/config'))
		) {
			const [allUsers, allTokens] = await Promise.all([getAdminDataCached('users', locals.tenantId), getAdminDataCached('tokens', locals.tenantId)]);
			locals.allUsers = allUsers;
			locals.allTokens = allTokens;
		} else {
			locals.allUsers = [];
			locals.allTokens = [];
		}

		// Redirect authenticated users from public pages
		if (isPublic && !isOAuthRoute(url.pathname) && !isApi) {
			throw redirect(302, '/');
		}
	} else {
		// Unauthenticated users
		locals.isAdmin = false;
		locals.hasManageUsersPermission = false;
		locals.allUsers = [];
		locals.allTokens = [];

		// Block access to protected routes
		if (!isPublic && !locals.isFirstUser) {
			if (isApi) throw error(401, 'Unauthorized');
			throw redirect(302, '/login');
		}
	}

	return resolve(event);
};
```

**Key Features**:

- Conditional loading of heavy data (only for admins on admin routes)
- Multi-layer caching (in-memory + Redis)
- Deduplication prevents concurrent duplicate queries
- Most requests skip heavy database queries

---

### 10. addSecurityHeaders - HTTP Security

**File**: `src/hooks/addSecurityHeaders.ts`  
**Purpose**: Essential HTTP security headers

```typescript
export const addSecurityHeaders: Handle = async ({ event, resolve }) => {
	const response = await resolve(event);

	// Essential security headers (CSP handled by SvelteKit)
	response.headers.set('X-Frame-Options', 'SAMEORIGIN');
	response.headers.set('X-Content-Type-Options', 'nosniff');
	response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
	response.headers.set(
		'Permissions-Policy',
		'geolocation=(), microphone=(), camera=(), display-capture=(), ' + 'clipboard-read=(), clipboard-write=(self), web-share=(self)'
	);

	// HSTS for production
	if (!dev && event.url.protocol === 'https:') {
		response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
	}

	return response;
};
```

**Key Features**:

- X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy
- HSTS enforcement for HTTPS (1 year + subdomains + preload)
- CSP managed by SvelteKit (`svelte.config.js`)

---

## Optional Middleware

### handleRateLimit - DDoS Protection

**File**: `src/hooks/handleRateLimit.ts`  
**Use Case**: Add to pipeline when rate limiting is needed

````typescript
// Distributed store for clustered environments
const distributedStore = {
	async get(key: string): Promise<number | undefined> {
		const data = await cacheService.get<{ count: number; expires: number }>(`ratelimit:${key}`);
		return (data && data.expires > Date.now()) ? data.count : undefined;
	},
	async increment(key: string, ttlSeconds: number): Promise<number> {
		const existing = await this.get(key);
		const newCount = (existing || 0) + 1;
		await cacheService.set(`ratelimit:${key}`, { count: newCount, expires: Date.now() + ttlSeconds * 1000 }, ttlSeconds);
		return newCount;
	}
};
```typescript
// Distributed store for clustered environments
const distributedStore = {
	async get(key: string): Promise<number | undefined> {
		const data = await cacheService.get<{ count: number; expires: number }>(`ratelimit:${key}`);
		return (data && data.expires > Date.now()) ? data.count : undefined;
	},
	async increment(key: string, ttlSeconds: number): Promise<number> {
		const existing = await this.get(key);
		const newCount = (existing || 0) + 1;
		await cacheService.set(`ratelimit:${key}`,
		                       { count: newCount, expires: Date.now() + ttlSeconds * 1000 },
		                       ttlSeconds);
		return newCount;
	}
};

const generalLimiter = new RateLimiter({
	IP: [500, 'm'],
	IPUA: [500, 'm'],
	cookie: { name: 'ratelimit', secret: JWT_SECRET, rate: [500, 'm'] },
	store: cacheService ? distributedStore : undefined  // Redis support
});

export const handleRateLimit: Handle = async ({ event, resolve }) => {
	if (building || (dev && isLocalhost(getClientIp(event)))) {
		return resolve(event);
	}

	if (isStaticAsset(url.pathname)) {
		return resolve(event);
	}

	const limiter = url.pathname.startsWith('/api/') ? apiLimiter : generalLimiter;

	if (await limiter.isLimited(event)) {
		metricsService.incrementRateLimitViolations();
		throw error(429, 'Too Many Requests');
	}

	return resolve(event);
};
````

**Key Features**:

- Redis-backed distributed rate limiting for clustered deployments
- Automatic fallback to in-memory for single instance
- Static asset exemption (skips rate limiting for CDN content)
- Separate limits for API vs general routes

---

### handleApiRequests - API Caching & Permissions

**File**: `src/hooks/handleApiRequests.ts`  
**Use Case**: Add for API-specific caching and permission enforcement
const limiter = url.pathname.startsWith('/api/') ? apiLimiter : generalLimiter;

    if (await limiter.isLimited(event)) {
    	metricsService.incrementRateLimitViolations();
    	throw error(429, 'Too Many Requests');
    }

    return resolve(event);

};

````

**Benefits**:
- **Clustered Support**: Rate limits shared across all server instances via Redis
- **Static Asset Exemption**: CDN-cached content skips rate limiting (20% faster)
- **Automatic Fallback**: Uses in-memory if Redis unavailable

---

### **handleApiRequests** - API Caching & Permissions (Optional)

**File**: `src/hooks/handleApiRequests.ts`
**Features**: Streaming optimization with non-blocking cache population

```typescript
export const handleApiRequests: Handle = async ({ event, resolve }) => {
	if (!url.pathname.startsWith('/api/') || !locals.user) {
		return resolve(event);
	}

	const apiEndpoint = getApiEndpoint(url.pathname);

	// Authorization check
	if (!hasApiPermission(locals.user.role, apiEndpoint)) {
		throw error(403, 'Forbidden');
	}

	// GET requests with caching
	if (request.method === 'GET') {
		const cached = await cacheService.get(cacheKey, locals.tenantId);
		if (cached) {
			metricsService.recordApiCacheHit();
			return new Response(JSON.stringify(cached.data), {
				status: 200,
				headers: { ...cached.headers, 'X-Cache': 'HIT' }
			});
		}

		const response = await resolve(event);

		// GraphQL bypass (no Response recreation)
		if (apiEndpoint === 'graphql') {
			response.headers.set('X-Cache': 'BYPASS');
			return response;
		}

		// STREAMING OPTIMIZATION: Clone for background caching
		if (response.ok) {
			const responseClone = response.clone();
			response.headers.set('X-Cache', 'MISS');

			// Cache in background - don't block response
			(async () => {
				try {
					const responseBody = await responseClone.text();
					const responseData = JSON.parse(responseBody);
					await cacheService.set(cacheKey, { data: responseData, headers: {...} }, TTL, tenantId);
				} catch (err) {
					logger.error(`Error caching: ${err}`);
				}
			})();

```typescript
export const handleApiRequests: Handle = async ({ event, resolve }) => {
	if (!url.pathname.startsWith('/api/') || !locals.user) {
		return resolve(event);
	}

	const apiEndpoint = getApiEndpoint(url.pathname);

	// Authorization check
	if (!hasApiPermission(locals.user.role, apiEndpoint)) {
		throw error(403, 'Forbidden');
	}

	// GET requests with caching
	if (request.method === 'GET') {
		const cached = await cacheService.get(cacheKey, locals.tenantId);
		if (cached) {
			metricsService.recordApiCacheHit();
			return new Response(JSON.stringify(cached.data), {
				status: 200,
				headers: { ...cached.headers, 'X-Cache': 'HIT' }
			});
		}

		const response = await resolve(event);

		// GraphQL bypass
		if (apiEndpoint === 'graphql') {
			response.headers.set('X-Cache', 'BYPASS');
			return response;
		}

		// Streaming optimization: clone for background caching
		if (response.ok) {
			const responseClone = response.clone();
			response.headers.set('X-Cache', 'MISS');

			// Cache in background without blocking response
			(async () => {
				try {
					const responseBody = await responseClone.text();
					const responseData = JSON.parse(responseBody);
					await cacheService.set(cacheKey, { data: responseData, headers: {...} }, TTL, tenantId);
				} catch (err) {
					logger.error(`Error caching: ${err}`);
				}
			})();

			return response;
		}
	}

	// Mutations: invalidate cache
	const response = await resolve(event);
	if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method) && response.ok) {
		await cacheService.clearByPattern(`api:${locals.user._id}:/api/${apiEndpoint}*`, locals.tenantId);
	}

	return response;
};
````

**Key Features**:

- Non-blocking streaming (background cache population)
- Response cloning to avoid blocking client
- GraphQL bypass for efficient handling
- Automatic cache invalidation on mutations

---

## Middleware Pipeline

```mermaid
sequenceDiagram
    participant Client
    participant SvelteKit
    participant SystemState as 1. handleSystemState
    participant Setup as 2. handleSetup
    participant Locale as 3. handleLocale
    participant Theme as 4. handleTheme
    participant Auth as 5. handleAuthentication
    participant Authz as 6. handleAuthorization
    participant Security as 7. addSecurityHeaders
    participant Endpoint

    Client->>SvelteKit: Request
    SvelteKit->>SystemState: resolve(event)
    alt System NOT READY
        SystemState-->>Client: 503 Service Unavailable
    end
    SystemState->>Setup: resolve(event)
    alt Setup INCOMPLETE
        Setup-->>Client: 302 Redirect to /setup
    end
    Setup->>Locale: resolve(event)
    Locale->>Theme: resolve(event)
    Theme->>Auth: resolve(event)
    Auth->>Authz: resolve(event)
    alt User UNAUTHORIZED
        Authz-->>Client: 302 Redirect to /login
    end
    Authz->>Security: resolve(event)
    Security->>Endpoint: resolve(event)
    Endpoint-->>Security: Response
    Security-->>Authz: Response
    Authz-->>Auth: Response
    Auth-->>Theme: Response
    Theme-->>Locale: Response
    Locale-->>Setup: Response
    Setup-->>SystemState: Response
    SystemState-->>SvelteKit: Response
    SvelteKit-->>Client: Final Response
```

---

## Best Practices for Creating New Hooks

When extending the middleware pipeline, follow these best practices to maintain system stability, performance, and consistency:

1.  **Idempotency**: Ensure your hook can run multiple times without causing side effects.
2.  **Performance First**: Avoid long-running operations. Use caching for expensive lookups.
3.  **Early Exits**: Design your hook to exit as early as possible for requests it doesn't need to handle.
4.  **Use `event.locals`**: Pass data between hooks using `event.locals` instead of global state.
5.  **Single Responsibility**: Each hook should have a single, well-defined purpose.
6.  **Error Handling**: Wrap your logic in `try...catch` blocks and use the SvelteKit `error` helper for throwing errors.
7.  **Logging**: Use the `logger` service to log important information and errors.

---

## Testing Strategy

The server hooks middleware employs a **strategic testing approach** that balances direct unit testing with integration coverage:

### Direct Unit Tests (2 hooks, 53 tests total)

Complex hooks with intricate state machines and security logic receive dedicated unit tests:

#### 1. handleSystemState (26 tests)

**File:** `tests/bun/hooks/system-state.test.ts`

**Why dedicated tests?** Complex state machine with 5 states (IDLE, INITIALIZING, READY, DEGRADED, FAILED) and state-dependent route blocking logic.

**Test Coverage:**

- âœ… READY state: All routes allowed
- âœ… DEGRADED state: Routes allowed with service warnings in `event.locals`
- âœ… IDLE state: Only setup/health/static routes allowed
- âœ… INITIALIZING state: Essential routes only
- âœ… FAILED state: Only health checks allowed
- âœ… Route pattern matching for special paths
- âœ… State transition logging and metrics

```bash
bun test tests/bun/hooks/system-state.test.ts  # 26 tests
```

#### 2. handleFirewall (27 tests)

**File:** `tests/bun/hooks/firewall.test.ts`

**Why dedicated tests?** Security-critical pattern matching and bot detection requiring comprehensive validation.

**Test Coverage:**

- âœ… Suspicious parameter detection (password, token, secret in URLs)
- âœ… Bulk operation abuse patterns
- âœ… Administrative endpoint enumeration
- âœ… Advanced bot detection (HeadlessChrome, Selenium, Puppeteer, Playwright, PhantomJS)
- âœ… Legitimate bot allowlist (Googlebot, facebookexternalhit, Twitterbot, Bingbot)
- âœ… Normal traffic allowance
- âœ… Path traversal and injection pattern detection

```bash
bun test tests/bun/hooks/firewall.test.ts      # 27 tests
```

### Indirect Integration Coverage (9 hooks)

Simpler hooks with straightforward logic are tested through integration and API tests:

| Hook                       | Tested Via                       | Test Count | Reasoning                                             |
| -------------------------- | -------------------------------- | ---------- | ----------------------------------------------------- |
| `handleAuthentication`     | User API tests                   | 47         | Session validation tested via authenticated API calls |
| `handleAuthorization`      | Collections API tests            | 19         | RBAC tested via role-specific endpoints               |
| `handleRateLimit`          | Setup API & stress tests         | 20+        | Rate limiting validated under load                    |
| `handleSetup`              | Setup API tests                  | 20         | Installation flow tested end-to-end                   |
| `handleLocale`             | UI rendering & i18n tests        | 5+         | Language sync tested in component tests               |
| `handleTheme`              | UI rendering tests               | 5+         | Theme injection tested in SSR tests                   |
| `handleStaticAssetCaching` | Static asset integration tests   | Implicit   | Simple regex matching, validated via asset requests   |
| `addSecurityHeaders`       | Security & CSP integration tests | 8          | Header validation in security service tests           |
| `handleApiRequests`        | All API endpoint tests           | 80+        | API authorization/caching tested across APIs          |

### Testing Philosophy

**When to use direct unit tests:**

- Complex state machines with multiple branches
- Security-critical pattern matching
- Intricate business logic requiring edge case validation
- Performance-sensitive code needing microbenchmarks

**When to rely on integration tests:**

- Simple transformations (header setting, cookie reading)
- Middleware with straightforward pass-through logic
- Hooks that primarily compose other services
- Functionality already validated in downstream tests

### Running All Hook Tests

```bash
# Run all direct hook tests
bun test tests/bun/hooks/

# Run hook tests + related integration tests
bun test tests/bun/hooks/ tests/bun/api/ tests/bun/services/

# Full test suite
bun test
```

---

### 10. handleCompression - Response Compression

**File**: `src/hooks/handleCompression.ts`
**Purpose**: Compresses API responses using GZIP or Brotli for improved performance.

```typescript
export const handleCompression: Handle = async ({ event, resolve }) => {
	const response = await resolve(event);

	// Only compress API responses
	if (!event.url.pathname.startsWith('/api/')) {
		return response;
	}

	// Check Accept-Encoding header
	const acceptEncoding = event.request.headers.get('accept-encoding') || '';

	// ... compression logic ...

	return response;
};
```

**Key Features**:

- **Algorithm Selection**: Prioritizes Brotli (`br`) over Gzip (`gzip`).
- **Selective Compression**: Targets only API JSON responses (static assets are handled by adapter/CDN).
- **Performance**: Reduces payload size by up to 80%, significantly improving mobile experience.

---

## Utility Exports

Utility functions exported from `hooks.server.ts`:

```typescript
// Health metrics
export const getHealthMetrics = () => metricsService.getReport();

// Session management
export {
	invalidateSessionCache,
	clearAllSessionCaches,
	clearSessionRefreshAttempt,
	forceSessionRotation,
	getSessionCacheStats
} from './hooks/handleAuthentication';
```

---

## Summary

The middleware architecture provides:

- **Security**: Multi-layered defense with tenant isolation and automated threat detection
- **Performance**: WeakRef caching, streaming responses, conditional loading
- **Observability**: Unified MetricsService with comprehensive logging
- **Scalability**: Clustered support with distributed caching and rate limiting

---

## Related Documentation

- [Cache System](./cache-system.mdx) - CacheService implementation details
- [Security Plugin](./security-plugin.mdx) - SecurityResponseService integration
- [Initialization Workflow](./initialization-workflow.mdx) - System startup sequence
