---
path: 'docs/architecture/authentication-system.mdx'
title: 'Authentication System'
description: 'Enterprise-grade authentication with 3-layer caching, automatic session rotation, and multi-tenancy support.'
order: 5
icon: 'mdi:shield-lock'
author: 'admin'
created: '2025-10-30'
updated: '2025-10-30'
tags:
  - 'authentication'
  - 'security'
  - 'sessions'
  - 'multi-tenancy'
  - 'caching'
  - 'architecture'
---

# Authentication System

SveltyCMS features an enterprise-grade authentication system with 3-layer caching, automatic session rotation, multi-tenancy support, and comprehensive security features.

---

## Overview

The authentication system provides:

- **Session Management**: 3-layer caching with WeakRef memory optimization
- **Security Enhancement**: Automatic session rotation every 15 minutes
- **Multi-tenancy**: Hostname-based tenant identification with strict isolation
- **Performance**: LRU cache for hot sessions, Redis for distributed caching
- **Monitoring**: Comprehensive metrics integration

---

## Architecture

### 3-Layer Session Caching

```
Request → In-Memory Cache (WeakRef) → Redis Cache → Database
          ↓ hit (fastest)           ↓ hit (fast)    ↓ miss (authoritative)
```

**Performance Impact:**

- **Memory hit**: <1ms (99% of requests for active users)
- **Redis hit**: 2-5ms (for sessions not in memory)
- **Database hit**: 10-50ms (only for cold starts or expired cache)

### WeakRef Memory Management

The system uses WeakRef for automatic memory management:

```typescript
sessionCache (WeakRef Map)      // Can be GC'd when not used
     ↓
strongRefs (LRU Map, max 100)   // Hot sessions stay in memory
     ↓
Automatic cleanup every 5min     // Removes expired entries
```

**Benefits:**

- Automatic garbage collection of unused sessions
- Low memory footprint (~100 sessions permanently cached)
- Ideal for clustered/edge deployments
- No memory leaks

---

## Session Rotation

### How It Works

The system automatically rotates sessions every 15 minutes for active users:

1. Every 15 minutes for active users
2. Creates new session with same user
3. Updates cookie with new session ID
4. Destroys old session
5. Invalidates all caches
6. Rate limited (100 rotations/min per IP)

### Security Benefits

- Prevents session hijacking (stolen tokens expire quickly)
- Limits damage from XSS attacks
- Complies with security best practices
- Zero downtime (seamless for users)

### Flow Diagram

```
User visits site → Session validated →
  Check: Last rotation >15min? → Yes →
    Create new session → Update cookie → Destroy old session
```

---

## Multi-Tenancy

### Hostname-Based Tenant Mapping

The system identifies tenants based on hostname:

```
https://customer1.yourdomain.com → tenantId: "customer1"
https://customer2.yourdomain.com → tenantId: "customer2"
https://localhost                → tenantId: "default"
```

### Tenant Isolation Enforcement

- User sessions are scoped to their tenant
- Cross-tenant access attempts are blocked
- Cache keys include tenant ID
- Database queries filtered by tenant

**Implementation:**

```typescript
// Cross-tenant access prevention
if (user.tenantId !== locals.tenantId) {
	logger.warn('Tenant isolation violation');
	cookies.delete(SESSION_COOKIE_NAME);
	throw error(403, 'Access denied: Tenant isolation violation');
}
```

---

## Configuration

### Environment Variables

```env
# Session Configuration
SESSION_CACHE_TTL_MS=300000          # 5 minutes (in-memory cache)
SESSION_ROTATION_INTERVAL_MS=900000  # 15 minutes (rotation)
MAX_STRONG_REFS=100                  # LRU cache size

# Multi-tenancy
MULTI_TENANT=true                    # Enable hostname-based tenants

# Security
JWT_SECRET_KEY=your-secret-key       # For rate limiter cookies
```

### Customization Options

#### Adjust Rotation Interval

**File**: `src/hooks/handleAuthentication.ts`

```typescript
// Default: 15 minutes
const SESSION_ROTATION_INTERVAL_MS = 15 * 60 * 1000;

// High security: 5 minutes (financial apps, admin panels)
const SESSION_ROTATION_INTERVAL_MS = 5 * 60 * 1000;

// Low frequency: 30 minutes (public content sites)
const SESSION_ROTATION_INTERVAL_MS = 30 * 60 * 1000;
```

#### Adjust Cache Size

```typescript
// Default: 100 sessions
const MAX_STRONG_REFS = 100;

// High memory: 200-500 sessions (if you have RAM to spare)
const MAX_STRONG_REFS = 200;

// Low memory: 50 sessions (edge/serverless environments)
const MAX_STRONG_REFS = 50;
```

#### Adjust Cache TTL

**File**: `src/databases/CacheService.ts`

```typescript
// Default: 5 minutes
export const SESSION_CACHE_TTL_MS = 5 * 60 * 1000;

// High traffic: 15 minutes (reduces database load)
export const SESSION_CACHE_TTL_MS = 15 * 60 * 1000;

// Real-time: 1-2 minutes (faster permission updates)
export const SESSION_CACHE_TTL_MS = 2 * 60 * 1000;
```

---

## Security Features

### Secure Cookie Configuration

```typescript
cookies.set(SESSION_COOKIE_NAME, sessionId, {
	path: '/',
	httpOnly: true, // No JavaScript access
	secure: !isDev, // HTTPS only in production
	sameSite: 'lax', // CSRF protection
	maxAge: 60 * 60 * 24 * 30 // 30 days
});
```

### Rate Limiting

Session rotation is rate limited to prevent abuse:

- **Limit**: 100 rotations per minute per IP
- **Cooldown**: 1 minute after failed validation
- **Purpose**: Prevents brute force attacks

### Failed Login Protection

- 1-minute cooldown after failed validation
- Prevents brute force on invalid sessions
- Metrics tracking for security monitoring

---

## API Reference

### Exported Functions

All functions are exported from `src/hooks.server.ts`:

```typescript
import {
	invalidateSessionCache,
	clearAllSessionCaches,
	clearSessionRefreshAttempt,
	forceSessionRotation,
	getSessionCacheStats
} from '@src/hooks.server';
```

#### `invalidateSessionCache(sessionId, tenantId?)`

Invalidates a session from all cache layers (memory, Redis, database).

**Parameters:**

- `sessionId` (string): Session ID to invalidate
- `tenantId` (string, optional): Tenant ID for multi-tenant setups

**Use Cases:**

- User logout
- Compromised session detection
- Permission changes

**Example:**

```typescript
// Logout user
await invalidateSessionCache(sessionId, tenantId);
```

#### `clearSessionRefreshAttempt(sessionId)`

Clears cooldown to allow immediate re-validation.

**Parameters:**

- `sessionId` (string): Session ID to clear cooldown for

**Use Cases:**

- Testing
- Forced session validation
- Password reset completion

**Example:**

```typescript
// Allow immediate login after password reset
clearSessionRefreshAttempt(sessionId);
```

#### `forceSessionRotation(sessionId)`

Forces session rotation on the next request.

**Parameters:**

- `sessionId` (string): Session ID to rotate

**Use Cases:**

- Security incident response
- Password change
- Permission elevation

**Example:**

```typescript
// Force rotation after password change
forceSessionRotation(user.sessionId);
```

#### `clearAllSessionCaches()`

Clears all session caches (maintenance only).

**⚠️ WARNING**: Forces all users to re-authenticate from database!

**Use Cases:**

- System maintenance
- Cache corruption recovery
- Emergency security response

**Example:**

```typescript
// Emergency: clear all caches
clearAllSessionCaches();
```

#### `getSessionCacheStats()`

Returns cache statistics for monitoring.

**Returns:**

```typescript
{
	weakRefs: number; // Total WeakRef entries
	strongRefs: number; // LRU cache entries
	pendingRefreshes: number; // Cooldown entries
	pendingRotations: number; // Rotation queue
	maxStrongRefs: number; // LRU cache limit
}
```

**Example:**

```typescript
const stats = getSessionCacheStats();
console.log(`Cache efficiency: ${stats.strongRefs}/${stats.weakRefs}`);
```

---

## Performance Benchmarks

### Session Validation Speed

| Scenario                 | Time    | Cache Layer |
| ------------------------ | ------- | ----------- |
| Hot user (in strongRefs) | <1ms    | In-memory   |
| Warm user (in WeakRef)   | 1-2ms   | In-memory   |
| Cold user (Redis hit)    | 2-5ms   | Redis       |
| New user (DB lookup)     | 10-50ms | Database    |

### Memory Usage

| Component                      | Memory     |
| ------------------------------ | ---------- |
| Per session (WeakRef)          | ~200 bytes |
| Per session (strongRefs)       | ~500 bytes |
| Top 100 sessions               | ~50 KB     |
| All WeakRefs (10,000 sessions) | ~2 MB      |

### Session Rotation

| Metric            | Value           |
| ----------------- | --------------- |
| Rotation interval | 15 minutes      |
| Rotation time     | 50-100ms        |
| User impact       | None (seamless) |
| Rate limit        | 100/min per IP  |

---

## Monitoring & Observability

### Cache Statistics

Get real-time cache statistics:

```typescript
import { getSessionCacheStats } from '@src/hooks.server';

const stats = getSessionCacheStats();
console.log(stats);
// {
//   weakRefs: 500,
//   strongRefs: 100,
//   pendingRefreshes: 5,
//   pendingRotations: 2,
//   maxStrongRefs: 100
// }
```

### Health Check Integration

**File**: `src/routes/api/health/+server.ts`

```typescript
import { getSessionCacheStats } from '@src/hooks.server';
import { metricsService } from '@src/services/MetricsService';

export async function GET() {
	const cacheStats = getSessionCacheStats();
	const metrics = metricsService.getReport();

	return json({
		authentication: {
			cacheHitRate: metrics.authentication.cacheHitRate,
			validations: metrics.authentication.validations,
			failures: metrics.authentication.failures,
			cache: cacheStats
		}
	});
}
```

### Prometheus Metrics

Available metrics for scraping from `/api/metrics`:

```typescript
svelty_auth_validations_total; // Total session validations
svelty_auth_failures_total; // Failed validations
svelty_auth_cache_hit_rate; // Cache efficiency (0-1)
svelty_auth_cache_hits_total; // Cache hits
svelty_auth_cache_misses_total; // Cache misses
svelty_session_rotations_total; // Session rotations performed
```

### Grafana Dashboard Queries

```promql
# Cache hit rate
rate(svelty_auth_cache_hits_total[5m]) /
  rate(svelty_auth_validations_total[5m])

# Failed login rate
rate(svelty_auth_failures_total[5m])

# Average session validation time
histogram_quantile(0.95,
  rate(svelty_auth_validation_duration_seconds_bucket[5m]))
```

---

## Best Practices

### Session Rotation Interval

Choose based on your security requirements:

- **15 minutes** (default) - Good balance of security and performance
- **5-10 minutes** - High security (financial apps, admin panels)
- **30-60 minutes** - Low frequency (public content sites)

### Cache TTL

Choose based on your traffic patterns:

- **5 minutes** (default) - Good for most use cases
- **15 minutes** - High traffic (reduces database load)
- **1-2 minutes** - Real-time (faster permission updates)

### Strong Refs Limit

Choose based on your available memory:

- **100** (default) - Optimal for most deployments
- **200-500** - High memory (if you have RAM to spare)
- **50** - Low memory (edge/serverless environments)

### Monitoring Targets

- **Cache hit rate**: Target >95%
- **Failed validations**: Monitor for sudden spikes (indicates attack)
- **Rotation failures**: Indicates database issues
- **Alert threshold**: Cache hit rate <80%

---

## Implementation Details

### WeakRef Usage

```typescript
// Weak reference allows GC when not actively used
const sessionCache = new Map<string, WeakRef<SessionCacheEntry>>();

// Get session (may return null if GC'd)
const weakRef = sessionCache.get(sessionId);
const entry = weakRef?.deref(); // Returns undefined if GC'd

// FinalizationRegistry cleans up Map keys when values are GC'd
const sessionCacheRegistry = new FinalizationRegistry<string>((sessionId) => {
	sessionCache.delete(sessionId);
});
```

### LRU Eviction Strategy

```typescript
// Always add new entries at the end (most recent)
strongRefs.set(sessionId, entry);

// Evict oldest when limit exceeded
if (strongRefs.size > MAX_STRONG_REFS) {
	const firstKey = strongRefs.keys().next().value;
	strongRefs.delete(firstKey);
}
```

### Session Validation Flow

```typescript
export const handleAuthentication: Handle = async ({ event, resolve }) => {
	const { locals, cookies } = event;

	// Get session ID from cookie
	const sessionId = cookies.get(SESSION_COOKIE_NAME);
	if (!sessionId) return resolve(event);

	// 3-layer validation
	const user = await getUserFromSession(sessionId, locals.tenantId);

	if (user) {
		// Tenant isolation check
		if (locals.tenantId && user.tenantId !== locals.tenantId) {
			cookies.delete(SESSION_COOKIE_NAME, { path: '/' });
			return resolve(event);
		}

		locals.user = user;
		locals.session_id = sessionId;

		// Check if rotation needed
		await handleSessionRotation(user, sessionId, cookies, locals.tenantId);
	} else {
		cookies.delete(SESSION_COOKIE_NAME, { path: '/' });
	}

	return resolve(event);
};
```

---

## Related Documentation

- [Server Hooks](./server-hooks.mdx) - Complete middleware architecture
- [Cache System](./cache-system.mdx) - Caching implementation details
- [Security Plugin](./security-plugin.mdx) - Security features
- [Production Deployment](../guides/production-deployment.mdx) - Production configuration

---

## Summary

The authentication system provides:

✅ **Security**: Automatic session rotation, tenant isolation, rate limiting  
✅ **Performance**: <1ms authentication for 99% of requests  
✅ **Scalability**: Redis-backed distributed cache for clusters  
✅ **Observability**: Comprehensive metrics and monitoring  
✅ **Reliability**: Graceful error handling, zero-downtime operations

**Performance**: <1ms for 99% of authentication checks  
**Security**: Sessions rotate every 15 minutes automatically  
**Memory**: ~50KB for top 100 active sessions  
**Scalability**: Supports 10,000+ concurrent users per instance
